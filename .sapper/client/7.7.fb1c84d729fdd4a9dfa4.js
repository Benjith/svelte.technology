webpackJsonp([7],{

/***/ 109:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, process) {(function (global, factory) {
	 true ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.svelte = {})));
}(this, (function (exports) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}











function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

















function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}

// Reserved word lists for various dialects of the language

var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};

// And the keywords

var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

var keywords = {
  5: ecma5AndLessKeywords,
  6: ecma5AndLessKeywords + " const class extends export import super"
};

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fd5\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7ae\ua7b0-\ua7b7\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d4-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c03\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d01-\u0d03\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf8\u1cf9\u1dc0-\u1df5\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua900-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true};
var startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;

// Checks if an object has a property.

function has(obj, propName) {
  return hasOwnProperty.call(obj, propName)
}

var isArray = Array.isArray || (function (obj) { return (
  toString.call(obj) === "[object Array]"
); });

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  this.line = line;
  this.column = col;
};

Position.prototype.offset = function offset (n) {
  return new Position(this.line, this.column + n)
};

var SourceLocation = function SourceLocation(p, start, end) {
  this.start = start;
  this.end = end;
  if (p.sourceFile !== null) { this.source = p.sourceFile; }
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur)
    }
  }
}

// A second optional argument can be given to further configure
// the parser process. These options are recognized:

var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must
  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support
  // for strict mode, the set of reserved words, and support for
  // new syntax features. The default is 7.
  ecmaVersion: 7,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called
  // when a semicolon is automatically inserted. It will be passed
  // th position of the comma as an offset, and if `locations` is
  // enabled, it is given the location as a `{line, column}` object
  // as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // When enabled, hashbang directive in the beginning of file
  // is allowed and treated as a line comment.
  allowHashBang: false,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false,
  plugins: {}
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};

  for (var opt in defaultOptions)
    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

  if (options.ecmaVersion >= 2015)
    { options.ecmaVersion -= 2009; }

  if (options.allowReserved == null)
    { options.allowReserved = options.ecmaVersion < 5; }

  if (isArray(options.onToken)) {
    var tokens = options.onToken;
    options.onToken = function (token) { return tokens.push(token); };
  }
  if (isArray(options.onComment))
    { options.onComment = pushComment(options, options.onComment); }

  return options
}

function pushComment(options, array) {
  return function(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text,
      start: start,
      end: end
    };
    if (options.locations)
      { comment.loc = new SourceLocation(this, startLoc, endLoc); }
    if (options.ranges)
      { comment.range = [start, end]; }
    array.push(comment);
  }
}

// Registered plugins
var plugins = {};

function keywordRegexp(words) {
  return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
}

var Parser$1 = function Parser(options, input, startPos) {
  this.options = options = getOptions(options);
  this.sourceFile = options.sourceFile;
  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);
  var reserved = "";
  if (!options.allowReserved) {
    for (var v = options.ecmaVersion;; v--)
      { if (reserved = reservedWords[v]) { break } }
    if (options.sourceType == "module") { reserved += " await"; }
  }
  this.reservedWords = keywordRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = keywordRegexp(reservedStrict);
  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);

  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.
  this.containsEsc = false;

  // Load plugins
  this.loadPlugins(options.plugins);

  // Set up token state

  // The current position of the tokenizer in the input.
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }

  // Properties of the current token:
  // Its type
  this.type = types.eof;
  // For tokens that include more information than their type, the value
  this.value = null;
  // Its start and end offset
  this.start = this.end = this.pos;
  // And, if locations are used, the {line, column} object
  // corresponding to those offsets
  this.startLoc = this.endLoc = this.curPosition();

  // Position information for the previous token
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;

  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.
  this.context = this.initialContext();
  this.exprAllowed = true;

  // Figure out if it's a module code.
  this.inModule = options.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);

  // Used to signify the start of a potential arrow function
  this.potentialArrowAt = -1;

  // Flags to track whether we are in a function, a generator, an async function.
  this.inFunction = this.inGenerator = this.inAsync = false;
  // Positions to delayed-check that yield/await does not exist in default parameters.
  this.yieldPos = this.awaitPos = 0;
  // Labels in scope.
  this.labels = [];

  // If enabled, skip leading hashbang line.
  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
    { this.skipLineComment(2); }

  // Scope tracking for duplicate variable names (see scope.js)
  this.scopeStack = [];
  this.enterFunctionScope();
};

// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them
Parser$1.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };
Parser$1.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };

Parser$1.prototype.extend = function extend (name, f) {
  this[name] = f(this[name]);
};

Parser$1.prototype.loadPlugins = function loadPlugins (pluginConfigs) {
    var this$1 = this;

  for (var name in pluginConfigs) {
    var plugin = plugins[name];
    if (!plugin) { throw new Error("Plugin '" + name + "' not found") }
    plugin(this$1, pluginConfigs[name]);
  }
};

Parser$1.prototype.parse = function parse () {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node)
};

var pp = Parser$1.prototype;

// ## Parser utilities

var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)"|;)/;
pp.strictDirective = function(start) {
  var this$1 = this;

  for (;;) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this$1.input)[0].length;
    var match = literal.exec(this$1.input.slice(start));
    if (!match) { return false }
    if ((match[1] || match[2]) == "use strict") { return true }
    start += match[0].length;
  }
};

// Predicate that tests whether the next token is of the given
// type, and if yes, consumes it as a side effect.

pp.eat = function(type) {
  if (this.type === type) {
    this.next();
    return true
  } else {
    return false
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function(name) {
  return this.type === types.name && this.value === name
};

// Consumes contextual keyword if possible.

pp.eatContextual = function(name) {
  return this.value === name && this.eat(types.name)
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function(name) {
  if (!this.eatContextual(name)) { this.unexpected(); }
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function() {
  return this.type === types.eof ||
    this.type === types.braceR ||
    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

pp.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon)
      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
    return true
  }
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function() {
  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
};

pp.afterTrailingComma = function(tokType, notNext) {
  if (this.type == tokType) {
    if (this.options.onTrailingComma)
      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
    if (!notNext)
      { this.next(); }
    return true
  }
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error.

pp.expect = function(type) {
  this.eat(type) || this.unexpected();
};

// Raise an unexpected token error.

pp.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};

function DestructuringErrors() {
  this.shorthandAssign =
  this.trailingComma =
  this.parenthesizedAssign =
  this.parenthesizedBind =
    -1;
}

pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) { return }
  if (refDestructuringErrors.trailingComma > -1)
    { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
};

pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1;
  if (!andThrow) { return pos >= 0 }
  if (pos > -1) { this.raise(pos, "Shorthand property assignments are valid only in destructuring patterns"); }
};

pp.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
    { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
  if (this.awaitPos)
    { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
};

pp.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression")
    { return this.isSimpleAssignTarget(expr.expression) }
  return expr.type === "Identifier" || expr.type === "MemberExpression"
};

var pp$1 = Parser$1.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function(node) {
  var this$1 = this;

  var exports = {};
  if (!node.body) { node.body = []; }
  while (this.type !== types.eof) {
    var stmt = this$1.parseStatement(true, true, exports);
    node.body.push(stmt);
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  if (this.options.ecmaVersion >= 6) {
    node.sourceType = this.options.sourceType;
  }
  return this.finishNode(node, "Program")
};

var loopLabel = {kind: "loop"};
var switchLabel = {kind: "switch"};

pp$1.isLet = function() {
  if (this.type !== types.name || this.options.ecmaVersion < 6 || this.value != "let") { return false }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh == 123) { return true } // '{' and '['
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
    var ident = this.input.slice(next, pos);
    if (!this.isKeyword(ident)) { return true }
  }
  return false
};

// check 'async [no LineTerminator here] function'
// - 'async /*foo*/ function' is OK.
// - 'async /*\n*/ function' is invalid.
pp$1.isAsyncFunction = function() {
  if (this.type !== types.name || this.options.ecmaVersion < 8 || this.value != "async")
    { return false }

  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  return !lineBreak.test(this.input.slice(this.pos, next)) &&
    this.input.slice(next, next + 8) === "function" &&
    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function(declaration, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;

  if (this.isLet()) {
    starttype = types._var;
    kind = "let";
  }

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
  case types._debugger: return this.parseDebuggerStatement(node)
  case types._do: return this.parseDoStatement(node)
  case types._for: return this.parseForStatement(node)
  case types._function:
    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }
    return this.parseFunctionStatement(node, false)
  case types._class:
    if (!declaration) { this.unexpected(); }
    return this.parseClass(node, true)
  case types._if: return this.parseIfStatement(node)
  case types._return: return this.parseReturnStatement(node)
  case types._switch: return this.parseSwitchStatement(node)
  case types._throw: return this.parseThrowStatement(node)
  case types._try: return this.parseTryStatement(node)
  case types._const: case types._var:
    kind = kind || this.value;
    if (!declaration && kind != "var") { this.unexpected(); }
    return this.parseVarStatement(node, kind)
  case types._while: return this.parseWhileStatement(node)
  case types._with: return this.parseWithStatement(node)
  case types.braceL: return this.parseBlock()
  case types.semi: return this.parseEmptyStatement(node)
  case types._export:
  case types._import:
    if (!this.options.allowImportExportEverywhere) {
      if (!topLevel)
        { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
      if (!this.inModule)
        { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
    }
    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

    // If the statement does not start with a statement keyword or a
    // brace, it's an ExpressionStatement or LabeledStatement. We
    // simply start parsing an expression, and afterwards, if the
    // next token is a colon and the expression was a simple
    // Identifier node, we switch to interpreting it as a label.
  default:
    if (this.isAsyncFunction() && declaration) {
      this.next();
      return this.parseFunctionStatement(node, true)
    }

    var maybeName = this.value, expr = this.parseExpression();
    if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
      { return this.parseLabeledStatement(node, maybeName, expr) }
    else { return this.parseExpressionStatement(node, expr) }
  }
};

pp$1.parseBreakContinueStatement = function(node, keyword) {
  var this$1 = this;

  var isBreak = keyword == "break";
  this.next();
  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
  else if (this.type !== types.name) { this.unexpected(); }
  else {
    node.label = this.parseIdent();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this$1.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
      if (node.label && isBreak) { break }
    }
  }
  if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
};

pp$1.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement")
};

pp$1.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6)
    { this.eat(types.semi); }
  else
    { this.semicolon(); }
  return this.finishNode(node, "DoWhileStatement")
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  this.enterLexicalScope();
  this.expect(types.parenL);
  if (this.type === types.semi) { return this.parseFor(node, null) }
  var isLet = this.isLet();
  if (this.type === types._var || this.type === types._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1 &&
        !(kind !== "var" && init$1.declarations[0].init))
      { return this.parseForIn(node, init$1) }
    return this.parseFor(node, init$1)
  }
  var refDestructuringErrors = new DestructuringErrors;
  var init = this.parseExpression(true, refDestructuringErrors);
  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    this.toAssignable(init);
    this.checkLVal(init);
    this.checkPatternErrors(refDestructuringErrors, true);
    return this.parseForIn(node, init)
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  return this.parseFor(node, init)
};

pp$1.parseFunctionStatement = function(node, isAsync) {
  this.next();
  return this.parseFunction(node, true, false, isAsync)
};

pp$1.isFunction = function() {
  return this.type === types._function || this.isAsyncFunction()
};

pp$1.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  // allow function declarations in branches, but only in non-strict mode
  node.consequent = this.parseStatement(!this.strict && this.isFunction());
  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.isFunction()) : null;
  return this.finishNode(node, "IfStatement")
};

pp$1.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction)
    { this.raise(this.start, "'return' outside of function"); }
  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
  else { node.argument = this.parseExpression(); this.semicolon(); }
  return this.finishNode(node, "ReturnStatement")
};

pp$1.parseSwitchStatement = function(node) {
  var this$1 = this;

  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.labels.push(switchLabel);
  this.enterLexicalScope();

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur;
  for (var sawDefault = false; this.type != types.braceR;) {
    if (this$1.type === types._case || this$1.type === types._default) {
      var isCase = this$1.type === types._case;
      if (cur) { this$1.finishNode(cur, "SwitchCase"); }
      node.cases.push(cur = this$1.startNode());
      cur.consequent = [];
      this$1.next();
      if (isCase) {
        cur.test = this$1.parseExpression();
      } else {
        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, "Multiple default clauses"); }
        sawDefault = true;
        cur.test = null;
      }
      this$1.expect(types.colon);
    } else {
      if (!cur) { this$1.unexpected(); }
      cur.consequent.push(this$1.parseStatement(true));
    }
  }
  this.exitLexicalScope();
  if (cur) { this.finishNode(cur, "SwitchCase"); }
  this.next(); // Closing brace
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement")
};

pp$1.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
    { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement")
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types._catch) {
    var clause = this.startNode();
    this.next();
    this.expect(types.parenL);
    clause.param = this.parseBindingAtom();
    this.enterLexicalScope();
    this.checkLVal(clause.param, "let");
    this.expect(types.parenR);
    clause.body = this.parseBlock(false);
    this.exitLexicalScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer)
    { this.raise(node.start, "Missing catch or finally clause"); }
  return this.finishNode(node, "TryStatement")
};

pp$1.parseVarStatement = function(node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration")
};

pp$1.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "WhileStatement")
};

pp$1.parseWithStatement = function(node) {
  if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement")
};

pp$1.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement")
};

pp$1.parseLabeledStatement = function(node, maybeName, expr) {
  var this$1 = this;

  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)
    {
    var label = list[i$1];

    if (label.name === maybeName)
      { this$1.raise(expr.start, "Label '" + maybeName + "' is already declared");
  } }
  var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this$1.labels[i];
    if (label$1.statementStart == node.start) {
      label$1.statementStart = this$1.start;
      label$1.kind = kind;
    } else { break }
  }
  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
  node.body = this.parseStatement(true);
  if (node.body.type == "ClassDeclaration" ||
      node.body.type == "VariableDeclaration" && node.body.kind != "var" ||
      node.body.type == "FunctionDeclaration" && (this.strict || node.body.generator))
    { this.raiseRecoverable(node.body.start, "Invalid labeled declaration"); }
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement")
};

pp$1.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement")
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function(createNewLexicalScope) {
  var this$1 = this;
  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;

  var node = this.startNode();
  node.body = [];
  this.expect(types.braceL);
  if (createNewLexicalScope) {
    this.enterLexicalScope();
  }
  while (!this.eat(types.braceR)) {
    var stmt = this$1.parseStatement(true);
    node.body.push(stmt);
  }
  if (createNewLexicalScope) {
    this.exitLexicalScope();
  }
  return this.finishNode(node, "BlockStatement")
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function(node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.type === types.semi ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.type === types.parenR ? null : this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, "ForStatement")
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function(node, init) {
  var type = this.type === types._in ? "ForInStatement" : "ForOfStatement";
  this.next();
  node.left = init;
  node.right = this.parseExpression();
  this.expect(types.parenR);
  this.exitLexicalScope();
  node.body = this.parseStatement(false);
  this.labels.pop();
  return this.finishNode(node, type)
};

// Parse a list of variable declarations.

pp$1.parseVar = function(node, isFor, kind) {
  var this$1 = this;

  node.declarations = [];
  node.kind = kind;
  for (;;) {
    var decl = this$1.startNode();
    this$1.parseVarId(decl, kind);
    if (this$1.eat(types.eq)) {
      decl.init = this$1.parseMaybeAssign(isFor);
    } else if (kind === "const" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual("of")))) {
      this$1.unexpected();
    } else if (decl.id.type != "Identifier" && !(isFor && (this$1.type === types._in || this$1.isContextual("of")))) {
      this$1.raise(this$1.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this$1.finishNode(decl, "VariableDeclarator"));
    if (!this$1.eat(types.comma)) { break }
  }
  return node
};

pp$1.parseVarId = function(decl, kind) {
  decl.id = this.parseBindingAtom(kind);
  this.checkLVal(decl.id, kind, false);
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6 && !isAsync)
    { node.generator = this.eat(types.star); }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  if (isStatement) {
    node.id = isStatement === "nullableID" && this.type != types.name ? null : this.parseIdent();
    if (node.id) {
      this.checkLVal(node.id, "var");
    }
  }

  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;
  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  if (!isStatement)
    { node.id = this.type == types.name ? this.parseIdent() : null; }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression")
};

pp$1.parseFunctionParams = function(node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function(node, isStatement) {
  var this$1 = this;

  this.next();

  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (this$1.eat(types.semi)) { continue }
    var method = this$1.startNode();
    var isGenerator = this$1.eat(types.star);
    var isAsync = false;
    var isMaybeStatic = this$1.type === types.name && this$1.value === "static";
    this$1.parsePropertyName(method);
    method.static = isMaybeStatic && this$1.type !== types.parenL;
    if (method.static) {
      if (isGenerator) { this$1.unexpected(); }
      isGenerator = this$1.eat(types.star);
      this$1.parsePropertyName(method);
    }
    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&
        method.key.type === "Identifier" && method.key.name === "async" && this$1.type !== types.parenL &&
        !this$1.canInsertSemicolon()) {
      isAsync = true;
      this$1.parsePropertyName(method);
    }
    method.kind = "method";
    var isGetSet = false;
    if (!method.computed) {
      var key = method.key;
      if (!isGenerator && !isAsync && key.type === "Identifier" && this$1.type !== types.parenL && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this$1.parsePropertyName(method);
      }
      if (!method.static && (key.type === "Identifier" && key.name === "constructor" ||
          key.type === "Literal" && key.value === "constructor")) {
        if (hadConstructor) { this$1.raise(key.start, "Duplicate constructor in the same class"); }
        if (isGetSet) { this$1.raise(key.start, "Constructor can't have get/set modifier"); }
        if (isGenerator) { this$1.raise(key.start, "Constructor can't be a generator"); }
        if (isAsync) { this$1.raise(key.start, "Constructor can't be an async method"); }
        method.kind = "constructor";
        hadConstructor = true;
      }
    }
    this$1.parseClassMethod(classBody, method, isGenerator, isAsync);
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.value.params.length !== paramCount) {
        var start = method.value.start;
        if (method.kind === "get")
          { this$1.raiseRecoverable(start, "getter should have no params"); }
        else
          { this$1.raiseRecoverable(start, "setter should have exactly one param"); }
      } else {
        if (method.kind === "set" && method.value.params[0].type === "RestElement")
          { this$1.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
      }
    }
  }
  node.body = this.finishNode(classBody, "ClassBody");
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
};

pp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {
  method.value = this.parseMethod(isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "MethodDefinition"));
};

pp$1.parseClassId = function(node, isStatement) {
  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;
};

pp$1.parseClassSuper = function(node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function(node, exports) {
  var this$1 = this;

  this.next();
  // export * from '...'
  if (this.eat(types.star)) {
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    this.semicolon();
    return this.finishNode(node, "ExportAllDeclaration")
  }
  if (this.eat(types._default)) { // export default ...
    this.checkExport(exports, "default", this.lastTokStart);
    var isAsync;
    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
      var fNode = this.startNode();
      this.next();
      if (isAsync) { this.next(); }
      node.declaration = this.parseFunction(fNode, "nullableID", false, isAsync);
    } else if (this.type === types._class) {
      var cNode = this.startNode();
      node.declaration = this.parseClass(cNode, "nullableID");
    } else {
      node.declaration = this.parseMaybeAssign();
      this.semicolon();
    }
    return this.finishNode(node, "ExportDefaultDeclaration")
  }
  // export var|const|let|function|class ...
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseStatement(true);
    if (node.declaration.type === "VariableDeclaration")
      { this.checkVariableExport(exports, node.declaration.declarations); }
    else
      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
    node.specifiers = [];
    node.source = null;
  } else { // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
    } else {
      // check for keywords used as local names
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];

        this$1.checkUnreserved(spec.local);
      }

      node.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration")
};

pp$1.checkExport = function(exports, name, pos) {
  if (!exports) { return }
  if (has(exports, name))
    { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
  exports[name] = true;
};

pp$1.checkPatternExport = function(exports, pat) {
  var this$1 = this;

  var type = pat.type;
  if (type == "Identifier")
    { this.checkExport(exports, pat.name, pat.start); }
  else if (type == "ObjectPattern")
    { for (var i = 0, list = pat.properties; i < list.length; i += 1)
      {
        var prop = list[i];

        this$1.checkPatternExport(exports, prop.value);
      } }
  else if (type == "ArrayPattern")
    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];

        if (elt) { this$1.checkPatternExport(exports, elt); }
    } }
  else if (type == "AssignmentPattern")
    { this.checkPatternExport(exports, pat.left); }
  else if (type == "ParenthesizedExpression")
    { this.checkPatternExport(exports, pat.expression); }
};

pp$1.checkVariableExport = function(exports, decls) {
  var this$1 = this;

  if (!exports) { return }
  for (var i = 0, list = decls; i < list.length; i += 1)
    {
    var decl = list[i];

    this$1.checkPatternExport(exports, decl.id);
  }
};

pp$1.shouldParseExportStatement = function() {
  return this.type.keyword === "var" ||
    this.type.keyword === "const" ||
    this.type.keyword === "class" ||
    this.type.keyword === "function" ||
    this.isLet() ||
    this.isAsyncFunction()
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function(exports) {
  var this$1 = this;

  var nodes = [], first = true;
  // export { x, y as z } [from '...']
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node = this$1.startNode();
    node.local = this$1.parseIdent(true);
    node.exported = this$1.eatContextual("as") ? this$1.parseIdent(true) : node.local;
    this$1.checkExport(exports, node.exported.name, node.exported.start);
    nodes.push(this$1.finishNode(node, "ExportSpecifier"));
  }
  return nodes
};

// Parses import declaration.

pp$1.parseImport = function(node) {
  this.next();
  // import '...'
  if (this.type === types.string) {
    node.specifiers = empty;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration")
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function() {
  var this$1 = this;

  var nodes = [], first = true;
  if (this.type === types.name) {
    // import defaultObj, { x, y as z } from '...'
    var node = this.startNode();
    node.local = this.parseIdent();
    this.checkLVal(node.local, "let");
    nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
    if (!this.eat(types.comma)) { return nodes }
  }
  if (this.type === types.star) {
    var node$1 = this.startNode();
    this.next();
    this.expectContextual("as");
    node$1.local = this.parseIdent();
    this.checkLVal(node$1.local, "let");
    nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
    return nodes
  }
  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var node$2 = this$1.startNode();
    node$2.imported = this$1.parseIdent(true);
    if (this$1.eatContextual("as")) {
      node$2.local = this$1.parseIdent();
    } else {
      this$1.checkUnreserved(node$2.imported);
      node$2.local = node$2.imported;
    }
    this$1.checkLVal(node$2.local, "let");
    nodes.push(this$1.finishNode(node$2, "ImportSpecifier"));
  }
  return nodes
};

// Set `ExpressionStatement#directive` property for directive prologues.
pp$1.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$1.isDirectiveCandidate = function(statement) {
  return (
    statement.type === "ExpressionStatement" &&
    statement.expression.type === "Literal" &&
    typeof statement.expression.value === "string" &&
    // Reject parenthesized strings.
    (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
  )
};

var pp$2 = Parser$1.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function(node, isBinding) {
  var this$1 = this;

  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
    case "Identifier":
      if (this.inAsync && node.name === "await")
        { this.raise(node.start, "Can not use 'await' as identifier inside an async function"); }
      break

    case "ObjectPattern":
    case "ArrayPattern":
      break

    case "ObjectExpression":
      node.type = "ObjectPattern";
      for (var i = 0, list = node.properties; i < list.length; i += 1) {
        var prop = list[i];

      if (prop.kind !== "init") { this$1.raise(prop.key.start, "Object pattern can't contain getter or setter"); }
        this$1.toAssignable(prop.value, isBinding);
      }
      break

    case "ArrayExpression":
      node.type = "ArrayPattern";
      this.toAssignableList(node.elements, isBinding);
      break

    case "AssignmentExpression":
      if (node.operator === "=") {
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        // falls through to AssignmentPattern
      } else {
        this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        break
      }

    case "AssignmentPattern":
      break

    case "ParenthesizedExpression":
      this.toAssignable(node.expression, isBinding);
      break

    case "MemberExpression":
      if (!isBinding) { break }

    default:
      this.raise(node.start, "Assigning to rvalue");
    }
  }
  return node
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function(exprList, isBinding) {
  var this$1 = this;

  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type == "RestElement") {
      --end;
    } else if (last && last.type == "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding);
      --end;
    }

    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
      { this.unexpected(last.argument.start); }
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) { this$1.toAssignable(elt, isBinding); }
  }
  return exprList
};

// Parses spread element.

pp$2.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement")
};

pp$2.parseRestBinding = function() {
  var node = this.startNode();
  this.next();

  // RestElement inside of a function parameter must be an identifier
  if (this.options.ecmaVersion === 6 && this.type !== types.name)
    { this.unexpected(); }

  node.argument = this.parseBindingAtom();

  return this.finishNode(node, "RestElement")
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true, true);
      return this.finishNode(node, "ArrayPattern")

    case types.braceL:
      return this.parseObj(true)
    }
  }
  return this.parseIdent()
};

pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) { first = false; }
    else { this$1.expect(types.comma); }
    if (allowEmpty && this$1.type === types.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {
      break
    } else if (this$1.type === types.ellipsis) {
      var rest = this$1.parseRestBinding();
      this$1.parseBindingListItem(rest);
      elts.push(rest);
      if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
      this$1.expect(close);
      break
    } else {
      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);
      this$1.parseBindingListItem(elem);
      elts.push(elem);
    }
  }
  return elts
};

pp$2.parseBindingListItem = function(param) {
  return param
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern")
};

// Verify that a node is an lval — something that can be assigned
// to.
// bindingType can be either:
// 'var' indicating that the lval creates a 'var' binding
// 'let' indicating that the lval creates a lexical ('let' or 'const') binding
// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references

pp$2.checkLVal = function(expr, bindingType, checkClashes) {
  var this$1 = this;

  switch (expr.type) {
  case "Identifier":
    if (this.strict && this.reservedWordsStrictBind.test(expr.name))
      { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
    if (checkClashes) {
      if (has(checkClashes, expr.name))
        { this.raiseRecoverable(expr.start, "Argument name clash"); }
      checkClashes[expr.name] = true;
    }
    if (bindingType && bindingType !== "none") {
      if (
        bindingType === "var" && !this.canDeclareVarName(expr.name) ||
        bindingType !== "var" && !this.canDeclareLexicalName(expr.name)
      ) {
        this.raiseRecoverable(expr.start, ("Identifier '" + (expr.name) + "' has already been declared"));
      }
      if (bindingType === "var") {
        this.declareVarName(expr.name);
      } else {
        this.declareLexicalName(expr.name);
      }
    }
    break

  case "MemberExpression":
    if (bindingType) { this.raiseRecoverable(expr.start, (bindingType ? "Binding" : "Assigning to") + " member expression"); }
    break

  case "ObjectPattern":
    for (var i = 0, list = expr.properties; i < list.length; i += 1)
      {
    var prop = list[i];

    this$1.checkLVal(prop.value, bindingType, checkClashes);
  }
    break

  case "ArrayPattern":
    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
      var elem = list$1[i$1];

    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }
    }
    break

  case "AssignmentPattern":
    this.checkLVal(expr.left, bindingType, checkClashes);
    break

  case "RestElement":
    this.checkLVal(expr.argument, bindingType, checkClashes);
    break

  case "ParenthesizedExpression":
    this.checkLVal(expr.expression, bindingType, checkClashes);
    break

  default:
    this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
  }
};

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts — that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser$1.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash —
// either with each other or with an init property — and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function(prop, propHash) {
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
    { return }
  var key = prop.key;
  var name;
  switch (key.type) {
  case "Identifier": name = key.name; break
  case "Literal": name = String(key.value); break
  default: return
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
      propHash.proto = true;
    }
    return
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition)
      { this.raiseRecoverable(key.start, "Redefinition of property"); }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function(s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function(noIn, refDestructuringErrors) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
  if (this.type === types.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }
    return this.finishNode(node, "SequenceExpression")
  }
  return expr
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
  if (this.inGenerator && this.isContextual("yield")) { return this.parseYield() }

  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors;
    ownDestructuringErrors = true;
  }

  var startPos = this.start, startLoc = this.startLoc;
  if (this.type == types.parenL || this.type == types.name)
    { this.potentialArrowAt = this.start; }
  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
  if (this.type.isAssign) {
    this.checkPatternErrors(refDestructuringErrors, true);
    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    node.left = this.type === types.eq ? this.toAssignable(left) : left;
    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly
    this.checkLVal(left);
    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression")
  } else {
    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
  }
  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
  return left
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(noIn, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression")
  }
  return expr
};

// Start the precedence parser.

pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false);
  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
  return expr.start == startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.type.binop;
  if (prec != null && (!noIn || this.type !== types._in)) {
    if (prec > minPrec) {
      var logical = this.type === types.logicalOR || this.type === types.logicalAND;
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
    }
  }
  return left
};

pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.inAsync && this.isContextual("await")) {
    expr = this.parseAwait();
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) { this.checkLVal(node.argument); }
    else if (this.strict && node.operator === "delete" &&
             node.argument.type === "Identifier")
      { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
    else { sawUnary = true; }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors);
    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.operator = this$1.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this$1.checkLVal(expr);
      this$1.next();
      expr = this$1.finishNode(node$1, "UpdateExpression");
    }
  }

  if (!sawUnary && this.eat(types.starstar))
    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
  else
    { return expr }
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function(refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors);
  var skipArrowSubscripts = expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")";
  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }
  var result = this.parseSubscripts(expr, startPos, startLoc);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
  }
  return result
};

pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
  var this$1 = this;

  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
      this.lastTokEnd == base.end && !this.canInsertSemicolon();
  for (var computed = (void 0);;) {
    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {
      var node = this$1.startNodeAt(startPos, startLoc);
      node.object = base;
      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);
      node.computed = !!computed;
      if (computed) { this$1.expect(types.bracketR); }
      base = this$1.finishNode(node, "MemberExpression");
    } else if (!noCalls && this$1.eat(types.parenL)) {
      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;
      this$1.yieldPos = 0;
      this$1.awaitPos = 0;
      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);
      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {
        this$1.checkPatternErrors(refDestructuringErrors, false);
        this$1.checkYieldAwaitInDefaultParams();
        this$1.yieldPos = oldYieldPos;
        this$1.awaitPos = oldAwaitPos;
        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)
      }
      this$1.checkExpressionErrors(refDestructuringErrors, true);
      this$1.yieldPos = oldYieldPos || this$1.yieldPos;
      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;
      var node$1 = this$1.startNodeAt(startPos, startLoc);
      node$1.callee = base;
      node$1.arguments = exprList;
      base = this$1.finishNode(node$1, "CallExpression");
    } else if (this$1.type === types.backQuote) {
      var node$2 = this$1.startNodeAt(startPos, startLoc);
      node$2.tag = base;
      node$2.quasi = this$1.parseTemplate({isTagged: true});
      base = this$1.finishNode(node$2, "TaggedTemplateExpression");
    } else {
      return base
    }
  }
};

// Parse an atomic expression — either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function(refDestructuringErrors) {
  var node, canBeArrow = this.potentialArrowAt == this.start;
  switch (this.type) {
  case types._super:
    if (!this.inFunction)
      { this.raise(this.start, "'super' outside of function or class"); }
    node = this.startNode();
    this.next();
    // The `super` keyword can appear at below:
    // SuperProperty:
    //     super [ Expression ]
    //     super . IdentifierName
    // SuperCall:
    //     super Arguments
    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
      { this.unexpected(); }
    return this.finishNode(node, "Super")

  case types._this:
    node = this.startNode();
    this.next();
    return this.finishNode(node, "ThisExpression")

  case types.name:
    var startPos = this.start, startLoc = this.startLoc;
    var id = this.parseIdent(this.type !== types.name);
    if (this.options.ecmaVersion >= 8 && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }
    if (canBeArrow && !this.canInsertSemicolon()) {
      if (this.eat(types.arrow))
        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
      if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name) {
        id = this.parseIdent();
        if (this.canInsertSemicolon() || !this.eat(types.arrow))
          { this.unexpected(); }
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
      }
    }
    return id

  case types.regexp:
    var value = this.value;
    node = this.parseLiteral(value.value);
    node.regex = {pattern: value.pattern, flags: value.flags};
    return node

  case types.num: case types.string:
    return this.parseLiteral(this.value)

  case types._null: case types._true: case types._false:
    node = this.startNode();
    node.value = this.type === types._null ? null : this.type === types._true;
    node.raw = this.type.keyword;
    this.next();
    return this.finishNode(node, "Literal")

  case types.parenL:
    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
    if (refDestructuringErrors) {
      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
        { refDestructuringErrors.parenthesizedAssign = start; }
      if (refDestructuringErrors.parenthesizedBind < 0)
        { refDestructuringErrors.parenthesizedBind = start; }
    }
    return expr

  case types.bracketL:
    node = this.startNode();
    this.next();
    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
    return this.finishNode(node, "ArrayExpression")

  case types.braceL:
    return this.parseObj(false, refDestructuringErrors)

  case types._function:
    node = this.startNode();
    this.next();
    return this.parseFunction(node, false)

  case types._class:
    return this.parseClass(this.startNode(), false)

  case types._new:
    return this.parseNew()

  case types.backQuote:
    return this.parseTemplate()

  default:
    this.unexpected();
  }
};

pp$3.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  this.next();
  return this.finishNode(node, "Literal")
};

pp$3.parseParenExpression = function() {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val
};

pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
  var this$1 = this;

  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();

    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types.parenR) {
      first ? first = false : this$1.expect(types.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {
        lastIsComma = true;
        break
      } else if (this$1.type === types.ellipsis) {
        spreadStart = this$1.start;
        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));
        if (this$1.type === types.comma) { this$1.raise(this$1.start, "Comma is not permitted after the rest element"); }
        break
      } else {
        if (this$1.type === types.parenL && !innerParenStart) {
          innerParenStart = this$1.start;
        }
        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));
      }
    }
    var innerEndPos = this.start, innerEndLoc = this.startLoc;
    this.expect(types.parenR);

    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (innerParenStart) { this.unexpected(innerParenStart); }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList)
    }

    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
    if (spreadStart) { this.unexpected(spreadStart); }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;

    if (exprList.length > 1) {
      val = this.startNodeAt(innerStartPos, innerStartLoc);
      val.expressions = exprList;
      this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val = exprList[0];
    }
  } else {
    val = this.parseParenExpression();
  }

  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val;
    return this.finishNode(par, "ParenthesizedExpression")
  } else {
    return val
  }
};

pp$3.parseParenItem = function(item) {
  return item
};

pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
};

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call — at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.

var empty$1 = [];

pp$3.parseNew = function() {
  var node = this.startNode();
  var meta = this.parseIdent(true);
  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
    node.meta = meta;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target")
      { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
    if (!this.inFunction)
      { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
    return this.finishNode(node, "MetaProperty")
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
  else { node.arguments = empty$1; }
  return this.finishNode(node, "NewExpression")
};

// Parse template expression.

pp$3.parseTemplateElement = function(ref) {
  var isTagged = ref.isTagged;

  var elem = this.startNode();
  if (this.type === types.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value,
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types.backQuote;
  return this.finishNode(elem, "TemplateElement")
};

pp$3.parseTemplate = function(ref) {
  var this$1 = this;
  if ( ref === void 0 ) ref = {};
  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({isTagged: isTagged});
  node.quasis = [curElt];
  while (!curElt.tail) {
    this$1.expect(types.dollarBraceL);
    node.expressions.push(this$1.parseExpression());
    this$1.expect(types.braceR);
    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral")
};

pp$3.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword) &&
    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function(isPattern, refDestructuringErrors) {
  var this$1 = this;

  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types.braceR)) {
    if (!first) {
      this$1.expect(types.comma);
      if (this$1.afterTrailingComma(types.braceR)) { break }
    } else { first = false; }

    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);
    this$1.checkPropClash(prop, propHash);
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
};

pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern)
      { isGenerator = this.eat(types.star); }
  }
  this.parsePropertyName(prop);
  if (!isPattern && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    this.parsePropertyName(prop, refDestructuringErrors);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors);
  return this.finishNode(prop, "Property")
};

pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {
  if ((isGenerator || isAsync) && this.type === types.colon)
    { this.unexpected(); }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
    if (isPattern) { this.unexpected(); }
    prop.kind = "init";
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
  } else if (!isPattern &&
             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
             (prop.key.name === "get" || prop.key.name === "set") &&
             (this.type != types.comma && this.type != types.braceR)) {
    if (isGenerator || isAsync) { this.unexpected(); }
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    prop.value = this.parseMethod(false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.value.params.length !== paramCount) {
      var start = prop.value.start;
      if (prop.kind === "get")
        { this.raiseRecoverable(start, "getter should have no params"); }
      else
        { this.raiseRecoverable(start, "setter should have exactly one param"); }
    } else {
      if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
        { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
    }
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    this.checkUnreserved(prop.key);
    prop.kind = "init";
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else if (this.type === types.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0)
        { refDestructuringErrors.shorthandAssign = this.start; }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
    } else {
      prop.value = prop.key;
    }
    prop.shorthand = true;
  } else { this.unexpected(); }
};

pp$3.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types.bracketR);
      return prop.key
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)
};

// Initialize empty function node.

pp$3.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = false;
    node.expression = false;
  }
  if (this.options.ecmaVersion >= 8)
    { node.async = false; }
};

// Parse object or class method.

pp$3.parseMethod = function(isGenerator, isAsync) {
  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.initFunction(node);
  if (this.options.ecmaVersion >= 6)
    { node.generator = isGenerator; }
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.inGenerator = node.generator;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;
  this.enterFunctionScope();

  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "FunctionExpression")
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function(node, params, isAsync) {
  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,
      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;

  this.enterFunctionScope();
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8)
    { node.async = !!isAsync; }

  this.inGenerator = false;
  this.inAsync = node.async;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.inFunction = true;

  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true);

  this.inGenerator = oldInGen;
  this.inAsync = oldInAsync;
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.inFunction = oldInFunc;
  return this.finishNode(node, "ArrowFunctionExpression")
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function(node, isArrowFunction) {
  var isExpression = isArrowFunction && this.type !== types.braceL;
  var oldStrict = this.strict, useStrict = false;

  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      // If this is a strict mode function, verify that argument names
      // are not repeated, and it does not try to bind the words `eval`
      // or `arguments`.
      if (useStrict && nonSimple)
        { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
    }
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) { this.strict = true; }

    // Add the params to varDeclaredNames to ensure that an error is thrown
    // if a let/const declaration in the function clashes with one of the params.
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));
    node.body = this.parseBlock(false);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitFunctionScope();

  if (this.strict && node.id) {
    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'
    this.checkLVal(node.id, "none");
  }
  this.strict = oldStrict;
};

pp$3.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1)
    {
    var param = list[i];

    if (param.type !== "Identifier") { return false
  } }
  return true
};

// Checks function params for various disallowed patterns such as using "eval"
// or "arguments" and duplicate parameters.

pp$3.checkParams = function(node, allowDuplicates) {
  var this$1 = this;

  var nameHash = {};
  for (var i = 0, list = node.params; i < list.length; i += 1)
    {
    var param = list[i];

    this$1.checkLVal(param, "var", allowDuplicates ? null : nameHash);
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var this$1 = this;

  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this$1.expect(types.comma);
      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }
    } else { first = false; }

    var elt = (void 0);
    if (allowEmpty && this$1.type === types.comma)
      { elt = null; }
    else if (this$1.type === types.ellipsis) {
      elt = this$1.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)
        { refDestructuringErrors.trailingComma = this$1.start; }
    } else {
      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts
};

pp$3.checkUnreserved = function(ref) {
  var start = ref.start;
  var end = ref.end;
  var name = ref.name;

  if (this.inGenerator && name === "yield")
    { this.raiseRecoverable(start, "Can not use 'yield' as identifier inside a generator"); }
  if (this.inAsync && name === "await")
    { this.raiseRecoverable(start, "Can not use 'await' as identifier inside an async function"); }
  if (this.isKeyword(name))
    { this.raise(start, ("Unexpected keyword '" + name + "'")); }
  if (this.options.ecmaVersion < 6 &&
    this.input.slice(start, end).indexOf("\\") != -1) { return }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name))
    { this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved")); }
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdent = function(liberal, isBinding) {
  var node = this.startNode();
  if (liberal && this.options.allowReserved == "never") { liberal = false; }
  if (this.type === types.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;

    // To fix https://github.com/ternjs/acorn/issues/575
    // `class` and `function` keywords push new context into this.context.
    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.
    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword
    if ((node.name === "class" || node.name === "function") &&
        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "Identifier");
  if (!liberal) { this.checkUnreserved(node); }
  return node
};

// Parses yield expression inside generator.

pp$3.parseYield = function() {
  if (!this.yieldPos) { this.yieldPos = this.start; }

  var node = this.startNode();
  this.next();
  if (this.type == types.semi || this.canInsertSemicolon() || (this.type != types.star && !this.type.startsExpr)) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression")
};

pp$3.parseAwait = function() {
  if (!this.awaitPos) { this.awaitPos = this.start; }

  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true);
  return this.finishNode(node, "AwaitExpression")
};

var pp$4 = Parser$1.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
  throw err
};

pp$4.raiseRecoverable = pp$4.raise;

pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart)
  }
};

var pp$5 = Parser$1.prototype;

// Object.assign polyfill
var assign = Object.assign || function(target) {
  var sources = [], len = arguments.length - 1;
  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];

  for (var i = 0, list = sources; i < list.length; i += 1) {
    var source = list[i];

    for (var key in source) {
      if (has(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp$5.enterFunctionScope = function() {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});
};

pp$5.exitFunctionScope = function() {
  this.scopeStack.pop();
};

pp$5.enterLexicalScope = function() {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};

  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp$5.exitLexicalScope = function() {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];

  assign(parentScope.childVar, childScope.var, childScope.childVar);
};

/**
 * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
 * in the current lexical scope or any of the parent lexical scopes in this function.
 */
pp$5.canDeclareVarName = function(name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)
};

/**
 * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
 * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
 * any child lexical scopes in this function.
 */
pp$5.canDeclareLexicalName = function(name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)
};

pp$5.declareVarName = function(name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp$5.declareLexicalName = function(name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};

var Node = function Node(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations)
    { this.loc = new SourceLocation(parser, loc); }
  if (parser.options.directSourceFile)
    { this.sourceFile = parser.options.directSourceFile; }
  if (parser.options.ranges)
    { this.range = [pos, 0]; }
};

// Start an AST node, attaching a start offset.

var pp$6 = Parser$1.prototype;

pp$6.startNode = function() {
  return new Node(this, this.start, this.startLoc)
};

pp$6.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc)
};

// Finish an AST node, adding `type` and `end` properties.

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  if (this.options.locations)
    { node.loc.end = loc; }
  if (this.options.ranges)
    { node.range[1] = pos; }
  return node
}

pp$6.finishNode = function(node, type) {
  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
};

// Finish node at given position

pp$6.finishNodeAt = function(node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc)
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

var pp$7 = Parser$1.prototype;

pp$7.initialContext = function() {
  return [types$1.b_stat]
};

pp$7.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types$1.f_expr || parent === types$1.f_stat)
    { return true }
  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
    { return !parent.isExpr }

  // The check for `tt.name && exprAllowed` detects whether we are
  // after a `yield` or `of` construct. See the `updateContext` for
  // `tt.name`.
  if (prevType === types._return || prevType == types.name && this.exprAllowed)
    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType == types.arrow)
    { return true }
  if (prevType == types.braceL)
    { return parent === types$1.b_stat }
  if (prevType == types._var || prevType == types.name)
    { return false }
  return !this.exprAllowed
};

pp$7.inGeneratorContext = function() {
  var this$1 = this;

  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this$1.context[i];
    if (context.token === "function")
      { return context.generator }
  }
  return false
};

pp$7.updateContext = function(prevType) {
  var update, type = this.type;
  if (type.keyword && prevType == types.dot)
    { this.exprAllowed = false; }
  else if (update = type.updateContext)
    { update.call(this, prevType); }
  else
    { this.exprAllowed = type.beforeExpr; }
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length == 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType == types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6) {
    if (this.value == "of" && !this.exprAllowed ||
        this.value == "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(p) {
  this.type = p.type;
  this.value = p.value;
  this.start = p.start;
  this.end = p.end;
  if (p.options.locations)
    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
  if (p.options.ranges)
    { this.range = [p.start, p.end]; }
};

// ## Tokenizer

var pp$8 = Parser$1.prototype;

// Are we running under Rhino?
var isRhino = typeof Packages == "object" && Object.prototype.toString.call(Packages) == "[object JavaPackage]";

// Move to the next token

pp$8.next = function() {
  if (this.options.onToken)
    { this.options.onToken(new Token(this)); }

  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};

pp$8.getToken = function() {
  this.next();
  return new Token(this)
};

// If we're in an ES6 environment, make parsers iterable
if (typeof Symbol !== "undefined")
  { pp$8[Symbol.iterator] = function() {
    var this$1 = this;

    return {
      next: function () {
        var token = this$1.getToken();
        return {
          done: token.type === types.eof,
          value: token
        }
      }
    }
  }; }

// Toggle strict mode. Re-reads the next number or string to please
// pedantic tests (`"use strict"; 010;` should fail).

pp$8.curContext = function() {
  return this.context[this.context.length - 1]
};

// Read a single token, updating the parser object's token-related
// properties.

pp$8.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

  this.start = this.pos;
  if (this.options.locations) { this.startLoc = this.curPosition(); }
  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

  if (curContext.override) { return curContext.override(this) }
  else { this.readToken(this.fullCharCodeAtPos()); }
};

pp$8.readToken = function(code) {
  // Identifier or keyword. '\uXXXX' sequences are allowed in
  // identifiers, so '\' also dispatches to that.
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\' */)
    { return this.readWord() }

  return this.getTokenFromCode(code)
};

pp$8.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 0xd7ff || code >= 0xe000) { return code }
  var next = this.input.charCodeAt(this.pos + 1);
  return (code << 10) + next - 0x35fdc00
};

pp$8.skipBlockComment = function() {
  var this$1 = this;

  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
  this.pos = end + 2;
  if (this.options.locations) {
    lineBreakG.lastIndex = start;
    var match;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
      ++this$1.curLine;
      this$1.lineStart = match.index + match[0].length;
    }
  }
  if (this.options.onComment)
    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                           startLoc, this.curPosition()); }
};

pp$8.skipLineComment = function(startSkip) {
  var this$1 = this;

  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this$1.input.charCodeAt(++this$1.pos);
  }
  if (this.options.onComment)
    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                           startLoc, this.curPosition()); }
};

// Called at the start of the parse and after every token. Skips
// whitespace and comments, and.

pp$8.skipSpace = function() {
  var this$1 = this;

  loop: while (this.pos < this.input.length) {
    var ch = this$1.input.charCodeAt(this$1.pos);
    switch (ch) {
    case 32: case 160: // ' '
      ++this$1.pos;
      break
    case 13:
      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {
        ++this$1.pos;
      }
    case 10: case 8232: case 8233:
      ++this$1.pos;
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      break
    case 47: // '/'
      switch (this$1.input.charCodeAt(this$1.pos + 1)) {
      case 42: // '*'
        this$1.skipBlockComment();
        break
      case 47:
        this$1.skipLineComment(2);
        break
      default:
        break loop
      }
      break
    default:
      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
        ++this$1.pos;
      } else {
        break loop
      }
    }
  }
};

// Called at the end of every token. Sets `end`, `val`, and
// maintains `context` and `exprAllowed`, and skips the space after
// the token, so that the next one's `start` will point at the
// right position.

pp$8.finishToken = function(type, val) {
  this.end = this.pos;
  if (this.options.locations) { this.endLoc = this.curPosition(); }
  var prevType = this.type;
  this.type = type;
  this.value = val;

  this.updateContext(prevType);
};

// ### Token reading

// This is the function that is called to fetch the next token. It
// is somewhat obscure, because it works in character codes rather
// than characters, and because operator parsing has been inlined
// into it.
//
// All in the name of speed.
//
pp$8.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) { return this.readNumber(true) }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'
    this.pos += 3;
    return this.finishToken(types.ellipsis)
  } else {
    ++this.pos;
    return this.finishToken(types.dot)
  }
};

pp$8.readToken_slash = function() { // '/'
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.slash, 1)
};

pp$8.readToken_mult_modulo_exp = function(code) { // '%*'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types.star : types.modulo;

  // exponentiation operator ** and **=
  if (this.options.ecmaVersion >= 7 && code == 42 && next === 42) {
    ++size;
    tokentype = types.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }

  if (next === 61) { return this.finishOp(types.assign, size + 1) }
  return this.finishOp(tokentype, size)
};

pp$8.readToken_pipe_amp = function(code) { // '|&'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
};

pp$8.readToken_caret = function() { // '^'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.bitwiseXOR, 1)
};

pp$8.readToken_plus_min = function(code) { // '+-'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next == 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 62 &&
        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      // A `-->` line comment
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken()
    }
    return this.finishOp(types.incDec, 2)
  }
  if (next === 61) { return this.finishOp(types.assign, 2) }
  return this.finishOp(types.plusMin, 1)
};

pp$8.readToken_lt_gt = function(code) { // '<>'
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
    return this.finishOp(types.bitShift, size)
  }
  if (next == 33 && code == 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) == 45 &&
      this.input.charCodeAt(this.pos + 3) == 45) {
    // `<!--`, an XML-style comment that should be interpreted as a line comment
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken()
  }
  if (next === 61) { size = 2; }
  return this.finishOp(types.relational, size)
};

pp$8.readToken_eq_excl = function(code) { // '=!'
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'
    this.pos += 2;
    return this.finishToken(types.arrow)
  }
  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
};

pp$8.getTokenFromCode = function(code) {
  switch (code) {
    // The interpretation of a dot depends on whether it is followed
    // by a digit or another two dots.
  case 46: // '.'
    return this.readToken_dot()

    // Punctuation tokens.
  case 40: ++this.pos; return this.finishToken(types.parenL)
  case 41: ++this.pos; return this.finishToken(types.parenR)
  case 59: ++this.pos; return this.finishToken(types.semi)
  case 44: ++this.pos; return this.finishToken(types.comma)
  case 91: ++this.pos; return this.finishToken(types.bracketL)
  case 93: ++this.pos; return this.finishToken(types.bracketR)
  case 123: ++this.pos; return this.finishToken(types.braceL)
  case 125: ++this.pos; return this.finishToken(types.braceR)
  case 58: ++this.pos; return this.finishToken(types.colon)
  case 63: ++this.pos; return this.finishToken(types.question)

  case 96: // '`'
    if (this.options.ecmaVersion < 6) { break }
    ++this.pos;
    return this.finishToken(types.backQuote)

  case 48: // '0'
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number
    if (this.options.ecmaVersion >= 6) {
      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number
      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number
    }
    // Anything else beginning with a digit is an integer, octal
    // number, or float.
  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9
    return this.readNumber(false)

    // Quotes produce strings.
  case 34: case 39: // '"', "'"
    return this.readString(code)

    // Operators are parsed inline in tiny state machines. '=' (61) is
    // often referred to. `finishOp` simply skips the amount of
    // characters it is given as second argument, and returns a token
    // of the type given by its first argument.

  case 47: // '/'
    return this.readToken_slash()

  case 37: case 42: // '%*'
    return this.readToken_mult_modulo_exp(code)

  case 124: case 38: // '|&'
    return this.readToken_pipe_amp(code)

  case 94: // '^'
    return this.readToken_caret()

  case 43: case 45: // '+-'
    return this.readToken_plus_min(code)

  case 60: case 62: // '<>'
    return this.readToken_lt_gt(code)

  case 61: case 33: // '=!'
    return this.readToken_eq_excl(code)

  case 126: // '~'
    return this.finishOp(types.prefix, 1)
  }

  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};

pp$8.finishOp = function(type, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type, str)
};

// Parse a regular expression. Some context-awareness is necessary,
// since a '/' inside a '[]' set does not end the expression.

function tryCreateRegexp(src, flags, throwErrorAt, parser) {
  try {
    return new RegExp(src, flags)
  } catch (e) {
    if (throwErrorAt !== undefined) {
      if (e instanceof SyntaxError) { parser.raise(throwErrorAt, "Error parsing regular expression: " + e.message); }
      throw e
    }
  }
}

var regexpUnicodeSupport = !!tryCreateRegexp("\uffff", "u");

pp$8.readRegexp = function() {
  var this$1 = this;

  var escaped, inClass, start = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(start, "Unterminated regular expression"); }
    var ch = this$1.input.charAt(this$1.pos);
    if (lineBreak.test(ch)) { this$1.raise(start, "Unterminated regular expression"); }
    if (!escaped) {
      if (ch === "[") { inClass = true; }
      else if (ch === "]" && inClass) { inClass = false; }
      else if (ch === "/" && !inClass) { break }
      escaped = ch === "\\";
    } else { escaped = false; }
    ++this$1.pos;
  }
  var content = this.input.slice(start, this.pos);
  ++this.pos;
  // Need to use `readWord1` because '\uXXXX' sequences are allowed
  // here (don't ask).
  var mods = this.readWord1();
  var tmp = content, tmpFlags = "";
  if (mods) {
    var validFlags = /^[gim]*$/;
    if (this.options.ecmaVersion >= 6) { validFlags = /^[gimuy]*$/; }
    if (!validFlags.test(mods)) { this.raise(start, "Invalid regular expression flag"); }
    if (mods.indexOf("u") >= 0) {
      if (regexpUnicodeSupport) {
        tmpFlags = "u";
      } else {
        // Replace each astral symbol and every Unicode escape sequence that
        // possibly represents an astral symbol or a paired surrogate with a
        // single ASCII symbol to avoid throwing on regular expressions that
        // are only valid in combination with the `/u` flag.
        // Note: replacing with the ASCII symbol `x` might cause false
        // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
        // perfectly valid pattern that is equivalent to `[a-b]`, but it would
        // be replaced by `[x-b]` which throws an error.
        tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, function (_match, code, offset) {
          code = Number("0x" + code);
          if (code > 0x10FFFF) { this$1.raise(start + offset + 3, "Code point out of bounds"); }
          return "x"
        });
        tmp = tmp.replace(/\\u([a-fA-F0-9]{4})|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x");
        tmpFlags = tmpFlags.replace("u", "");
      }
    }
  }
  // Detect invalid regular expressions.
  var value = null;
  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,
  // so don't do detection if we are running under Rhino
  if (!isRhino) {
    tryCreateRegexp(tmp, tmpFlags, start, this);
    // Get a regular expression object for this pattern-flag pair, or `null` in
    // case the current environment doesn't support the flags it uses.
    value = tryCreateRegexp(content, mods);
  }
  return this.finishToken(types.regexp, {pattern: content, flags: mods, value: value})
};

// Read an integer in the given radix. Return null if zero digits
// were read, the integer value otherwise. When `len` is given, this
// will return `null` unless the integer has exactly `len` digits.

pp$8.readInt = function(radix, len) {
  var this$1 = this;

  var start = this.pos, total = 0;
  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);
    if (code >= 97) { val = code - 97 + 10; } // a
    else if (code >= 65) { val = code - 65 + 10; } // A
    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9
    else { val = Infinity; }
    if (val >= radix) { break }
    ++this$1.pos;
    total = total * radix + val;
  }
  if (this.pos === start || len != null && this.pos - start !== len) { return null }

  return total
};

pp$8.readRadixNumber = function(radix) {
  this.pos += 2; // 0x
  var val = this.readInt(radix);
  if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  return this.finishToken(types.num, val)
};

// Read an integer, octal integer, or floating-point number.

pp$8.readNumber = function(startsWithDot) {
  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48;
  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
  if (octal && this.pos == start + 1) { octal = false; }
  var next = this.input.charCodeAt(this.pos);
  if (next === 46 && !octal) { // '.'
    ++this.pos;
    this.readInt(10);
    isFloat = true;
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) { // 'eE'
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) { ++this.pos; } // '+-'
    if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
    isFloat = true;
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

  var str = this.input.slice(start, this.pos), val;
  if (isFloat) { val = parseFloat(str); }
  else if (!octal || str.length === 1) { val = parseInt(str, 10); }
  else if (this.strict) { this.raise(start, "Invalid number"); }
  else if (/[89]/.test(str)) { val = parseInt(str, 10); }
  else { val = parseInt(str, 8); }
  return this.finishToken(types.num, val)
};

// Read a string value, interpreting backslash-escapes.

pp$8.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;

  if (ch === 123) { // '{'
    if (this.options.ecmaVersion < 6) { this.unexpected(); }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
  } else {
    code = this.readHexChar(4);
  }
  return code
};

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) { return String.fromCharCode(code) }
  code -= 0x10000;
  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
}

pp$8.readString = function(quote) {
  var this$1 = this;

  var out = "", chunkStart = ++this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated string constant"); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === quote) { break }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(false);
      chunkStart = this$1.pos;
    } else {
      if (isNewLine(ch)) { this$1.raise(this$1.start, "Unterminated string constant"); }
      ++this$1.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types.string, out)
};

// Reads template string tokens.

var INVALID_TEMPLATE_ESCAPE_ERROR = {};

pp$8.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err) {
    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err
    }
  }

  this.inTemplateElement = false;
};

pp$8.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR
  } else {
    this.raise(position, message);
  }
};

pp$8.readTmplToken = function() {
  var this$1 = this;

  var out = "", chunkStart = this.pos;
  for (;;) {
    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, "Unterminated template"); }
    var ch = this$1.input.charCodeAt(this$1.pos);
    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'
      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {
        if (ch === 36) {
          this$1.pos += 2;
          return this$1.finishToken(types.dollarBraceL)
        } else {
          ++this$1.pos;
          return this$1.finishToken(types.backQuote)
        }
      }
      out += this$1.input.slice(chunkStart, this$1.pos);
      return this$1.finishToken(types.template, out)
    }
    if (ch === 92) { // '\'
      out += this$1.input.slice(chunkStart, this$1.pos);
      out += this$1.readEscapedChar(true);
      chunkStart = this$1.pos;
    } else if (isNewLine(ch)) {
      out += this$1.input.slice(chunkStart, this$1.pos);
      ++this$1.pos;
      switch (ch) {
      case 13:
        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }
      case 10:
        out += "\n";
        break
      default:
        out += String.fromCharCode(ch);
        break
      }
      if (this$1.options.locations) {
        ++this$1.curLine;
        this$1.lineStart = this$1.pos;
      }
      chunkStart = this$1.pos;
    } else {
      ++this$1.pos;
    }
  }
};

// Reads a template token to search for the end, without validating any escape sequences
pp$8.readInvalidTemplateToken = function() {
  var this$1 = this;

  for (; this.pos < this.input.length; this.pos++) {
    switch (this$1.input[this$1.pos]) {
    case "\\":
      ++this$1.pos;
      break

    case "$":
      if (this$1.input[this$1.pos + 1] !== "{") {
        break
      }
    // falls through

    case "`":
      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))

    // no default
    }
  }
  this.raise(this.start, "Unterminated template");
};

// Used to read escaped characters

pp$8.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
  case 110: return "\n" // 'n' -> '\n'
  case 114: return "\r" // 'r' -> '\r'
  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'
  case 117: return codePointToString(this.readCodePoint()) // 'u'
  case 116: return "\t" // 't' -> '\t'
  case 98: return "\b" // 'b' -> '\b'
  case 118: return "\u000b" // 'v' -> '\u000b'
  case 102: return "\f" // 'f' -> '\f'
  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\r\n'
  case 10: // ' \n'
    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
    return ""
  default:
    if (ch >= 48 && ch <= 55) {
      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
      var octal = parseInt(octalStr, 8);
      if (octal > 255) {
        octalStr = octalStr.slice(0, -1);
        octal = parseInt(octalStr, 8);
      }
      if (octalStr !== "0" && (this.strict || inTemplate)) {
        this.invalidStringToken(this.pos - 2, "Octal literal in strict mode");
      }
      this.pos += octalStr.length - 1;
      return String.fromCharCode(octal)
    }
    return String.fromCharCode(ch)
  }
};

// Used to read character escape sequences ('\x', '\u', '\U').

pp$8.readHexChar = function(len) {
  var codePos = this.pos;
  var n = this.readInt(16, len);
  if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
  return n
};

// Read an identifier, and return it as a string. Sets `this.containsEsc`
// to whether the word contained a '\u' escape.
//
// Incrementally adds only escaped chars, adding other chunks as-is
// as a micro-optimization.

pp$8.readWord1 = function() {
  var this$1 = this;

  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this$1.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this$1.pos += ch <= 0xffff ? 1 : 2;
    } else if (ch === 92) { // "\"
      this$1.containsEsc = true;
      word += this$1.input.slice(chunkStart, this$1.pos);
      var escStart = this$1.pos;
      if (this$1.input.charCodeAt(++this$1.pos) != 117) // "u"
        { this$1.invalidStringToken(this$1.pos, "Expecting Unicode escape sequence \\uXXXX"); }
      ++this$1.pos;
      var esc = this$1.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
        { this$1.invalidStringToken(escStart, "Invalid Unicode escape"); }
      word += codePointToString(esc);
      chunkStart = this$1.pos;
    } else {
      break
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos)
};

// Read an identifier or keyword token. Will check for reserved
// words when necessary.

pp$8.readWord = function() {
  var word = this.readWord1();
  var type = types.name;
  if (this.keywords.test(word)) {
    if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword " + word); }
    type = keywords$1[word];
  }
  return this.finishToken(type, word)
};

// Acorn is a tiny, fast JavaScript parser written in JavaScript.
//
// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and
// various contributors and released under an MIT license.
//
// Git repositories for Acorn are available at
//
//     http://marijnhaverbeke.nl/git/acorn
//     https://github.com/ternjs/acorn.git
//
// Please use the [github bug tracker][ghbt] to report issues.
//
// [ghbt]: https://github.com/ternjs/acorn/issues
//
// This file defines the main parser interface. The library also comes
// with a [error-tolerant parser][dammit] and an
// [abstract syntax tree walker][walk], defined in other files.
//
// [dammit]: acorn_loose.js
// [walk]: util/walk.js

var version$1 = "5.2.1";

// The main exported interface (under `self.acorn` when in the
// browser) is a `parse` function that takes a code string and
// returns an abstract syntax tree as specified by [Mozilla parser
// API][api].
//
// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

function parse$1(input, options) {
  return new Parser$1(options, input).parse()
}

// This function tries to parse a single expression at a given
// offset in a string. Useful for parsing mixed-language formats
// that embed JavaScript expressions.

function parseExpressionAt(input, pos, options) {
  var p = new Parser$1(options, input, pos);
  p.nextToken();
  return p.parseExpression()
}

// Acorn is organized as a tokenizer and a recursive-descent parser.
// The `tokenizer` export provides an interface to the tokenizer.

function tokenizer(input, options) {
  return new Parser$1(options, input)
}

// This is a terrible kludge to support the existing, pre-ES6
// interface where the loose parser module retroactively adds exports
// to this module.
var parse_dammit;
var LooseParser;
var pluginsLoose; // eslint-disable-line camelcase
function addLooseExports(parse, Parser$$1, plugins$$1) {
  parse_dammit = parse; // eslint-disable-line camelcase
  LooseParser = Parser$$1;
  pluginsLoose = plugins$$1;
}




var acorn = Object.freeze({
	version: version$1,
	parse: parse$1,
	parseExpressionAt: parseExpressionAt,
	tokenizer: tokenizer,
	get parse_dammit () { return parse_dammit; },
	get LooseParser () { return LooseParser; },
	get pluginsLoose () { return pluginsLoose; },
	addLooseExports: addLooseExports,
	Parser: Parser$1,
	plugins: plugins,
	defaultOptions: defaultOptions,
	Position: Position,
	SourceLocation: SourceLocation,
	getLineInfo: getLineInfo,
	Node: Node,
	TokenType: TokenType,
	tokTypes: types,
	keywordTypes: keywords$1,
	TokContext: TokContext,
	tokContexts: types$1,
	isIdentifierChar: isIdentifierChar,
	isIdentifierStart: isIdentifierStart,
	Token: Token,
	isNewLine: isNewLine,
	lineBreak: lineBreak,
	lineBreakG: lineBreakG,
	nonASCIIwhitespace: nonASCIIwhitespace
});

var literals = new Map([['true', true], ['false', false], ['null', null]]);
function readExpression(parser) {
    var start = parser.index;
    var name = parser.readUntil(/\s*}}/);
    if (name && /^[a-z]+$/.test(name)) {
        var end = start + name.length;
        if (literals.has(name)) {
            return {
                type: 'Literal',
                start: start,
                end: end,
                value: literals.get(name),
                raw: name
            };
        }
        return {
            type: 'Identifier',
            start: start,
            end: start + name.length,
            name: name
        };
    }
    parser.index = start;
    try {
        var node = parseExpressionAt(parser.template, parser.index, {
            preserveParens: true
        });
        parser.index = node.end;
        return node;
    }
    catch (err) {
        parser.acornError(err);
    }
}

/* eslint-disable no-underscore-dangle */

function injectDynamicImport(acorn) {
  const tt = acorn.tokTypes;

  // NOTE: This allows `yield import()` to parse correctly.
  tt._import.startsExpr = true;

  function parseDynamicImport() {
    const node = this.startNode();
    this.next();
    if (this.type !== tt.parenL) {
      this.unexpected();
    }
    return this.finishNode(node, 'Import');
  }

  function peekNext() {
    return this.input[this.pos];
  }

  // eslint-disable-next-line no-param-reassign
  acorn.plugins.dynamicImport = function dynamicImportPlugin(instance) {
    instance.extend('parseStatement', nextMethod => (
      function parseStatement(...args) {
        const node = this.startNode();
        if (this.type === tt._import) {
          const nextToken = peekNext.call(this);
          if (nextToken === tt.parenL.label) {
            const expr = this.parseExpression();
            return this.parseExpressionStatement(node, expr);
          }
        }

        return nextMethod.apply(this, args);
      }
    ));

    instance.extend('parseExprAtom', nextMethod => (
      function parseExprAtom(refDestructuringErrors) {
        if (this.type === tt._import) {
          return parseDynamicImport.call(this);
        }
        return nextMethod.call(this, refDestructuringErrors);
      }
    ));
  };

  return acorn;
}

function repeat(str, i) {
    var result = '';
    while (i--)
        result += str;
    return result;
}

var scriptClosingTag = '</script>';
injectDynamicImport(acorn);
function readScript(parser, start, attributes) {
    var scriptStart = parser.index;
    var scriptEnd = parser.template.indexOf(scriptClosingTag, scriptStart);
    if (scriptEnd === -1)
        parser.error("<script> must have a closing tag");
    var source = repeat(' ', scriptStart) + parser.template.slice(scriptStart, scriptEnd);
    parser.index = scriptEnd + scriptClosingTag.length;
    var ast;
    try {
        ast = parse$1(source, {
            ecmaVersion: 8,
            sourceType: 'module',
            plugins: {
                dynamicImport: true
            }
        });
    }
    catch (err) {
        parser.acornError(err);
    }
    if (!ast.body.length)
        return null;
    ast.start = scriptStart;
    return {
        start: start,
        end: parser.index,
        attributes: attributes,
        content: ast
    };
}

var MAX_LINE_LENGTH = 100;
var OFFSET_CORRECTION = 60;
var TAB_REPLACEMENT = '    ';

function sourceFragment(error, extraLines) {
    function processLines(start, end) {
        return lines.slice(start, end).map(function(line, idx) {
            var num = String(start + idx + 1);

            while (num.length < maxNumLength) {
                num = ' ' + num;
            }

            return num + ' |' + line;
        }).join('\n');
    }

    var lines = error.source.split(/\n|\r\n?|\f/);
    var line = error.line;
    var column = error.column;
    var startLine = Math.max(1, line - extraLines) - 1;
    var endLine = Math.min(line + extraLines, lines.length + 1);
    var maxNumLength = Math.max(4, String(endLine).length) + 1;
    var cutLeft = 0;

    // correct column according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].join('\n');
}

var CssSyntaxError = function(message, source, offset, line, column) {
    // some VMs prevent setting line/column otherwise (iOS Safari 10 even throw an exception)
    var error = Object.create(SyntaxError.prototype);

    error.name = 'CssSyntaxError';
    error.message = message;
    error.stack = (new Error().stack || '').replace(/^.+\n/, error.name + ': ' + error.message + '\n');
    error.source = source;
    error.offset = offset;
    error.line = line;
    error.column = column;

    error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
    };
    Object.defineProperty(error, 'formattedMessage', {
        get: function() {
            return (
                'Parse error: ' + error.message + '\n' +
                sourceFragment(error, 2)
            );
        }
    });

    // for backward capability
    error.parseError = {
        offset: offset,
        line: line,
        column: column
    };

    return error;
};

var error = CssSyntaxError;

// token types (note: value shouldn't intersect with used char codes)
var WHITESPACE$1 = 1;
var IDENTIFIER$1 = 2;
var NUMBER$1 = 3;
var STRING$1 = 4;
var COMMENT$1 = 5;
var PUNCTUATOR$1 = 6;
var CDO$1 = 7;
var CDC$1 = 8;
var ATRULE$1 = 14;
var FUNCTION$1 = 15;
var URL$1 = 16;
var RAW$1 = 17;

var TAB = 9;
var N$1 = 10;
var F$1 = 12;
var R$1 = 13;
var SPACE = 32;

var TYPE$1 = {
    WhiteSpace:   WHITESPACE$1,
    Identifier:   IDENTIFIER$1,
    Number:           NUMBER$1,
    String:           STRING$1,
    Comment:         COMMENT$1,
    Punctuator:   PUNCTUATOR$1,
    CDO:                 CDO$1,
    CDC:                 CDC$1,
    Atrule:           ATRULE$1,
    Function:       FUNCTION$1,
    Url:                 URL$1,
    Raw:                 RAW$1,

    ExclamationMark:      33,  // !
    QuotationMark:        34,  // "
    NumberSign:           35,  // #
    DollarSign:           36,  // $
    PercentSign:          37,  // %
    Ampersand:            38,  // &
    Apostrophe:           39,  // '
    LeftParenthesis:      40,  // (
    RightParenthesis:     41,  // )
    Asterisk:             42,  // *
    PlusSign:             43,  // +
    Comma:                44,  // ,
    HyphenMinus:          45,  // -
    FullStop:             46,  // .
    Solidus:              47,  // /
    Colon:                58,  // :
    Semicolon:            59,  // ;
    LessThanSign:         60,  // <
    EqualsSign:           61,  // =
    GreaterThanSign:      62,  // >
    QuestionMark:         63,  // ?
    CommercialAt:         64,  // @
    LeftSquareBracket:    91,  // [
    Backslash:            92,  // \
    RightSquareBracket:   93,  // ]
    CircumflexAccent:     94,  // ^
    LowLine:              95,  // _
    GraveAccent:          96,  // `
    LeftCurlyBracket:    123,  // {
    VerticalLine:        124,  // |
    RightCurlyBracket:   125,  // }
    Tilde:               126   // ~
};

var NAME$1 = Object.keys(TYPE$1).reduce(function(result, key) {
    result[TYPE$1[key]] = key;
    return result;
}, {});

// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
// > non-ASCII code point
// >   A code point with a value equal to or greater than U+0080 <control>
// > name-start code point
// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
// > name code point
// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
// That means only ASCII code points has a special meaning and we a maps for 0..127 codes only
var SafeUint32Array$1 = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported
var SYMBOL_TYPE$1 = new SafeUint32Array$1(0x80);
var PUNCTUATION = new SafeUint32Array$1(0x80);
var STOP_URL_RAW = new SafeUint32Array$1(0x80);

for (var i = 0; i < SYMBOL_TYPE$1.length; i++) {
    SYMBOL_TYPE$1[i] = IDENTIFIER$1;
}

// fill categories
[
    TYPE$1.ExclamationMark,    // !
    TYPE$1.QuotationMark,      // "
    TYPE$1.NumberSign,         // #
    TYPE$1.DollarSign,         // $
    TYPE$1.PercentSign,        // %
    TYPE$1.Ampersand,          // &
    TYPE$1.Apostrophe,         // '
    TYPE$1.LeftParenthesis,    // (
    TYPE$1.RightParenthesis,   // )
    TYPE$1.Asterisk,           // *
    TYPE$1.PlusSign,           // +
    TYPE$1.Comma,              // ,
    TYPE$1.HyphenMinus,        // -
    TYPE$1.FullStop,           // .
    TYPE$1.Solidus,            // /
    TYPE$1.Colon,              // :
    TYPE$1.Semicolon,          // ;
    TYPE$1.LessThanSign,       // <
    TYPE$1.EqualsSign,         // =
    TYPE$1.GreaterThanSign,    // >
    TYPE$1.QuestionMark,       // ?
    TYPE$1.CommercialAt,       // @
    TYPE$1.LeftSquareBracket,  // [
    // TYPE.Backslash,          // \
    TYPE$1.RightSquareBracket, // ]
    TYPE$1.CircumflexAccent,   // ^
    // TYPE.LowLine,            // _
    TYPE$1.GraveAccent,        // `
    TYPE$1.LeftCurlyBracket,   // {
    TYPE$1.VerticalLine,       // |
    TYPE$1.RightCurlyBracket,  // }
    TYPE$1.Tilde               // ~
].forEach(function(key) {
    SYMBOL_TYPE$1[Number(key)] = PUNCTUATOR$1;
    PUNCTUATION[Number(key)] = PUNCTUATOR$1;
});

for (var i = 48; i <= 57; i++) {
    SYMBOL_TYPE$1[i] = NUMBER$1;
}

SYMBOL_TYPE$1[SPACE] = WHITESPACE$1;
SYMBOL_TYPE$1[TAB] = WHITESPACE$1;
SYMBOL_TYPE$1[N$1] = WHITESPACE$1;
SYMBOL_TYPE$1[R$1] = WHITESPACE$1;
SYMBOL_TYPE$1[F$1] = WHITESPACE$1;

SYMBOL_TYPE$1[TYPE$1.Apostrophe] = STRING$1;
SYMBOL_TYPE$1[TYPE$1.QuotationMark] = STRING$1;

STOP_URL_RAW[SPACE] = 1;
STOP_URL_RAW[TAB] = 1;
STOP_URL_RAW[N$1] = 1;
STOP_URL_RAW[R$1] = 1;
STOP_URL_RAW[F$1] = 1;
STOP_URL_RAW[TYPE$1.Apostrophe] = 1;
STOP_URL_RAW[TYPE$1.QuotationMark] = 1;
STOP_URL_RAW[TYPE$1.LeftParenthesis] = 1;
STOP_URL_RAW[TYPE$1.RightParenthesis] = 1;

// whitespace is punctuation ...
PUNCTUATION[SPACE] = PUNCTUATOR$1;
PUNCTUATION[TAB] = PUNCTUATOR$1;
PUNCTUATION[N$1] = PUNCTUATOR$1;
PUNCTUATION[R$1] = PUNCTUATOR$1;
PUNCTUATION[F$1] = PUNCTUATOR$1;
// ... hyper minus is not
PUNCTUATION[TYPE$1.HyphenMinus] = 0;

var _const = {
    TYPE: TYPE$1,
    NAME: NAME$1,

    SYMBOL_TYPE: SYMBOL_TYPE$1,
    PUNCTUATION: PUNCTUATION,
    STOP_URL_RAW: STOP_URL_RAW
};

var PUNCTUATION$1 = _const.PUNCTUATION;
var STOP_URL_RAW$1 = _const.STOP_URL_RAW;
var TYPE$2 = _const.TYPE;
var FULLSTOP$1 = TYPE$2.FullStop;
var PLUSSIGN$1 = TYPE$2.PlusSign;
var HYPHENMINUS$1 = TYPE$2.HyphenMinus;
var PUNCTUATOR$2 = TYPE$2.Punctuator;
var TAB$1 = 9;
var N$2 = 10;
var F$2 = 12;
var R$2 = 13;
var SPACE$1 = 32;
var BACK_SLASH = 92;
var E = 101; // 'e'.charCodeAt(0)

function firstCharOffset$1(source) {
    // detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
    if (source.charCodeAt(0) === 0xFEFF ||  // UTF-16BE
        source.charCodeAt(0) === 0xFFFE) {  // UTF-16LE
        return 1;
    }

    return 0;
}

function isHex(code) {
    return (code >= 48 && code <= 57) || // 0 .. 9
           (code >= 65 && code <= 70) || // A .. F
           (code >= 97 && code <= 102);  // a .. f
}

function isNumber$1(code) {
    return code >= 48 && code <= 57;
}

function isNewline(source, offset, code) {
    if (code === N$2 || code === F$2 || code === R$2) {
        if (code === R$2 && offset + 1 < source.length && source.charCodeAt(offset + 1) === N$2) {
            return 2;
        }

        return 1;
    }

    return 0;
}

function cmpChar(testStr, offset, referenceCode) {
    var code = testStr.charCodeAt(offset);

    // code.toLowerCase()
    if (code >= 65 && code <= 90) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr$1(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var refCode = referenceStr.charCodeAt(i - start);

        // testStr[i].toLowerCase()
        if (testCode >= 65 && testCode <= 90) {
            testCode = testCode | 32;
        }

        if (testCode !== refCode) {
            return false;
        }
    }

    return true;
}

function endsWith(testStr, referenceStr) {
    return cmpStr$1(testStr, testStr.length - referenceStr.length, testStr.length, referenceStr);
}

function findLastNonSpaceLocation$1(scanner) {
    for (var i = scanner.source.length - 1; i >= 0; i--) {
        var code = scanner.source.charCodeAt(i);

        if (code !== SPACE$1 && code !== TAB$1 && code !== R$2 && code !== N$2 && code !== F$2) {
            break;
        }
    }

    return scanner.getLocation(i + 1);
}

function findWhiteSpaceEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code !== SPACE$1 && code !== TAB$1 && code !== R$2 && code !== N$2 && code !== F$2) {
            break;
        }
    }

    return offset;
}

function findCommentEnd$1(source, offset) {
    var commentEnd = source.indexOf('*/', offset);

    if (commentEnd === -1) {
        return source.length;
    }

    return commentEnd + 2;
}

function findStringEnd$1(source, offset, quote) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        // TODO: bad string
        if (code === BACK_SLASH) {
            offset++;
        } else if (code === quote) {
            offset++;
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code < 48 || code > 57) {  // not a 0 .. 9
            break;
        }
    }

    return offset;
}

function findNumberEnd$1(source, offset, allowFraction) {
    var code;

    offset = findDecimalNumberEnd(source, offset);

    // fraction: .\d+
    if (allowFraction && offset + 1 < source.length && source.charCodeAt(offset) === FULLSTOP$1) {
        code = source.charCodeAt(offset + 1);

        if (isNumber$1(code)) {
            offset = findDecimalNumberEnd(source, offset + 1);
        }
    }

    // exponent: e[+-]\d+
    if (offset + 1 < source.length) {
        if ((source.charCodeAt(offset) | 32) === E) { // case insensitive check for `e`
            code = source.charCodeAt(offset + 1);

            if (code === PLUSSIGN$1 || code === HYPHENMINUS$1) {
                if (offset + 2 < source.length) {
                    code = source.charCodeAt(offset + 2);
                }
            }

            if (isNumber$1(code)) {
                offset = findDecimalNumberEnd(source, offset + 2);
            }
        }
    }

    return offset;
}

// skip escaped unicode sequence that can ends with space
// [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
function findEscaseEnd(source, offset) {
    for (var i = 0; i < 7 && offset + i < source.length; i++) {
        var code = source.charCodeAt(offset + i);

        if (i !== 6 && isHex(code)) {
            continue;
        }

        if (i > 0) {
            offset += i - 1 + isNewline(source, offset + i, code);
            if (code === SPACE$1 || code === TAB$1) {
                offset++;
            }
        }

        break;
    }

    return offset;
}

function findIdentifierEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code === BACK_SLASH) {
            offset = findEscaseEnd(source, offset + 1);
        } else if (code < 0x80 && PUNCTUATION$1[code] === PUNCTUATOR$2) {
            break;
        }
    }

    return offset;
}

function findUrlRawEnd$1(source, offset) {
    for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);

        if (code === BACK_SLASH) {
            offset = findEscaseEnd(source, offset + 1);
        } else if (code < 0x80 && STOP_URL_RAW$1[code] === 1) {
            break;
        }
    }

    return offset;
}

var utils = {
    firstCharOffset: firstCharOffset$1,

    isHex: isHex,
    isNumber: isNumber$1,
    isNewline: isNewline,

    cmpChar: cmpChar,
    cmpStr: cmpStr$1,
    endsWith: endsWith,

    findLastNonSpaceLocation: findLastNonSpaceLocation$1,
    findWhiteSpaceEnd: findWhiteSpaceEnd$1,
    findCommentEnd: findCommentEnd$1,
    findStringEnd: findStringEnd$1,
    findDecimalNumberEnd: findDecimalNumberEnd,
    findNumberEnd: findNumberEnd$1,
    findEscaseEnd: findEscaseEnd,
    findIdentifierEnd: findIdentifierEnd$1,
    findUrlRawEnd: findUrlRawEnd$1
};

var TYPE = _const.TYPE;
var NAME = _const.NAME;
var SYMBOL_TYPE = _const.SYMBOL_TYPE;


var firstCharOffset = utils.firstCharOffset;
var cmpStr = utils.cmpStr;
var isNumber = utils.isNumber;
var findLastNonSpaceLocation = utils.findLastNonSpaceLocation;
var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
var findCommentEnd = utils.findCommentEnd;
var findStringEnd = utils.findStringEnd;
var findNumberEnd = utils.findNumberEnd;
var findIdentifierEnd = utils.findIdentifierEnd;
var findUrlRawEnd = utils.findUrlRawEnd;

var NULL = 0;
var WHITESPACE = TYPE.WhiteSpace;
var IDENTIFIER = TYPE.Identifier;
var NUMBER = TYPE.Number;
var STRING = TYPE.String;
var COMMENT = TYPE.Comment;
var PUNCTUATOR = TYPE.Punctuator;
var CDO = TYPE.CDO;
var CDC = TYPE.CDC;
var ATRULE = TYPE.Atrule;
var FUNCTION = TYPE.Function;
var URL = TYPE.Url;
var RAW = TYPE.Raw;

var N = 10;
var F = 12;
var R = 13;
var STAR = TYPE.Asterisk;
var SLASH = TYPE.Solidus;
var FULLSTOP = TYPE.FullStop;
var PLUSSIGN = TYPE.PlusSign;
var HYPHENMINUS = TYPE.HyphenMinus;
var GREATERTHANSIGN = TYPE.GreaterThanSign;
var LESSTHANSIGN = TYPE.LessThanSign;
var EXCLAMATIONMARK = TYPE.ExclamationMark;
var COMMERCIALAT = TYPE.CommercialAt;
var QUOTATIONMARK = TYPE.QuotationMark;
var APOSTROPHE = TYPE.Apostrophe;
var LEFTPARENTHESIS = TYPE.LeftParenthesis;
var RIGHTPARENTHESIS = TYPE.RightParenthesis;
var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;

var MIN_BUFFER_SIZE = 16 * 1024;
var OFFSET_MASK = 0x00FFFFFF;
var TYPE_SHIFT = 24;
var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

function computeLinesAndColumns(tokenizer, source) {
    var sourceLength = source.length;
    var start = firstCharOffset(source);
    var lines = tokenizer.lines;
    var line = tokenizer.startLine;
    var columns = tokenizer.columns;
    var column = tokenizer.startColumn;

    if (lines === null || lines.length < sourceLength + 1) {
        lines = new SafeUint32Array(Math.max(sourceLength + 1024, MIN_BUFFER_SIZE));
        columns = new SafeUint32Array(lines.length);
    }

    for (var i = start; i < sourceLength; i++) {
        var code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[i] = line;
    columns[i] = column;

    tokenizer.linesAnsColumnsComputed = true;
    tokenizer.lines = lines;
    tokenizer.columns = columns;
}

function tokenLayout(tokenizer, source, startPos) {
    var sourceLength = source.length;
    var offsetAndType = tokenizer.offsetAndType;
    var balance = tokenizer.balance;
    var tokenCount = 0;
    var prevType = 0;
    var offset = startPos;
    var anchor = 0;
    var balanceCloseCode = 0;
    var balanceStart = 0;
    var balancePrev = 0;

    if (offsetAndType === null || offsetAndType.length < sourceLength + 1) {
        offsetAndType = new SafeUint32Array(sourceLength + 1024);
        balance = new SafeUint32Array(sourceLength + 1024);
    }

    while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = code < 0x80 ? SYMBOL_TYPE[code] : IDENTIFIER;

        balance[tokenCount] = sourceLength;

        switch (type) {
            case WHITESPACE:
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            case PUNCTUATOR:
                switch (code) {
                    case balanceCloseCode:
                        balancePrev = balanceStart & OFFSET_MASK;
                        balanceStart = balance[balancePrev];
                        balanceCloseCode = balanceStart >> TYPE_SHIFT;
                        balance[tokenCount] = balancePrev;
                        balance[balancePrev++] = tokenCount;
                        for (; balancePrev < tokenCount; balancePrev++) {
                            if (balance[balancePrev] === sourceLength) {
                                balance[balancePrev] = tokenCount;
                            }
                        }
                        break;

                    case LEFTSQUAREBRACKET:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTSQUAREBRACKET;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;

                    case LEFTCURLYBRACKET:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTCURLYBRACKET;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;

                    case LEFTPARENTHESIS:
                        balance[tokenCount] = balanceStart;
                        balanceCloseCode = RIGHTPARENTHESIS;
                        balanceStart = (balanceCloseCode << TYPE_SHIFT) | tokenCount;
                        break;
                }

                // /*
                if (code === STAR && prevType === SLASH) {
                    type = COMMENT;
                    offset = findCommentEnd(source, offset + 1);
                    tokenCount--; // rewrite prev token
                    break;
                }

                // edge case for -.123 and +.123
                if (code === FULLSTOP && (prevType === PLUSSIGN || prevType === HYPHENMINUS)) {
                    if (offset + 1 < sourceLength && isNumber(source.charCodeAt(offset + 1))) {
                        type = NUMBER;
                        offset = findNumberEnd(source, offset + 2, false);
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // <!--
                if (code === EXCLAMATIONMARK && prevType === LESSTHANSIGN) {
                    if (offset + 2 < sourceLength &&
                        source.charCodeAt(offset + 1) === HYPHENMINUS &&
                        source.charCodeAt(offset + 2) === HYPHENMINUS) {
                        type = CDO;
                        offset = offset + 3;
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // -->
                if (code === HYPHENMINUS && prevType === HYPHENMINUS) {
                    if (offset + 1 < sourceLength && source.charCodeAt(offset + 1) === GREATERTHANSIGN) {
                        type = CDC;
                        offset = offset + 2;
                        tokenCount--; // rewrite prev token
                        break;
                    }
                }

                // ident(
                if (code === LEFTPARENTHESIS && prevType === IDENTIFIER) {
                    offset = offset + 1;
                    tokenCount--; // rewrite prev token
                    balance[tokenCount] = balance[tokenCount + 1];
                    balanceStart--;

                    // 4 char length identifier and equal to `url(` (case insensitive)
                    if (offset - anchor === 4 && cmpStr(source, anchor, offset, 'url(')) {
                        // special case for url() because it can contain any symbols sequence with few exceptions
                        anchor = findWhiteSpaceEnd(source, offset);
                        code = source.charCodeAt(anchor);
                        if (code !== LEFTPARENTHESIS &&
                            code !== RIGHTPARENTHESIS &&
                            code !== QUOTATIONMARK &&
                            code !== APOSTROPHE) {
                            // url(
                            offsetAndType[tokenCount++] = (URL << TYPE_SHIFT) | offset;
                            balance[tokenCount] = sourceLength;

                            // ws*
                            if (anchor !== offset) {
                                offsetAndType[tokenCount++] = (WHITESPACE << TYPE_SHIFT) | anchor;
                                balance[tokenCount] = sourceLength;
                            }

                            // raw
                            type = RAW;
                            offset = findUrlRawEnd(source, anchor);
                        } else {
                            type = URL;
                        }
                    } else {
                        type = FUNCTION;
                    }
                    break;
                }

                type = code;
                offset = offset + 1;
                break;

            case NUMBER:
                offset = findNumberEnd(source, offset + 1, prevType !== FULLSTOP);

                // merge number with a preceding dot, dash or plus
                if (prevType === FULLSTOP ||
                    prevType === HYPHENMINUS ||
                    prevType === PLUSSIGN) {
                    tokenCount--; // rewrite prev token
                }

                break;

            case STRING:
                offset = findStringEnd(source, offset + 1, code);
                break;

            default:
                anchor = offset;
                offset = findIdentifierEnd(source, offset);

                // merge identifier with a preceding dash
                if (prevType === HYPHENMINUS) {
                    // rewrite prev token
                    tokenCount--;
                    // restore prev prev token type
                    // for case @-prefix-ident
                    prevType = tokenCount === 0 ? 0 : offsetAndType[tokenCount - 1] >> TYPE_SHIFT;
                }

                if (prevType === COMMERCIALAT) {
                    // rewrite prev token and change type to <at-keyword-token>
                    tokenCount--;
                    type = ATRULE;
                }
        }

        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;
        prevType = type;
    }

    // finalize arrays
    offsetAndType[tokenCount] = offset;
    balance[tokenCount] = sourceLength;
    while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
    }

    tokenizer.offsetAndType = offsetAndType;
    tokenizer.tokenCount = tokenCount;
    tokenizer.balance = balance;
}

//
// tokenizer
//

var Tokenizer = function(source, startOffset, startLine, startColumn) {
    this.offsetAndType = null;
    this.balance = null;
    this.lines = null;
    this.columns = null;

    this.setSource(source, startOffset, startLine, startColumn);
};

Tokenizer.prototype = {
    setSource: function(source, startOffset, startLine, startColumn) {
        var safeSource = String(source || '');
        var start = firstCharOffset(safeSource);

        this.source = safeSource;
        this.firstCharOffset = start;
        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
        this.linesAnsColumnsComputed = false;

        this.eof = false;
        this.currentToken = -1;
        this.tokenType = 0;
        this.tokenStart = start;
        this.tokenEnd = start;

        tokenLayout(this, safeSource, start);
        this.next();
    },

    lookupType: function(offset) {
        offset += this.currentToken;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
        }

        return NULL;
    },
    lookupNonWSType: function(offset) {
        offset += this.currentToken;

        for (var type; offset < this.tokenCount; offset++) {
            type = this.offsetAndType[offset] >> TYPE_SHIFT;

            if (type !== WHITESPACE) {
                return type;
            }
        }

        return NULL;
    },
    lookupValue: function(offset, referenceStr) {
        offset += this.currentToken;

        if (offset < this.tokenCount) {
            return cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    },
    getTokenStart: function(tokenNum) {
        if (tokenNum === this.currentToken) {
            return this.tokenStart;
        }

        if (tokenNum > 0) {
            return tokenNum < this.tokenCount
                ? this.offsetAndType[tokenNum - 1] & OFFSET_MASK
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }

        return this.firstCharOffset;
    },
    getOffsetExcludeWS: function() {
        if (this.currentToken > 0) {
            if ((this.offsetAndType[this.currentToken - 1] >> TYPE_SHIFT) === WHITESPACE) {
                return this.currentToken > 1
                    ? this.offsetAndType[this.currentToken - 2] & OFFSET_MASK
                    : this.firstCharOffset;
            }
        }
        return this.tokenStart;
    },
    getRawLength: function(startToken, endTokenType1, endTokenType2, includeTokenType2) {
        var cursor = startToken;
        var balanceEnd;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // belance end points to offset before start
            if (balanceEnd < startToken) {
                break loop;
            }

            // check token is stop type
            switch (this.offsetAndType[cursor] >> TYPE_SHIFT) {
                case endTokenType1:
                    break loop;

                case endTokenType2:
                    if (includeTokenType2) {
                        cursor++;
                    }
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }
            }

        }

        return cursor - this.currentToken;
    },

    getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
    },
    substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
    },

    skipWS: function() {
        for (var i = this.currentToken, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
                break;
            }
        }

        if (skipTokenCount > 0) {
            this.skip(skipTokenCount);
        }
    },
    skipSC: function() {
        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
            this.next();
        }
    },
    skip: function(tokenCount) {
        var next = this.currentToken + tokenCount;

        if (next < this.tokenCount) {
            this.currentToken = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.currentToken = this.tokenCount;
            this.next();
        }
    },
    next: function() {
        var next = this.currentToken + 1;

        if (next < this.tokenCount) {
            this.currentToken = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.currentToken = this.tokenCount;
            this.eof = true;
            this.tokenType = NULL;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    },

    eat: function(tokenType) {
        if (this.tokenType !== tokenType) {
            var offset = this.tokenStart;
            var message = NAME[tokenType] + ' is expected';

            // tweak message and offset
            if (tokenType === IDENTIFIER) {
                // when identifier is expected but there is a function or url
                if (this.tokenType === FUNCTION || this.tokenType === URL) {
                    offset = this.tokenEnd - 1;
                    message += ' but function found';
                }
            } else {
                // when test type is part of another token show error for current position + 1
                // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
                if (this.source.charCodeAt(this.tokenStart) === tokenType) {
                    offset = offset + 1;
                }
            }

            this.error(message, offset);
        }

        this.next();
    },
    eatNonWS: function(tokenType) {
        this.skipWS();
        this.eat(tokenType);
    },

    consume: function(tokenType) {
        var value = this.getTokenValue();

        this.eat(tokenType);

        return value;
    },
    consumeFunctionName: function() {
        var name = this.source.substring(this.tokenStart, this.tokenEnd - 1);

        this.eat(FUNCTION);

        return name;
    },
    consumeNonWS: function(tokenType) {
        this.skipWS();

        return this.consume(tokenType);
    },

    expectIdentifier: function(name) {
        if (this.tokenType !== IDENTIFIER || cmpStr(this.source, this.tokenStart, this.tokenEnd, name) === false) {
            this.error('Identifier `' + name + '` is expected');
        }

        this.next();
    },

    getLocation: function(offset, filename) {
        if (!this.linesAnsColumnsComputed) {
            computeLinesAndColumns(this, this.source);
        }

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    },

    getLocationRange: function(start, end, filename) {
        if (!this.linesAnsColumnsComputed) {
            computeLinesAndColumns(this, this.source);
        }

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    },

    error: function(message, offset) {
        var location = typeof offset !== 'undefined' && offset < this.source.length
            ? this.getLocation(offset)
            : this.eof
                ? findLastNonSpaceLocation(this)
                : this.getLocation(this.tokenStart);

        throw new error(
            message || 'Unexpected input',
            this.source,
            location.offset,
            location.line,
            location.column
        );
    },

    dump: function() {
        var offset = 0;

        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
            var start = offset;
            var end = item & OFFSET_MASK;

            offset = end;

            return {
                idx: idx,
                type: NAME[item >> TYPE_SHIFT],
                chunk: this.source.substring(start, end),
                balance: this.balance[idx]
            };
        }, this);
    }
};

// extend with error class
Tokenizer.CssSyntaxError = error;

// extend tokenizer with constants
Object.keys(_const).forEach(function(key) {
    Tokenizer[key] = _const[key];
});

// extend tokenizer with static methods from utils
Object.keys(utils).forEach(function(key) {
    Tokenizer[key] = utils[key];
});

// warm up tokenizer to elimitate code branches that never execute
// fix soft deoptimizations (insufficient type feedback)
new Tokenizer('\n\r\r\n\f<!---->//""\'\'/*\r\n\f*/1a;.\\31\t\+2{url(a);func();+1.2e3 -.4e-5 .6e+7}').getLocation();

var Tokenizer_1 = Tokenizer;

var tokenizer$1 = Tokenizer_1;

//
//            item        item        item        item
//          /------\    /------\    /------\    /------\
//          | data |    | data |    | data |    | data |
//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
//          | next-+--->| next-+--->| next-+--->| next-+--> null
//          \------/    \------/    \------/    \------/
//             ^                                    ^
//             |                list                |
//             |              /------\              |
//             \--------------+-head |              |
//                            | tail-+--------------/
//                            \------/
//

function createItem(data) {
    return {
        prev: null,
        next: null,
        data: data
    };
}

var cursors = null;
var List = function() {
    this.cursor = null;
    this.head = null;
    this.tail = null;
};

List.createItem = createItem;
List.prototype.createItem = createItem;

List.prototype.getSize = function() {
    var size = 0;
    var cursor = this.head;

    while (cursor) {
        size++;
        cursor = cursor.next;
    }

    return size;
};

List.prototype.fromArray = function(array) {
    var cursor = null;

    this.head = null;

    for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);

        if (cursor !== null) {
            cursor.next = item;
        } else {
            this.head = item;
        }

        item.prev = cursor;
        cursor = item;
    }

    this.tail = cursor;

    return this;
};

List.prototype.toArray = function() {
    var cursor = this.head;
    var result = [];

    while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
    }

    return result;
};

List.prototype.toJSON = List.prototype.toArray;

List.prototype.isEmpty = function() {
    return this.head === null;
};

List.prototype.first = function() {
    return this.head && this.head.data;
};

List.prototype.last = function() {
    return this.tail && this.tail.data;
};

function allocateCursor(node, prev, next) {
    var cursor;

    if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
    } else {
        cursor = {
            prev: prev,
            next: next,
            cursor: node.cursor
        };
    }

    node.cursor = cursor;

    return cursor;
}

function releaseCursor(node) {
    var cursor = node.cursor;

    node.cursor = cursor.cursor;
    cursor.prev = null;
    cursor.next = null;
    cursor.cursor = cursors;
    cursors = cursor;
}

List.prototype.each = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, this.head);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.eachRight = function(fn, context) {
    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, this.tail, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        fn.call(context, item.data, item, this);
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.nextUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, null, start);

    while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.prevUntil = function(start, fn, context) {
    if (start === null) {
        return;
    }

    var item;

    if (context === undefined) {
        context = this;
    }

    // push cursor
    var cursor = allocateCursor(this, start, null);

    while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;

        if (fn.call(context, item.data, item, this)) {
            break;
        }
    }

    // pop cursor
    releaseCursor(this);
};

List.prototype.some = function(fn, context) {
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
            return true;
        }

        cursor = cursor.next;
    }

    return false;
};

List.prototype.map = function(fn, context) {
    var result = [];
    var cursor = this.head;

    if (context === undefined) {
        context = this;
    }

    while (cursor !== null) {
        result.push(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.clear = function() {
    this.head = null;
    this.tail = null;
};

List.prototype.copy = function() {
    var result = new List();
    var cursor = this.head;

    while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
    }

    return result;
};

List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
    var cursor = this.cursor;

    while (cursor !== null) {
        if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
        }

        if (cursor.next === nextOld) {
            cursor.next = nextNew;
        }

        cursor = cursor.cursor;
    }
};

List.prototype.prepend = function(item) {
    //      head
    //    ^
    // item
    this.updateCursors(null, item, this.head, item);

    // insert to the beginning of the list
    if (this.head !== null) {
        // new item <- first item
        this.head.prev = item;

        // new item -> first item
        item.next = this.head;
    } else {
        // if list has no head, then it also has no tail
        // in this case tail points to the new item
        this.tail = item;
    }

    // head always points to new item
    this.head = item;

    return this;
};

List.prototype.prependData = function(data) {
    return this.prepend(createItem(data));
};

List.prototype.append = function(item) {
    // tail
    //      ^
    //      item
    this.updateCursors(this.tail, item, null, item);

    // insert to the ending of the list
    if (this.tail !== null) {
        // last item -> new item
        this.tail.next = item;

        // last item <- new item
        item.prev = this.tail;
    } else {
        // if list has no tail, then it also has no head
        // in this case head points to new item
        this.head = item;
    }

    // tail always points to new item
    this.tail = item;

    return this;
};

List.prototype.appendData = function(data) {
    return this.append(createItem(data));
};

List.prototype.insert = function(item, before) {
    if (before !== undefined && before !== null) {
        // prev   before
        //      ^
        //     item
        this.updateCursors(before.prev, item, before, item);

        if (before.prev === null) {
            // insert to the beginning of list
            if (this.head !== before) {
                throw new Error('before doesn\'t belong to list');
            }

            // since head points to before therefore list doesn't empty
            // no need to check tail
            this.head = item;
            before.prev = item;
            item.next = before;

            this.updateCursors(null, item);
        } else {

            // insert between two items
            before.prev.next = item;
            item.prev = before.prev;

            before.prev = item;
            item.next = before;
        }
    } else {
        this.append(item);
    }
};

List.prototype.insertData = function(data, before) {
    this.insert(createItem(data), before);
};

List.prototype.remove = function(item) {
    //      item
    //       ^
    // prev     next
    this.updateCursors(item, item.prev, item, item.next);

    if (item.prev !== null) {
        item.prev.next = item.next;
    } else {
        if (this.head !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.head = item.next;
    }

    if (item.next !== null) {
        item.next.prev = item.prev;
    } else {
        if (this.tail !== item) {
            throw new Error('item doesn\'t belong to list');
        }

        this.tail = item.prev;
    }

    item.prev = null;
    item.next = null;

    return item;
};

List.prototype.appendList = function(list) {
    // ignore empty lists
    if (list.head === null) {
        return;
    }

    this.updateCursors(this.tail, list.tail, null, list.head);

    // insert to end of the list
    if (this.tail !== null) {
        // if destination list has a tail, then it also has a head,
        // but head doesn't change

        // dest tail -> source head
        this.tail.next = list.head;

        // dest tail <- source head
        list.head.prev = this.tail;
    } else {
        // if list has no a tail, then it also has no a head
        // in this case points head to new item
        this.head = list.head;
    }

    // tail always start point to new item
    this.tail = list.tail;

    list.head = null;
    list.tail = null;
};

List.prototype.insertList = function(list, before) {
    if (before !== undefined && before !== null) {
        // ignore empty lists
        if (list.head === null) {
            return;
        }

        this.updateCursors(before.prev, list.tail, before, list.head);

        // insert in the middle of dist list
        if (before.prev !== null) {
            // before.prev <-> list.head
            before.prev.next = list.head;
            list.head.prev = before.prev;
        } else {
            this.head = list.head;
        }

        before.prev = list.tail;
        list.tail.next = before;

        list.head = null;
        list.tail = null;
    } else {
        this.appendList(list);
    }
};

List.prototype.replace = function(oldItem, newItemOrList) {
    if ('head' in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
    } else {
        this.insert(newItemOrList, oldItem);
    }
    this.remove(oldItem);
};

var list = List;

var TYPE$3 = tokenizer$1.TYPE;
var WHITESPACE$2 = TYPE$3.WhiteSpace;
var COMMENT$2 = TYPE$3.Comment;

var sequence = function readSequence(recognizer) {
    var children = new list();
    var child = null;
    var context = {
        recognizer: recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
    };

    this.scanner.skipSC();

    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case COMMENT$2:
                this.scanner.next();
                continue;

            case WHITESPACE$2:
                if (context.ignoreWS) {
                    this.scanner.next();
                } else {
                    context.space = this.WhiteSpace();
                }
                continue;
        }

        child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (context.space !== null) {
            children.appendData(context.space);
            context.space = null;
        }

        children.appendData(child);

        if (context.ignoreWSAfter) {
            context.ignoreWSAfter = false;
            context.ignoreWS = true;
        } else {
            context.ignoreWS = false;
        }
    }

    return children;
};

var noop = function() {};

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function processConfig(config) {
    var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
    };

    if (config.parseContext) {
        for (var name in config.parseContext) {
            switch (typeof config.parseContext[name]) {
                case 'function':
                    parserConfig.context[name] = config.parseContext[name];
                    break;

                case 'string':
                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
                    break;
            }
        }
    }

    if (config.scope) {
        for (var name in config.scope) {
            parserConfig.scope[name] = config.scope[name];
        }
    }

    if (config.atrule) {
        for (var name in config.atrule) {
            var atrule = config.atrule[name];

            if (atrule.parse) {
                parserConfig.atrule[name] = atrule.parse;
            }
        }
    }

    if (config.pseudo) {
        for (var name in config.pseudo) {
            var pseudo = config.pseudo[name];

            if (pseudo.parse) {
                parserConfig.pseudo[name] = pseudo.parse;
            }
        }
    }

    if (config.node) {
        for (var name in config.node) {
            parserConfig[name] = config.node[name].parse;
        }
    }

    return parserConfig;
}

var create$1 = function createParser(config) {
    var parser = {
        scanner: new tokenizer$1(),
        filename: '<unknown>',
        needPositions: false,
        tolerant: false,
        onParseError: noop,
        parseAtruleExpression: true,
        parseSelector: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: sequence,

        tolerantParse: function(consumer, fallback) {
            if (this.tolerant) {
                var start = this.scanner.currentToken;

                try {
                    return consumer.call(this);
                } catch (e) {
                    this.onParseError(e);
                    return fallback.call(this, start);
                }
            } else {
                return consumer.call(this);
            }
        },

        getLocation: function(start, end) {
            if (this.needPositions) {
                return this.scanner.getLocationRange(
                    start,
                    end,
                    this.filename
                );
            }

            return null;
        },
        getLocationFromList: function(list) {
            if (this.needPositions) {
                return this.scanner.getLocationRange(
                    list.head !== null ? list.first().loc.start.offset - this.scanner.startOffset : this.scanner.tokenStart,
                    list.head !== null ? list.last().loc.end.offset - this.scanner.startOffset : this.scanner.tokenStart,
                    this.filename
                );
            }

            return null;
        }
    };

    config = processConfig(config || {});
    for (var key in config) {
        parser[key] = config[key];
    }

    return function(source, options) {
        options = options || {};

        var context = options.context || 'default';
        var ast;

        parser.scanner.setSource(source, options.offset, options.line, options.column);
        parser.filename = options.filename || '<unknown>';
        parser.needPositions = Boolean(options.positions);
        parser.tolerant = Boolean(options.tolerant);
        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;
        parser.parseAtruleExpression = 'parseAtruleExpression' in options ? Boolean(options.parseAtruleExpression) : true;
        parser.parseSelector = 'parseSelector' in options ? Boolean(options.parseSelector) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        if (!parser.context.hasOwnProperty(context)) {
            throw new Error('Unknown context `' + context + '`');
        }

        ast = parser.context[context].call(parser, options);

        if (!parser.scanner.eof) {
            parser.scanner.error();
        }

        // console.log(JSON.stringify(ast, null, 4));
        return ast;
    };
};

var cmpChar$1 = tokenizer$1.cmpChar;
var TYPE$4 = tokenizer$1.TYPE;

var IDENTIFIER$2 = TYPE$4.Identifier;
var STRING$2 = TYPE$4.String;
var NUMBER$2 = TYPE$4.Number;
var FUNCTION$2 = TYPE$4.Function;
var URL$2 = TYPE$4.Url;
var NUMBERSIGN = TYPE$4.NumberSign;
var LEFTPARENTHESIS$1 = TYPE$4.LeftParenthesis;
var LEFTSQUAREBRACKET$1 = TYPE$4.LeftSquareBracket;
var PLUSSIGN$2 = TYPE$4.PlusSign;
var HYPHENMINUS$2 = TYPE$4.HyphenMinus;
var COMMA = TYPE$4.Comma;
var SOLIDUS = TYPE$4.Solidus;
var ASTERISK = TYPE$4.Asterisk;
var PERCENTSIGN = TYPE$4.PercentSign;
var BACKSLASH = TYPE$4.Backslash;
var U = 117; // 'u'.charCodeAt(0)

var _default = function defaultRecognizer(context) {
    switch (this.scanner.tokenType) {
        case NUMBERSIGN:
            return this.HexColor();

        case COMMA:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Operator();

        case SOLIDUS:
        case ASTERISK:
        case PLUSSIGN$2:
        case HYPHENMINUS$2:
            return this.Operator();

        case LEFTPARENTHESIS$1:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LEFTSQUAREBRACKET$1:
            return this.Brackets(this.readSequence, context.recognizer);

        case STRING$2:
            return this.String();

        case NUMBER$2:
            switch (this.scanner.lookupType(1)) {
                case PERCENTSIGN:
                    return this.Percentage();

                case IDENTIFIER$2:
                    // edge case: number with folowing \0 and \9 hack shouldn't to be a Dimension
                    if (cmpChar$1(this.scanner.source, this.scanner.tokenEnd, BACKSLASH)) {
                        return this.Number();
                    } else {
                        return this.Dimension();
                    }

                default:
                    return this.Number();
            }

        case FUNCTION$2:
            return this.Function(this.readSequence, context.recognizer);

        case URL$2:
            return this.Url();

        case IDENTIFIER$2:
            // check for unicode range, it should start with u+ or U+
            if (cmpChar$1(this.scanner.source, this.scanner.tokenStart, U) &&
                cmpChar$1(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$2)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }
    }
};

var atruleExpression = {
    getNode: _default
};

var TYPE$5 = tokenizer$1.TYPE;

var IDENTIFIER$3 = TYPE$5.Identifier;
var NUMBER$3 = TYPE$5.Number;
var NUMBERSIGN$1 = TYPE$5.NumberSign;
var LEFTSQUAREBRACKET$2 = TYPE$5.LeftSquareBracket;
var PLUSSIGN$3 = TYPE$5.PlusSign;
var SOLIDUS$1 = TYPE$5.Solidus;
var ASTERISK$1 = TYPE$5.Asterisk;
var FULLSTOP$2 = TYPE$5.FullStop;
var COLON = TYPE$5.Colon;
var GREATERTHANSIGN$1 = TYPE$5.GreaterThanSign;
var VERTICALLINE = TYPE$5.VerticalLine;
var TILDE = TYPE$5.Tilde;

function getNode(context) {
    switch (this.scanner.tokenType) {
        case PLUSSIGN$3:
        case GREATERTHANSIGN$1:
        case TILDE:
            context.space = null;
            context.ignoreWSAfter = true;
            return this.Combinator();

        case SOLIDUS$1:  // /deep/
            return this.Combinator();

        case FULLSTOP$2:
            return this.ClassSelector();

        case LEFTSQUAREBRACKET$2:
            return this.AttributeSelector();

        case NUMBERSIGN$1:
            return this.IdSelector();

        case COLON:
            if (this.scanner.lookupType(1) === COLON) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case IDENTIFIER$3:
        case ASTERISK$1:
        case VERTICALLINE:
            return this.TypeSelector();

        case NUMBER$3:
            return this.Percentage();
    }
}

var selector = {
    getNode: getNode
};

// https://drafts.csswg.org/css-images-4/#element-notation
// https://developer.mozilla.org/en-US/docs/Web/CSS/element
var element = function() {
    this.scanner.skipSC();

    var id = this.IdSelector();

    this.scanner.skipSC();

    return new list().appendData(
        id
    );
};

// legacy IE function
// expression '(' raw ')'
var expression = function() {
    return new list().appendData(
        this.Raw(this.scanner.currentToken, 0, 0, false, false)
    );
};

var TYPE$6 = tokenizer$1.TYPE;

var IDENTIFIER$4 = TYPE$6.Identifier;
var COMMA$1 = TYPE$6.Comma;
var SEMICOLON = TYPE$6.Semicolon;
var HYPHENMINUS$3 = TYPE$6.HyphenMinus;
var EXCLAMATIONMARK$1 = TYPE$6.ExclamationMark;

// var '(' ident (',' <value>? )? ')'
var _var = function() {
    var children = new list();

    this.scanner.skipSC();

    var identStart = this.scanner.tokenStart;

    this.scanner.eat(HYPHENMINUS$3);
    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== HYPHENMINUS$3) {
        this.scanner.error('HyphenMinus is expected');
    }
    this.scanner.eat(IDENTIFIER$4);

    children.appendData({
        type: 'Identifier',
        loc: this.getLocation(identStart, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(identStart)
    });

    this.scanner.skipSC();

    if (this.scanner.tokenType === COMMA$1) {
        children.appendData(this.Operator());
        children.appendData(this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$1, SEMICOLON, false, false)
        );
    }

    return children;
};

var value = {
    getNode: _default,
    '-moz-element': element,
    'element': element,
    'expression': expression,
    'var': _var
};

var scope = {
    AtruleExpression: atruleExpression,
    Selector: selector,
    Value: value
};

var fontFace = {
    parse: {
        expression: null,
        block: function() {
            return this.Block(this.Declaration);
        }
    }
};

var TYPE$7 = tokenizer$1.TYPE;

var STRING$3 = TYPE$7.String;
var IDENTIFIER$5 = TYPE$7.Identifier;
var URL$3 = TYPE$7.Url;
var LEFTPARENTHESIS$2 = TYPE$7.LeftParenthesis;

var _import = {
    parse: {
        expression: function() {
            var children = new list();

            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case STRING$3:
                    children.appendData(this.String());
                    break;

                case URL$3:
                    children.appendData(this.Url());
                    break;

                default:
                    this.scanner.error('String or url() is expected');
            }

            if (this.scanner.lookupNonWSType(0) === IDENTIFIER$5 ||
                this.scanner.lookupNonWSType(0) === LEFTPARENTHESIS$2) {
                children.appendData(this.WhiteSpace());
                children.appendData(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
};

var media = {
    parse: {
        expression: function() {
            return new list().appendData(
                this.MediaQueryList()
            );
        },
        block: function() {
            return this.Block(this.Rule);
        }
    }
};

var TYPE$8 = tokenizer$1.TYPE;
var LEFTCURLYBRACKET$1 = TYPE$8.LeftCurlyBracket;

var page = {
    parse: {
        expression: function() {
            if (this.scanner.lookupNonWSType(0) === LEFTCURLYBRACKET$1) {
                return null;
            }

            return new list().appendData(
                this.SelectorList()
            );
        },
        block: function() {
            return this.Block(this.Declaration);
        }
    }
};

var TYPE$9 = tokenizer$1.TYPE;

var WHITESPACE$3 = TYPE$9.WhiteSpace;
var COMMENT$3 = TYPE$9.Comment;
var IDENTIFIER$6 = TYPE$9.Identifier;
var FUNCTION$3 = TYPE$9.Function;
var LEFTPARENTHESIS$3 = TYPE$9.LeftParenthesis;
var HYPHENMINUS$4 = TYPE$9.HyphenMinus;
var COLON$1 = TYPE$9.Colon;

function consumeRaw() {
    return new list().appendData(
        this.Raw(this.scanner.currentToken, 0, 0, false, false)
    );
}

function parentheses() {
    var index = 0;

    this.scanner.skipSC();

    // TODO: make it simplier
    if (this.scanner.tokenType === IDENTIFIER$6) {
        index = 1;
    } else if (this.scanner.tokenType === HYPHENMINUS$4 &&
               this.scanner.lookupType(1) === IDENTIFIER$6) {
        index = 2;
    }

    if (index !== 0 && this.scanner.lookupNonWSType(index) === COLON$1) {
        return new list().appendData(
            this.Declaration()
        );
    }

    return readSequence$1.call(this);
}

function readSequence$1() {
    var children = new list();
    var space = null;
    var child;

    this.scanner.skipSC();

    scan:
    while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
            case WHITESPACE$3:
                space = this.WhiteSpace();
                continue;

            case COMMENT$3:
                this.scanner.next();
                continue;

            case FUNCTION$3:
                child = this.Function(consumeRaw, this.scope.AtruleExpression);
                break;

            case IDENTIFIER$6:
                child = this.Identifier();
                break;

            case LEFTPARENTHESIS$3:
                child = this.Parentheses(parentheses, this.scope.AtruleExpression);
                break;

            default:
                break scan;
        }

        if (space !== null) {
            children.appendData(space);
            space = null;
        }

        children.appendData(child);
    }

    return children;
}

var supports = {
    parse: {
        expression: function() {
            var children = readSequence$1.call(this);

            if (children.isEmpty()) {
                this.scanner.error('Condition is expected');
            }

            return children;
        },
        block: function() {
            return this.Block(this.Rule);
        }
    }
};

var atrule = {
    'font-face': fontFace,
    'import': _import,
    'media': media,
    'page': page,
    'supports': supports
};

var dir = {
    parse: function() {
        return new list().appendData(
            this.Identifier()
        );
    }
};

var has$1 = {
    parse: function() {
        return new list().appendData(
            this.SelectorList()
        );
    }
};

var lang = {
    parse: function() {
        return new list().appendData(
            this.Identifier()
        );
    }
};

var selectorList = {
    parse: function selectorList() {
        return new list().appendData(
            this.SelectorList()
        );
    }
};

var matches = selectorList;

var not = selectorList;

var ALLOW_OF_CLAUSE = true;

var nthWithOfClause = {
    parse: function() {
        return new list().appendData(
            this.Nth(ALLOW_OF_CLAUSE)
        );
    }
};

var nthChild = nthWithOfClause;

var nthLastChild = nthWithOfClause;

var DISALLOW_OF_CLAUSE = false;

var nth = {
    parse: function nth() {
        return new list().appendData(
            this.Nth(DISALLOW_OF_CLAUSE)
        );
    }
};

var nthLastOfType = nth;

var nthOfType = nth;

var slotted = {
    parse: function compoundSelector() {
        return new list().appendData(
            this.Selector()
        );
    }
};

var pseudo = {
    'dir': dir,
    'has': has$1,
    'lang': lang,
    'matches': matches,
    'not': not,
    'nth-child': nthChild,
    'nth-last-child': nthLastChild,
    'nth-last-of-type': nthLastOfType,
    'nth-of-type': nthOfType,
    'slotted': slotted
};

var cmpChar$2 = tokenizer$1.cmpChar;
var isNumber$2 = tokenizer$1.isNumber;
var TYPE$10 = tokenizer$1.TYPE;

var IDENTIFIER$7 = TYPE$10.Identifier;
var NUMBER$4 = TYPE$10.Number;
var PLUSSIGN$4 = TYPE$10.PlusSign;
var HYPHENMINUS$5 = TYPE$10.HyphenMinus;
var N$3 = 110; // 'n'.charCodeAt(0)
var DISALLOW_SIGN = true;
var ALLOW_SIGN = false;

function checkTokenIsInteger(scanner, disallowSign) {
    var pos = scanner.tokenStart;

    if (scanner.source.charCodeAt(pos) === PLUSSIGN$4 ||
        scanner.source.charCodeAt(pos) === HYPHENMINUS$5) {
        if (disallowSign) {
            scanner.error();
        }
        pos++;
    }

    for (; pos < scanner.tokenEnd; pos++) {
        if (!isNumber$2(scanner.source.charCodeAt(pos))) {
            scanner.error('Unexpected input', pos);
        }
    }
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
var AnPlusB = {
    name: 'AnPlusB',
    structure: {
        a: [String, null],
        b: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = start;
        var prefix = '';
        var a = null;
        var b = null;

        if (this.scanner.tokenType === NUMBER$4 ||
            this.scanner.tokenType === PLUSSIGN$4) {
            checkTokenIsInteger(this.scanner, ALLOW_SIGN);
            prefix = this.scanner.getTokenValue();
            this.scanner.next();
            end = this.scanner.tokenStart;
        }

        if (this.scanner.tokenType === IDENTIFIER$7) {
            var bStart = this.scanner.tokenStart;

            if (cmpChar$2(this.scanner.source, bStart, HYPHENMINUS$5)) {
                if (prefix === '') {
                    prefix = '-';
                    bStart++;
                } else {
                    this.scanner.error('Unexpected hyphen minus');
                }
            }

            if (!cmpChar$2(this.scanner.source, bStart, N$3)) {
                this.scanner.error();
            }

            a = prefix === ''  ? '1'  :
                prefix === '+' ? '+1' :
                prefix === '-' ? '-1' :
                prefix;

            var len = this.scanner.tokenEnd - bStart;
            if (len > 1) {
                // ..n-..
                if (this.scanner.source.charCodeAt(bStart + 1) !== HYPHENMINUS$5) {
                    this.scanner.error('Unexpected input', bStart + 1);
                }

                if (len > 2) {
                    // ..n-{number}..
                    this.scanner.tokenStart = bStart + 2;
                } else {
                    // ..n- {number}
                    this.scanner.next();
                    this.scanner.skipSC();
                }

                checkTokenIsInteger(this.scanner, DISALLOW_SIGN);
                b = '-' + this.scanner.getTokenValue();
                this.scanner.next();
                end = this.scanner.tokenStart;
            } else {
                prefix = '';
                this.scanner.next();
                end = this.scanner.tokenStart;
                this.scanner.skipSC();

                if (this.scanner.tokenType === HYPHENMINUS$5 ||
                    this.scanner.tokenType === PLUSSIGN$4) {
                    prefix = this.scanner.getTokenValue();
                    this.scanner.next();
                    this.scanner.skipSC();
                }

                if (this.scanner.tokenType === NUMBER$4) {
                    checkTokenIsInteger(this.scanner, prefix !== '');

                    if (!isNumber$2(this.scanner.source.charCodeAt(this.scanner.tokenStart))) {
                        prefix = this.scanner.source.charAt(this.scanner.tokenStart);
                        this.scanner.tokenStart++;
                    }

                    if (prefix === '') {
                        // should be an operator before number
                        this.scanner.error();
                    } else if (prefix === '+') {
                        // plus is using by default
                        prefix = '';
                    }

                    b = prefix + this.scanner.getTokenValue();

                    this.scanner.next();
                    end = this.scanner.tokenStart;
                } else {
                    if (prefix) {
                        this.scanner.eat(NUMBER$4);
                    }
                }
            }
        } else {
            if (prefix === '' || prefix === '+') { // no number
                this.scanner.error(
                    'Number or identifier is expected',
                    this.scanner.tokenStart + (
                        this.scanner.tokenType === PLUSSIGN$4 ||
                        this.scanner.tokenType === HYPHENMINUS$5
                    )
                );
            }

            b = prefix;
        }

        return {
            type: 'AnPlusB',
            loc: this.getLocation(start, end),
            a: a,
            b: b
        };
    },
    generate: function(processChunk, node) {
        var a = node.a !== null && node.a !== undefined;
        var b = node.b !== null && node.b !== undefined;

        if (a) {
            processChunk(
                node.a === '+1' ? '+n' :
                node.a ===  '1' ?  'n' :
                node.a === '-1' ? '-n' :
                node.a + 'n'
            );

            if (b) {
                b = String(node.b);
                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
                    processChunk(b.charAt(0));
                    processChunk(b.substr(1));
                } else {
                    processChunk('+');
                    processChunk(b);
                }
            }
        } else {
            processChunk(String(node.b));
        }
    }
};

var TYPE$11 = tokenizer$1.TYPE;

var ATRULE$2 = TYPE$11.Atrule;
var SEMICOLON$1 = TYPE$11.Semicolon;
var LEFTCURLYBRACKET$2 = TYPE$11.LeftCurlyBracket;
var RIGHTCURLYBRACKET$1 = TYPE$11.RightCurlyBracket;

function isBlockAtrule() {
    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET$1) {
            return true;
        }

        if (type === LEFTCURLYBRACKET$2 ||
            type === ATRULE$2) {
            return false;
        }
    }

    this.scanner.skip(offset);
    this.scanner.eat(RIGHTCURLYBRACKET$1);
}

var Atrule = {
    name: 'Atrule',
    structure: {
        name: String,
        expression: ['AtruleExpression', null],
        block: ['Block', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var expression = null;
        var block = null;

        this.scanner.eat(ATRULE$2);

        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();

        expression = this.AtruleExpression(name);

        // turn empty AtruleExpression into null
        if (expression.children.head === null) {
            expression = null;
        }

        this.scanner.skipSC();

        if (this.atrule.hasOwnProperty(nameLowerCase)) {
            if (typeof this.atrule[nameLowerCase].block === 'function') {
                if (this.scanner.tokenType !== LEFTCURLYBRACKET$2) {
                    // FIXME: make tolerant
                    this.scanner.error('Curly bracket is expected');
                }

                block = this.atrule[nameLowerCase].block.call(this);
            } else {
                if (!this.tolerant || !this.scanner.eof) {
                    this.scanner.eat(SEMICOLON$1);
                }
            }
        } else {
            switch (this.scanner.tokenType) {
                case SEMICOLON$1:
                    this.scanner.next();
                    break;

                case LEFTCURLYBRACKET$2:
                    // TODO: should consume block content as Raw?
                    block = this.Block(isBlockAtrule.call(this) ? this.Declaration : this.Rule);
                    break;

                default:
                    if (!this.tolerant) {
                        this.scanner.error('Semicolon or block is expected');
                    }
            }
        }

        return {
            type: 'Atrule',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            expression: expression,
            block: block
        };
    },
    generate: function(processChunk, node) {
        processChunk('@');
        processChunk(node.name);

        if (node.expression !== null) {
            processChunk(' ');
            this.generate(processChunk, node.expression);
        }

        if (node.block) {
            this.generate(processChunk, node.block);
        } else {
            processChunk(';');
        }
    },
    walkContext: 'atrule'
};

var TYPE$12 = tokenizer$1.TYPE;
var SEMICOLON$2 = TYPE$12.Semicolon;
var LEFTCURLYBRACKET$3 = TYPE$12.LeftCurlyBracket;

function consumeRaw$1(startToken) {
    return new list().appendData(
        this.Raw(startToken, SEMICOLON$2, LEFTCURLYBRACKET$3, false, true)
    );
}

function consumeDefaultSequence() {
    return this.readSequence(this.scope.AtruleExpression);
}

var AtruleExpression = {
    name: 'AtruleExpression',
    structure: {
        children: [[]]
    },
    parse: function(name) {
        var children = null;
        var startToken = this.scanner.currentToken;

        if (name !== null) {
            name = name.toLowerCase();
        }

        if (this.parseAtruleExpression) {
            // custom consumer
            if (this.atrule.hasOwnProperty(name)) {
                if (typeof this.atrule[name].expression === 'function') {
                    children = this.tolerantParse(this.atrule[name].expression, consumeRaw$1);
                }
            } else {
                // default consumer
                this.scanner.skipSC();
                children = this.tolerantParse(consumeDefaultSequence, consumeRaw$1);
            }

            if (this.tolerant) {
                if (this.scanner.eof || (this.scanner.tokenType !== SEMICOLON$2 && this.scanner.tokenType !== LEFTCURLYBRACKET$3)) {
                    children = consumeRaw$1.call(this, startToken);
                }
            }
        } else {
            children = consumeRaw$1.call(this, startToken);
        }

        if (children === null) {
            children = new list();
        }

        return {
            type: 'AtruleExpression',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(processChunk, node) {
        this.each(processChunk, node);
    },
    walkContext: 'atruleExpression'
};

var TYPE$13 = tokenizer$1.TYPE;

var IDENTIFIER$8 = TYPE$13.Identifier;
var STRING$4 = TYPE$13.String;
var DOLLARSIGN = TYPE$13.DollarSign;
var ASTERISK$2 = TYPE$13.Asterisk;
var COLON$2 = TYPE$13.Colon;
var EQUALSSIGN = TYPE$13.EqualsSign;
var LEFTSQUAREBRACKET$3 = TYPE$13.LeftSquareBracket;
var RIGHTSQUAREBRACKET$1 = TYPE$13.RightSquareBracket;
var CIRCUMFLEXACCENT = TYPE$13.CircumflexAccent;
var VERTICALLINE$1 = TYPE$13.VerticalLine;
var TILDE$1 = TYPE$13.Tilde;

function getAttributeName() {
    if (this.scanner.eof) {
        this.scanner.error('Unexpected end of input');
    }

    var start = this.scanner.tokenStart;
    var expectIdentifier = false;
    var checkColon = true;

    if (this.scanner.tokenType === ASTERISK$2) {
        expectIdentifier = true;
        checkColon = false;
        this.scanner.next();
    } else if (this.scanner.tokenType !== VERTICALLINE$1) {
        this.scanner.eat(IDENTIFIER$8);
    }

    if (this.scanner.tokenType === VERTICALLINE$1) {
        if (this.scanner.lookupType(1) !== EQUALSSIGN) {
            this.scanner.next();
            this.scanner.eat(IDENTIFIER$8);
        } else if (expectIdentifier) {
            this.scanner.error('Identifier is expected', this.scanner.tokenEnd);
        }
    } else if (expectIdentifier) {
        this.scanner.error('Vertical line is expected');
    }

    if (checkColon && this.scanner.tokenType === COLON$2) {
        this.scanner.next();
        this.scanner.eat(IDENTIFIER$8);
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
    };
}

function getOperator() {
    var start = this.scanner.tokenStart;
    var tokenType = this.scanner.tokenType;

    if (tokenType !== EQUALSSIGN &&        // =
        tokenType !== TILDE$1 &&             // ~=
        tokenType !== CIRCUMFLEXACCENT &&  // ^=
        tokenType !== DOLLARSIGN &&        // $=
        tokenType !== ASTERISK$2 &&          // *=
        tokenType !== VERTICALLINE$1         // |=
    ) {
        this.scanner.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    if (tokenType === EQUALSSIGN) {
        this.scanner.next();
    } else {
        this.scanner.next();
        this.scanner.eat(EQUALSSIGN);
    }

    return this.scanner.substrToCursor(start);
}

// '[' S* attrib_name ']'
// '[' S* attrib_name S* attrib_matcher S* [ IDENT | STRING ] S* attrib_flags? S* ']'
var AttributeSelector = {
    name: 'AttributeSelector',
    structure: {
        name: 'Identifier',
        matcher: [String, null],
        value: ['String', 'Identifier', null],
        flags: [String, null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;

        this.scanner.eat(LEFTSQUAREBRACKET$3);
        this.scanner.skipSC();

        name = getAttributeName.call(this);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
            // avoid case `[name i]`
            if (this.scanner.tokenType !== IDENTIFIER$8) {
                matcher = getOperator.call(this);

                this.scanner.skipSC();

                value = this.scanner.tokenType === STRING$4
                    ? this.String()
                    : this.Identifier();

                this.scanner.skipSC();
            }

            // attribute flags
            if (this.scanner.tokenType === IDENTIFIER$8) {
                flags = this.scanner.getTokenValue();
                this.scanner.next();

                this.scanner.skipSC();
            }
        }

        this.scanner.eat(RIGHTSQUAREBRACKET$1);

        return {
            type: 'AttributeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            matcher: matcher,
            value: value,
            flags: flags
        };
    },
    generate: function(processChunk, node) {
        var flagsPrefix = ' ';

        processChunk('[');
        this.generate(processChunk, node.name);

        if (node.matcher !== null) {
            processChunk(node.matcher);

            if (node.value !== null) {
                this.generate(processChunk, node.value);

                // space between string and flags is not required
                if (node.value.type === 'String') {
                    flagsPrefix = '';
                }
            }
        }

        if (node.flags !== null) {
            processChunk(flagsPrefix);
            processChunk(node.flags);
        }

        processChunk(']');
    }
};

var TYPE$14 = tokenizer$1.TYPE;

var WHITESPACE$4 = TYPE$14.WhiteSpace;
var COMMENT$4 = TYPE$14.Comment;
var SEMICOLON$3 = TYPE$14.Semicolon;
var ATRULE$3 = TYPE$14.Atrule;
var LEFTCURLYBRACKET$4 = TYPE$14.LeftCurlyBracket;
var RIGHTCURLYBRACKET$2 = TYPE$14.RightCurlyBracket;

function consumeRaw$2(startToken) {
    return this.Raw(startToken, 0, SEMICOLON$3, true, true);
}

var Block = {
    name: 'Block',
    structure: {
        children: [['Atrule', 'Rule', 'Declaration']]
    },
    parse: function(defaultConsumer) {
        if (!defaultConsumer) {
            defaultConsumer = this.Declaration;
        }

        var start = this.scanner.tokenStart;
        var children = new list();

        this.scanner.eat(LEFTCURLYBRACKET$4);

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case RIGHTCURLYBRACKET$2:
                    break scan;

                case WHITESPACE$4:
                case COMMENT$4:
                case SEMICOLON$3:
                    this.scanner.next();
                    break;

                case ATRULE$3:
                    children.appendData(this.tolerantParse(this.Atrule, consumeRaw$2));
                    break;

                default:
                    children.appendData(this.tolerantParse(defaultConsumer, consumeRaw$2));
            }
        }

        if (!this.tolerant || !this.scanner.eof) {
            this.scanner.eat(RIGHTCURLYBRACKET$2);
        }

        return {
            type: 'Block',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(processChunk, node) {
        processChunk('{');
        this.each(processChunk, node);
        processChunk('}');
    },
    walkContext: 'block'
};

var TYPE$15 = tokenizer$1.TYPE;
var LEFTSQUAREBRACKET$4 = TYPE$15.LeftSquareBracket;
var RIGHTSQUAREBRACKET$2 = TYPE$15.RightSquareBracket;

// currently only Grid Layout uses square brackets, but left it universal
// https://drafts.csswg.org/css-grid/#track-sizing
// [ ident* ]
var Brackets = {
    name: 'Brackets',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.scanner.eat(LEFTSQUAREBRACKET$4);
        children = readSequence.call(this, recognizer);
        this.scanner.eat(RIGHTSQUAREBRACKET$2);

        return {
            type: 'Brackets',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(processChunk, node) {
        processChunk('[');
        this.each(processChunk, node);
        processChunk(']');
    }
};

var CDC$2 = tokenizer$1.TYPE.CDC;

var CDC_1 = {
    name: 'CDC',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(CDC$2); // -->

        return {
            type: 'CDC',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function(processChunk) {
        processChunk('-->');
    }
};

var CDO$2 = tokenizer$1.TYPE.CDO;

var CDO_1 = {
    name: 'CDO',
    structure: [],
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(CDO$2); // <!--

        return {
            type: 'CDO',
            loc: this.getLocation(start, this.scanner.tokenStart)
        };
    },
    generate: function(processChunk) {
        processChunk('<!--');
    }
};

var TYPE$16 = tokenizer$1.TYPE;
var IDENTIFIER$9 = TYPE$16.Identifier;
var FULLSTOP$3 = TYPE$16.FullStop;

// '.' ident
var ClassSelector = {
    name: 'ClassSelector',
    structure: {
        name: String
    },
    parse: function() {
        this.scanner.eat(FULLSTOP$3);

        return {
            type: 'ClassSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER$9)
        };
    },
    generate: function(processChunk, node) {
        processChunk('.');
        processChunk(node.name);
    }
};

var TYPE$17 = tokenizer$1.TYPE;

var PLUSSIGN$5 = TYPE$17.PlusSign;
var SOLIDUS$2 = TYPE$17.Solidus;
var GREATERTHANSIGN$2 = TYPE$17.GreaterThanSign;
var TILDE$2 = TYPE$17.Tilde;

// + | > | ~ | /deep/
var Combinator = {
    name: 'Combinator',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        switch (this.scanner.tokenType) {
            case GREATERTHANSIGN$2:
            case PLUSSIGN$5:
            case TILDE$2:
                this.scanner.next();
                break;

            case SOLIDUS$2:
                this.scanner.next();
                this.scanner.expectIdentifier('deep');
                this.scanner.eat(SOLIDUS$2);
                break;

            default:
                this.scanner.error('Combinator is expected');
        }

        return {
            type: 'Combinator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.name);
    }
};

var TYPE$18 = tokenizer$1.TYPE;

var ASTERISK$3 = TYPE$18.Asterisk;
var SOLIDUS$3 = TYPE$18.Solidus;

// '/*' .* '*/'
var Comment = {
    name: 'Comment',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;

        if ((end - start + 2) >= 2 &&
            this.scanner.source.charCodeAt(end - 2) === ASTERISK$3 &&
            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$3) {
            end -= 2;
        }

        this.scanner.next();

        return {
            type: 'Comment',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.source.substring(start + 2, end)
        };
    },
    generate: function(processChunk, node) {
        processChunk('/*');
        processChunk(node.value);
        processChunk('*/');
    }
};

var TYPE$19 = tokenizer$1.TYPE;

var IDENTIFIER$10 = TYPE$19.Identifier;
var COLON$3 = TYPE$19.Colon;
var EXCLAMATIONMARK$2 = TYPE$19.ExclamationMark;
var SOLIDUS$4 = TYPE$19.Solidus;
var ASTERISK$4 = TYPE$19.Asterisk;
var DOLLARSIGN$1 = TYPE$19.DollarSign;
var HYPHENMINUS$6 = TYPE$19.HyphenMinus;
var SEMICOLON$4 = TYPE$19.Semicolon;
var RIGHTCURLYBRACKET$3 = TYPE$19.RightCurlyBracket;
var RIGHTPARENTHESIS$1 = TYPE$19.RightParenthesis;
var PLUSSIGN$6 = TYPE$19.PlusSign;
var NUMBERSIGN$2 = TYPE$19.NumberSign;

var Declaration = {
    name: 'Declaration',
    structure: {
        important: [Boolean, String],
        property: String,
        value: ['Value', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var property = readProperty.call(this);
        var important = false;
        var value;

        this.scanner.skipSC();
        this.scanner.eat(COLON$3);

        if (isCustomProperty(property) ? this.parseCustomProperty : this.parseValue) {
            value = this.Value(property);
        } else {
            value = this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$2, SEMICOLON$4, false, false);
        }

        if (this.scanner.tokenType === EXCLAMATIONMARK$2) {
            important = getImportant(this.scanner);
            this.scanner.skipSC();
        }

        // TODO: include or not to include semicolon to range?
        // if (this.scanner.tokenType === SEMICOLON) {
        //     this.scanner.next();
        // }

        if (!this.scanner.eof &&
            this.scanner.tokenType !== SEMICOLON$4 &&
            this.scanner.tokenType !== RIGHTPARENTHESIS$1 &&
            this.scanner.tokenType !== RIGHTCURLYBRACKET$3) {
            this.scanner.error();
        }

        return {
            type: 'Declaration',
            loc: this.getLocation(start, this.scanner.tokenStart),
            important: important,
            property: property,
            value: value
        };
    },
    generate: function(processChunk, node, item) {
        processChunk(node.property);
        processChunk(':');
        this.generate(processChunk, node.value);

        if (node.important) {
            processChunk(node.important === true ? '!important' : '!' + node.important);
        }

        if (item && item.next) {
            processChunk(';');
        }
    },
    walkContext: 'declaration'
};

function isCustomProperty(name) {
    return name.length >= 2 &&
           name.charCodeAt(0) === HYPHENMINUS$6 &&
           name.charCodeAt(1) === HYPHENMINUS$6;
}

function readProperty() {
    var start = this.scanner.tokenStart;
    var prefix = 0;

    // hacks
    switch (this.scanner.tokenType) {
        case ASTERISK$4:
        case DOLLARSIGN$1:
        case PLUSSIGN$6:
        case NUMBERSIGN$2:
            prefix = 1;
            break;

        // TODO: not sure we should support this hack
        case SOLIDUS$4:
            prefix = this.scanner.lookupType(1) === SOLIDUS$4 ? 2 : 1;
            break;
    }

    if (this.scanner.lookupType(prefix) === HYPHENMINUS$6) {
        prefix++;
    }

    if (prefix) {
        this.scanner.skip(prefix);
    }

    this.scanner.eat(IDENTIFIER$10);

    return this.scanner.substrToCursor(start);
}

// ! ws* important
function getImportant(scanner) {
    scanner.eat(EXCLAMATIONMARK$2);
    scanner.skipSC();

    var important = scanner.consume(IDENTIFIER$10);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}

var TYPE$20 = tokenizer$1.TYPE;

var WHITESPACE$5 = TYPE$20.WhiteSpace;
var COMMENT$5 = TYPE$20.Comment;
var SEMICOLON$5 = TYPE$20.Semicolon;

function consumeRaw$3(startToken) {
    return this.Raw(startToken, 0, SEMICOLON$5, true, true);
}

var DeclarationList = {
    name: 'DeclarationList',
    structure: {
        children: [['Declaration']]
    },
    parse: function() {
        var children = new list();

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE$5:
                case COMMENT$5:
                case SEMICOLON$5:
                    this.scanner.next();
                    break;

                default:
                    children.appendData(this.tolerantParse(this.Declaration, consumeRaw$3));
            }
        }

        return {
            type: 'DeclarationList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(processChunk, node) {
        this.each(processChunk, node);
    }
};

var NUMBER$5 = tokenizer$1.TYPE.Number;

// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
function readUnit(scanner) {
    var unit = scanner.getTokenValue();
    var backSlashPos = unit.indexOf('\\');

    if (backSlashPos > 0) {
        // patch token offset
        scanner.tokenStart += backSlashPos;

        // return part before backslash
        return unit.substring(0, backSlashPos);
    }

    // no backslash in unit name
    scanner.next();

    return unit;
}

// number ident
var Dimension = {
    name: 'Dimension',
    structure: {
        value: String,
        unit: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value = this.scanner.consume(NUMBER$5);
        var unit = readUnit(this.scanner);

        return {
            type: 'Dimension',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value,
            unit: unit
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.value);
        processChunk(node.unit);
    }
};

var TYPE$21 = tokenizer$1.TYPE;
var RIGHTPARENTHESIS$2 = TYPE$21.RightParenthesis;

// <function-token> <sequence> ')'
var _Function = {
    name: 'Function',
    structure: {
        name: String,
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.scanner.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;

        children = recognizer.hasOwnProperty(nameLowerCase)
            ? recognizer[nameLowerCase].call(this, recognizer)
            : readSequence.call(this, recognizer);

        this.scanner.eat(RIGHTPARENTHESIS$2);

        return {
            type: 'Function',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.name);
        processChunk('(');
        this.each(processChunk, node);
        processChunk(')');
    },
    walkContext: 'function'
};

var isHex$1 = tokenizer$1.isHex;
var TYPE$22 = tokenizer$1.TYPE;

var IDENTIFIER$11 = TYPE$22.Identifier;
var NUMBER$6 = TYPE$22.Number;
var NUMBERSIGN$3 = TYPE$22.NumberSign;

function consumeHexSequence(scanner, required) {
    if (!isHex$1(scanner.source.charCodeAt(scanner.tokenStart))) {
        if (required) {
            scanner.error('Unexpected input', scanner.tokenStart);
        } else {
            return;
        }
    }

    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
        var code = scanner.source.charCodeAt(pos);

        // break on non-hex char
        if (!isHex$1(code)) {
            // break token, exclude symbol
            scanner.tokenStart = pos;
            return;
        }
    }

    // token is full hex sequence, go to next token
    scanner.next();
}

// # ident
var HexColor = {
    name: 'HexColor',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.eat(NUMBERSIGN$3);

        scan:
        switch (this.scanner.tokenType) {
            case NUMBER$6:
                consumeHexSequence(this.scanner, true);

                // if token is identifier then number consists of hex only,
                // try to add identifier to result
                if (this.scanner.tokenType === IDENTIFIER$11) {
                    consumeHexSequence(this.scanner, false);
                }

                break;

            case IDENTIFIER$11:
                consumeHexSequence(this.scanner, true);
                break;

            default:
                this.scanner.error('Number or identifier is expected');
        }

        return {
            type: 'HexColor',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start + 1) // skip #
        };
    },
    generate: function(processChunk, node) {
        processChunk('#');
        processChunk(node.value);
    }
};

var TYPE$23 = tokenizer$1.TYPE;
var IDENTIFIER$12 = TYPE$23.Identifier;

var Identifier = {
    name: 'Identifier',
    structure: {
        name: String
    },
    parse: function() {
        return {
            type: 'Identifier',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER$12)
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.name);
    }
};

var TYPE$24 = tokenizer$1.TYPE;
var IDENTIFIER$13 = TYPE$24.Identifier;
var NUMBERSIGN$4 = TYPE$24.NumberSign;

// '#' ident
var IdSelector = {
    name: 'IdSelector',
    structure: {
        name: String
    },
    parse: function() {
        this.scanner.eat(NUMBERSIGN$4);

        return {
            type: 'IdSelector',
            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
            name: this.scanner.consume(IDENTIFIER$13)
        };
    },
    generate: function(processChunk, node) {
        processChunk('#');
        processChunk(node.name);
    }
};

var TYPE$25 = tokenizer$1.TYPE;

var IDENTIFIER$14 = TYPE$25.Identifier;
var NUMBER$7 = TYPE$25.Number;
var LEFTPARENTHESIS$4 = TYPE$25.LeftParenthesis;
var RIGHTPARENTHESIS$3 = TYPE$25.RightParenthesis;
var COLON$4 = TYPE$25.Colon;
var SOLIDUS$5 = TYPE$25.Solidus;

var MediaFeature = {
    name: 'MediaFeature',
    structure: {
        name: String,
        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;

        this.scanner.eat(LEFTPARENTHESIS$4);
        this.scanner.skipSC();

        name = this.scanner.consume(IDENTIFIER$14);
        this.scanner.skipSC();

        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
            this.scanner.eat(COLON$4);
            this.scanner.skipSC();

            switch (this.scanner.tokenType) {
                case NUMBER$7:
                    if (this.scanner.lookupType(1) === IDENTIFIER$14) {
                        value = this.Dimension();
                    } else if (this.scanner.lookupNonWSType(1) === SOLIDUS$5) {
                        value = this.Ratio();
                    } else {
                        value = this.Number();
                    }

                    break;

                case IDENTIFIER$14:
                    value = this.Identifier();

                    break;

                default:
                    this.scanner.error('Number, dimension, ratio or identifier is expected');
            }

            this.scanner.skipSC();
        }

        this.scanner.eat(RIGHTPARENTHESIS$3);

        return {
            type: 'MediaFeature',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            value: value
        };
    },
    generate: function(processChunk, node) {
        processChunk('(');
        processChunk(node.name);
        if (node.value !== null) {
            processChunk(':');
            this.generate(processChunk, node.value);
        }
        processChunk(')');
    }
};

var TYPE$26 = tokenizer$1.TYPE;

var WHITESPACE$6 = TYPE$26.WhiteSpace;
var COMMENT$6 = TYPE$26.Comment;
var IDENTIFIER$15 = TYPE$26.Identifier;
var LEFTPARENTHESIS$5 = TYPE$26.LeftParenthesis;

var MediaQuery = {
    name: 'MediaQuery',
    structure: {
        children: [['Identifier', 'MediaFeature', 'WhiteSpace']]
    },
    parse: function() {
        this.scanner.skipSC();

        var children = new list();
        var child = null;
        var space = null;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case COMMENT$6:
                    this.scanner.next();
                    continue;

                case WHITESPACE$6:
                    space = this.WhiteSpace();
                    continue;

                case IDENTIFIER$15:
                    child = this.Identifier();
                    break;

                case LEFTPARENTHESIS$5:
                    child = this.MediaFeature();
                    break;

                default:
                    break scan;
            }

            if (space !== null) {
                children.appendData(space);
                space = null;
            }

            children.appendData(child);
        }

        if (child === null) {
            this.scanner.error('Identifier or parenthesis is expected');
        }

        return {
            type: 'MediaQuery',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(processChunk, node) {
        this.each(processChunk, node);
    }
};

var COMMA$2 = tokenizer$1.TYPE.Comma;

var MediaQueryList = {
    name: 'MediaQueryList',
    structure: {
        children: [['MediaQuery']]
    },
    parse: function(relative) {
        var children = new list();

        this.scanner.skipSC();

        while (!this.scanner.eof) {
            children.appendData(this.MediaQuery(relative));

            if (this.scanner.tokenType !== COMMA$2) {
                break;
            }

            this.scanner.next();
        }

        return {
            type: 'MediaQueryList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(processChunk, node) {
        this.eachComma(processChunk, node);
    }
};

// https://drafts.csswg.org/css-syntax-3/#the-anb-type
var Nth = {
    name: 'Nth',
    structure: {
        nth: ['AnPlusB', 'Identifier'],
        selector: ['SelectorList', null]
    },
    parse: function(allowOfClause) {
        this.scanner.skipSC();

        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;

        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
            query = this.Identifier();
        } else {
            query = this.AnPlusB();
        }

        this.scanner.skipSC();

        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
            this.scanner.next();

            selector = this.SelectorList();

            if (this.needPositions) {
                end = selector.children.last().loc.end.offset;
            }
        } else {
            if (this.needPositions) {
                end = query.loc.end.offset;
            }
        }

        return {
            type: 'Nth',
            loc: this.getLocation(start, end),
            nth: query,
            selector: selector
        };
    },
    generate: function(processChunk, node) {
        this.generate(processChunk, node.nth);
        if (node.selector !== null) {
            processChunk(' of ');
            this.generate(processChunk, node.selector);
        }
    }
};

var NUMBER$8 = tokenizer$1.TYPE.Number;

var _Number = {
    name: 'Number',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'Number',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.scanner.consume(NUMBER$8)
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.value);
    }
};

// '/' | '*' | ',' | ':' | '+' | '-'
var Operator = {
    name: 'Operator',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next();

        return {
            type: 'Operator',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.value);
    }
};

var TYPE$27 = tokenizer$1.TYPE;
var LEFTPARENTHESIS$6 = TYPE$27.LeftParenthesis;
var RIGHTPARENTHESIS$4 = TYPE$27.RightParenthesis;

var Parentheses = {
    name: 'Parentheses',
    structure: {
        children: [[]]
    },
    parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;

        this.scanner.eat(LEFTPARENTHESIS$6);
        children = readSequence.call(this, recognizer);
        this.scanner.eat(RIGHTPARENTHESIS$4);

        return {
            type: 'Parentheses',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(processChunk, node) {
        processChunk('(');
        this.each(processChunk, node);
        processChunk(')');
    }
};

var TYPE$28 = tokenizer$1.TYPE;

var NUMBER$9 = TYPE$28.Number;
var PERCENTSIGN$1 = TYPE$28.PercentSign;

var Percentage = {
    name: 'Percentage',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var number = this.scanner.consume(NUMBER$9);

        this.scanner.eat(PERCENTSIGN$1);

        return {
            type: 'Percentage',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: number
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.value);
        processChunk('%');
    }
};

var TYPE$29 = tokenizer$1.TYPE;

var IDENTIFIER$16 = TYPE$29.Identifier;
var FUNCTION$4 = TYPE$29.Function;
var COLON$5 = TYPE$29.Colon;
var RIGHTPARENTHESIS$5 = TYPE$29.RightParenthesis;

// : ident [ '(' .. ')' ]?
var PseudoClassSelector = {
    name: 'PseudoClassSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.scanner.eat(COLON$5);

        if (this.scanner.tokenType === FUNCTION$4) {
            name = this.scanner.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = new list().appendData(
                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
                );
            }

            this.scanner.eat(RIGHTPARENTHESIS$5);
        } else {
            name = this.scanner.consume(IDENTIFIER$16);
        }

        return {
            type: 'PseudoClassSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(processChunk, node) {
        processChunk(':');
        processChunk(node.name);

        if (node.children !== null) {
            processChunk('(');
            this.each(processChunk, node);
            processChunk(')');
        }
    },
    walkContext: 'function'
};

var TYPE$30 = tokenizer$1.TYPE;

var IDENTIFIER$17 = TYPE$30.Identifier;
var FUNCTION$5 = TYPE$30.Function;
var COLON$6 = TYPE$30.Colon;
var RIGHTPARENTHESIS$6 = TYPE$30.RightParenthesis;

// :: ident [ '(' .. ')' ]?
var PseudoElementSelector = {
    name: 'PseudoElementSelector',
    structure: {
        name: String,
        children: [['Raw'], null]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;

        this.scanner.eat(COLON$6);
        this.scanner.eat(COLON$6);

        if (this.scanner.tokenType === FUNCTION$5) {
            name = this.scanner.consumeFunctionName();
            nameLowerCase = name.toLowerCase();

            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
                this.scanner.skipSC();
                children = this.pseudo[nameLowerCase].call(this);
                this.scanner.skipSC();
            } else {
                children = new list().appendData(
                    this.Raw(this.scanner.currentToken, 0, 0, false, false)
                );
            }

            this.scanner.eat(RIGHTPARENTHESIS$6);
        } else {
            name = this.scanner.consume(IDENTIFIER$17);
        }

        return {
            type: 'PseudoElementSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: name,
            children: children
        };
    },
    generate: function(processChunk, node) {
        processChunk('::');
        processChunk(node.name);

        if (node.children !== null) {
            processChunk('(');
            this.each(processChunk, node);
            processChunk(')');
        }
    },
    walkContext: 'function'
};

var isNumber$3 = tokenizer$1.isNumber;
var TYPE$31 = tokenizer$1.TYPE;
var NUMBER$10 = TYPE$31.Number;
var SOLIDUS$6 = TYPE$31.Solidus;
var FULLSTOP$4 = TYPE$31.FullStop;

// Terms of <ratio> should to be a positive number (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without exponent part.
// Additional checks may to be applied on lexer validation.
function consumeNumber(scanner) {
    var value = scanner.consumeNonWS(NUMBER$10);

    for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        if (!isNumber$3(code) && code !== FULLSTOP$4) {
            scanner.error('Unsigned number is expected', scanner.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        scanner.error('Zero number is not allowed', scanner.tokenStart - value.length);
    }

    return value;
}

// <positive-integer> S* '/' S* <positive-integer>
var Ratio = {
    name: 'Ratio',
    structure: {
        left: String,
        right: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber(this.scanner);
        var right;

        this.scanner.eatNonWS(SOLIDUS$6);
        right = consumeNumber(this.scanner);

        return {
            type: 'Ratio',
            loc: this.getLocation(start, this.scanner.tokenStart),
            left: left,
            right: right
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.left);
        processChunk('/');
        processChunk(node.right);
    }
};

var Raw = {
    name: 'Raw',
    structure: {
        value: String
    },
    parse: function(startToken, endTokenType1, endTokenType2, includeTokenType2, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;

        this.scanner.skip(
            this.scanner.getRawLength(
                startToken,
                endTokenType1,
                endTokenType2,
                includeTokenType2
            )
        );

        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
            endOffset = this.scanner.getOffsetExcludeWS();
        } else {
            endOffset = this.scanner.tokenStart;
        }

        return {
            type: 'Raw',
            loc: this.getLocation(startOffset, endOffset),
            value: this.scanner.source.substring(startOffset, endOffset)
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.value);
    }
};

var TYPE$32 = tokenizer$1.TYPE;

var LEFTCURLYBRACKET$5 = TYPE$32.LeftCurlyBracket;

function consumeRaw$4(startToken) {
    return this.Raw(startToken, LEFTCURLYBRACKET$5, 0, false, true);
}

var Rule = {
    name: 'Rule',
    structure: {
        selector: ['SelectorList', 'Raw'],
        block: ['Block']
    },
    parse: function() {
        var startToken = this.scanner.currentToken;
        var startOffset = this.scanner.tokenStart;
        var selector = this.parseSelector
            ? this.tolerantParse(this.SelectorList, consumeRaw$4)
            : consumeRaw$4.call(this, startToken);
        var block = this.Block(this.Declaration);

        return {
            type: 'Rule',
            loc: this.getLocation(startOffset, this.scanner.tokenStart),
            selector: selector,
            block: block
        };
    },
    generate: function(processChunk, node) {
        this.generate(processChunk, node.selector);
        this.generate(processChunk, node.block);
    },
    walkContext: 'rule'
};

var Selector = {
    name: 'Selector',
    structure: {
        children: [[
            'TypeSelector',
            'IdSelector',
            'ClassSelector',
            'AttributeSelector',
            'PseudoClassSelector',
            'PseudoElementSelector',
            'Combinator',
            'WhiteSpace'
        ]]
    },
    parse: function() {
        var children = this.readSequence(this.scope.Selector);

        // nothing were consumed
        if (children.isEmpty()) {
            this.scanner.error('Selector is expected');
        }

        return {
            type: 'Selector',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(processChunk, node) {
        this.each(processChunk, node);
    }
};

var TYPE$33 = tokenizer$1.TYPE;

var COMMA$3 = TYPE$33.Comma;
var LEFTCURLYBRACKET$6 = TYPE$33.LeftCurlyBracket;

var SelectorList = {
    name: 'SelectorList',
    structure: {
        children: [['Selector', 'Raw']]
    },
    parse: function() {
        var children = new list();

        while (!this.scanner.eof) {
            children.appendData(this.parseSelector
                ? this.Selector()
                : this.Raw(this.scanner.currentToken, COMMA$3, LEFTCURLYBRACKET$6, false, false)
            );

            if (this.scanner.tokenType === COMMA$3) {
                this.scanner.next();
                continue;
            }

            break;
        }

        return {
            type: 'SelectorList',
            loc: this.getLocationFromList(children),
            children: children
        };
    },
    generate: function(processChunk, node) {
        this.eachComma(processChunk, node);
    },
    walkContext: 'selector'
};

var STRING$5 = tokenizer$1.TYPE.String;

var _String = {
    name: 'String',
    structure: {
        value: String
    },
    parse: function() {
        return {
            type: 'String',
            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
            value: this.scanner.consume(STRING$5)
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.value);
    }
};

var TYPE$34 = tokenizer$1.TYPE;

var WHITESPACE$7 = TYPE$34.WhiteSpace;
var COMMENT$7 = TYPE$34.Comment;
var EXCLAMATIONMARK$3 = TYPE$34.ExclamationMark;
var ATRULE$4 = TYPE$34.Atrule;
var CDO$3 = TYPE$34.CDO;
var CDC$3 = TYPE$34.CDC;

function consumeRaw$5(startToken) {
    return this.Raw(startToken, 0, 0, false, false);
}

var StyleSheet = {
    name: 'StyleSheet',
    structure: {
        children: [['Comment', 'Atrule', 'Rule', 'Raw']]
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var children = new list();
        var child;

        scan:
        while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
                case WHITESPACE$7:
                    this.scanner.next();
                    continue;

                case COMMENT$7:
                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
                        this.scanner.next();
                        continue;
                    }

                    child = this.Comment();
                    break;

                case CDO$3: // <!--
                    child = this.CDO();
                    break;

                case CDC$3: // -->
                    child = this.CDC();
                    break;

                // CSS Syntax Module Level 3
                // §2.2 Error handling
                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
                case ATRULE$4:
                    child = this.Atrule();
                    break;

                // Anything else starts a qualified rule ...
                default:
                    child = this.tolerantParse(this.Rule, consumeRaw$5);
            }

            children.appendData(child);
        }

        return {
            type: 'StyleSheet',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(processChunk, node) {
        this.each(processChunk, node);
    },
    walkContext: 'stylesheet'
};

var TYPE$35 = tokenizer$1.TYPE;

var IDENTIFIER$18 = TYPE$35.Identifier;
var ASTERISK$5 = TYPE$35.Asterisk;
var VERTICALLINE$2 = TYPE$35.VerticalLine;

function eatIdentifierOrAsterisk() {
    if (this.scanner.tokenType !== IDENTIFIER$18 &&
        this.scanner.tokenType !== ASTERISK$5) {
        this.scanner.error('Identifier or asterisk is expected');
    }

    this.scanner.next();
}

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
var TypeSelector = {
    name: 'TypeSelector',
    structure: {
        name: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        if (this.scanner.tokenType === VERTICALLINE$2) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
        } else {
            eatIdentifierOrAsterisk.call(this);

            if (this.scanner.tokenType === VERTICALLINE$2) {
                this.scanner.next();
                eatIdentifierOrAsterisk.call(this);
            }
        }

        return {
            type: 'TypeSelector',
            loc: this.getLocation(start, this.scanner.tokenStart),
            name: this.scanner.substrToCursor(start)
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.name);
    }
};

var isHex$2 = tokenizer$1.isHex;
var TYPE$36 = tokenizer$1.TYPE;

var IDENTIFIER$19 = TYPE$36.Identifier;
var NUMBER$11 = TYPE$36.Number;
var PLUSSIGN$7 = TYPE$36.PlusSign;
var HYPHENMINUS$7 = TYPE$36.HyphenMinus;
var FULLSTOP$5 = TYPE$36.FullStop;
var QUESTIONMARK = TYPE$36.QuestionMark;

function scanUnicodeNumber(scanner) {
    for (var pos = scanner.tokenStart + 1; pos < scanner.tokenEnd; pos++) {
        var code = scanner.source.charCodeAt(pos);

        // break on fullstop or hyperminus/plussign after exponent
        if (code === FULLSTOP$5 || code === PLUSSIGN$7) {
            // break token, exclude symbol
            scanner.tokenStart = pos;
            return false;
        }
    }

    return true;
}

// https://drafts.csswg.org/css-syntax-3/#urange
function scanUnicodeRange(scanner) {
    var hexStart = scanner.tokenStart + 1; // skip +
    var hexLength = 0;

    scan: {
        if (scanner.tokenType === NUMBER$11) {
            if (scanner.source.charCodeAt(scanner.tokenStart) !== FULLSTOP$5 && scanUnicodeNumber(scanner)) {
                scanner.next();
            } else if (scanner.source.charCodeAt(scanner.tokenStart) !== HYPHENMINUS$7) {
                break scan;
            }
        } else {
            scanner.next(); // PLUSSIGN
        }

        if (scanner.tokenType === HYPHENMINUS$7) {
            scanner.next();
        }

        if (scanner.tokenType === NUMBER$11) {
            scanner.next();
        }

        if (scanner.tokenType === IDENTIFIER$19) {
            scanner.next();
        }

        if (scanner.tokenStart === hexStart) {
            scanner.error('Unexpected input', hexStart);
        }
    }

    // validate for U+x{1,6} or U+x{1,6}-x{1,6}
    // where x is [0-9a-fA-F]
    for (var i = hexStart, wasHyphenMinus = false; i < scanner.tokenStart; i++) {
        var code = scanner.source.charCodeAt(i);

        if (isHex$2(code) === false && (code !== HYPHENMINUS$7 || wasHyphenMinus)) {
            scanner.error('Unexpected input', i);
        }

        if (code === HYPHENMINUS$7) {
            // hex sequence shouldn't be an empty
            if (hexLength === 0) {
                scanner.error('Unexpected input', i);
            }

            wasHyphenMinus = true;
            hexLength = 0;
        } else {
            hexLength++;

            // too long hex sequence
            if (hexLength > 6) {
                scanner.error('Too long hex sequence', i);
            }
        }

    }

    // check we have a non-zero sequence
    if (hexLength === 0) {
        scanner.error('Unexpected input', i - 1);
    }

    // U+abc???
    if (!wasHyphenMinus) {
        // consume as many U+003F QUESTION MARK (?) code points as possible
        for (; hexLength < 6 && !scanner.eof; scanner.next()) {
            if (scanner.tokenType !== QUESTIONMARK) {
                break;
            }

            hexLength++;
        }
    }
}

var UnicodeRange = {
    name: 'UnicodeRange',
    structure: {
        value: String
    },
    parse: function() {
        var start = this.scanner.tokenStart;

        this.scanner.next(); // U or u
        scanUnicodeRange(this.scanner);

        return {
            type: 'UnicodeRange',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: this.scanner.substrToCursor(start)
        };
    },
    generate: function(processChunk, node) {
        processChunk(node.value);
    }
};

var TYPE$37 = tokenizer$1.TYPE;

var STRING$6 = TYPE$37.String;
var URL$4 = TYPE$37.Url;
var RAW$2 = TYPE$37.Raw;
var RIGHTPARENTHESIS$7 = TYPE$37.RightParenthesis;

// url '(' S* (string | raw) S* ')'
var Url = {
    name: 'Url',
    structure: {
        value: ['String', 'Raw']
    },
    parse: function() {
        var start = this.scanner.tokenStart;
        var value;

        this.scanner.eat(URL$4);
        this.scanner.skipSC();

        switch (this.scanner.tokenType) {
            case STRING$6:
                value = this.String();
                break;

            case RAW$2:
                value = this.Raw(this.scanner.currentToken, 0, RAW$2, true, false);
                break;

            default:
                this.scanner.error('String or Raw is expected');
        }

        this.scanner.skipSC();
        this.scanner.eat(RIGHTPARENTHESIS$7);

        return {
            type: 'Url',
            loc: this.getLocation(start, this.scanner.tokenStart),
            value: value
        };
    },
    generate: function(processChunk, node) {
        processChunk('url');
        processChunk('(');
        this.generate(processChunk, node.value);
        processChunk(')');
    }
};

var endsWith$1 = tokenizer$1.endsWith;
var TYPE$38 = tokenizer$1.TYPE;

var WHITESPACE$8 = TYPE$38.WhiteSpace;
var COMMENT$8 = TYPE$38.Comment;
var FUNCTION$6 = TYPE$38.Function;
var COLON$7 = TYPE$38.Colon;
var SEMICOLON$6 = TYPE$38.Semicolon;
var EXCLAMATIONMARK$4 = TYPE$38.ExclamationMark;

// 'progid:' ws* 'DXImageTransform.Microsoft.' ident ws* '(' .* ')'
function checkProgid(scanner) {
    var offset = 0;

    for (var type; type = scanner.lookupType(offset); offset++) {
        if (type !== WHITESPACE$8 && type !== COMMENT$8) {
            break;
        }
    }

    if (scanner.lookupValue(offset, 'alpha(') ||
        scanner.lookupValue(offset, 'chroma(') ||
        scanner.lookupValue(offset, 'dropshadow(')) {
        if (scanner.lookupType(offset) !== FUNCTION$6) {
            return false;
        }
    } else {
        if (scanner.lookupValue(offset, 'progid') === false ||
            scanner.lookupType(offset + 1) !== COLON$7) {
            return false;
        }
    }

    return true;
}

var Value = {
    name: 'Value',
    structure: {
        children: [[]]
    },
    parse: function(property) {
        // special parser for filter property since it can contains non-standart syntax for old IE
        if (property !== null && endsWith$1(property, 'filter') && checkProgid(this.scanner)) {
            this.scanner.skipSC();
            return this.Raw(this.scanner.currentToken, EXCLAMATIONMARK$4, SEMICOLON$6, false, false);
        }

        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);

        return {
            type: 'Value',
            loc: this.getLocation(start, this.scanner.tokenStart),
            children: children
        };
    },
    generate: function(processChunk, node) {
        this.each(processChunk, node);
    }
};

var WHITESPACE$9 = tokenizer$1.TYPE.WhiteSpace;
var SPACE$2 = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

var WhiteSpace = {
    name: 'WhiteSpace',
    structure: {
        value: String
    },
    parse: function() {
        this.scanner.eat(WHITESPACE$9);
        return SPACE$2;

        // return {
        //     type: 'WhiteSpace',
        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
        //     value: this.scanner.consume(WHITESPACE)
        // };
    },
    generate: function(processChunk, node) {
        processChunk(node.value);
    }
};

var node = {
    AnPlusB: AnPlusB,
    Atrule: Atrule,
    AtruleExpression: AtruleExpression,
    AttributeSelector: AttributeSelector,
    Block: Block,
    Brackets: Brackets,
    CDC: CDC_1,
    CDO: CDO_1,
    ClassSelector: ClassSelector,
    Combinator: Combinator,
    Comment: Comment,
    Declaration: Declaration,
    DeclarationList: DeclarationList,
    Dimension: Dimension,
    Function: _Function,
    HexColor: HexColor,
    Identifier: Identifier,
    IdSelector: IdSelector,
    MediaFeature: MediaFeature,
    MediaQuery: MediaQuery,
    MediaQueryList: MediaQueryList,
    Nth: Nth,
    Number: _Number,
    Operator: Operator,
    Parentheses: Parentheses,
    Percentage: Percentage,
    PseudoClassSelector: PseudoClassSelector,
    PseudoElementSelector: PseudoElementSelector,
    Ratio: Ratio,
    Raw: Raw,
    Rule: Rule,
    Selector: Selector,
    SelectorList: SelectorList,
    String: _String,
    StyleSheet: StyleSheet,
    TypeSelector: TypeSelector,
    UnicodeRange: UnicodeRange,
    Url: Url,
    Value: Value,
    WhiteSpace: WhiteSpace
};

var parser$1 = {
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atruleExpression: function(options) {
            return this.AtruleExpression(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block: function() {
            return this.Block(this.Declaration);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: function(options) {
            return this.Value(options.property ? String(options.property) : null);
        }
    },
    scope: scope,
    atrule: atrule,
    pseudo: pseudo,
    node: node
};

var parser = create$1(parser$1);

function walk ( ast, ref) {
	var enter = ref.enter;
	var leave = ref.leave;

	visit( ast, null, enter, leave );
}

var shouldSkip = false;
var context = { skip: function () { return shouldSkip = true; } };

var childKeys = {};

var toString$1 = Object.prototype.toString;

function isArray$1 ( thing ) {
	return toString$1.call( thing ) === '[object Array]';
}

function visit ( node, parent, enter, leave, prop, index ) {
	if ( !node ) { return; }

	if ( enter ) {
		var _shouldSkip = shouldSkip;
		shouldSkip = false;
		enter.call( context, node, parent, prop, index );
		var skipped = shouldSkip;
		shouldSkip = _shouldSkip;

		if ( skipped ) { return; }
	}

	var keys = childKeys[ node.type ] || (
		childKeys[ node.type ] = Object.keys( node ).filter( function (key) { return typeof node[ key ] === 'object'; } )
	);

	for ( var i = 0; i < keys.length; i += 1 ) {
		var key = keys[i];
		var value = node[ key ];

		if ( isArray$1( value ) ) {
			for ( var j = 0; j < value.length; j += 1 ) {
				visit( value[j], node, enter, leave, key, j );
			}
		}

		else if ( value && value.type ) {
			visit( value, node, enter, leave, key, null );
		}
	}

	if ( leave ) {
		leave( node, parent, prop, index );
	}
}

function readStyle(parser$$1, start, attributes) {
    var contentStart = parser$$1.index;
    var styles = parser$$1.readUntil(/<\/style>/);
    var contentEnd = parser$$1.index;
    var ast;
    try {
        ast = parser(styles, {
            positions: true,
            offset: contentStart
        });
    }
    catch (err) {
        if (err.name === 'CssSyntaxError') {
            parser$$1.error(err.message, err.offset);
        }
        else {
            throw err;
        }
    }
    ast = JSON.parse(JSON.stringify(ast));
    // tidy up AST
    walk(ast, {
        enter: function (node) {
            // replace `ref:a` nodes
            if (node.type === 'Selector') {
                for (var i = 0; i < node.children.length; i += 1) {
                    var a = node.children[i];
                    var b = node.children[i + 1];
                    if (isRefSelector(a, b)) {
                        node.children.splice(i, 2, {
                            type: 'RefSelector',
                            start: a.loc.start.offset,
                            end: b.loc.end.offset,
                            name: b.name
                        });
                    }
                }
            }
            if (node.loc) {
                node.start = node.loc.start.offset;
                node.end = node.loc.end.offset;
                delete node.loc;
            }
        }
    });
    parser$$1.eat('</style>', true);
    var end = parser$$1.index;
    return {
        start: start,
        end: end,
        attributes: attributes,
        children: ast.children,
        content: {
            start: contentStart,
            end: contentEnd,
            styles: styles
        }
    };
}
function isRefSelector(a, b) {
    if (!b)
        return false;
    return (a.type === 'TypeSelector' &&
        a.name === 'ref' &&
        b.type === 'PseudoClassSelector');
}

function readExpression$1(parser, start, quoteMark) {
    var str = '';
    var escaped = false;
    for (var i = start; i < parser.template.length; i += 1) {
        var char = parser.template[i];
        if (quoteMark) {
            if (char === quoteMark) {
                if (escaped) {
                    str += quoteMark;
                }
                else {
                    break;
                }
            }
            else if (escaped) {
                str += '\\' + char;
                escaped = false;
            }
            else if (char === '\\') {
                escaped = true;
            }
            else {
                str += char;
            }
        }
        else if (/\s/.test(char)) {
            break;
        }
        else {
            str += char;
        }
    }
    var expression = parseExpressionAt(repeat(' ', start) + str, start);
    parser.index = expression.end;
    parser.allowWhitespace();
    if (quoteMark)
        parser.eat(quoteMark, true);
    return expression;
}
function readEventHandlerDirective(parser, start, name, hasValue) {
    var expression;
    if (hasValue) {
        var quoteMark = parser.eat("'") ? "'" : parser.eat("\"") ? "\"" : null;
        var expressionStart = parser.index;
        expression = readExpression$1(parser, expressionStart, quoteMark);
        if (expression.type !== 'CallExpression') {
            parser.error("Expected call expression", expressionStart);
        }
    }
    return {
        start: start,
        end: parser.index,
        type: 'EventHandler',
        name: name,
        expression: expression
    };
}
function readBindingDirective(parser, start, name) {
    var value;
    if (parser.eat('=')) {
        var quoteMark = parser.eat("'") ? "'" : parser.eat("\"") ? "\"" : null;
        var a = parser.index;
        if (parser.eat('{{')) {
            var message = 'bound values should not be wrapped';
            var b_1 = parser.template.indexOf('}}', a);
            if (b_1 !== -1) {
                var value_1 = parser.template.slice(parser.index, b_1);
                message += " \u2014 use '" + value_1 + "', not '{{" + value_1 + "}}'";
            }
            parser.error(message, a);
        }
        // this is a bit of a hack so that we can give Acorn something parseable
        var b = void 0;
        if (quoteMark) {
            b = parser.index = parser.template.indexOf(quoteMark, parser.index);
        }
        else {
            parser.readUntil(/[\s\r\n\/>]/);
            b = parser.index;
        }
        var source = repeat(' ', a) + parser.template.slice(a, b);
        value = parseExpressionAt(source, a);
        if (value.type !== 'Identifier' && value.type !== 'MemberExpression') {
            parser.error("Cannot bind to rvalue", value.start);
        }
        parser.allowWhitespace();
        if (quoteMark) {
            parser.eat(quoteMark, true);
        }
    }
    else {
        // shorthand – bind:foo equivalent to bind:foo='foo'
        value = {
            type: 'Identifier',
            start: start + 5,
            end: parser.index,
            name: name
        };
    }
    return {
        start: start,
        end: parser.index,
        type: 'Binding',
        name: name,
        value: value
    };
}
function readTransitionDirective(parser, start, name, type) {
    var expression = null;
    if (parser.eat('=')) {
        var quoteMark = parser.eat("'") ? "'" : parser.eat("\"") ? "\"" : null;
        var expressionStart = parser.index;
        expression = readExpression$1(parser, expressionStart, quoteMark);
        if (expression.type !== 'ObjectExpression') {
            parser.error("Expected object expression", expressionStart);
        }
    }
    return {
        start: start,
        end: parser.index,
        type: 'Transition',
        name: name,
        intro: type === 'in' || type === 'transition',
        outro: type === 'out' || type === 'transition',
        expression: expression
    };
}

// https://dev.w3.org/html5/html-author/charref
var htmlEntities = {
    CounterClockwiseContourIntegral: 8755,
    ClockwiseContourIntegral: 8754,
    DoubleLongLeftRightArrow: 10234,
    DiacriticalDoubleAcute: 733,
    NotSquareSupersetEqual: 8931,
    CloseCurlyDoubleQuote: 8221,
    DoubleContourIntegral: 8751,
    FilledVerySmallSquare: 9642,
    NegativeVeryThinSpace: 8203,
    NotPrecedesSlantEqual: 8928,
    NotRightTriangleEqual: 8941,
    NotSucceedsSlantEqual: 8929,
    CapitalDifferentialD: 8517,
    DoubleLeftRightArrow: 8660,
    DoubleLongRightArrow: 10233,
    EmptyVerySmallSquare: 9643,
    NestedGreaterGreater: 8811,
    NotDoubleVerticalBar: 8742,
    NotLeftTriangleEqual: 8940,
    NotSquareSubsetEqual: 8930,
    OpenCurlyDoubleQuote: 8220,
    ReverseUpEquilibrium: 10607,
    DoubleLongLeftArrow: 10232,
    DownLeftRightVector: 10576,
    LeftArrowRightArrow: 8646,
    NegativeMediumSpace: 8203,
    RightArrowLeftArrow: 8644,
    SquareSupersetEqual: 8850,
    leftrightsquigarrow: 8621,
    DownRightTeeVector: 10591,
    DownRightVectorBar: 10583,
    LongLeftRightArrow: 10231,
    Longleftrightarrow: 10234,
    NegativeThickSpace: 8203,
    PrecedesSlantEqual: 8828,
    ReverseEquilibrium: 8651,
    RightDoubleBracket: 10215,
    RightDownTeeVector: 10589,
    RightDownVectorBar: 10581,
    RightTriangleEqual: 8885,
    SquareIntersection: 8851,
    SucceedsSlantEqual: 8829,
    blacktriangleright: 9656,
    longleftrightarrow: 10231,
    DoubleUpDownArrow: 8661,
    DoubleVerticalBar: 8741,
    DownLeftTeeVector: 10590,
    DownLeftVectorBar: 10582,
    FilledSmallSquare: 9724,
    GreaterSlantEqual: 10878,
    LeftDoubleBracket: 10214,
    LeftDownTeeVector: 10593,
    LeftDownVectorBar: 10585,
    LeftTriangleEqual: 8884,
    NegativeThinSpace: 8203,
    NotReverseElement: 8716,
    NotTildeFullEqual: 8775,
    RightAngleBracket: 10217,
    RightUpDownVector: 10575,
    SquareSubsetEqual: 8849,
    VerticalSeparator: 10072,
    blacktriangledown: 9662,
    blacktriangleleft: 9666,
    leftrightharpoons: 8651,
    rightleftharpoons: 8652,
    twoheadrightarrow: 8608,
    DiacriticalAcute: 180,
    DiacriticalGrave: 96,
    DiacriticalTilde: 732,
    DoubleRightArrow: 8658,
    DownArrowUpArrow: 8693,
    EmptySmallSquare: 9723,
    GreaterEqualLess: 8923,
    GreaterFullEqual: 8807,
    LeftAngleBracket: 10216,
    LeftUpDownVector: 10577,
    LessEqualGreater: 8922,
    NonBreakingSpace: 160,
    NotRightTriangle: 8939,
    NotSupersetEqual: 8841,
    RightTriangleBar: 10704,
    RightUpTeeVector: 10588,
    RightUpVectorBar: 10580,
    UnderParenthesis: 9181,
    UpArrowDownArrow: 8645,
    circlearrowright: 8635,
    downharpoonright: 8642,
    ntrianglerighteq: 8941,
    rightharpoondown: 8641,
    rightrightarrows: 8649,
    twoheadleftarrow: 8606,
    vartriangleright: 8883,
    CloseCurlyQuote: 8217,
    ContourIntegral: 8750,
    DoubleDownArrow: 8659,
    DoubleLeftArrow: 8656,
    DownRightVector: 8641,
    LeftRightVector: 10574,
    LeftTriangleBar: 10703,
    LeftUpTeeVector: 10592,
    LeftUpVectorBar: 10584,
    LowerRightArrow: 8600,
    NotGreaterEqual: 8817,
    NotGreaterTilde: 8821,
    NotLeftTriangle: 8938,
    OverParenthesis: 9180,
    RightDownVector: 8642,
    ShortRightArrow: 8594,
    UpperRightArrow: 8599,
    bigtriangledown: 9661,
    circlearrowleft: 8634,
    curvearrowright: 8631,
    downharpoonleft: 8643,
    leftharpoondown: 8637,
    leftrightarrows: 8646,
    nLeftrightarrow: 8654,
    nleftrightarrow: 8622,
    ntrianglelefteq: 8940,
    rightleftarrows: 8644,
    rightsquigarrow: 8605,
    rightthreetimes: 8908,
    straightepsilon: 1013,
    trianglerighteq: 8885,
    vartriangleleft: 8882,
    DiacriticalDot: 729,
    DoubleRightTee: 8872,
    DownLeftVector: 8637,
    GreaterGreater: 10914,
    HorizontalLine: 9472,
    InvisibleComma: 8291,
    InvisibleTimes: 8290,
    LeftDownVector: 8643,
    LeftRightArrow: 8596,
    Leftrightarrow: 8660,
    LessSlantEqual: 10877,
    LongRightArrow: 10230,
    Longrightarrow: 10233,
    LowerLeftArrow: 8601,
    NestedLessLess: 8810,
    NotGreaterLess: 8825,
    NotLessGreater: 8824,
    NotSubsetEqual: 8840,
    NotVerticalBar: 8740,
    OpenCurlyQuote: 8216,
    ReverseElement: 8715,
    RightTeeVector: 10587,
    RightVectorBar: 10579,
    ShortDownArrow: 8595,
    ShortLeftArrow: 8592,
    SquareSuperset: 8848,
    TildeFullEqual: 8773,
    UpperLeftArrow: 8598,
    ZeroWidthSpace: 8203,
    curvearrowleft: 8630,
    doublebarwedge: 8966,
    downdownarrows: 8650,
    hookrightarrow: 8618,
    leftleftarrows: 8647,
    leftrightarrow: 8596,
    leftthreetimes: 8907,
    longrightarrow: 10230,
    looparrowright: 8620,
    nshortparallel: 8742,
    ntriangleright: 8939,
    rightarrowtail: 8611,
    rightharpoonup: 8640,
    trianglelefteq: 8884,
    upharpoonright: 8638,
    ApplyFunction: 8289,
    DifferentialD: 8518,
    DoubleLeftTee: 10980,
    DoubleUpArrow: 8657,
    LeftTeeVector: 10586,
    LeftVectorBar: 10578,
    LessFullEqual: 8806,
    LongLeftArrow: 10229,
    Longleftarrow: 10232,
    NotTildeEqual: 8772,
    NotTildeTilde: 8777,
    Poincareplane: 8460,
    PrecedesEqual: 10927,
    PrecedesTilde: 8830,
    RightArrowBar: 8677,
    RightTeeArrow: 8614,
    RightTriangle: 8883,
    RightUpVector: 8638,
    SucceedsEqual: 10928,
    SucceedsTilde: 8831,
    SupersetEqual: 8839,
    UpEquilibrium: 10606,
    VerticalTilde: 8768,
    VeryThinSpace: 8202,
    bigtriangleup: 9651,
    blacktriangle: 9652,
    divideontimes: 8903,
    fallingdotseq: 8786,
    hookleftarrow: 8617,
    leftarrowtail: 8610,
    leftharpoonup: 8636,
    longleftarrow: 10229,
    looparrowleft: 8619,
    measuredangle: 8737,
    ntriangleleft: 8938,
    shortparallel: 8741,
    smallsetminus: 8726,
    triangleright: 9657,
    upharpoonleft: 8639,
    DownArrowBar: 10515,
    DownTeeArrow: 8615,
    ExponentialE: 8519,
    GreaterEqual: 8805,
    GreaterTilde: 8819,
    HilbertSpace: 8459,
    HumpDownHump: 8782,
    Intersection: 8898,
    LeftArrowBar: 8676,
    LeftTeeArrow: 8612,
    LeftTriangle: 8882,
    LeftUpVector: 8639,
    NotCongruent: 8802,
    NotLessEqual: 8816,
    NotLessTilde: 8820,
    Proportional: 8733,
    RightCeiling: 8969,
    RoundImplies: 10608,
    ShortUpArrow: 8593,
    SquareSubset: 8847,
    UnderBracket: 9141,
    VerticalLine: 124,
    blacklozenge: 10731,
    exponentiale: 8519,
    risingdotseq: 8787,
    triangledown: 9663,
    triangleleft: 9667,
    CircleMinus: 8854,
    CircleTimes: 8855,
    Equilibrium: 8652,
    GreaterLess: 8823,
    LeftCeiling: 8968,
    LessGreater: 8822,
    MediumSpace: 8287,
    NotPrecedes: 8832,
    NotSucceeds: 8833,
    OverBracket: 9140,
    RightVector: 8640,
    Rrightarrow: 8667,
    RuleDelayed: 10740,
    SmallCircle: 8728,
    SquareUnion: 8852,
    SubsetEqual: 8838,
    UpDownArrow: 8597,
    Updownarrow: 8661,
    VerticalBar: 8739,
    backepsilon: 1014,
    blacksquare: 9642,
    circledcirc: 8858,
    circleddash: 8861,
    curlyeqprec: 8926,
    curlyeqsucc: 8927,
    diamondsuit: 9830,
    eqslantless: 10901,
    expectation: 8496,
    nRightarrow: 8655,
    nrightarrow: 8603,
    preccurlyeq: 8828,
    precnapprox: 10937,
    quaternions: 8461,
    straightphi: 981,
    succcurlyeq: 8829,
    succnapprox: 10938,
    thickapprox: 8776,
    updownarrow: 8597,
    Bernoullis: 8492,
    CirclePlus: 8853,
    EqualTilde: 8770,
    Fouriertrf: 8497,
    ImaginaryI: 8520,
    Laplacetrf: 8466,
    LeftVector: 8636,
    Lleftarrow: 8666,
    NotElement: 8713,
    NotGreater: 8815,
    Proportion: 8759,
    RightArrow: 8594,
    RightFloor: 8971,
    Rightarrow: 8658,
    TildeEqual: 8771,
    TildeTilde: 8776,
    UnderBrace: 9183,
    UpArrowBar: 10514,
    UpTeeArrow: 8613,
    circledast: 8859,
    complement: 8705,
    curlywedge: 8911,
    eqslantgtr: 10902,
    gtreqqless: 10892,
    lessapprox: 10885,
    lesseqqgtr: 10891,
    lmoustache: 9136,
    longmapsto: 10236,
    mapstodown: 8615,
    mapstoleft: 8612,
    nLeftarrow: 8653,
    nleftarrow: 8602,
    precapprox: 10935,
    rightarrow: 8594,
    rmoustache: 9137,
    sqsubseteq: 8849,
    sqsupseteq: 8850,
    subsetneqq: 10955,
    succapprox: 10936,
    supsetneqq: 10956,
    upuparrows: 8648,
    varepsilon: 949,
    varnothing: 8709,
    Backslash: 8726,
    CenterDot: 183,
    CircleDot: 8857,
    Congruent: 8801,
    Coproduct: 8720,
    DoubleDot: 168,
    DownArrow: 8595,
    DownBreve: 785,
    Downarrow: 8659,
    HumpEqual: 8783,
    LeftArrow: 8592,
    LeftFloor: 8970,
    Leftarrow: 8656,
    LessTilde: 8818,
    Mellintrf: 8499,
    MinusPlus: 8723,
    NotCupCap: 8813,
    NotExists: 8708,
    OverBrace: 9182,
    PlusMinus: 177,
    Therefore: 8756,
    ThinSpace: 8201,
    TripleDot: 8411,
    UnionPlus: 8846,
    backprime: 8245,
    backsimeq: 8909,
    bigotimes: 10754,
    centerdot: 183,
    checkmark: 10003,
    complexes: 8450,
    dotsquare: 8865,
    downarrow: 8595,
    gtrapprox: 10886,
    gtreqless: 8923,
    heartsuit: 9829,
    leftarrow: 8592,
    lesseqgtr: 8922,
    nparallel: 8742,
    nshortmid: 8740,
    nsubseteq: 8840,
    nsupseteq: 8841,
    pitchfork: 8916,
    rationals: 8474,
    spadesuit: 9824,
    subseteqq: 10949,
    subsetneq: 8842,
    supseteqq: 10950,
    supsetneq: 8843,
    therefore: 8756,
    triangleq: 8796,
    varpropto: 8733,
    DDotrahd: 10513,
    DotEqual: 8784,
    Integral: 8747,
    LessLess: 10913,
    NotEqual: 8800,
    NotTilde: 8769,
    PartialD: 8706,
    Precedes: 8826,
    RightTee: 8866,
    Succeeds: 8827,
    SuchThat: 8715,
    Superset: 8835,
    Uarrocir: 10569,
    UnderBar: 818,
    andslope: 10840,
    angmsdaa: 10664,
    angmsdab: 10665,
    angmsdac: 10666,
    angmsdad: 10667,
    angmsdae: 10668,
    angmsdaf: 10669,
    angmsdag: 10670,
    angmsdah: 10671,
    angrtvbd: 10653,
    approxeq: 8778,
    awconint: 8755,
    backcong: 8780,
    barwedge: 8965,
    bbrktbrk: 9142,
    bigoplus: 10753,
    bigsqcup: 10758,
    biguplus: 10756,
    bigwedge: 8896,
    boxminus: 8863,
    boxtimes: 8864,
    capbrcup: 10825,
    circledR: 174,
    circledS: 9416,
    cirfnint: 10768,
    clubsuit: 9827,
    cupbrcap: 10824,
    curlyvee: 8910,
    cwconint: 8754,
    doteqdot: 8785,
    dotminus: 8760,
    drbkarow: 10512,
    dzigrarr: 10239,
    elinters: 9191,
    emptyset: 8709,
    eqvparsl: 10725,
    fpartint: 10765,
    geqslant: 10878,
    gesdotol: 10884,
    gnapprox: 10890,
    hksearow: 10533,
    hkswarow: 10534,
    imagline: 8464,
    imagpart: 8465,
    infintie: 10717,
    integers: 8484,
    intercal: 8890,
    intlarhk: 10775,
    laemptyv: 10676,
    ldrushar: 10571,
    leqslant: 10877,
    lesdotor: 10883,
    llcorner: 8990,
    lnapprox: 10889,
    lrcorner: 8991,
    lurdshar: 10570,
    mapstoup: 8613,
    multimap: 8888,
    naturals: 8469,
    otimesas: 10806,
    parallel: 8741,
    plusacir: 10787,
    pointint: 10773,
    precneqq: 10933,
    precnsim: 8936,
    profalar: 9006,
    profline: 8978,
    profsurf: 8979,
    raemptyv: 10675,
    realpart: 8476,
    rppolint: 10770,
    rtriltri: 10702,
    scpolint: 10771,
    setminus: 8726,
    shortmid: 8739,
    smeparsl: 10724,
    sqsubset: 8847,
    sqsupset: 8848,
    subseteq: 8838,
    succneqq: 10934,
    succnsim: 8937,
    supseteq: 8839,
    thetasym: 977,
    thicksim: 8764,
    timesbar: 10801,
    triangle: 9653,
    triminus: 10810,
    trpezium: 9186,
    ulcorner: 8988,
    urcorner: 8989,
    varkappa: 1008,
    varsigma: 962,
    vartheta: 977,
    Because: 8757,
    Cayleys: 8493,
    Cconint: 8752,
    Cedilla: 184,
    Diamond: 8900,
    DownTee: 8868,
    Element: 8712,
    Epsilon: 917,
    Implies: 8658,
    LeftTee: 8867,
    NewLine: 10,
    NoBreak: 8288,
    NotLess: 8814,
    Omicron: 927,
    OverBar: 175,
    Product: 8719,
    UpArrow: 8593,
    Uparrow: 8657,
    Upsilon: 933,
    alefsym: 8501,
    angrtvb: 8894,
    angzarr: 9084,
    asympeq: 8781,
    backsim: 8765,
    because: 8757,
    bemptyv: 10672,
    between: 8812,
    bigcirc: 9711,
    bigodot: 10752,
    bigstar: 9733,
    boxplus: 8862,
    ccupssm: 10832,
    cemptyv: 10674,
    cirscir: 10690,
    coloneq: 8788,
    congdot: 10861,
    cudarrl: 10552,
    cudarrr: 10549,
    cularrp: 10557,
    curarrm: 10556,
    dbkarow: 10511,
    ddagger: 8225,
    ddotseq: 10871,
    demptyv: 10673,
    diamond: 8900,
    digamma: 989,
    dotplus: 8724,
    dwangle: 10662,
    epsilon: 949,
    eqcolon: 8789,
    equivDD: 10872,
    gesdoto: 10882,
    gtquest: 10876,
    gtrless: 8823,
    harrcir: 10568,
    intprod: 10812,
    isindot: 8949,
    larrbfs: 10527,
    larrsim: 10611,
    lbrksld: 10639,
    lbrkslu: 10637,
    ldrdhar: 10599,
    lesdoto: 10881,
    lessdot: 8918,
    lessgtr: 8822,
    lesssim: 8818,
    lotimes: 10804,
    lozenge: 9674,
    ltquest: 10875,
    luruhar: 10598,
    maltese: 10016,
    minusdu: 10794,
    napprox: 8777,
    natural: 9838,
    nearrow: 8599,
    nexists: 8708,
    notinva: 8713,
    notinvb: 8951,
    notinvc: 8950,
    notniva: 8716,
    notnivb: 8958,
    notnivc: 8957,
    npolint: 10772,
    nsqsube: 8930,
    nsqsupe: 8931,
    nvinfin: 10718,
    nwarrow: 8598,
    olcross: 10683,
    omicron: 959,
    orderof: 8500,
    orslope: 10839,
    pertenk: 8241,
    planckh: 8462,
    pluscir: 10786,
    plussim: 10790,
    plustwo: 10791,
    precsim: 8830,
    quatint: 10774,
    questeq: 8799,
    rarrbfs: 10528,
    rarrsim: 10612,
    rbrksld: 10638,
    rbrkslu: 10640,
    rdldhar: 10601,
    realine: 8475,
    rotimes: 10805,
    ruluhar: 10600,
    searrow: 8600,
    simplus: 10788,
    simrarr: 10610,
    subedot: 10947,
    submult: 10945,
    subplus: 10943,
    subrarr: 10617,
    succsim: 8831,
    supdsub: 10968,
    supedot: 10948,
    suphsub: 10967,
    suplarr: 10619,
    supmult: 10946,
    supplus: 10944,
    swarrow: 8601,
    topfork: 10970,
    triplus: 10809,
    tritime: 10811,
    uparrow: 8593,
    upsilon: 965,
    uwangle: 10663,
    vzigzag: 10650,
    zigrarr: 8669,
    Aacute: 193,
    Abreve: 258,
    Agrave: 192,
    Assign: 8788,
    Atilde: 195,
    Barwed: 8966,
    Bumpeq: 8782,
    Cacute: 262,
    Ccaron: 268,
    Ccedil: 199,
    Colone: 10868,
    Conint: 8751,
    CupCap: 8781,
    Dagger: 8225,
    Dcaron: 270,
    DotDot: 8412,
    Dstrok: 272,
    Eacute: 201,
    Ecaron: 282,
    Egrave: 200,
    Exists: 8707,
    ForAll: 8704,
    Gammad: 988,
    Gbreve: 286,
    Gcedil: 290,
    HARDcy: 1066,
    Hstrok: 294,
    Iacute: 205,
    Igrave: 204,
    Itilde: 296,
    Jsercy: 1032,
    Kcedil: 310,
    Lacute: 313,
    Lambda: 923,
    Lcaron: 317,
    Lcedil: 315,
    Lmidot: 319,
    Lstrok: 321,
    Nacute: 323,
    Ncaron: 327,
    Ncedil: 325,
    Ntilde: 209,
    Oacute: 211,
    Odblac: 336,
    Ograve: 210,
    Oslash: 216,
    Otilde: 213,
    Otimes: 10807,
    Racute: 340,
    Rarrtl: 10518,
    Rcaron: 344,
    Rcedil: 342,
    SHCHcy: 1065,
    SOFTcy: 1068,
    Sacute: 346,
    Scaron: 352,
    Scedil: 350,
    Square: 9633,
    Subset: 8912,
    Supset: 8913,
    Tcaron: 356,
    Tcedil: 354,
    Tstrok: 358,
    Uacute: 218,
    Ubreve: 364,
    Udblac: 368,
    Ugrave: 217,
    Utilde: 360,
    Vdashl: 10982,
    Verbar: 8214,
    Vvdash: 8874,
    Yacute: 221,
    Zacute: 377,
    Zcaron: 381,
    aacute: 225,
    abreve: 259,
    agrave: 224,
    andand: 10837,
    angmsd: 8737,
    angsph: 8738,
    apacir: 10863,
    approx: 8776,
    atilde: 227,
    barvee: 8893,
    barwed: 8965,
    becaus: 8757,
    bernou: 8492,
    bigcap: 8898,
    bigcup: 8899,
    bigvee: 8897,
    bkarow: 10509,
    bottom: 8869,
    bowtie: 8904,
    boxbox: 10697,
    bprime: 8245,
    brvbar: 166,
    bullet: 8226,
    bumpeq: 8783,
    cacute: 263,
    capand: 10820,
    capcap: 10827,
    capcup: 10823,
    capdot: 10816,
    ccaron: 269,
    ccedil: 231,
    circeq: 8791,
    cirmid: 10991,
    colone: 8788,
    commat: 64,
    compfn: 8728,
    conint: 8750,
    coprod: 8720,
    copysr: 8471,
    cularr: 8630,
    cupcap: 10822,
    cupcup: 10826,
    cupdot: 8845,
    curarr: 8631,
    curren: 164,
    cylcty: 9005,
    dagger: 8224,
    daleth: 8504,
    dcaron: 271,
    dfisht: 10623,
    divide: 247,
    divonx: 8903,
    dlcorn: 8990,
    dlcrop: 8973,
    dollar: 36,
    drcorn: 8991,
    drcrop: 8972,
    dstrok: 273,
    eacute: 233,
    easter: 10862,
    ecaron: 283,
    ecolon: 8789,
    egrave: 232,
    egsdot: 10904,
    elsdot: 10903,
    emptyv: 8709,
    emsp13: 8196,
    emsp14: 8197,
    eparsl: 10723,
    eqcirc: 8790,
    equals: 61,
    equest: 8799,
    female: 9792,
    ffilig: 64259,
    ffllig: 64260,
    forall: 8704,
    frac12: 189,
    frac13: 8531,
    frac14: 188,
    frac15: 8533,
    frac16: 8537,
    frac18: 8539,
    frac23: 8532,
    frac25: 8534,
    frac34: 190,
    frac35: 8535,
    frac38: 8540,
    frac45: 8536,
    frac56: 8538,
    frac58: 8541,
    frac78: 8542,
    gacute: 501,
    gammad: 989,
    gbreve: 287,
    gesdot: 10880,
    gesles: 10900,
    gtlPar: 10645,
    gtrarr: 10616,
    gtrdot: 8919,
    gtrsim: 8819,
    hairsp: 8202,
    hamilt: 8459,
    hardcy: 1098,
    hearts: 9829,
    hellip: 8230,
    hercon: 8889,
    homtht: 8763,
    horbar: 8213,
    hslash: 8463,
    hstrok: 295,
    hybull: 8259,
    hyphen: 8208,
    iacute: 237,
    igrave: 236,
    iiiint: 10764,
    iinfin: 10716,
    incare: 8453,
    inodot: 305,
    intcal: 8890,
    iquest: 191,
    isinsv: 8947,
    itilde: 297,
    jsercy: 1112,
    kappav: 1008,
    kcedil: 311,
    kgreen: 312,
    lAtail: 10523,
    lacute: 314,
    lagran: 8466,
    lambda: 955,
    langle: 10216,
    larrfs: 10525,
    larrhk: 8617,
    larrlp: 8619,
    larrpl: 10553,
    larrtl: 8610,
    latail: 10521,
    lbrace: 123,
    lbrack: 91,
    lcaron: 318,
    lcedil: 316,
    ldquor: 8222,
    lesdot: 10879,
    lesges: 10899,
    lfisht: 10620,
    lfloor: 8970,
    lharul: 10602,
    llhard: 10603,
    lmidot: 320,
    lmoust: 9136,
    loplus: 10797,
    lowast: 8727,
    lowbar: 95,
    lparlt: 10643,
    lrhard: 10605,
    lsaquo: 8249,
    lsquor: 8218,
    lstrok: 322,
    lthree: 8907,
    ltimes: 8905,
    ltlarr: 10614,
    ltrPar: 10646,
    mapsto: 8614,
    marker: 9646,
    mcomma: 10793,
    midast: 42,
    midcir: 10992,
    middot: 183,
    minusb: 8863,
    minusd: 8760,
    mnplus: 8723,
    models: 8871,
    mstpos: 8766,
    nVDash: 8879,
    nVdash: 8878,
    nacute: 324,
    ncaron: 328,
    ncedil: 326,
    nearhk: 10532,
    nequiv: 8802,
    nesear: 10536,
    nexist: 8708,
    nltrie: 8940,
    nprcue: 8928,
    nrtrie: 8941,
    nsccue: 8929,
    nsimeq: 8772,
    ntilde: 241,
    numero: 8470,
    nvDash: 8877,
    nvHarr: 10500,
    nvdash: 8876,
    nvlArr: 10498,
    nvrArr: 10499,
    nwarhk: 10531,
    nwnear: 10535,
    oacute: 243,
    odblac: 337,
    odsold: 10684,
    ograve: 242,
    ominus: 8854,
    origof: 8886,
    oslash: 248,
    otilde: 245,
    otimes: 8855,
    parsim: 10995,
    percnt: 37,
    period: 46,
    permil: 8240,
    phmmat: 8499,
    planck: 8463,
    plankv: 8463,
    plusdo: 8724,
    plusdu: 10789,
    plusmn: 177,
    preceq: 10927,
    primes: 8473,
    prnsim: 8936,
    propto: 8733,
    prurel: 8880,
    puncsp: 8200,
    qprime: 8279,
    rAtail: 10524,
    racute: 341,
    rangle: 10217,
    rarrap: 10613,
    rarrfs: 10526,
    rarrhk: 8618,
    rarrlp: 8620,
    rarrpl: 10565,
    rarrtl: 8611,
    ratail: 10522,
    rbrace: 125,
    rbrack: 93,
    rcaron: 345,
    rcedil: 343,
    rdquor: 8221,
    rfisht: 10621,
    rfloor: 8971,
    rharul: 10604,
    rmoust: 9137,
    roplus: 10798,
    rpargt: 10644,
    rsaquo: 8250,
    rsquor: 8217,
    rthree: 8908,
    rtimes: 8906,
    sacute: 347,
    scaron: 353,
    scedil: 351,
    scnsim: 8937,
    searhk: 10533,
    seswar: 10537,
    sfrown: 8994,
    shchcy: 1097,
    sigmaf: 962,
    sigmav: 962,
    simdot: 10858,
    smashp: 10803,
    softcy: 1100,
    solbar: 9023,
    spades: 9824,
    sqsube: 8849,
    sqsupe: 8850,
    square: 9633,
    squarf: 9642,
    ssetmn: 8726,
    ssmile: 8995,
    sstarf: 8902,
    subdot: 10941,
    subset: 8834,
    subsim: 10951,
    subsub: 10965,
    subsup: 10963,
    succeq: 10928,
    supdot: 10942,
    supset: 8835,
    supsim: 10952,
    supsub: 10964,
    supsup: 10966,
    swarhk: 10534,
    swnwar: 10538,
    target: 8982,
    tcaron: 357,
    tcedil: 355,
    telrec: 8981,
    there4: 8756,
    thetav: 977,
    thinsp: 8201,
    thksim: 8764,
    timesb: 8864,
    timesd: 10800,
    topbot: 9014,
    topcir: 10993,
    tprime: 8244,
    tridot: 9708,
    tstrok: 359,
    uacute: 250,
    ubreve: 365,
    udblac: 369,
    ufisht: 10622,
    ugrave: 249,
    ulcorn: 8988,
    ulcrop: 8975,
    urcorn: 8989,
    urcrop: 8974,
    utilde: 361,
    vangrt: 10652,
    varphi: 966,
    varrho: 1009,
    veebar: 8891,
    vellip: 8942,
    verbar: 124,
    wedbar: 10847,
    wedgeq: 8793,
    weierp: 8472,
    wreath: 8768,
    xoplus: 10753,
    xotime: 10754,
    xsqcup: 10758,
    xuplus: 10756,
    xwedge: 8896,
    yacute: 253,
    zacute: 378,
    zcaron: 382,
    zeetrf: 8488,
    AElig: 198,
    Acirc: 194,
    Alpha: 913,
    Amacr: 256,
    Aogon: 260,
    Aring: 197,
    Breve: 728,
    Ccirc: 264,
    Colon: 8759,
    Cross: 10799,
    Dashv: 10980,
    Delta: 916,
    Ecirc: 202,
    Emacr: 274,
    Eogon: 280,
    Equal: 10869,
    Gamma: 915,
    Gcirc: 284,
    Hacek: 711,
    Hcirc: 292,
    IJlig: 306,
    Icirc: 206,
    Imacr: 298,
    Iogon: 302,
    Iukcy: 1030,
    Jcirc: 308,
    Jukcy: 1028,
    Kappa: 922,
    OElig: 338,
    Ocirc: 212,
    Omacr: 332,
    Omega: 937,
    Prime: 8243,
    RBarr: 10512,
    Scirc: 348,
    Sigma: 931,
    THORN: 222,
    TRADE: 8482,
    TSHcy: 1035,
    Theta: 920,
    Tilde: 8764,
    Ubrcy: 1038,
    Ucirc: 219,
    Umacr: 362,
    Union: 8899,
    Uogon: 370,
    UpTee: 8869,
    Uring: 366,
    VDash: 8875,
    Vdash: 8873,
    Wcirc: 372,
    Wedge: 8896,
    Ycirc: 374,
    acirc: 226,
    acute: 180,
    aelig: 230,
    aleph: 8501,
    alpha: 945,
    amacr: 257,
    amalg: 10815,
    angle: 8736,
    angrt: 8735,
    angst: 8491,
    aogon: 261,
    aring: 229,
    asymp: 8776,
    awint: 10769,
    bcong: 8780,
    bdquo: 8222,
    bepsi: 1014,
    blank: 9251,
    blk12: 9618,
    blk14: 9617,
    blk34: 9619,
    block: 9608,
    boxDL: 9559,
    boxDR: 9556,
    boxDl: 9558,
    boxDr: 9555,
    boxHD: 9574,
    boxHU: 9577,
    boxHd: 9572,
    boxHu: 9575,
    boxUL: 9565,
    boxUR: 9562,
    boxUl: 9564,
    boxUr: 9561,
    boxVH: 9580,
    boxVL: 9571,
    boxVR: 9568,
    boxVh: 9579,
    boxVl: 9570,
    boxVr: 9567,
    boxdL: 9557,
    boxdR: 9554,
    boxdl: 9488,
    boxdr: 9484,
    boxhD: 9573,
    boxhU: 9576,
    boxhd: 9516,
    boxhu: 9524,
    boxuL: 9563,
    boxuR: 9560,
    boxul: 9496,
    boxur: 9492,
    boxvH: 9578,
    boxvL: 9569,
    boxvR: 9566,
    boxvh: 9532,
    boxvl: 9508,
    boxvr: 9500,
    breve: 728,
    bsemi: 8271,
    bsime: 8909,
    bsolb: 10693,
    bumpE: 10926,
    bumpe: 8783,
    caret: 8257,
    caron: 711,
    ccaps: 10829,
    ccirc: 265,
    ccups: 10828,
    cedil: 184,
    check: 10003,
    clubs: 9827,
    colon: 58,
    comma: 44,
    crarr: 8629,
    cross: 10007,
    csube: 10961,
    csupe: 10962,
    ctdot: 8943,
    cuepr: 8926,
    cuesc: 8927,
    cupor: 10821,
    cuvee: 8910,
    cuwed: 8911,
    cwint: 8753,
    dashv: 8867,
    dblac: 733,
    ddarr: 8650,
    delta: 948,
    dharl: 8643,
    dharr: 8642,
    diams: 9830,
    disin: 8946,
    doteq: 8784,
    dtdot: 8945,
    dtrif: 9662,
    duarr: 8693,
    duhar: 10607,
    eDDot: 10871,
    ecirc: 234,
    efDot: 8786,
    emacr: 275,
    empty: 8709,
    eogon: 281,
    eplus: 10865,
    epsiv: 949,
    eqsim: 8770,
    equiv: 8801,
    erDot: 8787,
    erarr: 10609,
    esdot: 8784,
    exist: 8707,
    fflig: 64256,
    filig: 64257,
    fllig: 64258,
    fltns: 9649,
    forkv: 10969,
    frasl: 8260,
    frown: 8994,
    gamma: 947,
    gcirc: 285,
    gescc: 10921,
    gimel: 8503,
    gneqq: 8809,
    gnsim: 8935,
    grave: 96,
    gsime: 10894,
    gsiml: 10896,
    gtcir: 10874,
    gtdot: 8919,
    harrw: 8621,
    hcirc: 293,
    hoarr: 8703,
    icirc: 238,
    iexcl: 161,
    iiint: 8749,
    iiota: 8489,
    ijlig: 307,
    imacr: 299,
    image: 8465,
    imath: 305,
    imped: 437,
    infin: 8734,
    iogon: 303,
    iprod: 10812,
    isinE: 8953,
    isins: 8948,
    isinv: 8712,
    iukcy: 1110,
    jcirc: 309,
    jmath: 567,
    jukcy: 1108,
    kappa: 954,
    lAarr: 8666,
    lBarr: 10510,
    langd: 10641,
    laquo: 171,
    larrb: 8676,
    lbarr: 10508,
    lbbrk: 10098,
    lbrke: 10635,
    lceil: 8968,
    ldquo: 8220,
    lescc: 10920,
    lhard: 8637,
    lharu: 8636,
    lhblk: 9604,
    llarr: 8647,
    lltri: 9722,
    lneqq: 8808,
    lnsim: 8934,
    loang: 10220,
    loarr: 8701,
    lobrk: 10214,
    lopar: 10629,
    lrarr: 8646,
    lrhar: 8651,
    lrtri: 8895,
    lsime: 10893,
    lsimg: 10895,
    lsquo: 8216,
    ltcir: 10873,
    ltdot: 8918,
    ltrie: 8884,
    ltrif: 9666,
    mDDot: 8762,
    mdash: 8212,
    micro: 181,
    minus: 8722,
    mumap: 8888,
    nabla: 8711,
    napos: 329,
    natur: 9838,
    ncong: 8775,
    ndash: 8211,
    neArr: 8663,
    nearr: 8599,
    ngsim: 8821,
    nhArr: 8654,
    nharr: 8622,
    nhpar: 10994,
    nlArr: 8653,
    nlarr: 8602,
    nless: 8814,
    nlsim: 8820,
    nltri: 8938,
    notin: 8713,
    notni: 8716,
    nprec: 8832,
    nrArr: 8655,
    nrarr: 8603,
    nrtri: 8939,
    nsime: 8772,
    nsmid: 8740,
    nspar: 8742,
    nsube: 8840,
    nsucc: 8833,
    nsupe: 8841,
    numsp: 8199,
    nwArr: 8662,
    nwarr: 8598,
    ocirc: 244,
    odash: 8861,
    oelig: 339,
    ofcir: 10687,
    ohbar: 10677,
    olarr: 8634,
    olcir: 10686,
    oline: 8254,
    omacr: 333,
    omega: 969,
    operp: 10681,
    oplus: 8853,
    orarr: 8635,
    order: 8500,
    ovbar: 9021,
    parsl: 11005,
    phone: 9742,
    plusb: 8862,
    pluse: 10866,
    pound: 163,
    prcue: 8828,
    prime: 8242,
    prnap: 10937,
    prsim: 8830,
    quest: 63,
    rAarr: 8667,
    rBarr: 10511,
    radic: 8730,
    rangd: 10642,
    range: 10661,
    raquo: 187,
    rarrb: 8677,
    rarrc: 10547,
    rarrw: 8605,
    ratio: 8758,
    rbarr: 10509,
    rbbrk: 10099,
    rbrke: 10636,
    rceil: 8969,
    rdquo: 8221,
    reals: 8477,
    rhard: 8641,
    rharu: 8640,
    rlarr: 8644,
    rlhar: 8652,
    rnmid: 10990,
    roang: 10221,
    roarr: 8702,
    robrk: 10215,
    ropar: 10630,
    rrarr: 8649,
    rsquo: 8217,
    rtrie: 8885,
    rtrif: 9656,
    sbquo: 8218,
    sccue: 8829,
    scirc: 349,
    scnap: 10938,
    scsim: 8831,
    sdotb: 8865,
    sdote: 10854,
    seArr: 8664,
    searr: 8600,
    setmn: 8726,
    sharp: 9839,
    sigma: 963,
    simeq: 8771,
    simgE: 10912,
    simlE: 10911,
    simne: 8774,
    slarr: 8592,
    smile: 8995,
    sqcap: 8851,
    sqcup: 8852,
    sqsub: 8847,
    sqsup: 8848,
    srarr: 8594,
    starf: 9733,
    strns: 175,
    subnE: 10955,
    subne: 8842,
    supnE: 10956,
    supne: 8843,
    swArr: 8665,
    swarr: 8601,
    szlig: 223,
    theta: 952,
    thkap: 8776,
    thorn: 254,
    tilde: 732,
    times: 215,
    trade: 8482,
    trisb: 10701,
    tshcy: 1115,
    twixt: 8812,
    ubrcy: 1118,
    ucirc: 251,
    udarr: 8645,
    udhar: 10606,
    uharl: 8639,
    uharr: 8638,
    uhblk: 9600,
    ultri: 9720,
    umacr: 363,
    uogon: 371,
    uplus: 8846,
    upsih: 978,
    uring: 367,
    urtri: 9721,
    utdot: 8944,
    utrif: 9652,
    uuarr: 8648,
    vBarv: 10985,
    vDash: 8872,
    varpi: 982,
    vdash: 8866,
    veeeq: 8794,
    vltri: 8882,
    vprop: 8733,
    vrtri: 8883,
    wcirc: 373,
    wedge: 8743,
    xcirc: 9711,
    xdtri: 9661,
    xhArr: 10234,
    xharr: 10231,
    xlArr: 10232,
    xlarr: 10229,
    xodot: 10752,
    xrArr: 10233,
    xrarr: 10230,
    xutri: 9651,
    ycirc: 375,
    Aopf: 120120,
    Ascr: 119964,
    Auml: 196,
    Barv: 10983,
    Beta: 914,
    Bopf: 120121,
    Bscr: 8492,
    CHcy: 1063,
    COPY: 169,
    Cdot: 266,
    Copf: 8450,
    Cscr: 119966,
    DJcy: 1026,
    DScy: 1029,
    DZcy: 1039,
    Darr: 8609,
    Dopf: 120123,
    Dscr: 119967,
    Edot: 278,
    Eopf: 120124,
    Escr: 8496,
    Esim: 10867,
    Euml: 203,
    Fopf: 120125,
    Fscr: 8497,
    GJcy: 1027,
    Gdot: 288,
    Gopf: 120126,
    Gscr: 119970,
    Hopf: 8461,
    Hscr: 8459,
    IEcy: 1045,
    IOcy: 1025,
    Idot: 304,
    Iopf: 120128,
    Iota: 921,
    Iscr: 8464,
    Iuml: 207,
    Jopf: 120129,
    Jscr: 119973,
    KHcy: 1061,
    KJcy: 1036,
    Kopf: 120130,
    Kscr: 119974,
    LJcy: 1033,
    Lang: 10218,
    Larr: 8606,
    Lopf: 120131,
    Lscr: 8466,
    Mopf: 120132,
    Mscr: 8499,
    NJcy: 1034,
    Nopf: 8469,
    Nscr: 119977,
    Oopf: 120134,
    Oscr: 119978,
    Ouml: 214,
    Popf: 8473,
    Pscr: 119979,
    QUOT: 34,
    Qopf: 8474,
    Qscr: 119980,
    Rang: 10219,
    Rarr: 8608,
    Ropf: 8477,
    Rscr: 8475,
    SHcy: 1064,
    Sopf: 120138,
    Sqrt: 8730,
    Sscr: 119982,
    Star: 8902,
    TScy: 1062,
    Topf: 120139,
    Tscr: 119983,
    Uarr: 8607,
    Uopf: 120140,
    Upsi: 978,
    Uscr: 119984,
    Uuml: 220,
    Vbar: 10987,
    Vert: 8214,
    Vopf: 120141,
    Vscr: 119985,
    Wopf: 120142,
    Wscr: 119986,
    Xopf: 120143,
    Xscr: 119987,
    YAcy: 1071,
    YIcy: 1031,
    YUcy: 1070,
    Yopf: 120144,
    Yscr: 119988,
    Yuml: 376,
    ZHcy: 1046,
    Zdot: 379,
    Zeta: 918,
    Zopf: 8484,
    Zscr: 119989,
    andd: 10844,
    andv: 10842,
    ange: 10660,
    aopf: 120146,
    apid: 8779,
    apos: 39,
    ascr: 119990,
    auml: 228,
    bNot: 10989,
    bbrk: 9141,
    beta: 946,
    beth: 8502,
    bnot: 8976,
    bopf: 120147,
    boxH: 9552,
    boxV: 9553,
    boxh: 9472,
    boxv: 9474,
    bscr: 119991,
    bsim: 8765,
    bsol: 92,
    bull: 8226,
    bump: 8782,
    cdot: 267,
    cent: 162,
    chcy: 1095,
    cirE: 10691,
    circ: 710,
    cire: 8791,
    comp: 8705,
    cong: 8773,
    copf: 120148,
    copy: 169,
    cscr: 119992,
    csub: 10959,
    csup: 10960,
    dArr: 8659,
    dHar: 10597,
    darr: 8595,
    dash: 8208,
    diam: 8900,
    djcy: 1106,
    dopf: 120149,
    dscr: 119993,
    dscy: 1109,
    dsol: 10742,
    dtri: 9663,
    dzcy: 1119,
    eDot: 8785,
    ecir: 8790,
    edot: 279,
    emsp: 8195,
    ensp: 8194,
    eopf: 120150,
    epar: 8917,
    epsi: 1013,
    escr: 8495,
    esim: 8770,
    euml: 235,
    euro: 8364,
    excl: 33,
    flat: 9837,
    fnof: 402,
    fopf: 120151,
    fork: 8916,
    fscr: 119995,
    gdot: 289,
    geqq: 8807,
    gjcy: 1107,
    gnap: 10890,
    gneq: 10888,
    gopf: 120152,
    gscr: 8458,
    gsim: 8819,
    gtcc: 10919,
    hArr: 8660,
    half: 189,
    harr: 8596,
    hbar: 8463,
    hopf: 120153,
    hscr: 119997,
    iecy: 1077,
    imof: 8887,
    iocy: 1105,
    iopf: 120154,
    iota: 953,
    iscr: 119998,
    isin: 8712,
    iuml: 239,
    jopf: 120155,
    jscr: 119999,
    khcy: 1093,
    kjcy: 1116,
    kopf: 120156,
    kscr: 120000,
    lArr: 8656,
    lHar: 10594,
    lang: 10216,
    larr: 8592,
    late: 10925,
    lcub: 123,
    ldca: 10550,
    ldsh: 8626,
    leqq: 8806,
    ljcy: 1113,
    lnap: 10889,
    lneq: 10887,
    lopf: 120157,
    lozf: 10731,
    lpar: 40,
    lscr: 120001,
    lsim: 8818,
    lsqb: 91,
    ltcc: 10918,
    ltri: 9667,
    macr: 175,
    male: 9794,
    malt: 10016,
    mlcp: 10971,
    mldr: 8230,
    mopf: 120158,
    mscr: 120002,
    nbsp: 160,
    ncap: 10819,
    ncup: 10818,
    ngeq: 8817,
    ngtr: 8815,
    nisd: 8954,
    njcy: 1114,
    nldr: 8229,
    nleq: 8816,
    nmid: 8740,
    nopf: 120159,
    npar: 8742,
    nscr: 120003,
    nsim: 8769,
    nsub: 8836,
    nsup: 8837,
    ntgl: 8825,
    ntlg: 8824,
    oast: 8859,
    ocir: 8858,
    odiv: 10808,
    odot: 8857,
    ogon: 731,
    oint: 8750,
    omid: 10678,
    oopf: 120160,
    opar: 10679,
    ordf: 170,
    ordm: 186,
    oror: 10838,
    oscr: 8500,
    osol: 8856,
    ouml: 246,
    para: 182,
    part: 8706,
    perp: 8869,
    phiv: 966,
    plus: 43,
    popf: 120161,
    prap: 10935,
    prec: 8826,
    prnE: 10933,
    prod: 8719,
    prop: 8733,
    pscr: 120005,
    qint: 10764,
    qopf: 120162,
    qscr: 120006,
    quot: 34,
    rArr: 8658,
    rHar: 10596,
    race: 10714,
    rang: 10217,
    rarr: 8594,
    rcub: 125,
    rdca: 10551,
    rdsh: 8627,
    real: 8476,
    rect: 9645,
    rhov: 1009,
    ring: 730,
    ropf: 120163,
    rpar: 41,
    rscr: 120007,
    rsqb: 93,
    rtri: 9657,
    scap: 10936,
    scnE: 10934,
    sdot: 8901,
    sect: 167,
    semi: 59,
    sext: 10038,
    shcy: 1096,
    sime: 8771,
    simg: 10910,
    siml: 10909,
    smid: 8739,
    smte: 10924,
    solb: 10692,
    sopf: 120164,
    spar: 8741,
    squf: 9642,
    sscr: 120008,
    star: 9734,
    subE: 10949,
    sube: 8838,
    succ: 8827,
    sung: 9834,
    sup1: 185,
    sup2: 178,
    sup3: 179,
    supE: 10950,
    supe: 8839,
    tbrk: 9140,
    tdot: 8411,
    tint: 8749,
    toea: 10536,
    topf: 120165,
    tosa: 10537,
    trie: 8796,
    tscr: 120009,
    tscy: 1094,
    uArr: 8657,
    uHar: 10595,
    uarr: 8593,
    uopf: 120166,
    upsi: 965,
    uscr: 120010,
    utri: 9653,
    uuml: 252,
    vArr: 8661,
    vBar: 10984,
    varr: 8597,
    vert: 124,
    vopf: 120167,
    vscr: 120011,
    wopf: 120168,
    wscr: 120012,
    xcap: 8898,
    xcup: 8899,
    xmap: 10236,
    xnis: 8955,
    xopf: 120169,
    xscr: 120013,
    xvee: 8897,
    yacy: 1103,
    yicy: 1111,
    yopf: 120170,
    yscr: 120014,
    yucy: 1102,
    yuml: 255,
    zdot: 380,
    zeta: 950,
    zhcy: 1078,
    zopf: 120171,
    zscr: 120015,
    zwnj: 8204,
    AMP: 38,
    Acy: 1040,
    Afr: 120068,
    And: 10835,
    Bcy: 1041,
    Bfr: 120069,
    Cap: 8914,
    Cfr: 8493,
    Chi: 935,
    Cup: 8915,
    Dcy: 1044,
    Del: 8711,
    Dfr: 120071,
    Dot: 168,
    ENG: 330,
    ETH: 208,
    Ecy: 1069,
    Efr: 120072,
    Eta: 919,
    Fcy: 1060,
    Ffr: 120073,
    Gcy: 1043,
    Gfr: 120074,
    Hat: 94,
    Hfr: 8460,
    Icy: 1048,
    Ifr: 8465,
    Int: 8748,
    Jcy: 1049,
    Jfr: 120077,
    Kcy: 1050,
    Kfr: 120078,
    Lcy: 1051,
    Lfr: 120079,
    Lsh: 8624,
    Map: 10501,
    Mcy: 1052,
    Mfr: 120080,
    Ncy: 1053,
    Nfr: 120081,
    Not: 10988,
    Ocy: 1054,
    Ofr: 120082,
    Pcy: 1055,
    Pfr: 120083,
    Phi: 934,
    Psi: 936,
    Qfr: 120084,
    REG: 174,
    Rcy: 1056,
    Rfr: 8476,
    Rho: 929,
    Rsh: 8625,
    Scy: 1057,
    Sfr: 120086,
    Sub: 8912,
    Sum: 8721,
    Sup: 8913,
    Tab: 9,
    Tau: 932,
    Tcy: 1058,
    Tfr: 120087,
    Ucy: 1059,
    Ufr: 120088,
    Vcy: 1042,
    Vee: 8897,
    Vfr: 120089,
    Wfr: 120090,
    Xfr: 120091,
    Ycy: 1067,
    Yfr: 120092,
    Zcy: 1047,
    Zfr: 8488,
    acd: 8767,
    acy: 1072,
    afr: 120094,
    amp: 38,
    and: 8743,
    ang: 8736,
    apE: 10864,
    ape: 8778,
    ast: 42,
    bcy: 1073,
    bfr: 120095,
    bot: 8869,
    cap: 8745,
    cfr: 120096,
    chi: 967,
    cir: 9675,
    cup: 8746,
    dcy: 1076,
    deg: 176,
    dfr: 120097,
    die: 168,
    div: 247,
    dot: 729,
    ecy: 1101,
    efr: 120098,
    egs: 10902,
    ell: 8467,
    els: 10901,
    eng: 331,
    eta: 951,
    eth: 240,
    fcy: 1092,
    ffr: 120099,
    gEl: 10892,
    gap: 10886,
    gcy: 1075,
    gel: 8923,
    geq: 8805,
    ges: 10878,
    gfr: 120100,
    ggg: 8921,
    glE: 10898,
    gla: 10917,
    glj: 10916,
    gnE: 8809,
    gne: 10888,
    hfr: 120101,
    icy: 1080,
    iff: 8660,
    ifr: 120102,
    int: 8747,
    jcy: 1081,
    jfr: 120103,
    kcy: 1082,
    kfr: 120104,
    lEg: 10891,
    lap: 10885,
    lat: 10923,
    lcy: 1083,
    leg: 8922,
    leq: 8804,
    les: 10877,
    lfr: 120105,
    lgE: 10897,
    lnE: 8808,
    lne: 10887,
    loz: 9674,
    lrm: 8206,
    lsh: 8624,
    map: 8614,
    mcy: 1084,
    mfr: 120106,
    mho: 8487,
    mid: 8739,
    nap: 8777,
    ncy: 1085,
    nfr: 120107,
    nge: 8817,
    ngt: 8815,
    nis: 8956,
    niv: 8715,
    nle: 8816,
    nlt: 8814,
    not: 172,
    npr: 8832,
    nsc: 8833,
    num: 35,
    ocy: 1086,
    ofr: 120108,
    ogt: 10689,
    ohm: 8486,
    olt: 10688,
    ord: 10845,
    orv: 10843,
    par: 8741,
    pcy: 1087,
    pfr: 120109,
    phi: 966,
    piv: 982,
    prE: 10931,
    pre: 10927,
    psi: 968,
    qfr: 120110,
    rcy: 1088,
    reg: 174,
    rfr: 120111,
    rho: 961,
    rlm: 8207,
    rsh: 8625,
    scE: 10932,
    sce: 10928,
    scy: 1089,
    sfr: 120112,
    shy: 173,
    sim: 8764,
    smt: 10922,
    sol: 47,
    squ: 9633,
    sub: 8834,
    sum: 8721,
    sup: 8835,
    tau: 964,
    tcy: 1090,
    tfr: 120113,
    top: 8868,
    ucy: 1091,
    ufr: 120114,
    uml: 168,
    vcy: 1074,
    vee: 8744,
    vfr: 120115,
    wfr: 120116,
    xfr: 120117,
    ycy: 1099,
    yen: 165,
    yfr: 120118,
    zcy: 1079,
    zfr: 120119,
    zwj: 8205,
    DD: 8517,
    GT: 62,
    Gg: 8921,
    Gt: 8811,
    Im: 8465,
    LT: 60,
    Ll: 8920,
    Lt: 8810,
    Mu: 924,
    Nu: 925,
    Or: 10836,
    Pi: 928,
    Pr: 10939,
    Re: 8476,
    Sc: 10940,
    Xi: 926,
    ac: 8766,
    af: 8289,
    ap: 8776,
    dd: 8518,
    ee: 8519,
    eg: 10906,
    el: 10905,
    gE: 8807,
    ge: 8805,
    gg: 8811,
    gl: 8823,
    gt: 62,
    ic: 8291,
    ii: 8520,
    "in": 8712,
    it: 8290,
    lE: 8806,
    le: 8804,
    lg: 8822,
    ll: 8810,
    lt: 60,
    mp: 8723,
    mu: 956,
    ne: 8800,
    ni: 8715,
    nu: 957,
    oS: 9416,
    or: 8744,
    pi: 960,
    pm: 177,
    pr: 8826,
    rx: 8478,
    sc: 8827,
    wp: 8472,
    wr: 8768,
    xi: 958
};

var windows1252 = [
    8364,
    129,
    8218,
    402,
    8222,
    8230,
    8224,
    8225,
    710,
    8240,
    352,
    8249,
    338,
    141,
    381,
    143,
    144,
    8216,
    8217,
    8220,
    8221,
    8226,
    8211,
    8212,
    732,
    8482,
    353,
    8250,
    339,
    157,
    382,
    376,
];
var entityPattern = new RegExp("&(#?(?:x[\\w\\d]+|\\d+|" + Object.keys(htmlEntities).join('|') + "));?", 'g');
function decodeCharacterReferences(html) {
    return html.replace(entityPattern, function (match, entity) {
        var code;
        // Handle named entities
        if (entity[0] !== '#') {
            code = htmlEntities[entity];
        }
        else if (entity[1] === 'x') {
            code = parseInt(entity.substring(2), 16);
        }
        else {
            code = parseInt(entity.substring(1), 10);
        }
        if (!code) {
            return match;
        }
        return String.fromCodePoint(validateCode(code));
    });
}
var NUL = 0;
// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
// code points with alternatives in some cases - since we're bypassing that mechanism, we need
// to replace them ourselves
//
// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
function validateCode(code) {
    // line feed becomes generic whitespace
    if (code === 10) {
        return 32;
    }
    // ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
    if (code < 128) {
        return code;
    }
    // code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
    // to correct the mistake or we'll end up with missing € signs and so on
    if (code <= 159) {
        return windows1252[code - 128];
    }
    // basic multilingual plane
    if (code < 55296) {
        return code;
    }
    // UTF-16 surrogate halves
    if (code <= 57343) {
        return NUL;
    }
    // rest of the basic multilingual plane
    if (code <= 65535) {
        return code;
    }
    // supplementary multilingual plane 0x10000 - 0x1ffff
    if (code >= 65536 && code <= 131071) {
        return code;
    }
    // supplementary ideographic plane 0x20000 - 0x2ffff
    if (code >= 131072 && code <= 196607) {
        return code;
    }
    return NUL;
}

var voidElementNames = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function isVoidElementName(name) {
    return voidElementNames.test(name) || name.toLowerCase() === '!doctype';
}

var validTagName = /^\!?[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/;
var SELF = ':Self';
var COMPONENT = ':Component';
var metaTags = new Set([
    ':Window',
    ':Head'
]);
var specials = new Map([
    [
        'script',
        {
            read: readScript,
            property: 'js'
        },
    ],
    [
        'style',
        {
            read: readStyle,
            property: 'css'
        },
    ],
]);
// based on http://developers.whatwg.org/syntax.html#syntax-tag-omission
var disallowedContents = new Map([
    ['li', new Set(['li'])],
    ['dt', new Set(['dt', 'dd'])],
    ['dd', new Set(['dt', 'dd'])],
    [
        'p',
        new Set('address article aside blockquote div dl fieldset footer form h1 h2 h3 h4 h5 h6 header hgroup hr main menu nav ol p pre section table ul'.split(' ')),
    ],
    ['rt', new Set(['rt', 'rp'])],
    ['rp', new Set(['rt', 'rp'])],
    ['optgroup', new Set(['optgroup'])],
    ['option', new Set(['option', 'optgroup'])],
    ['thead', new Set(['tbody', 'tfoot'])],
    ['tbody', new Set(['tbody', 'tfoot'])],
    ['tfoot', new Set(['tbody'])],
    ['tr', new Set(['tr', 'tbody'])],
    ['td', new Set(['td', 'th', 'tr'])],
    ['th', new Set(['td', 'th', 'tr'])],
]);
function tag(parser) {
    var start = parser.index++;
    var parent = parser.current();
    if (parser.eat('!--')) {
        var data = parser.readUntil(/-->/);
        parser.eat('-->');
        parser.current().children.push({
            start: start,
            end: parser.index,
            type: 'Comment',
            data: data
        });
        return;
    }
    var isClosingTag = parser.eat('/');
    var name = readTagName(parser);
    if (metaTags.has(name)) {
        if (isClosingTag) {
            if (name === ':Window' && parser.current().children.length) {
                parser.error("<:Window> cannot have children", parser.current().children[0].start);
            }
        }
        else {
            if (name in parser.metaTags) {
                parser.error("A component can only have one <" + name + "> tag", start);
            }
            if (parser.stack.length > 1) {
                console.log(parser.stack);
                parser.error("<" + name + "> tags cannot be inside elements or blocks", start);
            }
            parser.metaTags[name] = true;
        }
    }
    var element = {
        start: start,
        end: null,
        type: 'Element',
        name: name,
        attributes: [],
        children: []
    };
    parser.allowWhitespace();
    if (isClosingTag) {
        if (isVoidElementName(name)) {
            parser.error("<" + name + "> is a void element and cannot have children, or a closing tag", start);
        }
        if (!parser.eat('>'))
            parser.error("Expected '>'");
        // close any elements that don't have their own closing tags, e.g. <div><p></div>
        while (parent.name !== name) {
            if (parent.type !== 'Element')
                parser.error("</" + name + "> attempted to close an element that was not open", start);
            parent.end = start;
            parser.stack.pop();
            parent = parser.current();
        }
        parent.end = parser.index;
        parser.stack.pop();
        return;
    }
    else if (disallowedContents.has(parent.name)) {
        // can this be a child of the parent element, or does it implicitly
        // close it, like `<li>one<li>two`?
        if (disallowedContents.get(parent.name).has(name)) {
            parent.end = start;
            parser.stack.pop();
        }
    }
    if (name === 'slot') {
        var i = parser.stack.length;
        while (i--) {
            var item = parser.stack[i];
            if (item.type === 'EachBlock') {
                parser.error("<slot> cannot be a child of an each-block", start);
            }
        }
    }
    if (name === COMPONENT) {
        parser.eat('{', true);
        element.expression = readExpression(parser);
        parser.allowWhitespace();
        parser.eat('}', true);
        parser.allowWhitespace();
    }
    var uniqueNames = new Set();
    var attribute;
    while ((attribute = readAttribute(parser, uniqueNames))) {
        element.attributes.push(attribute);
        parser.allowWhitespace();
    }
    // special cases – top-level <script> and <style>
    if (specials.has(name) && parser.stack.length === 1) {
        var special = specials.get(name);
        if (parser[special.property]) {
            parser.index = start;
            parser.error("You can only have one top-level <" + name + "> tag per component");
        }
        parser.eat('>', true);
        parser[special.property] = special.read(parser, start, element.attributes);
        return;
    }
    parser.current().children.push(element);
    var selfClosing = parser.eat('/') || isVoidElementName(name);
    parser.eat('>', true);
    if (selfClosing) {
        element.end = parser.index;
    }
    else if (name === 'textarea') {
        // special case
        element.children = readSequence(parser, function () {
            return parser.template.slice(parser.index, parser.index + 11) === '</textarea>';
        });
        parser.read(/<\/textarea>/);
        element.end = parser.index;
    }
    else {
        // don't push self-closing elements onto the stack
        parser.stack.push(element);
    }
}
function readTagName(parser) {
    var start = parser.index;
    if (parser.eat(SELF)) {
        // check we're inside a block, otherwise this
        // will cause infinite recursion
        var i = parser.stack.length;
        var legal = false;
        while (i--) {
            var fragment = parser.stack[i];
            if (fragment.type === 'IfBlock' || fragment.type === 'EachBlock') {
                legal = true;
                break;
            }
        }
        if (!legal) {
            parser.error("<" + SELF + "> components can only exist inside if-blocks or each-blocks", start);
        }
        return SELF;
    }
    if (parser.eat(COMPONENT))
        return COMPONENT;
    var name = parser.readUntil(/(\s|\/|>)/);
    if (metaTags.has(name))
        return name;
    if (!validTagName.test(name)) {
        parser.error("Expected valid tag name", start);
    }
    return name;
}
function readAttribute(parser, uniqueNames) {
    var start = parser.index;
    var name = parser.readUntil(/(\s|=|\/|>)/);
    if (!name)
        return null;
    if (uniqueNames.has(name)) {
        parser.error('Attributes need to be unique', start);
    }
    uniqueNames.add(name);
    parser.allowWhitespace();
    if (/^on:/.test(name)) {
        return readEventHandlerDirective(parser, start, name.slice(3), parser.eat('='));
    }
    if (/^bind:/.test(name)) {
        return readBindingDirective(parser, start, name.slice(5));
    }
    if (/^ref:/.test(name)) {
        return {
            start: start,
            end: parser.index,
            type: 'Ref',
            name: name.slice(4)
        };
    }
    var match = /^(in|out|transition):/.exec(name);
    if (match) {
        return readTransitionDirective(parser, start, name.slice(match[0].length), match[1]);
    }
    var value;
    // :foo is shorthand for foo='{{foo}}'
    if (/^:\w+$/.test(name)) {
        name = name.slice(1);
        value = getShorthandValue(start + 1, name);
    }
    else {
        value = parser.eat('=') ? readAttributeValue(parser) : true;
    }
    return {
        start: start,
        end: parser.index,
        type: 'Attribute',
        name: name,
        value: value
    };
}
function readAttributeValue(parser) {
    var quoteMark = parser.eat("'") ? "'" : parser.eat("\"") ? "\"" : null;
    var regex = quoteMark === "'"
        ? /'/
        : quoteMark === "\"" ? /"/ : /[\s"'=<>\/`]/;
    var value = readSequence(parser, function () {
        return regex.test(parser.template[parser.index]);
    });
    if (quoteMark)
        parser.index += 1;
    return value;
}
function getShorthandValue(start, name) {
    var end = start + name.length;
    return [
        {
            type: 'AttributeShorthand',
            start: start,
            end: end,
            expression: {
                type: 'Identifier',
                start: start,
                end: end,
                name: name
            }
        },
    ];
}
function readSequence(parser, done) {
    var currentChunk = {
        start: parser.index,
        end: null,
        type: 'Text',
        data: ''
    };
    var chunks = [];
    while (parser.index < parser.template.length) {
        var index = parser.index;
        if (done()) {
            currentChunk.end = parser.index;
            if (currentChunk.data)
                chunks.push(currentChunk);
            chunks.forEach(function (chunk) {
                if (chunk.type === 'Text')
                    chunk.data = decodeCharacterReferences(chunk.data);
            });
            return chunks;
        }
        else if (parser.eat('{{')) {
            if (currentChunk.data) {
                currentChunk.end = index;
                chunks.push(currentChunk);
            }
            var expression = readExpression(parser);
            parser.allowWhitespace();
            if (!parser.eat('}}')) {
                parser.error("Expected }}");
            }
            chunks.push({
                start: index,
                end: parser.index,
                type: 'MustacheTag',
                expression: expression
            });
            currentChunk = {
                start: parser.index,
                end: null,
                type: 'Text',
                data: ''
            };
        }
        else {
            currentChunk.data += parser.template[parser.index++];
        }
    }
    parser.error("Unexpected end of input");
}

var whitespace = /[ \t\r\n]/;

function trimStart(str) {
    var i = 0;
    while (whitespace.test(str[i]))
        i += 1;
    return str.slice(i);
}
function trimEnd(str) {
    var i = str.length;
    while (whitespace.test(str[i - 1]))
        i -= 1;
    return str.slice(0, i);
}

function trimWhitespace(block, trimBefore, trimAfter) {
    if (!block.children)
        return; // AwaitBlock
    var firstChild = block.children[0];
    var lastChild = block.children[block.children.length - 1];
    if (firstChild.type === 'Text' && trimBefore) {
        firstChild.data = trimStart(firstChild.data);
        if (!firstChild.data)
            block.children.shift();
    }
    if (lastChild.type === 'Text' && trimAfter) {
        lastChild.data = trimEnd(lastChild.data);
        if (!lastChild.data)
            block.children.pop();
    }
    if (block["else"]) {
        trimWhitespace(block["else"], trimBefore, trimAfter);
    }
    if (firstChild.elseif) {
        trimWhitespace(firstChild, trimBefore, trimAfter);
    }
}
function mustache(parser) {
    var start = parser.index;
    parser.index += 2;
    parser.allowWhitespace();
    // {{/if}} or {{/each}}
    if (parser.eat('/')) {
        var block = parser.current();
        var expected = void 0;
        if (block.type === 'ElseBlock' || block.type === 'PendingBlock' || block.type === 'ThenBlock' || block.type === 'CatchBlock') {
            block.end = start;
            parser.stack.pop();
            block = parser.current();
            expected = 'await';
        }
        if (block.type === 'IfBlock') {
            expected = 'if';
        }
        else if (block.type === 'EachBlock') {
            expected = 'each';
        }
        else if (block.type === 'AwaitBlock') {
            expected = 'await';
        }
        else {
            parser.error("Unexpected block closing tag");
        }
        parser.eat(expected, true);
        parser.allowWhitespace();
        parser.eat('}}', true);
        while (block.elseif) {
            block.end = parser.index;
            parser.stack.pop();
            block = parser.current();
            if (block["else"]) {
                block["else"].end = start;
            }
        }
        // strip leading/trailing whitespace as necessary
        if (block.children && !block.children.length)
            parser.error("Empty block", block.start);
        var charBefore = parser.template[block.start - 1];
        var charAfter = parser.template[parser.index];
        var trimBefore = !charBefore || whitespace.test(charBefore);
        var trimAfter = !charAfter || whitespace.test(charAfter);
        trimWhitespace(block, trimBefore, trimAfter);
        block.end = parser.index;
        parser.stack.pop();
    }
    else if (parser.eat('elseif')) {
        var block = parser.current();
        if (block.type !== 'IfBlock')
            parser.error('Cannot have an {{elseif ...}} block outside an {{#if ...}} block');
        parser.requireWhitespace();
        var expression = readExpression(parser);
        parser.allowWhitespace();
        parser.eat('}}', true);
        block["else"] = {
            start: parser.index,
            end: null,
            type: 'ElseBlock',
            children: [
                {
                    start: parser.index,
                    end: null,
                    type: 'IfBlock',
                    elseif: true,
                    expression: expression,
                    children: []
                },
            ]
        };
        parser.stack.push(block["else"].children[0]);
    }
    else if (parser.eat('else')) {
        var block = parser.current();
        if (block.type !== 'IfBlock' && block.type !== 'EachBlock') {
            parser.error('Cannot have an {{else}} block outside an {{#if ...}} or {{#each ...}} block');
        }
        parser.allowWhitespace();
        parser.eat('}}', true);
        block["else"] = {
            start: parser.index,
            end: null,
            type: 'ElseBlock',
            children: []
        };
        parser.stack.push(block["else"]);
    }
    else if (parser.eat('then')) {
        // TODO DRY out this and the next section
        var pendingBlock = parser.current();
        if (pendingBlock.type === 'PendingBlock') {
            pendingBlock.end = start;
            parser.stack.pop();
            var awaitBlock = parser.current();
            parser.requireWhitespace();
            awaitBlock.value = parser.readIdentifier();
            parser.allowWhitespace();
            parser.eat('}}', true);
            var thenBlock = {
                start: start,
                end: null,
                type: 'ThenBlock',
                children: []
            };
            awaitBlock.then = thenBlock;
            parser.stack.push(thenBlock);
        }
    }
    else if (parser.eat('catch')) {
        var thenBlock = parser.current();
        if (thenBlock.type === 'ThenBlock') {
            thenBlock.end = start;
            parser.stack.pop();
            var awaitBlock = parser.current();
            parser.requireWhitespace();
            awaitBlock.error = parser.readIdentifier();
            parser.allowWhitespace();
            parser.eat('}}', true);
            var catchBlock = {
                start: start,
                end: null,
                type: 'CatchBlock',
                children: []
            };
            awaitBlock["catch"] = catchBlock;
            parser.stack.push(catchBlock);
        }
    }
    else if (parser.eat('#')) {
        // {{#if foo}} or {{#each foo}}
        var type = void 0;
        if (parser.eat('if')) {
            type = 'IfBlock';
        }
        else if (parser.eat('each')) {
            type = 'EachBlock';
        }
        else if (parser.eat('await')) {
            type = 'AwaitBlock';
        }
        else {
            parser.error("Expected if, each or await");
        }
        parser.requireWhitespace();
        var expression = readExpression(parser);
        var block = type === 'AwaitBlock' ?
            {
                start: start,
                end: null,
                type: type,
                expression: expression,
                value: null,
                error: null,
                pending: {
                    start: null,
                    end: null,
                    type: 'PendingBlock',
                    children: []
                },
                then: {
                    start: null,
                    end: null,
                    type: 'ThenBlock',
                    children: []
                },
                "catch": {
                    start: null,
                    end: null,
                    type: 'CatchBlock',
                    children: []
                }
            } :
            {
                start: start,
                end: null,
                type: type,
                expression: expression,
                children: []
            };
        parser.allowWhitespace();
        // {{#each}} blocks must declare a context – {{#each list as item}}
        if (type === 'EachBlock') {
            parser.eat('as', true);
            parser.requireWhitespace();
            if (parser.eat('[')) {
                parser.allowWhitespace();
                block.destructuredContexts = [];
                do {
                    parser.allowWhitespace();
                    var destructuredContext = parser.readIdentifier();
                    if (!destructuredContext)
                        parser.error("Expected name");
                    block.destructuredContexts.push(destructuredContext);
                    parser.allowWhitespace();
                } while (parser.eat(','));
                if (!block.destructuredContexts.length)
                    parser.error("Expected name");
                block.context = block.destructuredContexts.join('_');
                parser.allowWhitespace();
                parser.eat(']', true);
            }
            else {
                block.context = parser.readIdentifier();
                if (!block.context)
                    parser.error("Expected name");
            }
            parser.allowWhitespace();
            if (parser.eat(',')) {
                parser.allowWhitespace();
                block.index = parser.readIdentifier();
                if (!block.index)
                    parser.error("Expected name");
                parser.allowWhitespace();
            }
            if (parser.eat('@')) {
                block.key = parser.readIdentifier();
                if (!block.key)
                    parser.error("Expected name");
                parser.allowWhitespace();
            }
        }
        var awaitBlockShorthand = type === 'AwaitBlock' && parser.eat('then');
        if (awaitBlockShorthand) {
            parser.requireWhitespace();
            block.value = parser.readIdentifier();
            parser.allowWhitespace();
        }
        parser.eat('}}', true);
        parser.current().children.push(block);
        parser.stack.push(block);
        if (type === 'AwaitBlock') {
            var childBlock = awaitBlockShorthand ? block.then : block.pending;
            childBlock.start = parser.index;
            parser.stack.push(childBlock);
        }
    }
    else if (parser.eat('yield')) {
        // {{yield}}
        // TODO deprecate
        parser.allowWhitespace();
        parser.eat('}}', true);
        parser.current().children.push({
            start: start,
            end: parser.index,
            type: 'Element',
            name: 'slot',
            attributes: [],
            children: []
        });
    }
    else if (parser.eat('{')) {
        // {{{raw}}} mustache
        var expression = readExpression(parser);
        parser.allowWhitespace();
        parser.eat('}}}', true);
        parser.current().children.push({
            start: start,
            end: parser.index,
            type: 'RawMustacheTag',
            expression: expression
        });
    }
    else {
        var expression = readExpression(parser);
        parser.allowWhitespace();
        parser.eat('}}', true);
        parser.current().children.push({
            start: start,
            end: parser.index,
            type: 'MustacheTag',
            expression: expression
        });
    }
}

function text(parser) {
    var start = parser.index;
    var data = '';
    while (parser.index < parser.template.length &&
        !parser.match('<') &&
        !parser.match('{{')) {
        data += parser.template[parser.index++];
    }
    parser.current().children.push({
        start: start,
        end: parser.index,
        type: 'Text',
        data: decodeCharacterReferences(data)
    });
}

function fragment(parser) {
    if (parser.match('<')) {
        return tag;
    }
    if (parser.match('{{')) {
        return mustache;
    }
    return text;
}

var reservedNames = new Set([
    'arguments',
    'await',
    'break',
    'case',
    'catch',
    'class',
    'const',
    'continue',
    'debugger',
    'default',
    'delete',
    'do',
    'else',
    'enum',
    'eval',
    'export',
    'extends',
    'false',
    'finally',
    'for',
    'function',
    'if',
    'implements',
    'import',
    'in',
    'instanceof',
    'interface',
    'let',
    'new',
    'null',
    'package',
    'private',
    'protected',
    'public',
    'return',
    'static',
    'super',
    'switch',
    'this',
    'throw',
    'true',
    'try',
    'typeof',
    'var',
    'void',
    'while',
    'with',
    'yield',
]);

// https://github.com/darkskyapp/string-hash/blob/master/index.js
function hash(str) {
    var hash = 5381;
    var i = str.length;
    while (i--)
        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
    return hash >>> 0;
}

function getLocator(source, options) {
    if (options === void 0) { options = {}; }
    var offsetLine = options.offsetLine || 0;
    var offsetColumn = options.offsetColumn || 0;
    var originalLines = source.split('\n');
    var start = 0;
    var lineRanges = originalLines.map(function (line, i) {
        var end = start + line.length + 1;
        var range = { start: start, end: end, line: i };
        start = end;
        return range;
    });
    var i = 0;
    function rangeContains(range, index) {
        return range.start <= index && index < range.end;
    }
    function getLocation(range, index) {
        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };
    }
    function locate(search, startIndex) {
        if (typeof search === 'string') {
            search = source.indexOf(search, startIndex || 0);
        }
        var range = lineRanges[i];
        var d = search >= range.end ? 1 : -1;
        while (range) {
            if (rangeContains(range, search))
                return getLocation(range, search);
            i += d;
            range = lineRanges[i];
        }
    }
    
    return locate;
}
function locate(source, search, options) {
    if (typeof options === 'number') {
        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');
    }
    return getLocator(source, options)(search, options && options.startIndex);
}

function tabsToSpaces(str) {
    return str.replace(/^\t+/, function (match) { return match.split('\t').join('  '); });
}
function getCodeFrame(source, line, column) {
    var lines = source.split('\n');
    var frameStart = Math.max(0, line - 2);
    var frameEnd = Math.min(line + 3, lines.length);
    var digits = String(frameEnd + 1).length;
    return lines
        .slice(frameStart, frameEnd)
        .map(function (str, i) {
        var isErrorLine = frameStart + i === line;
        var lineNum = String(i + frameStart + 1);
        while (lineNum.length < digits)
            lineNum = " " + lineNum;
        if (isErrorLine) {
            var indicator = repeat(' ', digits + 2 + tabsToSpaces(str.slice(0, column)).length) + '^';
            return lineNum + ": " + tabsToSpaces(str) + "\n" + indicator;
        }
        return lineNum + ": " + tabsToSpaces(str);
    })
        .join('\n');
}

var CompileError = /** @class */ (function (_super) {
    __extends(CompileError, _super);
    function CompileError(message, template, index, filename) {
        var _this = _super.call(this, message) || this;
        _this.toString = function () {
            return _this.message + " (" + _this.loc.line + ":" + _this.loc.column + ")\n" + _this
                .frame;
        };
        var _a = locate(template, index), line = _a.line, column = _a.column;
        _this.loc = { line: line + 1, column: column };
        _this.pos = index;
        _this.filename = filename;
        _this.frame = getCodeFrame(template, line, column);
        return _this;
    }
    return CompileError;
}(Error));

var ParseError = /** @class */ (function (_super) {
    __extends(ParseError, _super);
    function ParseError(message, template, index, filename) {
        var _this = _super.call(this, message, template, index, filename) || this;
        _this.name = 'ParseError';
        return _this;
    }
    return ParseError;
}(CompileError));
var Parser = /** @class */ (function () {
    function Parser(template, options) {
        if (typeof template !== 'string') {
            throw new TypeError('Template must be a string');
        }
        this.template = template.replace(/\s+$/, '');
        this.filename = options.filename;
        this.index = 0;
        this.stack = [];
        this.metaTags = {};
        this.html = {
            start: null,
            end: null,
            type: 'Fragment',
            children: []
        };
        this.css = null;
        this.js = null;
        this.stack.push(this.html);
        var state = fragment;
        while (this.index < this.template.length) {
            state = state(this) || fragment;
        }
        if (this.stack.length > 1) {
            var current = this.current();
            var type = current.type === 'Element' ? "<" + current.name + ">" : 'Block';
            this.error(type + " was left open", current.start);
        }
        if (state !== fragment) {
            this.error('Unexpected end of input');
        }
        if (this.html.children.length) {
            var start = this.html.children[0] && this.html.children[0].start;
            while (/\s/.test(template[start]))
                start += 1;
            var end = this.html.children[this.html.children.length - 1] && this.html.children[this.html.children.length - 1].end;
            while (/\s/.test(template[end - 1]))
                end -= 1;
            this.html.start = start;
            this.html.end = end;
        }
        else {
            this.html.start = this.html.end = null;
        }
    }
    Parser.prototype.current = function () {
        return this.stack[this.stack.length - 1];
    };
    Parser.prototype.acornError = function (err) {
        this.error(err.message.replace(/ \(\d+:\d+\)$/, ''), err.pos);
    };
    Parser.prototype.error = function (message, index) {
        if (index === void 0) { index = this.index; }
        throw new ParseError(message, this.template, index, this.filename);
    };
    Parser.prototype.eat = function (str, required) {
        if (this.match(str)) {
            this.index += str.length;
            return true;
        }
        if (required) {
            this.error("Expected " + str);
        }
        return false;
    };
    Parser.prototype.match = function (str) {
        return this.template.slice(this.index, this.index + str.length) === str;
    };
    Parser.prototype.allowWhitespace = function () {
        while (this.index < this.template.length &&
            whitespace.test(this.template[this.index])) {
            this.index++;
        }
    };
    Parser.prototype.read = function (pattern) {
        var match = pattern.exec(this.template.slice(this.index));
        if (!match || match.index !== 0)
            return null;
        this.index += match[0].length;
        return match[0];
    };
    Parser.prototype.readIdentifier = function () {
        var start = this.index;
        var identifier = this.read(/[a-zA-Z_$][a-zA-Z0-9_$]*/);
        if (reservedNames.has(identifier)) {
            this.error("'" + identifier + "' is a reserved word in JavaScript and cannot be used here", start);
        }
        return identifier;
    };
    Parser.prototype.readUntil = function (pattern) {
        if (this.index >= this.template.length)
            this.error('Unexpected end of input');
        var start = this.index;
        var match = pattern.exec(this.template.slice(start));
        if (match) {
            var start_1 = this.index;
            this.index = start_1 + match.index;
            return this.template.slice(start_1, this.index);
        }
        this.index = this.template.length;
        return this.template.slice(start);
    };
    Parser.prototype.remaining = function () {
        return this.template.slice(this.index);
    };
    Parser.prototype.requireWhitespace = function () {
        if (!whitespace.test(this.template[this.index])) {
            this.error("Expected whitespace");
        }
        this.allowWhitespace();
    };
    return Parser;
}());
function parse(template, options) {
    if (options === void 0) { options = {}; }
    var parser = new Parser(template, options);
    return {
        hash: hash(parser.template),
        html: parser.html,
        css: parser.css,
        js: parser.js
    };
}

var disallowed = new Set(['Literal', 'ObjectExpression', 'ArrayExpression']);
function data(validator, prop) {
    while (prop.type === 'ParenthesizedExpression')
        prop = prop.expression;
    // TODO should we disallow references and expressions as well?
    if (disallowed.has(prop.value.type)) {
        validator.error("'data' must be a function", prop.value.start);
    }
}

function getMethodName(node) {
    if (node.type === 'Identifier')
        return node.name;
    if (node.type === 'Literal')
        return String(node.value);
}

function checkForDupes(validator, properties) {
    var seen = new Set();
    properties.forEach(function (prop) {
        var name = getMethodName(prop.key);
        if (seen.has(name)) {
            validator.error("Duplicate property '" + name + "'", prop.start);
        }
        seen.add(name);
    });
}

function checkForComputedKeys(validator, properties) {
    properties.forEach(function (prop) {
        if (prop.key.computed) {
            validator.error("Cannot use computed keys", prop.start);
        }
    });
}

var isFunctionExpression = new Set([
    'FunctionExpression',
    'ArrowFunctionExpression',
]);
function computed(validator, prop) {
    if (prop.value.type !== 'ObjectExpression') {
        validator.error("The 'computed' property must be an object literal", prop.start);
    }
    checkForDupes(validator, prop.value.properties);
    checkForComputedKeys(validator, prop.value.properties);
    prop.value.properties.forEach(function (computation) {
        if (!isFunctionExpression.has(computation.value.type)) {
            validator.error("Computed properties can be function expressions or arrow function expressions", computation.value.start);
        }
        var params = computation.value.params;
        if (params.length === 0) {
            validator.error("A computed value must depend on at least one property", computation.value.start);
        }
        params.forEach(function (param) {
            var valid = param.type === 'Identifier' ||
                (param.type === 'AssignmentPattern' &&
                    param.left.type === 'Identifier');
            if (!valid) {
                validator.error("Computed properties cannot use destructuring in function parameters", param.start);
            }
        });
    });
}

function isReference(node, parent) {
    if (node.type === 'MemberExpression') {
        return !node.computed && isReference(node.object, node);
    }
    if (node.type === 'Identifier') {
        // the only time we could have an identifier node without a parent is
        // if it's the entire body of a function without a block statement –
        // i.e. an arrow function expression like `a => a`
        if (!parent)
            return true;
        // TODO is this right?
        if (parent.type === 'MemberExpression' ||
            parent.type === 'MethodDefinition') {
            return parent.computed || node === parent.object;
        }
        // disregard the `bar` in `{ bar: foo }`, but keep it in `{ [bar]: foo }`
        if (parent.type === 'Property')
            return parent.computed || node === parent.value;
        // disregard the `bar` in `class Foo { bar () {...} }`
        if (parent.type === 'MethodDefinition')
            return false;
        // disregard the `bar` in `export { foo as bar }`
        if (parent.type === 'ExportSpecifier' && node !== parent.local)
            return;
        return true;
    }
}

function usesThisOrArguments(node) {
    var result = false;
    walk(node, {
        enter: function (node, parent) {
            if (result ||
                node.type === 'FunctionExpression' ||
                node.type === 'FunctionDeclaration') {
                return this.skip();
            }
            if (node.type === 'ThisExpression') {
                result = true;
            }
            if (node.type === 'Identifier' &&
                isReference(node, parent) &&
                node.name === 'arguments') {
                result = true;
            }
        }
    });
    return result;
}

function oncreate(validator, prop) {
    if (prop.value.type === 'ArrowFunctionExpression') {
        if (usesThisOrArguments(prop.value.body)) {
            validator.error("'oncreate' should be a function expression, not an arrow function expression", prop.start);
        }
    }
}

function ondestroy(validator, prop) {
    if (prop.value.type === 'ArrowFunctionExpression') {
        if (usesThisOrArguments(prop.value.body)) {
            validator.error("'ondestroy' should be a function expression, not an arrow function expression", prop.start);
        }
    }
}

function onrender(validator, prop) {
    validator.warn("'onrender' has been deprecated in favour of 'oncreate', and will cause an error in Svelte 2.x", prop.start);
    oncreate(validator, prop);
}

function onteardown(validator, prop) {
    validator.warn("'onteardown' has been deprecated in favour of 'ondestroy', and will cause an error in Svelte 2.x", prop.start);
    ondestroy(validator, prop);
}

function helpers(validator, prop) {
    if (prop.value.type !== 'ObjectExpression') {
        validator.error("The 'helpers' property must be an object literal", prop.start);
    }
    checkForDupes(validator, prop.value.properties);
    checkForComputedKeys(validator, prop.value.properties);
    prop.value.properties.forEach(function (prop) {
        if (!/FunctionExpression/.test(prop.value.type))
            return;
        var lexicalDepth = 0;
        var usesArguments = false;
        walk(prop.value.body, {
            enter: function (node) {
                if (/^Function/.test(node.type)) {
                    lexicalDepth += 1;
                }
                else if (lexicalDepth === 0) {
                    // handle special case that's caused some people confusion — using `this.get(...)` instead of passing argument
                    // TODO do the same thing for computed values?
                    if (node.type === 'CallExpression' &&
                        node.callee.type === 'MemberExpression' &&
                        node.callee.object.type === 'ThisExpression' &&
                        node.callee.property.name === 'get' &&
                        !node.callee.property.computed) {
                        validator.error("Cannot use this.get(...) \u2014 it must be passed into the helper function as an argument", node.start);
                    }
                    if (node.type === 'ThisExpression') {
                        validator.error("Helpers should be pure functions \u2014 they do not have access to the component instance and cannot use 'this'. Did you mean to put this in 'methods'?", node.start);
                    }
                    else if (node.type === 'Identifier' && node.name === 'arguments') {
                        usesArguments = true;
                    }
                }
            },
            leave: function (node) {
                if (/^Function/.test(node.type)) {
                    lexicalDepth -= 1;
                }
            }
        });
        if (prop.value.params.length === 0 && !usesArguments) {
            validator.warn("Helpers should be pure functions, with at least one argument", prop.start);
        }
    });
}

function checkForAccessors(validator, properties, label) {
    properties.forEach(function (prop) {
        if (prop.kind !== 'init') {
            validator.error(label + " cannot use getters and setters", prop.start);
        }
    });
}

var builtin = new Set(['set', 'get', 'on', 'fire', 'observe', 'destroy']);
function methods(validator, prop) {
    if (prop.value.type !== 'ObjectExpression') {
        validator.error("The 'methods' property must be an object literal", prop.start);
    }
    checkForAccessors(validator, prop.value.properties, 'Methods');
    checkForDupes(validator, prop.value.properties);
    checkForComputedKeys(validator, prop.value.properties);
    prop.value.properties.forEach(function (prop) {
        var name = getMethodName(prop.key);
        if (builtin.has(name)) {
            validator.error("Cannot overwrite built-in method '" + name + "'", prop.start);
        }
        if (prop.value.type === 'ArrowFunctionExpression') {
            if (usesThisOrArguments(prop.value.body)) {
                validator.error("Method '" + prop.key
                    .name + "' should be a function expression, not an arrow function expression", prop.start);
            }
        }
    });
}

function components(validator, prop) {
    if (prop.value.type !== 'ObjectExpression') {
        validator.error("The 'components' property must be an object literal", prop.start);
    }
    checkForDupes(validator, prop.value.properties);
    checkForComputedKeys(validator, prop.value.properties);
    prop.value.properties.forEach(function (component) {
        var name = getMethodName(component.key);
        if (name === 'state') {
            validator.error("Component constructors cannot be called 'state' due to technical limitations", component.start);
        }
        if (!/^[A-Z]/.test(name)) {
            validator.warn("Component names should be capitalised", component.start);
        }
    });
}

function events(validator, prop) {
    if (prop.value.type !== 'ObjectExpression') {
        validator.error("The 'events' property must be an object literal", prop.start);
    }
    checkForDupes(validator, prop.value.properties);
    checkForComputedKeys(validator, prop.value.properties);
}

var html = 'http://www.w3.org/1999/xhtml';
var mathml = 'http://www.w3.org/1998/Math/MathML';
var svg = 'http://www.w3.org/2000/svg';
var xlink = 'http://www.w3.org/1999/xlink';
var xml = 'http://www.w3.org/XML/1998/namespace';
var xmlns = 'http://www.w3.org/2000/xmlns';
var validNamespaces = [
    'html',
    'mathml',
    'svg',
    'xlink',
    'xml',
    'xmlns',
    html,
    mathml,
    svg,
    xlink,
    xml,
    xmlns,
];
var namespaces = { html: html, mathml: mathml, svg: svg, xlink: xlink, xml: xml, xmlns: xmlns };

// adapted from https://github.com/Glench/fuzzyset.js/blob/master/lib/fuzzyset.js
// BSD Licensed
var GRAM_SIZE_LOWER = 2;
var GRAM_SIZE_UPPER = 3;
// return an edit distance from 0 to 1
function _distance(str1, str2) {
    if (str1 === null && str2 === null)
        throw 'Trying to compare two null values';
    if (str1 === null || str2 === null)
        return 0;
    str1 = String(str1);
    str2 = String(str2);
    var distance = levenshtein(str1, str2);
    if (str1.length > str2.length) {
        return 1 - distance / str1.length;
    }
    else {
        return 1 - distance / str2.length;
    }
}
// helper functions
function levenshtein(str1, str2) {
    var current = [];
    var prev;
    var value;
    for (var i = 0; i <= str2.length; i++) {
        for (var j = 0; j <= str1.length; j++) {
            if (i && j) {
                if (str1.charAt(j - 1) === str2.charAt(i - 1)) {
                    value = prev;
                }
                else {
                    value = Math.min(current[j], current[j - 1], prev) + 1;
                }
            }
            else {
                value = i + j;
            }
            prev = current[j];
            current[j] = value;
        }
    }
    return current.pop();
}
var _nonWordRe = /[^\w, ]+/;
function _iterateGrams(value, gramSize) {
    gramSize = gramSize || 2;
    var simplified = '-' + value.toLowerCase().replace(_nonWordRe, '') + '-';
    var lenDiff = gramSize - simplified.length;
    var results = [];
    if (lenDiff > 0) {
        for (var i = 0; i < lenDiff; ++i) {
            value += '-';
        }
    }
    for (var i = 0; i < simplified.length - gramSize + 1; ++i) {
        results.push(simplified.slice(i, i + gramSize));
    }
    return results;
}
function _gramCounter(value, gramSize) {
    // return an object where key=gram, value=number of occurrences
    gramSize = gramSize || 2;
    var result = {};
    var grams = _iterateGrams(value, gramSize);
    var i = 0;
    for (i; i < grams.length; ++i) {
        if (grams[i] in result) {
            result[grams[i]] += 1;
        }
        else {
            result[grams[i]] = 1;
        }
    }
    return result;
}
function sortDescending(a, b) {
    return b[0] - a[0];
}
var FuzzySet = /** @class */ (function () {
    function FuzzySet(arr) {
        // define all the object functions and attributes
        this.exactSet = {};
        this.matchDict = {};
        this.items = {};
        // initialization
        for (var i = GRAM_SIZE_LOWER; i < GRAM_SIZE_UPPER + 1; ++i) {
            this.items[i] = [];
        }
        // add all the items to the set
        for (var i = 0; i < arr.length; ++i) {
            this.add(arr[i]);
        }
    }
    FuzzySet.prototype.add = function (value) {
        var normalizedValue = value.toLowerCase();
        if (normalizedValue in this.exactSet) {
            return false;
        }
        var i = GRAM_SIZE_LOWER;
        for (i; i < GRAM_SIZE_UPPER + 1; ++i) {
            this._add(value, i);
        }
    };
    FuzzySet.prototype._add = function (value, gramSize) {
        var normalizedValue = value.toLowerCase();
        var items = this.items[gramSize] || [];
        var index = items.length;
        items.push(0);
        var gramCounts = _gramCounter(normalizedValue, gramSize);
        var sumOfSquareGramCounts = 0;
        var gram;
        var gramCount;
        for (gram in gramCounts) {
            gramCount = gramCounts[gram];
            sumOfSquareGramCounts += Math.pow(gramCount, 2);
            if (gram in this.matchDict) {
                this.matchDict[gram].push([index, gramCount]);
            }
            else {
                this.matchDict[gram] = [[index, gramCount]];
            }
        }
        var vectorNormal = Math.sqrt(sumOfSquareGramCounts);
        items[index] = [vectorNormal, normalizedValue];
        this.items[gramSize] = items;
        this.exactSet[normalizedValue] = value;
    };
    
    FuzzySet.prototype.get = function (value) {
        var normalizedValue = value.toLowerCase();
        var result = this.exactSet[normalizedValue];
        if (result) {
            return [[1, result]];
        }
        var results = [];
        // start with high gram size and if there are no results, go to lower gram sizes
        for (var gramSize = GRAM_SIZE_UPPER; gramSize >= GRAM_SIZE_LOWER; --gramSize) {
            results = this.__get(value, gramSize);
            if (results) {
                return results;
            }
        }
        return null;
    };
    FuzzySet.prototype.__get = function (value, gramSize) {
        var normalizedValue = value.toLowerCase();
        var matches = {};
        var gramCounts = _gramCounter(normalizedValue, gramSize);
        var items = this.items[gramSize];
        var sumOfSquareGramCounts = 0;
        var gram;
        var gramCount;
        var i;
        var index;
        var otherGramCount;
        for (gram in gramCounts) {
            gramCount = gramCounts[gram];
            sumOfSquareGramCounts += Math.pow(gramCount, 2);
            if (gram in this.matchDict) {
                for (i = 0; i < this.matchDict[gram].length; ++i) {
                    index = this.matchDict[gram][i][0];
                    otherGramCount = this.matchDict[gram][i][1];
                    if (index in matches) {
                        matches[index] += gramCount * otherGramCount;
                    }
                    else {
                        matches[index] = gramCount * otherGramCount;
                    }
                }
            }
        }
        var vectorNormal = Math.sqrt(sumOfSquareGramCounts);
        var results = [];
        var matchScore;
        // build a results list of [score, str]
        for (var matchIndex in matches) {
            matchScore = matches[matchIndex];
            results.push([
                matchScore / (vectorNormal * items[matchIndex][0]),
                items[matchIndex][1],
            ]);
        }
        results.sort(sortDescending);
        var newResults = [];
        var endIndex = Math.min(50, results.length);
        // truncate somewhat arbitrarily to 50
        for (var i_1 = 0; i_1 < endIndex; ++i_1) {
            newResults.push([
                _distance(results[i_1][1], normalizedValue),
                results[i_1][1],
            ]);
        }
        results = newResults;
        results.sort(sortDescending);
        newResults = [];
        for (var i_2 = 0; i_2 < results.length; ++i_2) {
            if (results[i_2][0] == results[0][0]) {
                newResults.push([results[i_2][0], this.exactSet[results[i_2][1]]]);
            }
        }
        return newResults;
    };
    
    return FuzzySet;
}());

function fuzzymatch(name, names) {
    var set = new FuzzySet(names);
    var matches = set.get(name);
    return matches && matches[0] && matches[0][0] > 0.7 ? matches[0][1] : null;
}

var valid = new Set(validNamespaces);
function namespace(validator, prop) {
    var ns = prop.value.value;
    if (prop.value.type !== 'Literal' || typeof ns !== 'string') {
        validator.error("The 'namespace' property must be a string literal representing a valid namespace", prop.start);
    }
    if (!valid.has(ns)) {
        var match = fuzzymatch(ns, validNamespaces);
        if (match) {
            validator.error("Invalid namespace '" + ns + "' (did you mean '" + match + "'?)", prop.start);
        }
        else {
            validator.error("Invalid namespace '" + ns + "'", prop.start);
        }
    }
}

function preload(validator, prop) {
    // not sure there's anything we need to check here...
}

function props(validator, prop) {
    if (prop.value.type !== 'ArrayExpression') {
        validator.error("'props' must be an array expression, if specified", prop.value.start);
    }
    prop.value.elements.forEach(function (element) {
        if (element.type !== 'Literal' || typeof element.value !== 'string') {
            validator.error("'props' must be an array of string literals", element.start);
        }
    });
}

function tag$1(validator, prop) {
    if (prop.value.type !== 'Literal' || typeof prop.value.value !== 'string') {
        validator.error("'tag' must be a string literal", prop.value.start);
    }
    var tag = prop.value.value;
    if (!/^[a-zA-Z][a-zA-Z0-9]*-[a-zA-Z0-9-]+$/.test(tag)) {
        validator.error("tag name must be two or more words joined by the '-' character", prop.value.start);
    }
}

function transitions(validator, prop) {
    if (prop.value.type !== 'ObjectExpression') {
        validator.error("The 'transitions' property must be an object literal", prop.start);
    }
    checkForDupes(validator, prop.value.properties);
    checkForComputedKeys(validator, prop.value.properties);
    prop.value.properties.forEach(function () {
        // TODO probably some validation that can happen here...
        // checking for use of `this` etc?
    });
}

var disallowed$1 = new Set(['Literal', 'ObjectExpression', 'ArrayExpression']);
function setup(validator, prop) {
    while (prop.type === 'ParenthesizedExpression')
        prop = prop.expression;
    if (disallowed$1.has(prop.value.type)) {
        validator.error("'setup' must be a function", prop.value.start);
    }
}

function store(validator, prop) {
    // not sure there's anything we need to check here...
}

var propValidators = {
    data: data,
    computed: computed,
    oncreate: oncreate,
    ondestroy: ondestroy,
    onrender: onrender,
    onteardown: onteardown,
    helpers: helpers,
    methods: methods,
    components: components,
    events: events,
    namespace: namespace,
    preload: preload,
    props: props,
    tag: tag$1,
    transitions: transitions,
    setup: setup,
    store: store
};

var validPropList = Object.keys(propValidators);
function validateJs(validator, js) {
    js.content.body.forEach(function (node) {
        // check there are no named exports
        if (node.type === 'ExportNamedDeclaration') {
            validator.error("A component can only have a default export", node.start);
        }
        if (node.type === 'ExportDefaultDeclaration') {
            if (node.declaration.type !== 'ObjectExpression') {
                return validator.error("Default export must be an object literal", node.declaration.start);
            }
            checkForComputedKeys(validator, node.declaration.properties);
            checkForDupes(validator, node.declaration.properties);
            var props_1 = validator.properties;
            node.declaration.properties.forEach(function (prop) {
                props_1.set(getMethodName(prop.key), prop);
            });
            // Remove these checks in version 2
            if (props_1.has('oncreate') && props_1.has('onrender')) {
                validator.error('Cannot have both oncreate and onrender', props_1.get('onrender').start);
            }
            if (props_1.has('ondestroy') && props_1.has('onteardown')) {
                validator.error('Cannot have both ondestroy and onteardown', props_1.get('onteardown').start);
            }
            // ensure all exported props are valid
            node.declaration.properties.forEach(function (prop) {
                var name = getMethodName(prop.key);
                var propValidator = propValidators[name];
                if (propValidator) {
                    propValidator(validator, prop);
                }
                else {
                    var match = fuzzymatch(name, validPropList);
                    if (match) {
                        validator.error("Unexpected property '" + name + "' (did you mean '" + match + "'?)", prop.start);
                    }
                    else if (/FunctionExpression/.test(prop.value.type)) {
                        validator.error("Unexpected property '" + name + "' (did you mean to include it in 'methods'?)", prop.start);
                    }
                    else {
                        validator.error("Unexpected property '" + name + "'", prop.start);
                    }
                }
            });
            if (props_1.has('namespace')) {
                var ns = props_1.get('namespace').value.value;
                validator.namespace = namespaces[ns] || ns;
            }
            validator.defaultExport = node;
        }
    });
    ['components', 'methods', 'helpers', 'transitions'].forEach(function (key) {
        if (validator.properties.has(key)) {
            validator.properties.get(key).value.properties.forEach(function (prop) {
                validator[key].set(getMethodName(prop.key), prop.value);
            });
        }
    });
}

function flatten(node) {
    var parts = [];
    var propEnd = node.end;
    while (node.type === 'MemberExpression') {
        if (node.computed)
            return null;
        parts.unshift(node.property.name);
        node = node.object;
    }
    var propStart = node.end;
    var name = node.type === 'Identifier'
        ? node.name
        : node.type === 'ThisExpression' ? 'this' : null;
    if (!name)
        return null;
    parts.unshift(name);
    return { name: name, parts: parts, keypath: name + "[\u2702" + propStart + "-" + propEnd + "\u2702]" };
}

function list$2(items, conjunction) {
    if (conjunction === void 0) { conjunction = 'or'; }
    if (items.length === 1)
        return items[0];
    return items.slice(0, -1).join(', ') + " " + conjunction + " " + items[items.length - 1];
}

var validCalleeObjects = new Set(['this', 'event', 'console']);

var validBuiltins = new Set(['set', 'fire', 'destroy']);
function validateEventHandlerCallee(validator, attribute, refCallees) {
    if (!attribute.expression)
        return;
    var _a = attribute.expression, callee = _a.callee, start = _a.start, type = _a.type;
    if (type !== 'CallExpression') {
        validator.error("Expected a call expression", start);
    }
    var name = flatten(callee).name;
    if (validCalleeObjects.has(name) || name === 'options')
        return;
    if (name === 'refs') {
        refCallees.push(callee);
        return;
    }
    if (name === 'store' && attribute.expression.callee.type === 'MemberExpression') {
        if (!validator.options.store) {
            validator.warn('compile with `store: true` in order to call store methods', attribute.expression.start);
        }
        return;
    }
    if ((callee.type === 'Identifier' && validBuiltins.has(callee.name)) ||
        validator.methods.has(callee.name))
        return;
    var validCallees = ['this.*', 'event.*', 'options.*', 'console.*'].concat(validator.options.store ? 'store.*' : [], Array.from(validBuiltins), Array.from(validator.methods.keys()));
    var message = "'" + validator.source.slice(callee.start, callee.end) + "' is an invalid callee (should be one of " + list$2(validCallees) + ")";
    if (callee.type === 'Identifier' && validator.helpers.has(callee.name)) {
        message += ". '" + callee.name + "' exists on 'helpers', did you put it in the wrong place?";
    }
    validator.warn(message, start);
}

var svg$1 = /^(?:altGlyph|altGlyphDef|altGlyphItem|animate|animateColor|animateMotion|animateTransform|circle|clipPath|color-profile|cursor|defs|desc|discard|ellipse|feBlend|feColorMatrix|feComponentTransfer|feComposite|feConvolveMatrix|feDiffuseLighting|feDisplacementMap|feDistantLight|feDropShadow|feFlood|feFuncA|feFuncB|feFuncG|feFuncR|feGaussianBlur|feImage|feMerge|feMergeNode|feMorphology|feOffset|fePointLight|feSpecularLighting|feSpotLight|feTile|feTurbulence|filter|font|font-face|font-face-format|font-face-name|font-face-src|font-face-uri|foreignObject|g|glyph|glyphRef|hatch|hatchpath|hkern|image|line|linearGradient|marker|mask|mesh|meshgradient|meshpatch|meshrow|metadata|missing-glyph|mpath|path|pattern|polygon|polyline|radialGradient|rect|set|solidcolor|stop|switch|symbol|text|textPath|title|tref|tspan|unknown|use|view|vkern)$/;
function validateElement(validator, node, refs, refCallees, stack, elementStack) {
    var isComponent = node.name === ':Self' || node.name === ':Component' || validator.components.has(node.name);
    if (!isComponent && /^[A-Z]/.test(node.name[0])) {
        // TODO upgrade to validator.error in v2
        validator.warn(node.name + " component is not defined", node.start);
    }
    if (elementStack.length === 0 && validator.namespace !== svg && svg$1.test(node.name)) {
        validator.warn("<" + node.name + "> is an SVG element \u2013 did you forget to add { namespace: 'svg' } ?", node.start);
    }
    if (node.name === 'slot') {
        var nameAttribute = node.attributes.find(function (attribute) { return attribute.name === 'name'; });
        if (nameAttribute) {
            if (nameAttribute.value.length !== 1 || nameAttribute.value[0].type !== 'Text') {
                validator.error("<slot> name cannot be dynamic", nameAttribute.start);
            }
            var slotName = nameAttribute.value[0].data;
            if (slotName === 'default') {
                validator.error("default is a reserved word \u2014 it cannot be used as a slot name", nameAttribute.start);
            }
            // TODO should duplicate slots be disallowed? Feels like it's more likely to be a
            // bug than anything. Perhaps it should be a warning
            // if (validator.slots.has(slotName)) {
            // 	validator.error(`duplicate '${slotName}' <slot> element`, nameAttribute.start);
            // }
            // validator.slots.add(slotName);
        }
        else {
            // if (validator.slots.has('default')) {
            // 	validator.error(`duplicate default <slot> element`, node.start);
            // }
            // validator.slots.add('default');
        }
    }
    var hasIntro;
    var hasOutro;
    var hasTransition;
    node.attributes.forEach(function (attribute) {
        if (attribute.type === 'Ref') {
            if (!refs.has(attribute.name))
                refs.set(attribute.name, []);
            refs.get(attribute.name).push(node);
        }
        if (!isComponent && attribute.type === 'Binding') {
            var name = attribute.name;
            if (name === 'value') {
                if (node.name !== 'input' &&
                    node.name !== 'textarea' &&
                    node.name !== 'select') {
                    validator.error("'value' is not a valid binding on <" + node.name + "> elements", attribute.start);
                }
                checkTypeAttribute(validator, node);
            }
            else if (name === 'checked' || name === 'indeterminate') {
                if (node.name !== 'input') {
                    validator.error("'" + name + "' is not a valid binding on <" + node.name + "> elements", attribute.start);
                }
                if (checkTypeAttribute(validator, node) !== 'checkbox') {
                    validator.error("'" + name + "' binding can only be used with <input type=\"checkbox\">", attribute.start);
                }
            }
            else if (name === 'group') {
                if (node.name !== 'input') {
                    validator.error("'group' is not a valid binding on <" + node.name + "> elements", attribute.start);
                }
                var type = checkTypeAttribute(validator, node);
                if (type !== 'checkbox' && type !== 'radio') {
                    validator.error("'checked' binding can only be used with <input type=\"checkbox\"> or <input type=\"radio\">", attribute.start);
                }
            }
            else if (name === 'currentTime' ||
                name === 'duration' ||
                name === 'paused' ||
                name === 'buffered' ||
                name === 'seekable' ||
                name === 'played') {
                if (node.name !== 'audio' && node.name !== 'video') {
                    validator.error("'" + name + "' binding can only be used with <audio> or <video>", attribute.start);
                }
            }
            else {
                validator.error("'" + attribute.name + "' is not a valid binding", attribute.start);
            }
        }
        else if (attribute.type === 'EventHandler') {
            validateEventHandlerCallee(validator, attribute, refCallees);
        }
        else if (attribute.type === 'Transition') {
            if (isComponent) {
                validator.error("Transitions can only be applied to DOM elements, not components", attribute.start);
            }
            var bidi = attribute.intro && attribute.outro;
            if (hasTransition) {
                if (bidi)
                    validator.error("An element can only have one 'transition' directive", attribute.start);
                validator.error("An element cannot have both a 'transition' directive and an '" + (attribute.intro
                    ? 'in'
                    : 'out') + "' directive", attribute.start);
            }
            if ((hasIntro && attribute.intro) || (hasOutro && attribute.outro)) {
                if (bidi)
                    validator.error("An element cannot have both an '" + (hasIntro
                        ? 'in'
                        : 'out') + "' directive and a 'transition' directive", attribute.start);
                validator.error("An element can only have one '" + (hasIntro ? 'in' : 'out') + "' directive", attribute.start);
            }
            if (attribute.intro)
                hasIntro = true;
            if (attribute.outro)
                hasOutro = true;
            if (bidi)
                hasTransition = true;
            if (!validator.transitions.has(attribute.name)) {
                validator.error("Missing transition '" + attribute.name + "'", attribute.start);
            }
        }
        else if (attribute.type === 'Attribute') {
            if (attribute.name === 'value' && node.name === 'textarea') {
                if (node.children.length) {
                    validator.error("A <textarea> can have either a value attribute or (equivalently) child content, but not both", attribute.start);
                }
            }
            if (attribute.name === 'slot' && !isComponent) {
                checkSlotAttribute(validator, node, attribute, stack);
            }
        }
    });
}
function checkTypeAttribute(validator, node) {
    var attribute = node.attributes.find(function (attribute) { return attribute.name === 'type'; });
    if (!attribute)
        return null;
    if (attribute.value === true) {
        validator.error("'type' attribute must be specified", attribute.start);
    }
    if (isDynamic(attribute)) {
        validator.error("'type' attribute cannot be dynamic if input uses two-way binding", attribute.start);
    }
    return attribute.value[0].data;
}
function checkSlotAttribute(validator, node, attribute, stack) {
    if (isDynamic(attribute)) {
        validator.error("slot attribute cannot have a dynamic value", attribute.start);
    }
    var i = stack.length;
    while (i--) {
        var parent = stack[i];
        if (parent.type === 'Element') {
            // if we're inside a component or a custom element, gravy
            if (parent.name === ':Self' || parent.name === ':Component' || validator.components.has(parent.name))
                return;
            if (/-/.test(parent.name))
                return;
        }
        if (parent.type === 'IfBlock' || parent.type === 'EachBlock') {
            var message = "Cannot place slotted elements inside an " + (parent.type === 'IfBlock' ? 'if' : 'each') + "-block";
            validator.error(message, attribute.start);
        }
    }
    validator.error("Element with a slot='...' attribute must be a descendant of a component or custom element", attribute.start);
}
function isDynamic(attribute) {
    return attribute.value.length > 1 || attribute.value[0].type !== 'Text';
}

var validBindings = [
    'innerWidth',
    'innerHeight',
    'outerWidth',
    'outerHeight',
    'scrollX',
    'scrollY',
    'online'
];
function validateWindow(validator, node, refs, refCallees) {
    node.attributes.forEach(function (attribute) {
        if (attribute.type === 'Binding') {
            if (attribute.value.type !== 'Identifier') {
                var parts = flatten(attribute.value).parts;
                validator.error("Bindings on <:Window/> must be to top-level properties, e.g. '" + parts[parts.length - 1] + "' rather than '" + parts.join('.') + "'", attribute.value.start);
            }
            if (!~validBindings.indexOf(attribute.name)) {
                var match = attribute.name === 'width'
                    ? 'innerWidth'
                    : attribute.name === 'height'
                        ? 'innerHeight'
                        : fuzzymatch(attribute.name, validBindings);
                var message = "'" + attribute.name + "' is not a valid binding on <:Window>";
                if (match) {
                    validator.error(message + " (did you mean '" + match + "'?)", attribute.start);
                }
                else {
                    validator.error(message + " \u2014 valid bindings are " + list$2(validBindings), attribute.start);
                }
            }
        }
        else if (attribute.type === 'EventHandler') {
            validateEventHandlerCallee(validator, attribute, refCallees);
        }
    });
}

function validateHead(validator, node, refs, refCallees) {
    if (node.attributes.length) {
        validator.error("<:Head> should not have any attributes or directives", node.start);
    }
}

function getStaticAttributeValue(node, name) {
    var attribute = node.attributes.find(function (attr) { return attr.name.toLowerCase() === name; });
    if (!attribute)
        return null;
    if (attribute.value === true)
        return true;
    if (attribute.value.length === 0)
        return '';
    if (attribute.value.length === 1 && attribute.value[0].type === 'Text') {
        return attribute.value[0].data;
    }
    return null;
}

var ariaAttributes = 'activedescendant atomic autocomplete busy checked controls current describedby disabled dropeffect expanded flowto grabbed haspopup hidden invalid label labelledby level live multiline multiselectable orientation owns posinset pressed readonly relevant required selected setsize sort valuemax valuemin valuenow valuetext'.split(' ');
var ariaAttributeSet = new Set(ariaAttributes);
var ariaRoles = 'alert alertdialog application article banner button checkbox columnheader combobox command complementary composite contentinfo definition dialog directory document form grid gridcell group heading img input landmark link list listbox listitem log main marquee math menu menubar menuitem menuitemcheckbox menuitemradio navigation note option presentation progressbar radio radiogroup range region roletype row rowgroup rowheader scrollbar search section sectionhead select separator slider spinbutton status structure tab tablist tabpanel textbox timer toolbar tooltip tree treegrid treeitem widget window'.split(' ');
var ariaRoleSet = new Set(ariaRoles);
var invisibleElements = new Set(['meta', 'html', 'script', 'style']);
function a11y(validator, node, elementStack) {
    if (node.type === 'Text') {
        // accessible-emoji
        return;
    }
    if (node.type !== 'Element')
        return;
    var attributeMap = new Map();
    node.attributes.forEach(function (attribute) {
        var name = attribute.name.toLowerCase();
        // aria-props
        if (name.startsWith('aria-')) {
            if (invisibleElements.has(node.name)) {
                // aria-unsupported-elements
                validator.warn("A11y: <" + node.name + "> should not have aria-* attributes", attribute.start);
            }
            var type = name.slice(5);
            if (!ariaAttributeSet.has(type)) {
                var match = fuzzymatch(type, ariaAttributes);
                var message = "A11y: Unknown aria attribute 'aria-" + type + "'";
                if (match)
                    message += " (did you mean '" + match + "'?)";
                validator.warn(message, attribute.start);
            }
        }
        // aria-role
        if (name === 'role') {
            if (invisibleElements.has(node.name)) {
                // aria-unsupported-elements
                validator.warn("A11y: <" + node.name + "> should not have role attribute", attribute.start);
            }
            var value = getStaticAttributeValue(node, 'role');
            if (value && !ariaRoleSet.has(value)) {
                var match = fuzzymatch(value, ariaRoles);
                var message = "A11y: Unknown role '" + value + "'";
                if (match)
                    message += " (did you mean '" + match + "'?)";
                validator.warn(message, attribute.start);
            }
        }
        // no-access-key
        if (name === 'accesskey') {
            validator.warn("A11y: Avoid using accesskey", attribute.start);
        }
        // no-autofocus
        if (name === 'autofocus') {
            validator.warn("A11y: Avoid using autofocus", attribute.start);
        }
        // scope
        if (name === 'scope' && node.name !== 'th') {
            validator.warn("A11y: The scope attribute should only be used with <th> elements", attribute.start);
        }
        // tabindex-no-positive
        if (name === 'tabindex') {
            var value = getStaticAttributeValue(node, 'tabindex');
            if (!isNaN(value) && +value > 0) {
                validator.warn("A11y: avoid tabindex values above zero", attribute.start);
            }
        }
        attributeMap.set(attribute.name, attribute);
    });
    function shouldHaveAttribute(attributes, name) {
        if (name === void 0) { name = node.name; }
        if (attributes.length === 0 || !attributes.some(function (name) { return attributeMap.has(name); })) {
            var article = /^[aeiou]/.test(attributes[0]) ? 'an' : 'a';
            var sequence = attributes.length > 1 ?
                attributes.slice(0, -1).join(', ') + (" or " + attributes[attributes.length - 1]) :
                attributes[0];
            validator.warn("A11y: <" + name + "> element should have " + article + " " + sequence + " attribute", node.start);
        }
    }
    function shouldHaveContent() {
        if (node.children.length === 0) {
            validator.warn("A11y: <" + node.name + "> element should have child content", node.start);
        }
    }
    if (node.name === 'a') {
        // anchor-is-valid
        var href = attributeMap.get('href');
        if (attributeMap.has('href')) {
            var value = getStaticAttributeValue(node, 'href');
            if (value === '' || value === '#') {
                validator.warn("A11y: '" + value + "' is not a valid href attribute", href.start);
            }
        }
        else {
            validator.warn("A11y: <a> element should have an href attribute", node.start);
        }
        // anchor-has-content
        shouldHaveContent();
    }
    if (node.name === 'img')
        shouldHaveAttribute(['alt']);
    if (node.name === 'area')
        shouldHaveAttribute(['alt', 'aria-label', 'aria-labelledby']);
    if (node.name === 'object')
        shouldHaveAttribute(['title', 'aria-label', 'aria-labelledby']);
    if (node.name === 'input' && getStaticAttributeValue(node, 'type') === 'image') {
        shouldHaveAttribute(['alt', 'aria-label', 'aria-labelledby'], 'input type="image"');
    }
    // heading-has-content
    if (/^h[1-6]$/.test(node.name)) {
        shouldHaveContent();
        if (attributeMap.has('aria-hidden')) {
            validator.warn("A11y: <" + node.name + "> element should not be hidden", attributeMap.get('aria-hidden').start);
        }
    }
    // iframe-has-title
    if (node.name === 'iframe') {
        shouldHaveAttribute(['title']);
    }
    // html-has-lang
    if (node.name === 'html') {
        shouldHaveAttribute(['lang']);
    }
    // no-distracting-elements
    if (node.name === 'marquee' || node.name === 'blink') {
        validator.warn("A11y: Avoid <" + node.name + "> elements", node.start);
    }
    if (node.name === 'figcaption') {
        var parent = elementStack[elementStack.length - 1];
        if (parent) {
            if (parent.name !== 'figure') {
                validator.warn("A11y: <figcaption> must be an immediate child of <figure>", node.start);
            }
            else {
                var children = parent.children.filter(function (node) {
                    if (node.type === 'Comment')
                        return false;
                    if (node.type === 'Text')
                        return /\S/.test(node.data);
                    return true;
                });
                var index = children.indexOf(node);
                if (index !== 0 && index !== children.length - 1) {
                    validator.warn("A11y: <figcaption> must be first or last child of <figure>", node.start);
                }
            }
        }
    }
}

var meta = new Map([
    [':Window', validateWindow],
    [':Head', validateHead]
]);
function validateHtml(validator, html) {
    var refs = new Map();
    var refCallees = [];
    var stack = [];
    var elementStack = [];
    function visit(node) {
        a11y(validator, node, elementStack);
        if (node.type === 'Element') {
            if (meta.has(node.name)) {
                return meta.get(node.name)(validator, node, refs, refCallees);
            }
            validateElement(validator, node, refs, refCallees, stack, elementStack);
        }
        else if (node.type === 'EachBlock') {
            if (validator.helpers.has(node.context)) {
                var c = node.expression.end;
                // find start of context
                while (/\s/.test(validator.source[c]))
                    c += 1;
                c += 2;
                while (/\s/.test(validator.source[c]))
                    c += 1;
                validator.warn("Context clashes with a helper. Rename one or the other to eliminate any ambiguity", c);
            }
        }
        if (node.children) {
            if (node.type === 'Element')
                elementStack.push(node);
            stack.push(node);
            node.children.forEach(visit);
            stack.pop();
            if (node.type === 'Element')
                elementStack.pop();
        }
        if (node["else"]) {
            visit(node["else"]);
        }
    }
    html.children.forEach(visit);
    refCallees.forEach(function (callee) {
        var parts = flatten(callee).parts;
        var ref = parts[1];
        if (refs.has(ref)) {
            // TODO check method is valid, e.g. `audio.stop()` should be `audio.pause()`
        }
        else {
            var match = fuzzymatch(ref, Array.from(refs.keys()));
            var message = "'refs." + ref + "' does not exist";
            if (match)
                message += " (did you mean 'refs." + match + "'?)";
            validator.error(message, callee.start);
        }
    });
}

var ValidationError = /** @class */ (function (_super) {
    __extends(ValidationError, _super);
    function ValidationError(message, template, index, filename) {
        var _this = _super.call(this, message, template, index, filename) || this;
        _this.name = 'ValidationError';
        return _this;
    }
    return ValidationError;
}(CompileError));
var Validator = /** @class */ (function () {
    function Validator(parsed, source, options) {
        this.source = source;
        this.filename = options.filename;
        this.onwarn = options.onwarn;
        this.options = options;
        this.namespace = null;
        this.defaultExport = null;
        this.properties = new Map();
        this.components = new Map();
        this.methods = new Map();
        this.helpers = new Map();
        this.transitions = new Map();
        this.slots = new Set();
    }
    Validator.prototype.error = function (message, pos) {
        throw new ValidationError(message, this.source, pos, this.filename);
    };
    Validator.prototype.warn = function (message, pos) {
        if (!this.locator)
            this.locator = getLocator(this.source);
        var _a = this.locator(pos), line = _a.line, column = _a.column;
        var frame = getCodeFrame(this.source, line, column);
        this.onwarn({
            message: message,
            frame: frame,
            loc: { line: line + 1, column: column },
            pos: pos,
            filename: this.filename,
            toString: function () { return message + " (" + (line + 1) + ":" + column + ")\n" + frame; }
        });
    };
    return Validator;
}());
function validate(parsed, source, stylesheet, options) {
    var onwarn = options.onwarn, onerror = options.onerror, name = options.name, filename = options.filename, store = options.store;
    try {
        if (name && !/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name)) {
            var error = new Error("options.name must be a valid identifier (got '" + name + "')");
            throw error;
        }
        if (name && !/^[A-Z]/.test(name)) {
            var message_1 = "options.name should be capitalised";
            onwarn({
                message: message_1,
                filename: filename,
                toString: function () { return message_1; }
            });
        }
        var validator = new Validator(parsed, source, {
            onwarn: onwarn,
            name: name,
            filename: filename,
            store: store
        });
        if (parsed.js) {
            validateJs(validator, parsed.js);
        }
        if (parsed.css) {
            stylesheet.validate(validator);
        }
        if (parsed.html) {
            validateHtml(validator, parsed.html);
        }
    }
    catch (err) {
        if (onerror) {
            onerror(err);
        }
        else {
            throw err;
        }
    }
}

var charToInteger = {};
var integerToChar = {};

'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split( '' ).forEach( function ( char, i ) {
	charToInteger[ char ] = i;
	integerToChar[ i ] = char;
});



function encode ( value ) {
	var result;

	if ( typeof value === 'number' ) {
		result = encodeInteger( value );
	} else {
		result = '';
		for ( var i = 0; i < value.length; i += 1 ) {
			result += encodeInteger( value[i] );
		}
	}

	return result;
}

function encodeInteger ( num ) {
	var result = '';

	if ( num < 0 ) {
		num = ( -num << 1 ) | 1;
	} else {
		num <<= 1;
	}

	do {
		var clamped = num & 31;
		num >>= 5;

		if ( num > 0 ) {
			clamped |= 32;
		}

		result += integerToChar[ clamped ];
	} while ( num > 0 );

	return result;
}

function Chunk ( start, end, content ) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties( this, {
		previous: { writable: true, value: null },
		next: { writable: true, value: null }
	});
}

Chunk.prototype = {
	appendLeft: function appendLeft ( content ) {
		this.outro += content;
	},

	appendRight: function appendRight ( content ) {
		this.intro = this.intro + content;
	},

	clone: function clone () {
		var chunk = new Chunk( this.start, this.end, this.original );

		chunk.intro = this.intro;
		chunk.outro = this.outro;
		chunk.content = this.content;
		chunk.storeName = this.storeName;
		chunk.edited = this.edited;

		return chunk;
	},

	contains: function contains ( index ) {
		return this.start < index && index < this.end;
	},

	eachNext: function eachNext ( fn ) {
		var chunk = this;
		while ( chunk ) {
			fn( chunk );
			chunk = chunk.next;
		}
	},

	eachPrevious: function eachPrevious ( fn ) {
		var chunk = this;
		while ( chunk ) {
			fn( chunk );
			chunk = chunk.previous;
		}
	},

	edit: function edit ( content, storeName, contentOnly ) {
		this.content = content;
		if ( !contentOnly ) {
			this.intro = '';
			this.outro = '';
		}
		this.storeName = storeName;

		this.edited = true;

		return this;
	},

	prependLeft: function prependLeft ( content ) {
		this.outro = content + this.outro;
	},

	prependRight: function prependRight ( content ) {
		this.intro = content + this.intro;
	},

	split: function split ( index ) {
		var sliceIndex = index - this.start;

		var originalBefore = this.original.slice( 0, sliceIndex );
		var originalAfter = this.original.slice( sliceIndex );

		this.original = originalBefore;

		var newChunk = new Chunk( index, this.end, originalAfter );
		newChunk.outro = this.outro;
		this.outro = '';

		this.end = index;

		if ( this.edited ) {
			// TODO is this block necessary?...
			newChunk.edit( '', false );
			this.content = '';
		} else {
			this.content = originalBefore;
		}

		newChunk.next = this.next;
		if ( newChunk.next ) { newChunk.next.previous = newChunk; }
		newChunk.previous = this;
		this.next = newChunk;

		return newChunk;
	},

	toString: function toString () {
		return this.intro + this.content + this.outro;
	},

	trimEnd: function trimEnd ( rx ) {
		this.outro = this.outro.replace( rx, '' );
		if ( this.outro.length ) { return true; }

		var trimmed = this.content.replace( rx, '' );

		if ( trimmed.length ) {
			if ( trimmed !== this.content ) {
				this.split( this.start + trimmed.length ).edit( '', false );
			}

			return true;
		} else {
			this.edit( '', false );

			this.intro = this.intro.replace( rx, '' );
			if ( this.intro.length ) { return true; }
		}
	},

	trimStart: function trimStart ( rx ) {
		this.intro = this.intro.replace( rx, '' );
		if ( this.intro.length ) { return true; }

		var trimmed = this.content.replace( rx, '' );

		if ( trimmed.length ) {
			if ( trimmed !== this.content ) {
				this.split( this.end - trimmed.length );
				this.edit( '', false );
			}

			return true;
		} else {
			this.edit( '', false );

			this.outro = this.outro.replace( rx, '' );
			if ( this.outro.length ) { return true; }
		}
	}
};

var _btoa;

if ( typeof window !== 'undefined' && typeof window.btoa === 'function' ) {
	_btoa = window.btoa;
} else if ( typeof Buffer === 'function' ) {
	_btoa = function (str) { return new Buffer( str ).toString( 'base64' ); };
} else {
	_btoa = function () {
		throw new Error( 'Unsupported environment: `window.btoa` or `Buffer` should be supported.' );
	};
}

var btoa = _btoa;

function SourceMap ( properties ) {
	this.version = 3;

	this.file           = properties.file;
	this.sources        = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names          = properties.names;
	this.mappings       = properties.mappings;
}

SourceMap.prototype = {
	toString: function toString () {
		return JSON.stringify( this );
	},

	toUrl: function toUrl () {
		return 'data:application/json;charset=utf-8;base64,' + btoa( this.toString() );
	}
};

function guessIndent ( code ) {
	var lines = code.split( '\n' );

	var tabbed = lines.filter( function (line) { return /^\t+/.test( line ); } );
	var spaced = lines.filter( function (line) { return /^ {2,}/.test( line ); } );

	if ( tabbed.length === 0 && spaced.length === 0 ) {
		return null;
	}

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if ( tabbed.length >= spaced.length ) {
		return '\t';
	}

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce( function ( previous, current ) {
		var numSpaces = /^ +/.exec( current )[0].length;
		return Math.min( numSpaces, previous );
	}, Infinity );

	return new Array( min + 1 ).join( ' ' );
}

function getRelativePath ( from, to ) {
	var fromParts = from.split( /[\/\\]/ );
	var toParts = to.split( /[\/\\]/ );

	fromParts.pop(); // get dirname

	while ( fromParts[0] === toParts[0] ) {
		fromParts.shift();
		toParts.shift();
	}

	if ( fromParts.length ) {
		var i = fromParts.length;
		while ( i-- ) { fromParts[i] = '..'; }
	}

	return fromParts.concat( toParts ).join( '/' );
}

var toString$1$1 = Object.prototype.toString;

function isObject ( thing ) {
	return toString$1$1.call( thing ) === '[object Object]';
}

function getLocator$1 ( source ) {
	var originalLines = source.split( '\n' );

	var start = 0;
	var lineRanges = originalLines.map( function ( line, i ) {
		var end = start + line.length + 1;
		var range = { start: start, end: end, line: i };

		start = end;
		return range;
	});

	var i = 0;

	function rangeContains ( range, index ) {
		return range.start <= index && index < range.end;
	}

	function getLocation ( range, index ) {
		return { line: range.line, column: index - range.start };
	}

	return function locate ( index ) {
		var range = lineRanges[i];

		var d = index >= range.end ? 1 : -1;

		while ( range ) {
			if ( rangeContains( range, index ) ) { return getLocation( range, index ); }

			i += d;
			range = lineRanges[i];
		}
	};
}

function Mappings ( hires ) {
	var this$1 = this;

	var offsets = {
		generatedCodeColumn: 0,
		sourceIndex: 0,
		sourceCodeLine: 0,
		sourceCodeColumn: 0,
		sourceCodeName: 0
	};

	var generatedCodeLine = 0;
	var generatedCodeColumn = 0;

	this.raw = [];
	var rawSegments = this.raw[ generatedCodeLine ] = [];

	var pending = null;

	this.addEdit = function ( sourceIndex, content, original, loc, nameIndex ) {
		if ( content.length ) {
			rawSegments.push([
				generatedCodeColumn,
				sourceIndex,
				loc.line,
				loc.column,
				nameIndex ]);
		} else if ( pending ) {
			rawSegments.push( pending );
		}

		this$1.advance( content );
		pending = null;
	};

	this.addUneditedChunk = function ( sourceIndex, chunk, original, loc, sourcemapLocations ) {
		var originalCharIndex = chunk.start;
		var first = true;

		while ( originalCharIndex < chunk.end ) {
			if ( hires || first || sourcemapLocations[ originalCharIndex ] ) {
				rawSegments.push([
					generatedCodeColumn,
					sourceIndex,
					loc.line,
					loc.column,
					-1
				]);
			}

			if ( original[ originalCharIndex ] === '\n' ) {
				loc.line += 1;
				loc.column = 0;
				generatedCodeLine += 1;
				this$1.raw[ generatedCodeLine ] = rawSegments = [];
				generatedCodeColumn = 0;
			} else {
				loc.column += 1;
				generatedCodeColumn += 1;
			}

			originalCharIndex += 1;
			first = false;
		}

		pending = [
			generatedCodeColumn,
			sourceIndex,
			loc.line,
			loc.column,
			-1 ];
	};

	this.advance = function (str) {
		if ( !str ) { return; }

		var lines = str.split( '\n' );
		var lastLine = lines.pop();

		if ( lines.length ) {
			generatedCodeLine += lines.length;
			this$1.raw[ generatedCodeLine ] = rawSegments = [];
			generatedCodeColumn = lastLine.length;
		} else {
			generatedCodeColumn += lastLine.length;
		}
	};

	this.encode = function () {
		return this$1.raw.map( function (segments) {
			var generatedCodeColumn = 0;

			return segments.map( function (segment) {
				var arr = [
					segment[0] - generatedCodeColumn,
					segment[1] - offsets.sourceIndex,
					segment[2] - offsets.sourceCodeLine,
					segment[3] - offsets.sourceCodeColumn
				];

				generatedCodeColumn = segment[0];
				offsets.sourceIndex = segment[1];
				offsets.sourceCodeLine = segment[2];
				offsets.sourceCodeColumn = segment[3];

				if ( ~segment[4] ) {
					arr.push( segment[4] - offsets.sourceCodeName );
					offsets.sourceCodeName = segment[4];
				}

				return encode( arr );
			}).join( ',' );
		}).join( ';' );
	};
}

var Stats = function Stats () {
	Object.defineProperties( this, {
		startTimes: { value: {} }
	});
};

Stats.prototype.time = function time ( label ) {
	this.startTimes[ label ] = process.hrtime();
};

Stats.prototype.timeEnd = function timeEnd ( label ) {
	var elapsed = process.hrtime( this.startTimes[ label ] );

	if ( !this[ label ] ) { this[ label ] = 0; }
	this[ label ] += elapsed[0] * 1e3 + elapsed[1] * 1e-6;
};

var warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false
};

function MagicString$1 ( string, options ) {
	if ( options === void 0 ) options = {};

	var chunk = new Chunk( 0, string.length, string );

	Object.defineProperties( this, {
		original:              { writable: true, value: string },
		outro:                 { writable: true, value: '' },
		intro:                 { writable: true, value: '' },
		firstChunk:            { writable: true, value: chunk },
		lastChunk:             { writable: true, value: chunk },
		lastSearchedChunk:     { writable: true, value: chunk },
		byStart:               { writable: true, value: {} },
		byEnd:                 { writable: true, value: {} },
		filename:              { writable: true, value: options.filename },
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges },
		sourcemapLocations:    { writable: true, value: {} },
		storedNames:           { writable: true, value: {} },
		indentStr:             { writable: true, value: guessIndent( string ) }
	});

	this.byStart[ 0 ] = chunk;
	this.byEnd[ string.length ] = chunk;
}

MagicString$1.prototype = {
	addSourcemapLocation: function addSourcemapLocation ( char ) {
		this.sourcemapLocations[ char ] = true;
	},

	append: function append ( content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }

		this.outro += content;
		return this;
	},

	appendLeft: function appendLeft ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byEnd[ index ];

		if ( chunk ) {
			chunk.appendLeft( content );
		} else {
			this.intro += content;
		}

		return this;
	},

	appendRight: function appendRight ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byStart[ index ];

		if ( chunk ) {
			chunk.appendRight( content );
		} else {
			this.outro += content;
		}

		return this;
	},

	clone: function clone () {
		var cloned = new MagicString$1( this.original, { filename: this.filename });

		var originalChunk = this.firstChunk;
		var clonedChunk = cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone();

		while ( originalChunk ) {
			cloned.byStart[ clonedChunk.start ] = clonedChunk;
			cloned.byEnd[ clonedChunk.end ] = clonedChunk;

			var nextOriginalChunk = originalChunk.next;
			var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

			if ( nextClonedChunk ) {
				clonedChunk.next = nextClonedChunk;
				nextClonedChunk.previous = clonedChunk;

				clonedChunk = nextClonedChunk;
			}

			originalChunk = nextOriginalChunk;
		}

		cloned.lastChunk = clonedChunk;

		if ( this.indentExclusionRanges ) {
			cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
		}

		Object.keys( this.sourcemapLocations ).forEach( function (loc) {
			cloned.sourcemapLocations[ loc ] = true;
		});

		return cloned;
	},

	generateMap: function generateMap ( options ) {
		var this$1 = this;

		options = options || {};

		var sourceIndex = 0;
		var names = Object.keys( this.storedNames );
		var mappings = new Mappings( options.hires );

		var locate = getLocator$1( this.original );

		if ( this.intro ) {
			mappings.advance( this.intro );
		}

		this.firstChunk.eachNext( function (chunk) {
			var loc = locate( chunk.start );

			if ( chunk.intro.length ) { mappings.advance( chunk.intro ); }

			if ( chunk.edited ) {
				mappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );
			} else {
				mappings.addUneditedChunk( sourceIndex, chunk, this$1.original, loc, this$1.sourcemapLocations );
			}

			if ( chunk.outro.length ) { mappings.advance( chunk.outro ); }
		});

		var map = new SourceMap({
			file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
			sources: [ options.source ? getRelativePath( options.file || '', options.source ) : null ],
			sourcesContent: options.includeContent ? [ this.original ] : [ null ],
			names: names,
			mappings: mappings.encode()
		});
		return map;
	},

	getIndentString: function getIndentString () {
		return this.indentStr === null ? '\t' : this.indentStr;
	},

	indent: function indent ( indentStr, options ) {
		var this$1 = this;

		var pattern = /^[^\r\n]/gm;

		if ( isObject( indentStr ) ) {
			options = indentStr;
			indentStr = undefined;
		}

		indentStr = indentStr !== undefined ? indentStr : ( this.indentStr || '\t' );

		if ( indentStr === '' ) { return this; } // noop

		options = options || {};

		// Process exclusion ranges
		var isExcluded = {};

		if ( options.exclude ) {
			var exclusions = typeof options.exclude[0] === 'number' ? [ options.exclude ] : options.exclude;
			exclusions.forEach( function (exclusion) {
				for ( var i = exclusion[0]; i < exclusion[1]; i += 1 ) {
					isExcluded[i] = true;
				}
			});
		}

		var shouldIndentNextCharacter = options.indentStart !== false;
		var replacer = function (match) {
			if ( shouldIndentNextCharacter ) { return ("" + indentStr + match); }
			shouldIndentNextCharacter = true;
			return match;
		};

		this.intro = this.intro.replace( pattern, replacer );

		var charIndex = 0;

		var chunk = this.firstChunk;

		while ( chunk ) {
			var end = chunk.end;

			if ( chunk.edited ) {
				if ( !isExcluded[ charIndex ] ) {
					chunk.content = chunk.content.replace( pattern, replacer );

					if ( chunk.content.length ) {
						shouldIndentNextCharacter = chunk.content[ chunk.content.length - 1 ] === '\n';
					}
				}
			} else {
				charIndex = chunk.start;

				while ( charIndex < end ) {
					if ( !isExcluded[ charIndex ] ) {
						var char = this$1.original[ charIndex ];

						if ( char === '\n' ) {
							shouldIndentNextCharacter = true;
						} else if ( char !== '\r' && shouldIndentNextCharacter ) {
							shouldIndentNextCharacter = false;

							if ( charIndex === chunk.start ) {
								chunk.prependRight( indentStr );
							} else {
								this$1._splitChunk( chunk, charIndex );
								chunk = chunk.next;
								chunk.prependRight( indentStr );
							}
						}
					}

					charIndex += 1;
				}
			}

			charIndex = chunk.end;
			chunk = chunk.next;
		}

		this.outro = this.outro.replace( pattern, replacer );

		return this;
	},

	insert: function insert () {
		throw new Error( 'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)' );
	},

	insertLeft: function insertLeft ( index, content ) {
		if ( !warned.insertLeft ) {
			console.warn( 'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead' ); // eslint-disable-line no-console
			warned.insertLeft = true;
		}

		return this.appendLeft( index, content );
	},

	insertRight: function insertRight ( index, content ) {
		if ( !warned.insertRight ) {
			console.warn( 'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead' ); // eslint-disable-line no-console
			warned.insertRight = true;
		}

		return this.prependRight( index, content );
	},

	move: function move ( start, end, index ) {
		if ( index >= start && index <= end ) { throw new Error( 'Cannot move a selection inside itself' ); }

		this._split( start );
		this._split( end );
		this._split( index );

		var first = this.byStart[ start ];
		var last = this.byEnd[ end ];

		var oldLeft = first.previous;
		var oldRight = last.next;

		var newRight = this.byStart[ index ];
		if ( !newRight && last === this.lastChunk ) { return this; }
		var newLeft = newRight ? newRight.previous : this.lastChunk;

		if ( oldLeft ) { oldLeft.next = oldRight; }
		if ( oldRight ) { oldRight.previous = oldLeft; }

		if ( newLeft ) { newLeft.next = first; }
		if ( newRight ) { newRight.previous = last; }

		if ( !first.previous ) { this.firstChunk = last.next; }
		if ( !last.next ) {
			this.lastChunk = first.previous;
			this.lastChunk.next = null;
		}

		first.previous = newLeft;
		last.next = newRight || null;

		if ( !newLeft ) { this.firstChunk = first; }
		if ( !newRight ) { this.lastChunk = last; }

		return this;
	},

	overwrite: function overwrite ( start, end, content, options ) {
		var this$1 = this;

		if ( typeof content !== 'string' ) { throw new TypeError( 'replacement content must be a string' ); }

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		if ( end > this.original.length ) { throw new Error( 'end is out of bounds' ); }
		if ( start === end ) { throw new Error( 'Cannot overwrite a zero-length range – use appendLeft or prependRight instead' ); }

		this._split( start );
		this._split( end );

		if ( options === true ) {
			if ( !warned.storeName ) {
				console.warn( 'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string' ); // eslint-disable-line no-console
				warned.storeName = true;
			}

			options = { storeName: true };
		}
		var storeName = options !== undefined ? options.storeName : false;
		var contentOnly = options !== undefined ? options.contentOnly : false;

		if ( storeName ) {
			var original = this.original.slice( start, end );
			this.storedNames[ original ] = true;
		}

		var first = this.byStart[ start ];
		var last = this.byEnd[ end ];

		if ( first ) {
			if ( end > first.end && first.next !== this.byStart[ first.end ] ) {
				throw new Error( 'Cannot overwrite across a split point' );
			}

			first.edit( content, storeName, contentOnly );

			if ( first !== last ) {
				var chunk = first.next;
				while ( chunk !== last ) {
					chunk.edit( '', false );
					chunk = chunk.next;
				}

				chunk.edit( '', false );
			}
		}

		else {
			// must be inserting at the end
			var newChunk = new Chunk( start, end, '' ).edit( content, storeName );

			// TODO last chunk in the array may not be the last chunk, if it's moved...
			last.next = newChunk;
			newChunk.previous = last;
		}

		return this;
	},

	prepend: function prepend ( content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'outro content must be a string' ); }

		this.intro = content + this.intro;
		return this;
	},

	prependLeft: function prependLeft ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byEnd[ index ];

		if ( chunk ) {
			chunk.prependLeft( content );
		} else {
			this.intro = content + this.intro;
		}

		return this;
	},

	prependRight: function prependRight ( index, content ) {
		if ( typeof content !== 'string' ) { throw new TypeError( 'inserted content must be a string' ); }

		this._split( index );

		var chunk = this.byStart[ index ];

		if ( chunk ) {
			chunk.prependRight( content );
		} else {
			this.outro = content + this.outro;
		}

		return this;
	},

	remove: function remove ( start, end ) {
		var this$1 = this;

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		if ( start === end ) { return this; }

		if ( start < 0 || end > this.original.length ) { throw new Error( 'Character is out of bounds' ); }
		if ( start > end ) { throw new Error( 'end must be greater than start' ); }

		this._split( start );
		this._split( end );

		var chunk = this.byStart[ start ];

		while ( chunk ) {
			chunk.intro = '';
			chunk.outro = '';
			chunk.edit( '' );

			chunk = end > chunk.end ? this$1.byStart[ chunk.end ] : null;
		}

		return this;
	},

	slice: function slice ( start, end ) {
		var this$1 = this;
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

		while ( start < 0 ) { start += this$1.original.length; }
		while ( end < 0 ) { end += this$1.original.length; }

		var result = '';

		// find start chunk
		var chunk = this.firstChunk;
		while ( chunk && ( chunk.start > start || chunk.end <= start ) ) {

			// found end chunk before start
			if ( chunk.start < end && chunk.end >= end ) {
				return result;
			}

			chunk = chunk.next;
		}

		if ( chunk && chunk.edited && chunk.start !== start ) { throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); }

		var startChunk = chunk;
		while ( chunk ) {
			if ( chunk.intro && ( startChunk !== chunk || chunk.start === start ) ) {
				result += chunk.intro;
			}

			var containsEnd = chunk.start < end && chunk.end >= end;
			if ( containsEnd && chunk.edited && chunk.end !== end ) { throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); }

			var sliceStart = startChunk === chunk ? start - chunk.start : 0;
			var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

			result += chunk.content.slice( sliceStart, sliceEnd );

			if ( chunk.outro && ( !containsEnd || chunk.end === end ) ) {
				result += chunk.outro;
			}

			if ( containsEnd ) {
				break;
			}

			chunk = chunk.next;
		}

		return result;
	},

	// TODO deprecate this? not really very useful
	snip: function snip ( start, end ) {
		var clone = this.clone();
		clone.remove( 0, start );
		clone.remove( end, clone.original.length );

		return clone;
	},

	_split: function _split ( index ) {
		var this$1 = this;

		if ( this.byStart[ index ] || this.byEnd[ index ] ) { return; }

		var chunk = this.lastSearchedChunk;
		var searchForward = index > chunk.end;

		while ( true ) {
			if ( chunk.contains( index ) ) { return this$1._splitChunk( chunk, index ); }

			chunk = searchForward ?
				this$1.byStart[ chunk.end ] :
				this$1.byEnd[ chunk.start ];
		}
	},

	_splitChunk: function _splitChunk ( chunk, index ) {
		if ( chunk.edited && chunk.content.length ) { // zero-length edited chunks are a special case (overlapping replacements)
			var loc = getLocator$1( this.original )( index );
			throw new Error( ("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")") );
		}

		var newChunk = chunk.split( index );

		this.byEnd[ index ] = chunk;
		this.byStart[ index ] = newChunk;
		this.byEnd[ newChunk.end ] = newChunk;

		if ( chunk === this.lastChunk ) { this.lastChunk = newChunk; }

		this.lastSearchedChunk = chunk;
		return true;
	},

	toString: function toString () {
		var str = this.intro;

		var chunk = this.firstChunk;
		while ( chunk ) {
			str += chunk.toString();
			chunk = chunk.next;
		}

		return str + this.outro;
	},

	trimLines: function trimLines () {
		return this.trim('[\\r\\n]');
	},

	trim: function trim ( charType ) {
		return this.trimStart( charType ).trimEnd( charType );
	},

	trimEnd: function trimEnd ( charType ) {
		var this$1 = this;

		var rx = new RegExp( ( charType || '\\s' ) + '+$' );

		this.outro = this.outro.replace( rx, '' );
		if ( this.outro.length ) { return this; }

		var chunk = this.lastChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimEnd( rx );

			// if chunk was trimmed, we have a new lastChunk
			if ( chunk.end !== end ) {
				if ( this$1.lastChunk === chunk ) {
					this$1.lastChunk = chunk.next;
				}

				this$1.byEnd[ chunk.end ] = chunk;
				this$1.byStart[ chunk.next.start ] = chunk.next;
				this$1.byEnd[ chunk.next.end ] = chunk.next;
			}

			if ( aborted ) { return this$1; }
			chunk = chunk.previous;
		} while ( chunk );

		return this;
	},

	trimStart: function trimStart ( charType ) {
		var this$1 = this;

		var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );

		this.intro = this.intro.replace( rx, '' );
		if ( this.intro.length ) { return this; }

		var chunk = this.firstChunk;

		do {
			var end = chunk.end;
			var aborted = chunk.trimStart( rx );

			if ( chunk.end !== end ) {
				// special case...
				if ( chunk === this$1.lastChunk ) { this$1.lastChunk = chunk.next; }

				this$1.byEnd[ chunk.end ] = chunk;
				this$1.byStart[ chunk.next.start ] = chunk.next;
				this$1.byEnd[ chunk.next.end ] = chunk.next;
			}

			if ( aborted ) { return this$1; }
			chunk = chunk.next;
		} while ( chunk );

		return this;
	}
};

var hasOwnProp = Object.prototype.hasOwnProperty;

function Bundle ( options ) {
	if ( options === void 0 ) options = {};

	this.intro = options.intro || '';
	this.separator = options.separator !== undefined ? options.separator : '\n';

	this.sources = [];

	this.uniqueSources = [];
	this.uniqueSourceIndexByFilename = {};
}

Bundle.prototype = {
	addSource: function addSource ( source ) {
		if ( source instanceof MagicString$1 ) {
			return this.addSource({
				content: source,
				filename: source.filename,
				separator: this.separator
			});
		}

		if ( !isObject( source ) || !source.content ) {
			throw new Error( 'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`' );
		}

		[ 'filename', 'indentExclusionRanges', 'separator' ].forEach( function (option) {
			if ( !hasOwnProp.call( source, option ) ) { source[ option ] = source.content[ option ]; }
		});

		if ( source.separator === undefined ) { // TODO there's a bunch of this sort of thing, needs cleaning up
			source.separator = this.separator;
		}

		if ( source.filename ) {
			if ( !hasOwnProp.call( this.uniqueSourceIndexByFilename, source.filename ) ) {
				this.uniqueSourceIndexByFilename[ source.filename ] = this.uniqueSources.length;
				this.uniqueSources.push({ filename: source.filename, content: source.content.original });
			} else {
				var uniqueSource = this.uniqueSources[ this.uniqueSourceIndexByFilename[ source.filename ] ];
				if ( source.content.original !== uniqueSource.content ) {
					throw new Error( ("Illegal source: same filename (" + (source.filename) + "), different contents") );
				}
			}
		}

		this.sources.push( source );
		return this;
	},

	append: function append ( str, options ) {
		this.addSource({
			content: new MagicString$1( str ),
			separator: ( options && options.separator ) || ''
		});

		return this;
	},

	clone: function clone () {
		var bundle = new Bundle({
			intro: this.intro,
			separator: this.separator
		});

		this.sources.forEach( function (source) {
			bundle.addSource({
				filename: source.filename,
				content: source.content.clone(),
				separator: source.separator
			});
		});

		return bundle;
	},

	generateMap: function generateMap ( options ) {
		var this$1 = this;
		if ( options === void 0 ) options = {};

		var names = [];
		this.sources.forEach( function (source) {
			Object.keys( source.content.storedNames ).forEach( function (name) {
				if ( !~names.indexOf( name ) ) { names.push( name ); }
			});
		});

		var mappings = new Mappings( options.hires );

		if ( this.intro ) {
			mappings.advance( this.intro );
		}

		this.sources.forEach( function ( source, i ) {
			if ( i > 0 ) {
				mappings.advance( this$1.separator );
			}

			var sourceIndex = source.filename ? this$1.uniqueSourceIndexByFilename[ source.filename ] : -1;
			var magicString = source.content;
			var locate = getLocator$1( magicString.original );

			if ( magicString.intro ) {
				mappings.advance( magicString.intro );
			}

			magicString.firstChunk.eachNext( function (chunk) {
				var loc = locate( chunk.start );

				if ( chunk.intro.length ) { mappings.advance( chunk.intro ); }

				if ( source.filename ) {
					if ( chunk.edited ) {
						mappings.addEdit( sourceIndex, chunk.content, chunk.original, loc, chunk.storeName ? names.indexOf( chunk.original ) : -1 );
					} else {
						mappings.addUneditedChunk( sourceIndex, chunk, magicString.original, loc, magicString.sourcemapLocations );
					}
				}

				else {
					mappings.advance( chunk.content );
				}

				if ( chunk.outro.length ) { mappings.advance( chunk.outro ); }
			});

			if ( magicString.outro ) {
				mappings.advance( magicString.outro );
			}
		});

		return new SourceMap({
			file: ( options.file ? options.file.split( /[\/\\]/ ).pop() : null ),
			sources: this.uniqueSources.map( function (source) {
				return options.file ? getRelativePath( options.file, source.filename ) : source.filename;
			}),
			sourcesContent: this.uniqueSources.map( function (source) {
				return options.includeContent ? source.content : null;
			}),
			names: names,
			mappings: mappings.encode()
		});
	},

	getIndentString: function getIndentString () {
		var indentStringCounts = {};

		this.sources.forEach( function (source) {
			var indentStr = source.content.indentStr;

			if ( indentStr === null ) { return; }

			if ( !indentStringCounts[ indentStr ] ) { indentStringCounts[ indentStr ] = 0; }
			indentStringCounts[ indentStr ] += 1;
		});

		return ( Object.keys( indentStringCounts ).sort( function ( a, b ) {
			return indentStringCounts[a] - indentStringCounts[b];
		})[0] ) || '\t';
	},

	indent: function indent ( indentStr ) {
		var this$1 = this;

		if ( !arguments.length ) {
			indentStr = this.getIndentString();
		}

		if ( indentStr === '' ) { return this; } // noop

		var trailingNewline = !this.intro || this.intro.slice( -1 ) === '\n';

		this.sources.forEach( function ( source, i ) {
			var separator = source.separator !== undefined ? source.separator : this$1.separator;
			var indentStart = trailingNewline || ( i > 0 && /\r?\n$/.test( separator ) );

			source.content.indent( indentStr, {
				exclude: source.indentExclusionRanges,
				indentStart: indentStart//: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
			});

			// TODO this is a very slow way to determine this
			trailingNewline = source.content.toString().slice( 0, -1 ) === '\n';
		});

		if ( this.intro ) {
			this.intro = indentStr + this.intro.replace( /^[^\n]/gm, function ( match, index ) {
				return index > 0 ? indentStr + match : match;
			});
		}

		return this;
	},

	prepend: function prepend ( str ) {
		this.intro = str + this.intro;
		return this;
	},

	toString: function toString () {
		var this$1 = this;

		var body = this.sources.map( function ( source, i ) {
			var separator = source.separator !== undefined ? source.separator : this$1.separator;
			var str = ( i > 0 ? separator : '' ) + source.content.toString();

			return str;
		}).join( '' );

		return this.intro + body;
	},

	trimLines: function trimLines () {
		return this.trim('[\\r\\n]');
	},

	trim: function trim ( charType ) {
		return this.trimStart( charType ).trimEnd( charType );
	},

	trimStart: function trimStart ( charType ) {
		var this$1 = this;

		var rx = new RegExp( '^' + ( charType || '\\s' ) + '+' );
		this.intro = this.intro.replace( rx, '' );

		if ( !this.intro ) {
			var source;
			var i = 0;

			do {
				source = this$1.sources[i];

				if ( !source ) {
					break;
				}

				source.content.trimStart( charType );
				i += 1;
			} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?
		}

		return this;
	},

	trimEnd: function trimEnd ( charType ) {
		var this$1 = this;

		var rx = new RegExp( ( charType || '\\s' ) + '+$' );

		var source;
		var i = this.sources.length - 1;

		do {
			source = this$1.sources[i];

			if ( !source ) {
				this$1.intro = this$1.intro.replace( rx, '' );
				break;
			}

			source.content.trimEnd( charType );
			i -= 1;
		} while ( source.content.toString() === '' ); // TODO faster way to determine non-empty source?

		return this;
	}
};

function annotateWithScopes(expression) {
    var scope = new Scope(null, false);
    walk(expression, {
        enter: function (node) {
            if (/Function/.test(node.type)) {
                if (node.type === 'FunctionDeclaration') {
                    scope.declarations.add(node.id.name);
                }
                else {
                    node._scope = scope = new Scope(scope, false);
                    if (node.id)
                        scope.declarations.add(node.id.name);
                }
                node.params.forEach(function (param) {
                    extractNames(param).forEach(function (name) {
                        scope.declarations.add(name);
                    });
                });
            }
            else if (/For(?:In|Of)Statement/.test(node.type)) {
                node._scope = scope = new Scope(scope, true);
            }
            else if (node.type === 'BlockStatement') {
                node._scope = scope = new Scope(scope, true);
            }
            else if (/(Function|Class|Variable)Declaration/.test(node.type)) {
                scope.addDeclaration(node);
            }
        },
        leave: function (node) {
            if (node._scope) {
                scope = scope.parent;
            }
        }
    });
    return scope;
}
var Scope = /** @class */ (function () {
    function Scope(parent, block) {
        this.parent = parent;
        this.block = block;
        this.declarations = new Set();
    }
    Scope.prototype.addDeclaration = function (node) {
        var _this = this;
        if (node.kind === 'var' && !this.block && this.parent) {
            this.parent.addDeclaration(node);
        }
        else if (node.type === 'VariableDeclaration') {
            node.declarations.forEach(function (declarator) {
                extractNames(declarator.id).forEach(function (name) {
                    _this.declarations.add(name);
                });
            });
        }
        else {
            this.declarations.add(node.id.name);
        }
    };
    Scope.prototype.has = function (name) {
        return (this.declarations.has(name) || (this.parent && this.parent.has(name)));
    };
    return Scope;
}());
function extractNames(param) {
    var names = [];
    extractors[param.type](names, param);
    return names;
}
var extractors = {
    Identifier: function (names, param) {
        names.push(param.name);
    },
    ObjectPattern: function (names, param) {
        param.properties.forEach(function (prop) {
            extractors[prop.value.type](names, prop.value);
        });
    },
    ArrayPattern: function (names, param) {
        param.elements.forEach(function (element) {
            if (element)
                extractors[element.type](names, element);
        });
    },
    RestElement: function (names, param) {
        extractors[param.argument.type](names, param.argument);
    },
    AssignmentPattern: function (names, param) {
        extractors[param.left.type](names, param.left);
    }
};

var start = /\n(\t+)/;
function deindent(strings) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    var indentation = start.exec(strings[0])[1];
    var pattern = new RegExp("^" + indentation, 'gm');
    var result = strings[0].replace(start, '').replace(pattern, '');
    var trailingIndentation = getTrailingIndentation(result);
    for (var i = 1; i < strings.length; i += 1) {
        var expression = values[i - 1];
        var string = strings[i].replace(pattern, '');
        if (Array.isArray(expression)) {
            expression = expression.length ? expression.join('\n') : null;
        }
        if (expression || expression === '') {
            var value = String(expression).replace(/\n/g, "\n" + trailingIndentation);
            result += value + string;
        }
        else {
            var c = result.length;
            while (/\s/.test(result[c - 1]))
                c -= 1;
            result = result.slice(0, c) + string;
        }
        trailingIndentation = getTrailingIndentation(result);
    }
    return result.trim().replace(/\t+$/gm, '');
}
function getTrailingIndentation(str) {
    var i = str.length;
    while (str[i - 1] === ' ' || str[i - 1] === '\t')
        i -= 1;
    return str.slice(i, str.length);
}

function stringify(data, options) {
    if (options === void 0) { options = {}; }
    return JSON.stringify(escape(data, options));
}
function escape(data, _a) {
    var _b = (_a === void 0 ? {} : _a).onlyEscapeAtSymbol, onlyEscapeAtSymbol = _b === void 0 ? false : _b;
    return data.replace(onlyEscapeAtSymbol ? /(%+|@+)/g : /(%+|@+|#+)/g, function (match) {
        return match + match[0];
    });
}

var ChunkType;
(function (ChunkType) {
    ChunkType[ChunkType["Line"] = 0] = "Line";
    ChunkType[ChunkType["Block"] = 1] = "Block";
})(ChunkType || (ChunkType = {}));
var CodeBuilder = /** @class */ (function () {
    function CodeBuilder(str) {
        if (str === void 0) { str = ''; }
        this.result = str;
        var initial = str
            ? /\n/.test(str) ? ChunkType.Block : ChunkType.Line
            : null;
        this.first = initial;
        this.last = initial;
        this.lastCondition = null;
        this.conditionStack = [];
        this.indent = '';
    }
    CodeBuilder.prototype.addConditional = function (condition, body) {
        this.reifyConditions();
        body = body.replace(/^/gm, this.indent + "\t");
        if (condition === this.lastCondition) {
            this.result += "\n" + body;
        }
        else {
            if (this.lastCondition) {
                this.result += "\n" + this.indent + "}";
            }
            this.result += "" + (this.last === ChunkType.Block ? '\n\n' : '\n') + this.indent + "if (" + condition + ") {\n" + body;
            this.lastCondition = condition;
        }
        this.last = ChunkType.Block;
    };
    CodeBuilder.prototype.addLine = function (line) {
        this.reifyConditions();
        if (this.lastCondition) {
            this.result += "\n" + this.indent + "}";
            this.lastCondition = null;
        }
        if (this.last === ChunkType.Block) {
            this.result += "\n\n" + this.indent + line;
        }
        else if (this.last === ChunkType.Line) {
            this.result += "\n" + this.indent + line;
        }
        else {
            this.result += line;
        }
        this.last = ChunkType.Line;
        if (!this.first)
            this.first = ChunkType.Line;
    };
    CodeBuilder.prototype.addLineAtStart = function (line) {
        this.reifyConditions();
        if (this.first === ChunkType.Block) {
            this.result = line + "\n\n" + this.indent + this.result;
        }
        else if (this.first === ChunkType.Line) {
            this.result = line + "\n" + this.indent + this.result;
        }
        else {
            this.result += line;
        }
        this.first = ChunkType.Line;
        if (!this.last)
            this.last = ChunkType.Line;
    };
    CodeBuilder.prototype.addBlock = function (block) {
        this.reifyConditions();
        if (this.indent)
            block = block.replace(/^/gm, "" + this.indent);
        if (this.lastCondition) {
            this.result += "\n" + this.indent + "}";
            this.lastCondition = null;
        }
        if (this.result) {
            this.result += "\n\n" + this.indent + block;
        }
        else {
            this.result += block;
        }
        this.last = ChunkType.Block;
        if (!this.first)
            this.first = ChunkType.Block;
    };
    CodeBuilder.prototype.addBlockAtStart = function (block) {
        this.reifyConditions();
        if (this.result) {
            this.result = block + "\n\n" + this.indent + this.result;
        }
        else {
            this.result += block;
        }
        this.first = ChunkType.Block;
        if (!this.last)
            this.last = ChunkType.Block;
    };
    CodeBuilder.prototype.isEmpty = function () {
        return this.result === '';
    };
    CodeBuilder.prototype.pushCondition = function (condition) {
        this.conditionStack.push({ condition: condition, used: false });
    };
    CodeBuilder.prototype.popCondition = function () {
        var used = this.conditionStack.pop().used;
        this.indent = repeat('\t', this.conditionStack.length);
        if (used)
            this.addLine('}');
    };
    CodeBuilder.prototype.reifyConditions = function () {
        for (var i = 0; i < this.conditionStack.length; i += 1) {
            var condition = this.conditionStack[i];
            if (!condition.used) {
                var line = "if (" + condition.condition + ") {";
                if (this.last === ChunkType.Block) {
                    this.result += "\n\n" + this.indent + line;
                }
                else if (this.last === ChunkType.Line) {
                    this.result += "\n" + this.indent + line;
                }
                else {
                    this.result += line;
                }
                this.last = ChunkType.Line;
                if (!this.first)
                    this.first = ChunkType.Line;
                this.indent = repeat('\t', this.conditionStack.length);
                condition.used = true;
            }
        }
    };
    CodeBuilder.prototype.toString = function () {
        return this.result.trim() + (this.lastCondition ? "\n}" : "");
    };
    return CodeBuilder;
}());

var globalWhitelist = new Set([
    'Array',
    'Boolean',
    'console',
    'Date',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'Infinity',
    'Intl',
    'isFinite',
    'isNaN',
    'JSON',
    'Map',
    'Math',
    'NaN',
    'Number',
    'Object',
    'parseFloat',
    'parseInt',
    'RegExp',
    'Set',
    'String',
    'undefined',
]);

// this file is auto-generated, do not edit it
var shared = {
    "appendNode": "function appendNode(node, target) {\n\ttarget.appendChild(node);\n}",
    "insertNode": "function insertNode(node, target, anchor) {\n\ttarget.insertBefore(node, anchor);\n}",
    "detachNode": "function detachNode(node) {\n\tnode.parentNode.removeChild(node);\n}",
    "detachBetween": "function detachBetween(before, after) {\n\twhile (before.nextSibling && before.nextSibling !== after) {\n\t\tbefore.parentNode.removeChild(before.nextSibling);\n\t}\n}",
    "detachBefore": "function detachBefore(after) {\n\twhile (after.previousSibling) {\n\t\tafter.parentNode.removeChild(after.previousSibling);\n\t}\n}",
    "detachAfter": "function detachAfter(before) {\n\twhile (before.nextSibling) {\n\t\tbefore.parentNode.removeChild(before.nextSibling);\n\t}\n}",
    "reinsertBetween": "function reinsertBetween(before, after, target) {\n\twhile (before.nextSibling && before.nextSibling !== after) {\n\t\ttarget.appendChild(before.parentNode.removeChild(before.nextSibling));\n\t}\n}",
    "reinsertChildren": "function reinsertChildren(parent, target) {\n\twhile (parent.firstChild) target.appendChild(parent.firstChild);\n}",
    "reinsertAfter": "function reinsertAfter(before, target) {\n\twhile (before.nextSibling) target.appendChild(before.nextSibling);\n}",
    "reinsertBefore": "function reinsertBefore(after, target) {\n\tvar parent = after.parentNode;\n\twhile (parent.firstChild !== after) target.appendChild(parent.firstChild);\n}",
    "destroyEach": "function destroyEach(iterations) {\n\tfor (var i = 0; i < iterations.length; i += 1) {\n\t\tif (iterations[i]) iterations[i].d();\n\t}\n}",
    "createFragment": "function createFragment() {\n\treturn document.createDocumentFragment();\n}",
    "createElement": "function createElement(name) {\n\treturn document.createElement(name);\n}",
    "createSvgElement": "function createSvgElement(name) {\n\treturn document.createElementNS('http://www.w3.org/2000/svg', name);\n}",
    "createText": "function createText(data) {\n\treturn document.createTextNode(data);\n}",
    "createComment": "function createComment() {\n\treturn document.createComment('');\n}",
    "addListener": "function addListener(node, event, handler) {\n\tnode.addEventListener(event, handler, false);\n}",
    "removeListener": "function removeListener(node, event, handler) {\n\tnode.removeEventListener(event, handler, false);\n}",
    "setAttribute": "function setAttribute(node, attribute, value) {\n\tnode.setAttribute(attribute, value);\n}",
    "setXlinkAttribute": "function setXlinkAttribute(node, attribute, value) {\n\tnode.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}",
    "getBindingGroupValue": "function getBindingGroupValue(group) {\n\tvar value = [];\n\tfor (var i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) value.push(group[i].__value);\n\t}\n\treturn value;\n}",
    "toNumber": "function toNumber(value) {\n\treturn value === '' ? undefined : +value;\n}",
    "timeRangesToArray": "function timeRangesToArray(ranges) {\n\tvar array = [];\n\tfor (var i = 0; i < ranges.length; i += 1) {\n\t\tarray.push({ start: ranges.start(i), end: ranges.end(i) });\n\t}\n\treturn array;\n}",
    "children": "function children (element) {\n\treturn Array.from(element.childNodes);\n}",
    "claimElement": "function claimElement (nodes, name, attributes, svg) {\n\tfor (var i = 0; i < nodes.length; i += 1) {\n\t\tvar node = nodes[i];\n\t\tif (node.nodeName === name) {\n\t\t\tfor (var j = 0; j < node.attributes.length; j += 1) {\n\t\t\t\tvar attribute = node.attributes[j];\n\t\t\t\tif (!attributes[attribute.name]) node.removeAttribute(attribute.name);\n\t\t\t}\n\t\t\treturn nodes.splice(i, 1)[0]; // TODO strip unwanted attributes\n\t\t}\n\t}\n\n\treturn svg ? createSvgElement(name) : createElement(name);\n}",
    "claimText": "function claimText (nodes, data) {\n\tfor (var i = 0; i < nodes.length; i += 1) {\n\t\tvar node = nodes[i];\n\t\tif (node.nodeType === 3) {\n\t\t\tnode.data = data;\n\t\t\treturn nodes.splice(i, 1)[0];\n\t\t}\n\t}\n\n\treturn createText(data);\n}",
    "setInputType": "function setInputType(input, type) {\n\ttry {\n\t\tinput.type = type;\n\t} catch (e) {}\n}",
    "setStyle": "function setStyle(node, key, value) {\n\tnode.style.setProperty(key, value);\n}",
    "selectOption": "function selectOption(select, value) {\n\tfor (var i = 0; i < select.options.length; i += 1) {\n\t\tvar option = select.options[i];\n\n\t\tif (option.__value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "selectOptions": "function selectOptions(select, value) {\n\tfor (var i = 0; i < select.options.length; i += 1) {\n\t\tvar option = select.options[i];\n\t\toption.selected = ~value.indexOf(option.__value);\n\t}\n}",
    "selectValue": "function selectValue(select) {\n\tvar selectedOption = select.querySelector(':checked') || select.options[0];\n\treturn selectedOption && selectedOption.__value;\n}",
    "selectMultipleValue": "function selectMultipleValue(select) {\n\treturn [].map.call(select.querySelectorAll(':checked'), function(option) {\n\t\treturn option.__value;\n\t});\n}",
    "blankObject": "function blankObject() {\n\treturn Object.create(null);\n}",
    "destroy": "function destroy(detach) {\n\tthis.destroy = noop;\n\tthis.fire('destroy');\n\tthis.set = this.get = noop;\n\n\tif (detach !== false) this._fragment.u();\n\tthis._fragment.d();\n\tthis._fragment = this._state = null;\n}",
    "destroyDev": "function destroyDev(detach) {\n\tdestroy.call(this, detach);\n\tthis.destroy = function() {\n\t\tconsole.warn('Component was already destroyed');\n\t};\n}",
    "differs": "function differs(a, b) {\n\treturn a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}",
    "dispatchObservers": "function dispatchObservers(component, group, changed, newState, oldState) {\n\tfor (var key in group) {\n\t\tif (!changed[key]) continue;\n\n\t\tvar newValue = newState[key];\n\t\tvar oldValue = oldState[key];\n\n\t\tvar callbacks = group[key];\n\t\tif (!callbacks) continue;\n\n\t\tfor (var i = 0; i < callbacks.length; i += 1) {\n\t\t\tvar callback = callbacks[i];\n\t\t\tif (callback.__calling) continue;\n\n\t\t\tcallback.__calling = true;\n\t\t\tcallback.call(component, newValue, oldValue);\n\t\t\tcallback.__calling = false;\n\t\t}\n\t}\n}",
    "fire": "function fire(eventName, data) {\n\tvar handlers =\n\t\teventName in this._handlers && this._handlers[eventName].slice();\n\tif (!handlers) return;\n\n\tfor (var i = 0; i < handlers.length; i += 1) {\n\t\thandlers[i].call(this, data);\n\t}\n}",
    "get": "function get(key) {\n\treturn key ? this._state[key] : this._state;\n}",
    "init": "function init(component, options) {\n\tcomponent._observers = { pre: blankObject(), post: blankObject() };\n\tcomponent._handlers = blankObject();\n\tcomponent._bind = options._bind;\n\n\tcomponent.options = options;\n\tcomponent.root = options.root || component;\n\tcomponent.store = component.root.store || options.store;\n}",
    "observe": "function observe(key, callback, options) {\n\tvar group = options && options.defer\n\t\t? this._observers.post\n\t\t: this._observers.pre;\n\n\t(group[key] || (group[key] = [])).push(callback);\n\n\tif (!options || options.init !== false) {\n\t\tcallback.__calling = true;\n\t\tcallback.call(this, this._state[key]);\n\t\tcallback.__calling = false;\n\t}\n\n\treturn {\n\t\tcancel: function() {\n\t\t\tvar index = group[key].indexOf(callback);\n\t\t\tif (~index) group[key].splice(index, 1);\n\t\t}\n\t};\n}",
    "observeDev": "function observeDev(key, callback, options) {\n\tvar c = (key = '' + key).search(/[^\\w]/);\n\tif (c > -1) {\n\t\tvar message =\n\t\t\t'The first argument to component.observe(...) must be the name of a top-level property';\n\t\tif (c > 0)\n\t\t\tmessage += \", i.e. '\" + key.slice(0, c) + \"' rather than '\" + key + \"'\";\n\n\t\tthrow new Error(message);\n\t}\n\n\treturn observe.call(this, key, callback, options);\n}",
    "on": "function on(eventName, handler) {\n\tif (eventName === 'teardown') return this.on('destroy', handler);\n\n\tvar handlers = this._handlers[eventName] || (this._handlers[eventName] = []);\n\thandlers.push(handler);\n\n\treturn {\n\t\tcancel: function() {\n\t\t\tvar index = handlers.indexOf(handler);\n\t\t\tif (~index) handlers.splice(index, 1);\n\t\t}\n\t};\n}",
    "onDev": "function onDev(eventName, handler) {\n\tif (eventName === 'teardown') {\n\t\tconsole.warn(\n\t\t\t\"Use component.on('destroy', ...) instead of component.on('teardown', ...) which has been deprecated and will be unsupported in Svelte 2\"\n\t\t);\n\t\treturn this.on('destroy', handler);\n\t}\n\n\treturn on.call(this, eventName, handler);\n}",
    "set": "function set(newState) {\n\tthis._set(assign({}, newState));\n\tif (this.root._lock) return;\n\tthis.root._lock = true;\n\tcallAll(this.root._beforecreate);\n\tcallAll(this.root._oncreate);\n\tcallAll(this.root._aftercreate);\n\tthis.root._lock = false;\n}",
    "_set": "function _set(newState) {\n\tvar oldState = this._state,\n\t\tchanged = {},\n\t\tdirty = false;\n\n\tfor (var key in newState) {\n\t\tif (differs(newState[key], oldState[key])) changed[key] = dirty = true;\n\t}\n\tif (!dirty) return;\n\n\tthis._state = assign({}, oldState, newState);\n\tthis._recompute(changed, this._state);\n\tif (this._bind) this._bind(changed, this._state);\n\n\tif (this._fragment) {\n\t\tdispatchObservers(this, this._observers.pre, changed, this._state, oldState);\n\t\tthis._fragment.p(changed, this._state);\n\t\tdispatchObservers(this, this._observers.post, changed, this._state, oldState);\n\t}\n}",
    "setDev": "function setDev(newState) {\n\tif (typeof newState !== 'object') {\n\t\tthrow new Error(\n\t\t\tthis._debugName + '.set was called without an object of data key-values to update.'\n\t\t);\n\t}\n\n\tthis._checkReadOnly(newState);\n\tset.call(this, newState);\n}",
    "callAll": "function callAll(fns) {\n\twhile (fns && fns.length) fns.pop()();\n}",
    "_mount": "function _mount(target, anchor) {\n\tthis._fragment.m(target, anchor);\n}",
    "_unmount": "function _unmount() {\n\tif (this._fragment) this._fragment.u();\n}",
    "isPromise": "function isPromise(value) {\n\treturn value && typeof value.then === 'function';\n}",
    "PENDING": "{}",
    "SUCCESS": "{}",
    "FAILURE": "{}",
    "removeFromStore": "function removeFromStore() {\n\tthis.store._remove(this);\n}",
    "proto": "{\n\tdestroy: destroy,\n\tget: get,\n\tfire: fire,\n\tobserve: observe,\n\ton: on,\n\tset: set,\n\tteardown: destroy,\n\t_recompute: noop,\n\t_set: _set,\n\t_mount: _mount,\n\t_unmount: _unmount\n}",
    "protoDev": "{\n\tdestroy: destroyDev,\n\tget: get,\n\tfire: fire,\n\tobserve: observeDev,\n\ton: onDev,\n\tset: setDev,\n\tteardown: destroyDev,\n\t_recompute: noop,\n\t_set: _set,\n\t_mount: _mount,\n\t_unmount: _unmount\n}",
    "linear": "function linear(t) {\n\treturn t;\n}",
    "generateRule": "function generateRule(\n\ta,\n\tb,\n\tdelta,\n\tduration,\n\tease,\n\tfn\n) {\n\tvar keyframes = '{\\n';\n\n\tfor (var p = 0; p <= 1; p += 16.666 / duration) {\n\t\tvar t = a + delta * ease(p);\n\t\tkeyframes += p * 100 + '%{' + fn(t) + '}\\n';\n\t}\n\n\treturn keyframes + '100% {' + fn(b) + '}\\n}';\n}",
    "hash": "function hash(str) {\n\tvar hash = 5381;\n\tvar i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn hash >>> 0;\n}",
    "wrapTransition": "function wrapTransition(component, node, fn, params, intro, outgroup) {\n\tvar obj = fn(node, params);\n\tvar duration = obj.duration || 300;\n\tvar ease = obj.easing || linear;\n\tvar cssText;\n\n\t// TODO share <style> tag between all transitions?\n\tif (obj.css && !transitionManager.stylesheet) {\n\t\tvar style = createElement('style');\n\t\tdocument.head.appendChild(style);\n\t\ttransitionManager.stylesheet = style.sheet;\n\t}\n\n\tif (intro) {\n\t\tif (obj.css && obj.delay) {\n\t\t\tcssText = node.style.cssText;\n\t\t\tnode.style.cssText += obj.css(0);\n\t\t}\n\n\t\tif (obj.tick) obj.tick(0);\n\t}\n\n\treturn {\n\t\tt: intro ? 0 : 1,\n\t\trunning: false,\n\t\tprogram: null,\n\t\tpending: null,\n\t\trun: function(intro, callback) {\n\t\t\tvar program = {\n\t\t\t\tstart: window.performance.now() + (obj.delay || 0),\n\t\t\t\tintro: intro,\n\t\t\t\tcallback: callback\n\t\t\t};\n\n\t\t\tif (obj.delay) {\n\t\t\t\tthis.pending = program;\n\t\t\t} else {\n\t\t\t\tthis.start(program);\n\t\t\t}\n\n\t\t\tif (!this.running) {\n\t\t\t\tthis.running = true;\n\t\t\t\ttransitionManager.add(this);\n\t\t\t}\n\t\t},\n\t\tstart: function(program) {\n\t\t\tcomponent.fire(program.intro ? 'intro.start' : 'outro.start', { node: node });\n\n\t\t\tprogram.a = this.t;\n\t\t\tprogram.b = program.intro ? 1 : 0;\n\t\t\tprogram.delta = program.b - program.a;\n\t\t\tprogram.duration = duration * Math.abs(program.b - program.a);\n\t\t\tprogram.end = program.start + program.duration;\n\n\t\t\tif (obj.css) {\n\t\t\t\tif (obj.delay) node.style.cssText = cssText;\n\n\t\t\t\tprogram.rule = generateRule(\n\t\t\t\t\tprogram.a,\n\t\t\t\t\tprogram.b,\n\t\t\t\t\tprogram.delta,\n\t\t\t\t\tprogram.duration,\n\t\t\t\t\tease,\n\t\t\t\t\tobj.css\n\t\t\t\t);\n\n\t\t\t\ttransitionManager.addRule(program.rule, program.name = '__svelte_' + hash(program.rule));\n\n\t\t\t\tnode.style.animation = (node.style.animation || '')\n\t\t\t\t\t.split(', ')\n\t\t\t\t\t.filter(function(anim) {\n\t\t\t\t\t\t// when introing, discard old animations if there are any\n\t\t\t\t\t\treturn anim && (program.delta < 0 || !/__svelte/.test(anim));\n\t\t\t\t\t})\n\t\t\t\t\t.concat(program.name + ' ' + duration + 'ms linear 1 forwards')\n\t\t\t\t\t.join(', ');\n\t\t\t}\n\n\t\t\tthis.program = program;\n\t\t\tthis.pending = null;\n\t\t},\n\t\tupdate: function(now) {\n\t\t\tvar program = this.program;\n\t\t\tif (!program) return;\n\n\t\t\tvar p = now - program.start;\n\t\t\tthis.t = program.a + program.delta * ease(p / program.duration);\n\t\t\tif (obj.tick) obj.tick(this.t);\n\t\t},\n\t\tdone: function() {\n\t\t\tvar program = this.program;\n\t\t\tthis.t = program.b;\n\t\t\tif (obj.tick) obj.tick(this.t);\n\t\t\tif (obj.css) transitionManager.deleteRule(node, program.name);\n\t\t\tprogram.callback();\n\t\t\tprogram = null;\n\t\t\tthis.running = !!this.pending;\n\t\t},\n\t\tabort: function() {\n\t\t\tif (obj.tick) obj.tick(1);\n\t\t\tif (obj.css) transitionManager.deleteRule(node, this.program.name);\n\t\t\tthis.program = this.pending = null;\n\t\t\tthis.running = false;\n\t\t}\n\t};\n}",
    "transitionManager": "{\n\trunning: false,\n\ttransitions: [],\n\tbound: null,\n\tstylesheet: null,\n\tactiveRules: {},\n\n\tadd: function(transition) {\n\t\tthis.transitions.push(transition);\n\n\t\tif (!this.running) {\n\t\t\tthis.running = true;\n\t\t\trequestAnimationFrame(this.bound || (this.bound = this.next.bind(this)));\n\t\t}\n\t},\n\n\taddRule: function(rule, name) {\n\t\tif (!this.activeRules[name]) {\n\t\t\tthis.activeRules[name] = true;\n\t\t\tthis.stylesheet.insertRule('@keyframes ' + name + ' ' + rule, this.stylesheet.cssRules.length);\n\t\t}\n\t},\n\n\tnext: function() {\n\t\tthis.running = false;\n\n\t\tvar now = window.performance.now();\n\t\tvar i = this.transitions.length;\n\n\t\twhile (i--) {\n\t\t\tvar transition = this.transitions[i];\n\n\t\t\tif (transition.program && now >= transition.program.end) {\n\t\t\t\ttransition.done();\n\t\t\t}\n\n\t\t\tif (transition.pending && now >= transition.pending.start) {\n\t\t\t\ttransition.start(transition.pending);\n\t\t\t}\n\n\t\t\tif (transition.running) {\n\t\t\t\ttransition.update(now);\n\t\t\t\tthis.running = true;\n\t\t\t} else if (!transition.pending) {\n\t\t\t\tthis.transitions.splice(i, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (this.running) {\n\t\t\trequestAnimationFrame(this.bound);\n\t\t} else if (this.stylesheet) {\n\t\t\tvar i = this.stylesheet.cssRules.length;\n\t\t\twhile (i--) this.stylesheet.deleteRule(i);\n\t\t\tthis.activeRules = {};\n\t\t}\n\t},\n\n\tdeleteRule: function(node, name) {\n\t\tnode.style.animation = node.style.animation\n\t\t\t.split(', ')\n\t\t\t.filter(function(anim) {\n\t\t\t\treturn anim.slice(0, name.length) !== name;\n\t\t\t})\n\t\t\t.join(', ');\n\t}\n}",
    "noop": "function noop() {}",
    "assign": "function assign(target) {\n\tvar k,\n\t\tsource,\n\t\ti = 1,\n\t\tlen = arguments.length;\n\tfor (; i < len; i++) {\n\t\tsource = arguments[i];\n\t\tfor (k in source) target[k] = source[k];\n\t}\n\n\treturn target;\n}"
};

var keys = {
    ObjectExpression: 'properties',
    Program: 'body'
};
var offsets = {
    ObjectExpression: [1, -1],
    Program: [0, 0]
};
function removeNode(code, parent, node) {
    var key = keys[parent.type];
    var offset = offsets[parent.type];
    if (!key || !offset)
        throw new Error("not implemented: " + parent.type);
    var list = parent[key];
    var i = list.indexOf(node);
    if (i === -1)
        throw new Error('node not in list');
    var a;
    var b;
    if (list.length === 1) {
        // remove everything, leave {}
        a = parent.start + offset[0];
        b = parent.end + offset[1];
    }
    else if (i === 0) {
        // remove everything before second node, including comments
        a = parent.start + offset[0];
        while (/\s/.test(code.original[a]))
            a += 1;
        b = list[i].end;
        while (/[\s,]/.test(code.original[b]))
            b += 1;
    }
    else {
        // remove the end of the previous node to the end of this one
        a = list[i - 1].end;
        b = node.end;
    }
    code.remove(a, b);
    list.splice(i, 1);
    return;
}

var wrappers = { es: es, amd: amd, cjs: cjs, iife: iife, umd: umd, eval: expr };
function wrapModule(code, format, name, options, banner, sharedPath, helpers, imports, source) {
    if (format === 'es')
        return es(code, name, options, banner, sharedPath, helpers, imports, source);
    var dependencies = imports.map(function (declaration, i) {
        var defaultImport = declaration.specifiers.find(function (x) {
            return x.type === 'ImportDefaultSpecifier' ||
                (x.type === 'ImportSpecifier' && x.imported.name === 'default');
        });
        var namespaceImport = declaration.specifiers.find(function (x) { return x.type === 'ImportNamespaceSpecifier'; });
        var namedImports = declaration.specifiers.filter(function (x) {
            return x.type === 'ImportSpecifier' && x.imported.name !== 'default';
        });
        var name = defaultImport || namespaceImport
            ? (defaultImport || namespaceImport).local.name
            : "__import" + i;
        var statements = [];
        namedImports.forEach(function (specifier) {
            statements.push("var " + specifier.local.name + " = " + name + "." + specifier.imported.name + ";");
        });
        if (defaultImport) {
            statements.push(name + " = (" + name + " && " + name + ".__esModule) ? " + name + "[\"default\"] : " + name + ";");
        }
        return { name: name, statements: statements, source: declaration.source.value };
    });
    if (format === 'amd')
        return amd(code, name, options, banner, dependencies);
    if (format === 'cjs')
        return cjs(code, name, options, banner, sharedPath, helpers, dependencies);
    if (format === 'iife')
        return iife(code, name, options, banner, dependencies);
    if (format === 'umd')
        return umd(code, name, options, banner, dependencies);
    if (format === 'eval')
        return expr(code, name, options, banner, dependencies);
    throw new Error("options.format is invalid (must be " + list$2(Object.keys(wrappers)) + ")");
}
function es(code, name, options, banner, sharedPath, helpers, imports, source) {
    var importHelpers = helpers && ("import { " + helpers.map(function (h) { return h.name === h.alias ? h.name : h.name + " as " + h.alias; }).join(', ') + " } from " + JSON.stringify(sharedPath) + ";");
    var importBlock = imports.length > 0 && (imports
        .map(function (declaration) { return source.slice(declaration.start, declaration.end); })
        .join('\n'));
    return deindent(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject(["\n\t\t", "\n\t\t", "\n\t\t", "\n\n\t\t", "\n\t\texport default ", ";"], ["\n\t\t", "\n\t\t", "\n\t\t", "\n\n\t\t", "\n\t\texport default ", ";"])), banner, importHelpers, importBlock, code, name);
}
function amd(code, name, options, banner, dependencies) {
    var sourceString = dependencies.length
        ? "[" + dependencies.map(function (d) { return "\"" + removeExtension(d.source) + "\""; }).join(', ') + "], "
        : '';
    var id = options.amd && options.amd.id;
    return deindent(templateObject_2$2 || (templateObject_2$2 = __makeTemplateObject(["\n\t\tdefine(", "", "function(", ") { \"use strict\";\n\t\t\t", "\n\n\t\t\t", "\n\t\t\treturn ", ";\n\t\t});"], ["\n\t\tdefine(", "", "function(", ") { \"use strict\";\n\t\t\t", "\n\n\t\t\t", "\n\t\t\treturn ", ";\n\t\t});"])), id ? "\"" + id + "\", " : '', sourceString, paramString(dependencies), getCompatibilityStatements(dependencies), code, name);
}
function cjs(code, name, options, banner, sharedPath, helpers, dependencies) {
    var SHARED = '__shared';
    var helperBlock = helpers && ("var " + SHARED + " = require(" + JSON.stringify(sharedPath) + ");\n" +
        helpers.map(function (helper) {
            return "var " + helper.alias + " = " + SHARED + "." + helper.name + ";";
        }).join('\n'));
    var requireBlock = dependencies.length > 0 && (dependencies
        .map(function (d) { return "var " + d.name + " = require(\"" + d.source + "\");"; })
        .join('\n\n'));
    return deindent(templateObject_3$2 || (templateObject_3$2 = __makeTemplateObject(["\n\t\t", "\n\t\t\"use strict\";\n\n\t\t", "\n\t\t", "\n\t\t", "\n\n\t\t", "\n\n\t\tmodule.exports = ", ";"], ["\n\t\t", "\n\t\t\"use strict\";\n\n\t\t", "\n\t\t", "\n\t\t", "\n\n\t\t", "\n\n\t\tmodule.exports = ", ";"])), banner, helperBlock, requireBlock, getCompatibilityStatements(dependencies), code, name);
}
function iife(code, name, options, banner, dependencies) {
    if (!options.name) {
        throw new Error("Missing required 'name' option for IIFE export");
    }
    var globals = getGlobals(dependencies, options);
    return deindent(templateObject_4$2 || (templateObject_4$2 = __makeTemplateObject(["\n\t\t", "\n\t\tvar ", " = (function(", ") { \"use strict\";\n\t\t\t", "\n\n\t\t\t", "\n\t\t\treturn ", ";\n\t\t}(", "));"], ["\n\t\t", "\n\t\tvar ", " = (function(", ") { \"use strict\";\n\t\t\t", "\n\n\t\t\t", "\n\t\t\treturn ", ";\n\t\t}(", "));"])), banner, options.name, paramString(dependencies), getCompatibilityStatements(dependencies), code, name, globals.join(', '));
}
function umd(code, name, options, banner, dependencies) {
    if (!options.name) {
        throw new Error("Missing required 'name' option for UMD export");
    }
    var amdId = options.amd && options.amd.id ? "'" + options.amd.id + "', " : '';
    var amdDeps = dependencies.length
        ? "[" + dependencies.map(function (d) { return "\"" + removeExtension(d.source) + "\""; }).join(', ') + "], "
        : '';
    var cjsDeps = dependencies
        .map(function (d) { return "require(\"" + d.source + "\")"; })
        .join(', ');
    var globals = getGlobals(dependencies, options);
    return deindent(templateObject_5$1 || (templateObject_5$1 = __makeTemplateObject(["\n\t\t", "\n\t\t(function(global, factory) {\n\t\t\ttypeof exports === \"object\" && typeof module !== \"undefined\" ? module.exports = factory(", ") :\n\t\t\ttypeof define === \"function\" && define.amd ? define(", "", "factory) :\n\t\t\t(global.", " = factory(", "));\n\t\t}(this, (function (", ") { \"use strict\";\n\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\treturn ", ";\n\n\t\t})));"], ["\n\t\t", "\n\t\t(function(global, factory) {\n\t\t\ttypeof exports === \"object\" && typeof module !== \"undefined\" ? module.exports = factory(", ") :\n\t\t\ttypeof define === \"function\" && define.amd ? define(", "", "factory) :\n\t\t\t(global.", " = factory(", "));\n\t\t}(this, (function (", ") { \"use strict\";\n\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\treturn ", ";\n\n\t\t})));"])), banner, cjsDeps, amdId, amdDeps, options.name, globals.join(', '), paramString(dependencies), getCompatibilityStatements(dependencies), code, name);
}
function expr(code, name, options, banner, dependencies) {
    var globals = getGlobals(dependencies, options);
    return deindent(templateObject_6$1 || (templateObject_6$1 = __makeTemplateObject(["\n\t\t(function (", ") { \"use strict\";\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\treturn ", ";\n\t\t}(", "))"], ["\n\t\t(function (", ") { \"use strict\";\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\treturn ", ";\n\t\t}(", "))"])), paramString(dependencies), banner, getCompatibilityStatements(dependencies), code, name, globals.join(', '));
}
function paramString(dependencies) {
    return dependencies.map(function (dep) { return dep.name; }).join(', ');
}
function removeExtension(file) {
    var index = file.lastIndexOf('.');
    return ~index ? file.slice(0, index) : file;
}
function getCompatibilityStatements(dependencies) {
    if (!dependencies.length)
        return null;
    var statements = [];
    dependencies.forEach(function (dependency) {
        statements.push.apply(statements, dependency.statements);
    });
    return statements.join('\n');
}
function getGlobals(dependencies, options) {
    var globals = options.globals, onerror = options.onerror, onwarn = options.onwarn;
    var globalFn = getGlobalFn(globals);
    return dependencies.map(function (d) {
        var name = globalFn(d.source);
        if (!name) {
            if (d.name.startsWith('__import')) {
                var error = new Error("Could not determine name for imported module '" + d.source + "' \u2013 use options.globals");
                onerror(error);
            }
            else {
                var warning = {
                    message: "No name was supplied for imported module '" + d.source + "'. Guessing '" + d.name + "', but you should use options.globals"
                };
                onwarn(warning);
            }
            name = d.name;
        }
        return name;
    });
}
function getGlobalFn(globals) {
    if (typeof globals === 'function')
        return globals;
    if (typeof globals === 'object') {
        return function (id) { return globals[id]; };
    }
    return function () { return undefined; };
}
var templateObject_1$2;
var templateObject_2$2;
var templateObject_3$2;
var templateObject_4$2;
var templateObject_5$1;
var templateObject_6$1;

function clone(node) {
    var cloned = {};
    for (var key in node) {
        var value = node[key];
        if (Array.isArray(value)) {
            cloned[key] = value.map(clone);
        }
        else if (value && typeof value === 'object') {
            cloned[key] = clone(value);
        }
        else {
            cloned[key] = value;
        }
    }
    return cloned;
}

var test = typeof process !== 'undefined' && process.env.TEST;

var binaryOperators = {
    '**': 15,
    '*': 14,
    '/': 14,
    '%': 14,
    '+': 13,
    '-': 13,
    '<<': 12,
    '>>': 12,
    '>>>': 12,
    '<': 11,
    '<=': 11,
    '>': 11,
    '>=': 11,
    'in': 11,
    'instanceof': 11,
    '==': 10,
    '!=': 10,
    '===': 10,
    '!==': 10,
    '&': 9,
    '^': 8,
    '|': 7
};
var logicalOperators = {
    '&&': 6,
    '||': 5
};
var precedence = {
    Literal: function () { return 21; },
    Identifier: function () { return 21; },
    ParenthesizedExpression: function () { return 20; },
    MemberExpression: function () { return 19; },
    NewExpression: function () { return 19; },
    CallExpression: function () { return 19; },
    UpdateExpression: function () { return 17; },
    UnaryExpression: function () { return 16; },
    BinaryExpression: function (expression) { return binaryOperators[expression.operator]; },
    LogicalExpression: function (expression) { return logicalOperators[expression.operator]; },
    ConditionalExpression: function () { return 4; },
    AssignmentExpression: function () { return 3; },
    YieldExpression: function () { return 2; },
    SpreadElement: function () { return 1; },
    SequenceExpression: function () { return 0; }
};
function getExpressionPrecedence(expression) {
    return expression.type in precedence ? precedence[expression.type](expression) : 0;
}

var Attribute = /** @class */ (function () {
    function Attribute(_a) {
        var generator = _a.generator, name = _a.name, value = _a.value, parent = _a.parent;
        this.type = 'Attribute';
        this.generator = generator;
        this.parent = parent;
        this.name = name;
        this.value = value;
    }
    Attribute.prototype.render = function (block) {
        var node = this.parent;
        var name = this.name;
        if (name === 'style') {
            var styleProps = optimizeStyle(this.value);
            if (styleProps) {
                this.renderStyle(block, styleProps);
                return;
            }
        }
        var metadata = node.namespace ? null : attributeLookup[name];
        if (metadata && metadata.appliesTo && !~metadata.appliesTo.indexOf(node.name))
            metadata = null;
        var isIndirectlyBoundValue = name === 'value' &&
            (node.name === 'option' || // TODO check it's actually bound
                (node.name === 'input' &&
                    node.attributes.find(function (attribute) {
                        return attribute.type === 'Binding' && /checked|group/.test(attribute.name);
                    })));
        var propertyName = isIndirectlyBoundValue
            ? '__value'
            : metadata && metadata.propertyName;
        // xlink is a special case... we could maybe extend this to generic
        // namespaced attributes but I'm not sure that's applicable in
        // HTML5?
        var method = name.slice(0, 6) === 'xlink:'
            ? '@setXlinkAttribute'
            : '@setAttribute';
        var isDynamic = this.isDynamic();
        var isLegacyInputType = this.generator.legacy && name === 'type' && this.parent.name === 'input';
        var isDataSet = /^data-/.test(name) && !this.generator.legacy && !node.namespace;
        var camelCaseName = isDataSet ? name.replace('data-', '').replace(/(-\w)/g, function (m) {
            return m[1].toUpperCase();
        }) : name;
        if (isDynamic) {
            var value = void 0;
            var allDependencies_1 = new Set();
            var shouldCache = void 0;
            var hasChangeableIndex_1;
            // TODO some of this code is repeated in Tag.ts — would be good to
            // DRY it out if that's possible without introducing crazy indirection
            if (this.value.length === 1) {
                // single {{tag}} — may be a non-string
                var expression = this.value[0].expression;
                var indexes = block.contextualise(expression).indexes;
                var _a = this.value[0].metadata, dependencies = _a.dependencies, snippet = _a.snippet;
                value = snippet;
                dependencies.forEach(function (d) {
                    allDependencies_1.add(d);
                });
                hasChangeableIndex_1 = Array.from(indexes).some(function (index) { return block.changeableIndexes.get(index); });
                shouldCache = (expression.type !== 'Identifier' ||
                    block.contexts.has(expression.name) ||
                    hasChangeableIndex_1);
            }
            else {
                // '{{foo}} {{bar}}' — treat as string concatenation
                value =
                    (this.value[0].type === 'Text' ? '' : "\"\" + ") +
                        this.value
                            .map(function (chunk) {
                            if (chunk.type === 'Text') {
                                return stringify(chunk.data);
                            }
                            else {
                                var indexes = block.contextualise(chunk.expression).indexes;
                                var _a = chunk.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
                                if (Array.from(indexes).some(function (index) { return block.changeableIndexes.get(index); })) {
                                    hasChangeableIndex_1 = true;
                                }
                                dependencies.forEach(function (d) {
                                    allDependencies_1.add(d);
                                });
                                return getExpressionPrecedence(chunk.expression) <= 13 ? "(" + snippet + ")" : snippet;
                            }
                        })
                            .join(' + ');
                shouldCache = true;
            }
            var isSelectValueAttribute = name === 'value' && node.name === 'select';
            var last = (shouldCache || isSelectValueAttribute) && block.getUniqueName(node["var"] + "_" + name.replace(/[^a-zA-Z_$]/g, '_') + "_value");
            if (shouldCache || isSelectValueAttribute)
                block.addVariable(last);
            var updater = void 0;
            var init = shouldCache ? last + " = " + value : value;
            if (isLegacyInputType) {
                block.builders.hydrate.addLine("@setInputType(" + node["var"] + ", " + init + ");");
                updater = "@setInputType(" + node["var"] + ", " + (shouldCache ? last : value) + ");";
            }
            else if (isSelectValueAttribute) {
                // annoying special case
                var isMultipleSelect = node.getStaticAttributeValue('multiple');
                var i = block.getUniqueName('i');
                var option = block.getUniqueName('option');
                var ifStatement = isMultipleSelect
                    ? deindent(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject(["\n\t\t\t\t\t\t", ".selected = ~", ".indexOf(", ".__value);"], ["\n\t\t\t\t\t\t", ".selected = ~", ".indexOf(", ".__value);"])), option, last, option) : deindent(templateObject_2$3 || (templateObject_2$3 = __makeTemplateObject(["\n\t\t\t\t\t\tif (", ".__value === ", ") {\n\t\t\t\t\t\t\t", ".selected = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}"], ["\n\t\t\t\t\t\tif (", ".__value === ", ") {\n\t\t\t\t\t\t\t", ".selected = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}"])), option, last, option);
                updater = deindent(templateObject_3$3 || (templateObject_3$3 = __makeTemplateObject(["\n\t\t\t\t\tfor (var ", " = 0; ", " < ", ".options.length; ", " += 1) {\n\t\t\t\t\t\tvar ", " = ", ".options[", "];\n\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\t\t\t\t"], ["\n\t\t\t\t\tfor (var ", " = 0; ", " < ", ".options.length; ", " += 1) {\n\t\t\t\t\t\tvar ", " = ", ".options[", "];\n\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\t\t\t\t"])), i, i, node["var"], i, option, node["var"], i, ifStatement);
                block.builders.hydrate.addBlock(deindent(templateObject_4$3 || (templateObject_4$3 = __makeTemplateObject(["\n\t\t\t\t\t", " = ", ";\n\t\t\t\t\t", "\n\t\t\t\t"], ["\n\t\t\t\t\t", " = ", ";\n\t\t\t\t\t", "\n\t\t\t\t"])), last, value, updater));
                block.builders.update.addLine(last + " = " + value + ";");
            }
            else if (propertyName) {
                block.builders.hydrate.addLine(node["var"] + "." + propertyName + " = " + init + ";");
                updater = node["var"] + "." + propertyName + " = " + (shouldCache || isSelectValueAttribute ? last : value) + ";";
            }
            else if (isDataSet) {
                block.builders.hydrate.addLine(node["var"] + ".dataset." + camelCaseName + " = " + init + ";");
                updater = node["var"] + ".dataset." + camelCaseName + " = " + (shouldCache || isSelectValueAttribute ? last : value) + ";";
            }
            else {
                block.builders.hydrate.addLine(method + "(" + node["var"] + ", \"" + name + "\", " + init + ");");
                updater = method + "(" + node["var"] + ", \"" + name + "\", " + (shouldCache || isSelectValueAttribute ? last : value) + ");";
            }
            if (allDependencies_1.size || hasChangeableIndex_1 || isSelectValueAttribute) {
                var dependencies = Array.from(allDependencies_1);
                var changedCheck = ((block.hasOutroMethod ? "#outroing || " : '') +
                    dependencies.map(function (dependency) { return "changed." + dependency; }).join(' || '));
                var updateCachedValue = last + " !== (" + last + " = " + value + ")";
                var condition = shouldCache ?
                    (dependencies.length ? "(" + changedCheck + ") && " + updateCachedValue : updateCachedValue) :
                    changedCheck;
                block.builders.update.addConditional(condition, updater);
            }
        }
        else {
            var value = this.value === true
                ? 'true'
                : this.value.length === 0
                    ? "''"
                    : stringify(this.value[0].data);
            var statement = (isLegacyInputType ? "@setInputType(" + node["var"] + ", " + value + ");" :
                propertyName ? node["var"] + "." + propertyName + " = " + value + ";" :
                    isDataSet ? node["var"] + ".dataset." + camelCaseName + " = " + value + ";" :
                        method + "(" + node["var"] + ", \"" + name + "\", " + value + ");");
            block.builders.hydrate.addLine(statement);
            // special case – autofocus. has to be handled in a bit of a weird way
            if (this.value === true && name === 'autofocus') {
                block.autofocus = node["var"];
            }
        }
        if (isIndirectlyBoundValue) {
            var updateValue = node["var"] + ".value = " + node["var"] + ".__value;";
            block.builders.hydrate.addLine(updateValue);
            if (isDynamic)
                block.builders.update.addLine(updateValue);
        }
    };
    Attribute.prototype.renderStyle = function (block, styleProps) {
        var _this = this;
        styleProps.forEach(function (prop) {
            var value;
            if (isDynamic$1(prop.value)) {
                var allDependencies_2 = new Set();
                var shouldCache = void 0;
                var hasChangeableIndex_2;
                value =
                    ((prop.value.length === 1 || prop.value[0].type === 'Text') ? '' : "\"\" + ") +
                        prop.value
                            .map(function (chunk) {
                            if (chunk.type === 'Text') {
                                return stringify(chunk.data);
                            }
                            else {
                                var indexes = block.contextualise(chunk.expression).indexes;
                                var _a = chunk.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
                                if (Array.from(indexes).some(function (index) { return block.changeableIndexes.get(index); })) {
                                    hasChangeableIndex_2 = true;
                                }
                                dependencies.forEach(function (d) {
                                    allDependencies_2.add(d);
                                });
                                return getExpressionPrecedence(chunk.expression) <= 13 ? "( " + snippet + " )" : snippet;
                            }
                        })
                            .join(' + ');
                if (allDependencies_2.size || hasChangeableIndex_2) {
                    var dependencies = Array.from(allDependencies_2);
                    var condition = ((block.hasOutroMethod ? "#outroing || " : '') +
                        dependencies.map(function (dependency) { return "changed." + dependency; }).join(' || '));
                    block.builders.update.addConditional(condition, "@setStyle(" + _this.parent["var"] + ", \"" + prop.key + "\", " + value + ");");
                }
            }
            else {
                value = stringify(prop.value[0].data);
            }
            block.builders.hydrate.addLine("@setStyle(" + _this.parent["var"] + ", \"" + prop.key + "\", " + value + ");");
        });
    };
    Attribute.prototype.isDynamic = function () {
        if (this.value === true || this.value.length === 0)
            return false;
        if (this.value.length > 1)
            return true;
        return this.value[0].type !== 'Text';
    };
    return Attribute;
}());
// source: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes
var attributeLookup = {
    accept: { appliesTo: ['form', 'input'] },
    'accept-charset': { propertyName: 'acceptCharset', appliesTo: ['form'] },
    accesskey: { propertyName: 'accessKey' },
    action: { appliesTo: ['form'] },
    align: {
        appliesTo: [
            'applet',
            'caption',
            'col',
            'colgroup',
            'hr',
            'iframe',
            'img',
            'table',
            'tbody',
            'td',
            'tfoot',
            'th',
            'thead',
            'tr',
        ]
    },
    allowfullscreen: { propertyName: 'allowFullscreen', appliesTo: ['iframe'] },
    alt: { appliesTo: ['applet', 'area', 'img', 'input'] },
    async: { appliesTo: ['script'] },
    autocomplete: { appliesTo: ['form', 'input'] },
    autofocus: { appliesTo: ['button', 'input', 'keygen', 'select', 'textarea'] },
    autoplay: { appliesTo: ['audio', 'video'] },
    autosave: { appliesTo: ['input'] },
    bgcolor: {
        propertyName: 'bgColor',
        appliesTo: [
            'body',
            'col',
            'colgroup',
            'marquee',
            'table',
            'tbody',
            'tfoot',
            'td',
            'th',
            'tr',
        ]
    },
    border: { appliesTo: ['img', 'object', 'table'] },
    buffered: { appliesTo: ['audio', 'video'] },
    challenge: { appliesTo: ['keygen'] },
    charset: { appliesTo: ['meta', 'script'] },
    checked: { appliesTo: ['command', 'input'] },
    cite: { appliesTo: ['blockquote', 'del', 'ins', 'q'] },
    "class": { propertyName: 'className' },
    code: { appliesTo: ['applet'] },
    codebase: { propertyName: 'codeBase', appliesTo: ['applet'] },
    color: { appliesTo: ['basefont', 'font', 'hr'] },
    cols: { appliesTo: ['textarea'] },
    colspan: { propertyName: 'colSpan', appliesTo: ['td', 'th'] },
    content: { appliesTo: ['meta'] },
    contenteditable: { propertyName: 'contentEditable' },
    contextmenu: {},
    controls: { appliesTo: ['audio', 'video'] },
    coords: { appliesTo: ['area'] },
    data: { appliesTo: ['object'] },
    datetime: { propertyName: 'dateTime', appliesTo: ['del', 'ins', 'time'] },
    "default": { appliesTo: ['track'] },
    defer: { appliesTo: ['script'] },
    dir: {},
    dirname: { propertyName: 'dirName', appliesTo: ['input', 'textarea'] },
    disabled: {
        appliesTo: [
            'button',
            'command',
            'fieldset',
            'input',
            'keygen',
            'optgroup',
            'option',
            'select',
            'textarea',
        ]
    },
    download: { appliesTo: ['a', 'area'] },
    draggable: {},
    dropzone: {},
    enctype: { appliesTo: ['form'] },
    "for": { propertyName: 'htmlFor', appliesTo: ['label', 'output'] },
    form: {
        appliesTo: [
            'button',
            'fieldset',
            'input',
            'keygen',
            'label',
            'meter',
            'object',
            'output',
            'progress',
            'select',
            'textarea',
        ]
    },
    formaction: { appliesTo: ['input', 'button'] },
    headers: { appliesTo: ['td', 'th'] },
    height: {
        appliesTo: ['canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video']
    },
    hidden: {},
    high: { appliesTo: ['meter'] },
    href: { appliesTo: ['a', 'area', 'base', 'link'] },
    hreflang: { appliesTo: ['a', 'area', 'link'] },
    'http-equiv': { propertyName: 'httpEquiv', appliesTo: ['meta'] },
    icon: { appliesTo: ['command'] },
    id: {},
    indeterminate: { appliesTo: ['input'] },
    ismap: { propertyName: 'isMap', appliesTo: ['img'] },
    itemprop: {},
    keytype: { appliesTo: ['keygen'] },
    kind: { appliesTo: ['track'] },
    label: { appliesTo: ['track'] },
    lang: {},
    language: { appliesTo: ['script'] },
    loop: { appliesTo: ['audio', 'bgsound', 'marquee', 'video'] },
    low: { appliesTo: ['meter'] },
    manifest: { appliesTo: ['html'] },
    max: { appliesTo: ['input', 'meter', 'progress'] },
    maxlength: { propertyName: 'maxLength', appliesTo: ['input', 'textarea'] },
    media: { appliesTo: ['a', 'area', 'link', 'source', 'style'] },
    method: { appliesTo: ['form'] },
    min: { appliesTo: ['input', 'meter'] },
    multiple: { appliesTo: ['input', 'select'] },
    muted: { appliesTo: ['audio', 'video'] },
    name: {
        appliesTo: [
            'button',
            'form',
            'fieldset',
            'iframe',
            'input',
            'keygen',
            'object',
            'output',
            'select',
            'textarea',
            'map',
            'meta',
            'param',
        ]
    },
    novalidate: { propertyName: 'noValidate', appliesTo: ['form'] },
    open: { appliesTo: ['details'] },
    optimum: { appliesTo: ['meter'] },
    pattern: { appliesTo: ['input'] },
    ping: { appliesTo: ['a', 'area'] },
    placeholder: { appliesTo: ['input', 'textarea'] },
    poster: { appliesTo: ['video'] },
    preload: { appliesTo: ['audio', 'video'] },
    radiogroup: { appliesTo: ['command'] },
    readonly: { propertyName: 'readOnly', appliesTo: ['input', 'textarea'] },
    rel: { appliesTo: ['a', 'area', 'link'] },
    required: { appliesTo: ['input', 'select', 'textarea'] },
    reversed: { appliesTo: ['ol'] },
    rows: { appliesTo: ['textarea'] },
    rowspan: { propertyName: 'rowSpan', appliesTo: ['td', 'th'] },
    sandbox: { appliesTo: ['iframe'] },
    scope: { appliesTo: ['th'] },
    scoped: { appliesTo: ['style'] },
    seamless: { appliesTo: ['iframe'] },
    selected: { appliesTo: ['option'] },
    shape: { appliesTo: ['a', 'area'] },
    size: { appliesTo: ['input', 'select'] },
    sizes: { appliesTo: ['link', 'img', 'source'] },
    span: { appliesTo: ['col', 'colgroup'] },
    spellcheck: {},
    src: {
        appliesTo: [
            'audio',
            'embed',
            'iframe',
            'img',
            'input',
            'script',
            'source',
            'track',
            'video',
        ]
    },
    srcdoc: { appliesTo: ['iframe'] },
    srclang: { appliesTo: ['track'] },
    srcset: { appliesTo: ['img'] },
    start: { appliesTo: ['ol'] },
    step: { appliesTo: ['input'] },
    style: { propertyName: 'style.cssText' },
    summary: { appliesTo: ['table'] },
    tabindex: { propertyName: 'tabIndex' },
    target: { appliesTo: ['a', 'area', 'base', 'form'] },
    title: {},
    type: {
        appliesTo: [
            'button',
            'input',
            'command',
            'embed',
            'object',
            'script',
            'source',
            'style',
            'menu',
        ]
    },
    usemap: { propertyName: 'useMap', appliesTo: ['img', 'input', 'object'] },
    value: {
        appliesTo: [
            'button',
            'option',
            'input',
            'li',
            'meter',
            'progress',
            'param',
            'select',
            'textarea',
        ]
    },
    width: {
        appliesTo: ['canvas', 'embed', 'iframe', 'img', 'input', 'object', 'video']
    },
    wrap: { appliesTo: ['textarea'] }
};
Object.keys(attributeLookup).forEach(function (name) {
    var metadata = attributeLookup[name];
    if (!metadata.propertyName)
        metadata.propertyName = name;
});
function optimizeStyle(value) {
    var expectingKey = true;
    var i = 0;
    var props = [];
    var chunks = value.slice();
    while (chunks.length) {
        var chunk = chunks[0];
        if (chunk.type !== 'Text')
            return null;
        var keyMatch = /^\s*([\w-]+):\s*/.exec(chunk.data);
        if (!keyMatch)
            return null;
        var key = keyMatch[1];
        var offset = keyMatch.index + keyMatch[0].length;
        var remainingData = chunk.data.slice(offset);
        if (remainingData) {
            chunks[0] = {
                start: chunk.start + offset,
                end: chunk.end,
                type: 'Text',
                data: remainingData
            };
        }
        else {
            chunks.shift();
        }
        var result = getStyleValue(chunks);
        if (!result)
            return null;
        props.push({ key: key, value: result.value });
        chunks = result.chunks;
    }
    return props;
}
function getStyleValue(chunks) {
    var value = [];
    var inUrl = false;
    var quoteMark = null;
    var escaped = false;
    while (chunks.length) {
        var chunk = chunks.shift();
        if (chunk.type === 'Text') {
            var c = 0;
            while (c < chunk.data.length) {
                var char = chunk.data[c];
                if (escaped) {
                    escaped = false;
                }
                else if (char === '\\') {
                    escaped = true;
                }
                else if (char === quoteMark) {
                    quoteMark === null;
                }
                else if (char === '"' || char === "'") {
                    quoteMark = char;
                }
                else if (char === ')' && inUrl) {
                    inUrl = false;
                }
                else if (char === 'u' && chunk.data.slice(c, c + 4) === 'url(') {
                    inUrl = true;
                }
                else if (char === ';' && !inUrl && !quoteMark) {
                    break;
                }
                c += 1;
            }
            if (c > 0) {
                value.push({
                    type: 'Text',
                    start: chunk.start,
                    end: chunk.start + c,
                    data: chunk.data.slice(0, c)
                });
            }
            while (/[;\s]/.test(chunk.data[c]))
                c += 1;
            var remainingData = chunk.data.slice(c);
            if (remainingData) {
                chunks.unshift({
                    start: chunk.start + c,
                    end: chunk.end,
                    type: 'Text',
                    data: remainingData
                });
                break;
            }
        }
        else {
            value.push(chunk);
        }
    }
    return {
        chunks: chunks,
        value: value
    };
}
function isDynamic$1(value) {
    return value.length > 1 || value[0].type !== 'Text';
}
var templateObject_1$3;
var templateObject_2$3;
var templateObject_3$3;
var templateObject_4$3;

var Node$1 = /** @class */ (function () {
    function Node(data) {
        Object.assign(this, data);
    }
    Node.prototype.cannotUseInnerHTML = function () {
        if (this.canUseInnerHTML !== false) {
            this.canUseInnerHTML = false;
            if (this.parent) {
                if (!this.parent.cannotUseInnerHTML)
                    console.log(this.parent.type, this.type);
                this.parent.cannotUseInnerHTML();
            }
        }
    };
    Node.prototype.init = function (block, stripWhitespace, nextSibling) {
        // implemented by subclasses
    };
    Node.prototype.initChildren = function (block, stripWhitespace, nextSibling) {
        var _this = this;
        // glue text nodes together
        var cleaned = [];
        var lastChild;
        var windowComponent;
        this.children.forEach(function (child) {
            if (child.type === 'Comment')
                return;
            // special case — this is an easy way to remove whitespace surrounding
            // <:Window/>. lil hacky but it works
            if (child.type === 'Window') {
                windowComponent = child;
                return;
            }
            if (child.type === 'Text' && lastChild && lastChild.type === 'Text') {
                lastChild.data += child.data;
                lastChild.end = child.end;
            }
            else {
                if (child.type === 'Text' && stripWhitespace && cleaned.length === 0) {
                    child.data = trimStart(child.data);
                    if (child.data)
                        cleaned.push(child);
                }
                else {
                    cleaned.push(child);
                }
            }
            lastChild = child;
        });
        lastChild = null;
        cleaned.forEach(function (child, i) {
            child.canUseInnerHTML = !_this.generator.hydratable;
            child.init(block, stripWhitespace, cleaned[i + 1] || nextSibling);
            if (child.shouldSkip)
                return;
            if (lastChild)
                lastChild.next = child;
            child.prev = lastChild;
            lastChild = child;
        });
        // We want to remove trailing whitespace inside an element/component/block,
        // *unless* there is no whitespace between this node and its next sibling
        if (stripWhitespace && lastChild && lastChild.type === 'Text') {
            var shouldTrim = (nextSibling ? (nextSibling.type === 'Text' && /^\s/.test(nextSibling.data)) : !this.hasAncestor('EachBlock'));
            if (shouldTrim) {
                lastChild.data = trimEnd(lastChild.data);
                if (!lastChild.data) {
                    cleaned.pop();
                    lastChild = cleaned[cleaned.length - 1];
                    lastChild.next = null;
                }
            }
        }
        this.children = cleaned;
        if (windowComponent)
            cleaned.unshift(windowComponent);
    };
    Node.prototype.build = function (block, parentNode, parentNodes) {
        // implemented by subclasses
    };
    Node.prototype.isDomNode = function () {
        return this.type === 'Element' || this.type === 'Text' || this.type === 'MustacheTag';
    };
    Node.prototype.hasAncestor = function (type) {
        return this.parent ?
            this.parent.type === type || this.parent.hasAncestor(type) :
            false;
    };
    Node.prototype.findNearest = function (selector) {
        if (selector.test(this.type))
            return this;
        if (this.parent)
            return this.parent.findNearest(selector);
    };
    Node.prototype.getOrCreateAnchor = function (block, parentNode, parentNodes) {
        // TODO use this in EachBlock and IfBlock — tricky because
        // children need to be created first
        var needsAnchor = this.next ? !this.next.isDomNode() : !parentNode || !this.parent.isDomNode();
        var anchor = needsAnchor
            ? block.getUniqueName(this["var"] + "_anchor")
            : (this.next && this.next["var"]) || 'null';
        if (needsAnchor) {
            block.addElement(anchor, "@createComment()", parentNodes && "@createComment()", parentNode);
        }
        return anchor;
    };
    Node.prototype.getUpdateMountNode = function (anchor) {
        return this.parent.isDomNode() ? this.parent["var"] : anchor + ".parentNode";
    };
    return Node;
}());

function createDebuggingComment(node, generator) {
    var locate = generator.locate, source = generator.source;
    var c = node.start;
    if (node.type === 'ElseBlock') {
        while (source[c] !== '{')
            c -= 1;
        c -= 1;
    }
    var d = node.expression ? node.expression.end : c;
    while (source[d] !== '}')
        d += 1;
    d += 2;
    var start = locate(c);
    var loc = "(" + (start.line + 1) + ":" + start.column + ")";
    return (loc + " " + source.slice(c, d)).replace(/\n/g, ' ');
}

var AwaitBlock = /** @class */ (function (_super) {
    __extends(AwaitBlock, _super);
    function AwaitBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AwaitBlock.prototype.init = function (block, stripWhitespace, nextSibling) {
        var _this = this;
        this.cannotUseInnerHTML();
        this["var"] = block.getUniqueName('await_block');
        block.addDependencies(this.metadata.dependencies);
        var dynamic = false;
        [
            ['pending', null],
            ['then', this.value],
            ['catch', this.error]
        ].forEach(function (_a) {
            var status = _a[0], arg = _a[1];
            var child = _this[status];
            var context = block.getUniqueName(arg || '_');
            var contexts = new Map(block.contexts);
            contexts.set(arg, context);
            child.block = block.child({
                comment: createDebuggingComment(child, _this.generator),
                name: _this.generator.getUniqueName("create_" + status + "_block"),
                params: block.params.concat(context),
                context: context,
                contexts: contexts
            });
            child.initChildren(child.block, stripWhitespace, nextSibling);
            _this.generator.blocks.push(child.block);
            if (child.block.dependencies.size > 0) {
                dynamic = true;
                block.addDependencies(child.block.dependencies);
            }
        });
        this.pending.block.hasUpdateMethod = dynamic;
        this.then.block.hasUpdateMethod = dynamic;
        this["catch"].block.hasUpdateMethod = dynamic;
    };
    AwaitBlock.prototype.build = function (block, parentNode, parentNodes) {
        var name = this["var"];
        var anchor = this.getOrCreateAnchor(block, parentNode, parentNodes);
        var updateMountNode = this.getUpdateMountNode(anchor);
        var params = block.params.join(', ');
        block.contextualise(this.expression);
        var snippet = this.metadata.snippet;
        var promise = block.getUniqueName("promise");
        var resolved = block.getUniqueName("resolved");
        var await_block = block.getUniqueName("await_block");
        var await_block_type = block.getUniqueName("await_block_type");
        var token = block.getUniqueName("token");
        var await_token = block.getUniqueName("await_token");
        var handle_promise = block.getUniqueName("handle_promise");
        var replace_await_block = block.getUniqueName("replace_await_block");
        var old_block = block.getUniqueName("old_block");
        var value = block.getUniqueName("value");
        var error = block.getUniqueName("error");
        var create_pending_block = this.pending.block.name;
        var create_then_block = this.then.block.name;
        var create_catch_block = this["catch"].block.name;
        block.addVariable(await_block);
        block.addVariable(await_block_type);
        block.addVariable(await_token);
        block.addVariable(promise);
        block.addVariable(resolved);
        block.builders.init.addBlock(deindent(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject(["\n\t\t\tfunction ", "(", ", type, ", ", ", ") {\n\t\t\t\tif (", " !== ", ") return;\n\n\t\t\t\tvar ", " = ", ";\n\t\t\t\t", " = (", " = type)(", ", ", " = ", ", #component);\n\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".u();\n\t\t\t\t\t", ".d();\n\t\t\t\t\t", ".c();\n\t\t\t\t\t", ".m(", ", ", ");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ", "(", ", ", ") {\n\t\t\t\tvar ", " = ", " = {};\n\n\t\t\t\tif (@isPromise(", ")) {\n\t\t\t\t\t", ".then(function(", ") {\n\t\t\t\t\t\t", "(", ", ", ", ", ", ", ");\n\t\t\t\t\t}, function (", ") {\n\t\t\t\t\t\t", "(", ", ", ", ", ", ", ");\n\t\t\t\t\t});\n\n\t\t\t\t\t// if we previously had a then/catch block, destroy it\n\t\t\t\t\tif (", " !== ", ") {\n\t\t\t\t\t\t", "(", ", ", ", null, ", ");\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t", " = ", ";\n\t\t\t\t\tif (", " !== ", ") {\n\t\t\t\t\t\t", "(", ", ", ", ", ", ", ");\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t", "(", " = ", ", ", ");\n\t\t"], ["\n\t\t\tfunction ", "(", ", type, ", ", ", ") {\n\t\t\t\tif (", " !== ", ") return;\n\n\t\t\t\tvar ", " = ", ";\n\t\t\t\t", " = (", " = type)(", ", ", " = ", ", #component);\n\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".u();\n\t\t\t\t\t", ".d();\n\t\t\t\t\t", ".c();\n\t\t\t\t\t", ".m(", ", ", ");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction ", "(", ", ", ") {\n\t\t\t\tvar ", " = ", " = {};\n\n\t\t\t\tif (@isPromise(", ")) {\n\t\t\t\t\t", ".then(function(", ") {\n\t\t\t\t\t\t", "(", ", ", ", ", ", ", ");\n\t\t\t\t\t}, function (", ") {\n\t\t\t\t\t\t", "(", ", ", ", ", ", ", ");\n\t\t\t\t\t});\n\n\t\t\t\t\t// if we previously had a then/catch block, destroy it\n\t\t\t\t\tif (", " !== ", ") {\n\t\t\t\t\t\t", "(", ", ", ", null, ", ");\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t", " = ", ";\n\t\t\t\t\tif (", " !== ", ") {\n\t\t\t\t\t\t", "(", ", ", ", ", ", ", ");\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t", "(", " = ", ", ", ");\n\t\t"])), replace_await_block, token, value, params, token, await_token, old_block, await_block, await_block, await_block_type, params, resolved, value, old_block, old_block, old_block, await_block, await_block, updateMountNode, anchor, handle_promise, promise, params, token, await_token, promise, promise, value, replace_await_block, token, create_then_block, value, params, error, replace_await_block, token, create_catch_block, error, params, await_block_type, create_pending_block, replace_await_block, token, create_pending_block, params, resolved, promise, await_block_type, create_then_block, replace_await_block, token, create_then_block, resolved, params, handle_promise, promise, snippet, params));
        block.builders.create.addBlock(deindent(templateObject_2$4 || (templateObject_2$4 = __makeTemplateObject(["\n\t\t\t", ".c();\n\t\t"], ["\n\t\t\t", ".c();\n\t\t"])), await_block));
        if (parentNodes) {
            block.builders.claim.addBlock(deindent(templateObject_3$4 || (templateObject_3$4 = __makeTemplateObject(["\n\t\t\t\t", ".l(", ");\n\t\t\t"], ["\n\t\t\t\t", ".l(", ");\n\t\t\t"])), await_block, parentNodes));
        }
        var initialMountNode = parentNode || '#target';
        var anchorNode = parentNode ? 'null' : 'anchor';
        block.builders.mount.addBlock(deindent(templateObject_4$4 || (templateObject_4$4 = __makeTemplateObject(["\n\t\t\t", ".m(", ", ", ");\n\t\t"], ["\n\t\t\t", ".m(", ", ", ");\n\t\t"])), await_block, initialMountNode, anchorNode));
        var conditions = [];
        if (this.metadata.dependencies) {
            conditions.push("(" + this.metadata.dependencies.map(function (dep) { return "'" + dep + "' in changed"; }).join(' || ') + ")");
        }
        conditions.push(promise + " !== (" + promise + " = " + snippet + ")", handle_promise + "(" + promise + ", " + params + ")");
        if (this.pending.block.hasUpdateMethod) {
            block.builders.update.addBlock(deindent(templateObject_5$2 || (templateObject_5$2 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t// nothing\n\t\t\t\t} else {\n\t\t\t\t\t", ".p(changed, ", ", ", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t// nothing\n\t\t\t\t} else {\n\t\t\t\t\t", ".p(changed, ", ", ", ");\n\t\t\t\t}\n\t\t\t"])), conditions.join(' && '), await_block, params, resolved));
        }
        else {
            block.builders.update.addBlock(deindent(templateObject_6$2 || (templateObject_6$2 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".c();\n\t\t\t\t\t", ".m(", ".parentNode, ", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".c();\n\t\t\t\t\t", ".m(", ".parentNode, ", ");\n\t\t\t\t}\n\t\t\t"])), conditions.join(' && '), await_block, await_block, anchor, anchor));
        }
        block.builders.unmount.addBlock(deindent(templateObject_7$1 || (templateObject_7$1 = __makeTemplateObject(["\n\t\t\t", ".u();\n\t\t"], ["\n\t\t\t", ".u();\n\t\t"])), await_block));
        block.builders.destroy.addBlock(deindent(templateObject_8$1 || (templateObject_8$1 = __makeTemplateObject(["\n\t\t\t", " = null;\n\t\t\t", ".d();\n\t\t"], ["\n\t\t\t", " = null;\n\t\t\t", ".d();\n\t\t"])), await_token, await_block));
        [this.pending, this.then, this["catch"]].forEach(function (status) {
            status.children.forEach(function (child) {
                child.build(status.block, null, 'nodes');
            });
        });
    };
    return AwaitBlock;
}(Node$1));
var templateObject_1$4;
var templateObject_2$4;
var templateObject_3$4;
var templateObject_4$4;
var templateObject_5$2;
var templateObject_6$2;
var templateObject_7$1;
var templateObject_8$1;

function getObject(node) {
    while (node.type === 'MemberExpression')
        node = node.object;
    return node;
}

function getTailSnippet(node) {
    var end = node.end;
    while (node.type === 'MemberExpression')
        node = node.object;
    var start = node.end;
    return "[\u2702" + start + "-" + end + "\u2702]";
}

var readOnlyMediaAttributes = new Set([
    'duration',
    'buffered',
    'seekable',
    'played'
]);
var Binding = /** @class */ (function (_super) {
    __extends(Binding, _super);
    function Binding() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Binding.prototype.munge = function (block, allUsedContexts) {
        var _this = this;
        var node = this.parent;
        var needsLock = node.name !== 'input' || !/radio|checkbox|range|color/.test(node.getStaticAttributeValue('type'));
        var isReadOnly = node.isMediaNode() && readOnlyMediaAttributes.has(this.name);
        var updateCondition;
        var name = getObject(this.value).name;
        var contexts = block.contextualise(this.value).contexts;
        var snippet = this.metadata.snippet;
        // special case: if you have e.g. `<input type=checkbox bind:checked=selected.done>`
        // and `selected` is an object chosen with a <select>, then when `checked` changes,
        // we need to tell the component to update all the values `selected` might be
        // pointing to
        // TODO should this happen in preprocess?
        var dependencies = this.metadata.dependencies.slice();
        this.metadata.dependencies.forEach(function (prop) {
            var indirectDependencies = _this.generator.indirectDependencies.get(prop);
            if (indirectDependencies) {
                indirectDependencies.forEach(function (indirectDependency) {
                    if (!~dependencies.indexOf(indirectDependency))
                        dependencies.push(indirectDependency);
                });
            }
        });
        contexts.forEach(function (context) {
            allUsedContexts.add(context);
        });
        // view to model
        var valueFromDom = getValueFromDom(this.generator, node, this);
        var handler = getEventHandler(this.generator, block, name, snippet, this, dependencies, valueFromDom);
        // model to view
        var updateDom = getDomUpdater(node, this, snippet);
        var initialUpdate = updateDom;
        // special cases
        if (this.name === 'group') {
            var bindingGroup = getBindingGroup(this.generator, this.value);
            block.builders.hydrate.addLine("#component._bindingGroups[" + bindingGroup + "].push(" + node["var"] + ");");
            block.builders.destroy.addLine("#component._bindingGroups[" + bindingGroup + "].splice(#component._bindingGroups[" + bindingGroup + "].indexOf(" + node["var"] + "), 1);");
        }
        if (this.name === 'currentTime') {
            updateCondition = "!isNaN(" + snippet + ")";
            initialUpdate = null;
        }
        if (this.name === 'paused') {
            // this is necessary to prevent audio restarting by itself
            var last = block.getUniqueName(node["var"] + "_is_paused");
            block.addVariable(last, 'true');
            updateCondition = last + " !== (" + last + " = " + snippet + ")";
            updateDom = node["var"] + "[" + last + " ? \"pause\" : \"play\"]();";
            initialUpdate = null;
        }
        return {
            name: this.name,
            object: name,
            handler: handler,
            updateDom: updateDom,
            initialUpdate: initialUpdate,
            needsLock: !isReadOnly && needsLock,
            updateCondition: updateCondition,
            isReadOnlyMediaAttribute: this.isReadOnlyMediaAttribute()
        };
    };
    Binding.prototype.isReadOnlyMediaAttribute = function () {
        return readOnlyMediaAttributes.has(this.name);
    };
    return Binding;
}(Node$1));
function getDomUpdater(node, binding, snippet) {
    if (binding.isReadOnlyMediaAttribute()) {
        return null;
    }
    if (node.name === 'select') {
        return node.getStaticAttributeValue('multiple') === true ?
            "@selectOptions(" + node["var"] + ", " + snippet + ")" :
            "@selectOption(" + node["var"] + ", " + snippet + ")";
    }
    if (binding.name === 'group') {
        var type = node.getStaticAttributeValue('type');
        var condition = type === 'checkbox'
            ? "~" + snippet + ".indexOf(" + node["var"] + ".__value)"
            : node["var"] + ".__value === " + snippet;
        return node["var"] + ".checked = " + condition + ";";
    }
    return node["var"] + "." + binding.name + " = " + snippet + ";";
}
function getBindingGroup(generator, value) {
    var parts = flatten(value).parts; // TODO handle cases involving computed member expressions
    var keypath = parts.join('.');
    // TODO handle contextual bindings — `keypath` should include unique ID of
    // each block that provides context
    var index = generator.bindingGroups.indexOf(keypath);
    if (index === -1) {
        index = generator.bindingGroups.length;
        generator.bindingGroups.push(keypath);
    }
    return index;
}
function getEventHandler(generator, block, name, snippet, attribute, dependencies, value) {
    var storeDependencies = [];
    if (generator.options.store) {
        storeDependencies = dependencies.filter(function (prop) { return prop[0] === '$'; }).map(function (prop) { return prop.slice(1); });
        dependencies = dependencies.filter(function (prop) { return prop[0] !== '$'; });
    }
    if (block.contexts.has(name)) {
        var tail = attribute.value.type === 'MemberExpression'
            ? getTailSnippet(attribute.value)
            : '';
        var list = "context." + block.listNames.get(name);
        var index = "context." + block.indexNames.get(name);
        return {
            usesContext: true,
            usesState: true,
            usesStore: storeDependencies.length > 0,
            mutation: list + "[" + index + "]" + tail + " = " + value + ";",
            props: dependencies.map(function (prop) { return prop + ": state." + prop; }),
            storeProps: storeDependencies.map(function (prop) { return prop + ": $." + prop; })
        };
    }
    if (attribute.value.type === 'MemberExpression') {
        // This is a little confusing, and should probably be tidied up
        // at some point. It addresses a tricky bug (#893), wherein
        // Svelte tries to `set()` a computed property, which throws an
        // error in dev mode. a) it's possible that we should be
        // replacing computations with *their* dependencies, and b)
        // we should probably populate `generator.readonly` sooner so
        // that we don't have to do the `.some()` here
        dependencies = dependencies.filter(function (prop) { return !generator.computations.some(function (computation) { return computation.key === prop; }); });
        return {
            usesContext: false,
            usesState: true,
            usesStore: storeDependencies.length > 0,
            mutation: snippet + " = " + value,
            props: dependencies.map(function (prop) { return prop + ": state." + prop; }),
            storeProps: storeDependencies.map(function (prop) { return prop + ": $." + prop; })
        };
    }
    var props;
    var storeProps;
    if (generator.options.store && name[0] === '$') {
        props = [];
        storeProps = [name.slice(1) + ": " + value];
    }
    else {
        props = [name + ": " + value];
        storeProps = [];
    }
    return {
        usesContext: false,
        usesState: false,
        usesStore: false,
        mutation: null,
        props: props,
        storeProps: storeProps
    };
}
function getValueFromDom(generator, node, binding) {
    // <select bind:value='selected>
    if (node.name === 'select') {
        return node.getStaticAttributeValue('multiple') === true ?
            "@selectMultipleValue(" + node["var"] + ")" :
            "@selectValue(" + node["var"] + ")";
    }
    var type = node.getStaticAttributeValue('type');
    // <input type='checkbox' bind:group='foo'>
    if (binding.name === 'group') {
        var bindingGroup = getBindingGroup(generator, binding.value);
        if (type === 'checkbox') {
            return "@getBindingGroupValue(#component._bindingGroups[" + bindingGroup + "])";
        }
        return node["var"] + ".__value";
    }
    // <input type='range|number' bind:value>
    if (type === 'range' || type === 'number') {
        return "@toNumber(" + node["var"] + "." + binding.name + ")";
    }
    if ((binding.name === 'buffered' || binding.name === 'seekable' || binding.name === 'played')) {
        return "@timeRangesToArray(" + node["var"] + "." + binding.name + ")";
    }
    // everything else
    return node["var"] + "." + binding.name;
}

var CatchBlock = /** @class */ (function (_super) {
    __extends(CatchBlock, _super);
    function CatchBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return CatchBlock;
}(Node$1));

var Comment$2 = /** @class */ (function (_super) {
    __extends(Comment, _super);
    function Comment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Comment;
}(Node$1));

function stringifyProps(props) {
    if (!props.length)
        return '{}';
    var joined = props.join(', ');
    if (joined.length > 40) {
        // make larger data objects readable
        return "{\n\t" + props.join(',\n\t') + "\n}";
    }
    return "{ " + joined + " }";
}

var Component = /** @class */ (function (_super) {
    __extends(Component, _super);
    function Component() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Component.prototype.init = function (block, stripWhitespace, nextSibling) {
        this.cannotUseInnerHTML();
        this.attributes.forEach(function (attribute) {
            if (attribute.type === 'Attribute' && attribute.value !== true) {
                attribute.value.forEach(function (chunk) {
                    if (chunk.type !== 'Text') {
                        var dependencies = chunk.metadata.dependencies;
                        block.addDependencies(dependencies);
                    }
                });
            }
            else {
                if (attribute.type === 'EventHandler' && attribute.expression) {
                    attribute.expression.arguments.forEach(function (arg) {
                        block.addDependencies(arg.metadata.dependencies);
                    });
                }
                else if (attribute.type === 'Binding') {
                    block.addDependencies(attribute.metadata.dependencies);
                }
            }
        });
        this["var"] = block.getUniqueName((this.name === ':Self' ? this.generator.name :
            this.name === ':Component' ? 'switch_instance' :
                this.name).toLowerCase());
        if (this.children.length) {
            this._slots = new Set(['default']);
            this.children.forEach(function (child) {
                child.init(block, stripWhitespace, nextSibling);
            });
        }
    };
    Component.prototype.build = function (block, parentNode, parentNodes) {
        var _this = this;
        var generator = this.generator;
        generator.hasComponents = true;
        var name = this["var"];
        var componentInitProperties = ["root: #component.root"];
        if (this.children.length > 0) {
            var slots = Array.from(this._slots).map(function (name) { return name + ": @createFragment()"; });
            componentInitProperties.push("slots: { " + slots.join(', ') + " }");
            this.children.forEach(function (child) {
                child.build(block, _this["var"] + "._slotted.default", 'nodes');
            });
        }
        var allContexts = new Set();
        var statements = [];
        var name_context = block.getUniqueName(name + "_context");
        var name_updating;
        var name_initial_data;
        var beforecreate = null;
        var attributes = this.attributes
            .filter(function (a) { return a.type === 'Attribute'; })
            .map(function (a) { return mungeAttribute(a, block); });
        var bindings = this.attributes
            .filter(function (a) { return a.type === 'Binding'; })
            .map(function (a) { return mungeBinding(a, block); });
        var eventHandlers = this.attributes
            .filter(function (a) { return a.type === 'EventHandler'; })
            .map(function (a) { return mungeEventHandler(generator, _this, a, block, name_context, allContexts); });
        var ref = this.attributes.find(function (a) { return a.type === 'Ref'; });
        if (ref)
            generator.usesRefs = true;
        var updates = [];
        if (attributes.length || bindings.length) {
            var initialProps = attributes
                .map(function (attribute) { return attribute.name + ": " + attribute.value; });
            var initialPropString = stringifyProps(initialProps);
            attributes
                .filter(function (attribute) { return attribute.dynamic; })
                .forEach(function (attribute) {
                if (attribute.dependencies.length) {
                    updates.push(deindent(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject(["\n\t\t\t\t\t\t\tif (", ") ", "_changes.", " = ", ";\n\t\t\t\t\t\t"], ["\n\t\t\t\t\t\t\tif (",
                        ") ", "_changes.", " = ", ";\n\t\t\t\t\t\t"])), attribute.dependencies
                        .map(function (dependency) { return "changed." + dependency; })
                        .join(' || '), name, attribute.name, attribute.value));
                }
                else {
                    // TODO this is an odd situation to encounter – I *think* it should only happen with
                    // each block indices, in which case it may be possible to optimise this
                    updates.push(name + "_changes." + attribute.name + " = " + attribute.value + ";");
                }
            });
            if (bindings.length) {
                generator.hasComplexBindings = true;
                name_updating = block.alias(name + "_updating");
                name_initial_data = block.getUniqueName(name + "_initial_data");
                block.addVariable(name_updating, '{}');
                statements.push("var " + name_initial_data + " = " + initialPropString + ";");
                var setParentFromChildOnChange_1 = new CodeBuilder();
                var setParentFromChildOnInit_1 = new CodeBuilder();
                bindings.forEach(function (binding) {
                    var setParentFromChild;
                    binding.contexts.forEach(function (context) {
                        allContexts.add(context);
                    });
                    var key = getObject(binding.value).name;
                    if (block.contexts.has(key)) {
                        var prop = binding.dependencies[0];
                        var computed = isComputed$1(binding.value);
                        var tail = binding.value.type === 'MemberExpression' ? getTailSnippet(binding.value) : '';
                        setParentFromChild = deindent(templateObject_2$5 || (templateObject_2$5 = __makeTemplateObject(["\n\t\t\t\t\t\t\tvar list = ", ".", ";\n\t\t\t\t\t\t\tvar index = ", ".", ";\n\t\t\t\t\t\t\tlist[index]", " = childState.", ";\n\n\t\t\t\t\t\t\t", "\n\t\t\t\t\t\t"], ["\n\t\t\t\t\t\t\tvar list = ", ".", ";\n\t\t\t\t\t\t\tvar index = ", ".", ";\n\t\t\t\t\t\t\tlist[index]", " = childState.", ";\n\n\t\t\t\t\t\t\t",
                            "\n\t\t\t\t\t\t"])), name_context, block.listNames.get(key), name_context, block.indexNames.get(key), tail, binding.name, binding.dependencies
                            .map(function (prop) { return "newState." + prop + " = state." + prop + ";"; })
                            .join('\n'));
                    }
                    else if (binding.value.type === 'MemberExpression') {
                        setParentFromChild = deindent(templateObject_3$5 || (templateObject_3$5 = __makeTemplateObject(["\n\t\t\t\t\t\t\t", " = childState.", ";\n\t\t\t\t\t\t\t", "\n\t\t\t\t\t\t"], ["\n\t\t\t\t\t\t\t", " = childState.", ";\n\t\t\t\t\t\t\t", "\n\t\t\t\t\t\t"])), binding.snippet, binding.name, binding.dependencies.map(function (prop) { return "newState." + prop + " = state." + prop + ";"; }).join('\n'));
                    }
                    else {
                        setParentFromChild = "newState." + binding.value.name + " = childState." + binding.name + ";";
                    }
                    statements.push(deindent(templateObject_4$5 || (templateObject_4$5 = __makeTemplateObject(["\n\t\t\t\t\t\tif (", " in ", ") {\n\t\t\t\t\t\t\t", ".", " = ", ";\n\t\t\t\t\t\t\t", ".", " = true;\n\t\t\t\t\t\t}"], ["\n\t\t\t\t\t\tif (", " in ", ") {\n\t\t\t\t\t\t\t", ".", " = ", ";\n\t\t\t\t\t\t\t", ".", " = true;\n\t\t\t\t\t\t}"])), binding.prop, binding.obj, name_initial_data, binding.name, binding.snippet, name_updating, binding.name));
                    setParentFromChildOnChange_1.addConditional("!" + name_updating + "." + binding.name + " && changed." + binding.name, setParentFromChild);
                    setParentFromChildOnInit_1.addConditional("!" + name_updating + "." + binding.name, setParentFromChild);
                    // TODO could binding.dependencies.length ever be 0?
                    if (binding.dependencies.length) {
                        updates.push(deindent(templateObject_5$3 || (templateObject_5$3 = __makeTemplateObject(["\n\t\t\t\t\t\t\tif (!", ".", " && ", ") {\n\t\t\t\t\t\t\t\t", "_changes.", " = ", ";\n\t\t\t\t\t\t\t\t", ".", " = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t"], ["\n\t\t\t\t\t\t\tif (!", ".", " && ", ") {\n\t\t\t\t\t\t\t\t", "_changes.", " = ", ";\n\t\t\t\t\t\t\t\t", ".", " = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t"])), name_updating, binding.name, binding.dependencies.map(function (dependency) { return "changed." + dependency; }).join(' || '), name, binding.name, binding.snippet, name_updating, binding.name));
                    }
                });
                componentInitProperties.push("data: " + name_initial_data);
                componentInitProperties.push(deindent(templateObject_6$3 || (templateObject_6$3 = __makeTemplateObject(["\n\t\t\t\t\t_bind: function(changed, childState) {\n\t\t\t\t\t\tvar state = #component.get(), newState = {};\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", " = @assign({}, changed);\n\t\t\t\t\t\t#component._set(newState);\n\t\t\t\t\t\t", " = {};\n\t\t\t\t\t}\n\t\t\t\t"], ["\n\t\t\t\t\t_bind: function(changed, childState) {\n\t\t\t\t\t\tvar state = #component.get(), newState = {};\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", " = @assign({}, changed);\n\t\t\t\t\t\t#component._set(newState);\n\t\t\t\t\t\t", " = {};\n\t\t\t\t\t}\n\t\t\t\t"])), setParentFromChildOnChange_1, name_updating, name_updating));
                beforecreate = deindent(templateObject_7$2 || (templateObject_7$2 = __makeTemplateObject(["\n\t\t\t\t\t#component.root._beforecreate.push(function() {\n\t\t\t\t\t\tvar state = #component.get(), childState = ", ".get(), newState = {};\n\t\t\t\t\t\tif (!childState) return;\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", " = { ", " };\n\t\t\t\t\t\t#component._set(newState);\n\t\t\t\t\t\t", " = {};\n\t\t\t\t\t});\n\t\t\t\t"], ["\n\t\t\t\t\t#component.root._beforecreate.push(function() {\n\t\t\t\t\t\tvar state = #component.get(), childState = ", ".get(), newState = {};\n\t\t\t\t\t\tif (!childState) return;\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", " = { ", " };\n\t\t\t\t\t\t#component._set(newState);\n\t\t\t\t\t\t", " = {};\n\t\t\t\t\t});\n\t\t\t\t"])), name, setParentFromChildOnInit_1, name_updating, bindings.map(function (binding) { return binding.name + ": true"; }).join(', '), name_updating);
            }
            else if (initialProps.length) {
                componentInitProperties.push("data: " + initialPropString);
            }
        }
        var isDynamicComponent = this.name === ':Component';
        var switch_vars = isDynamicComponent && {
            value: block.getUniqueName('switch_value'),
            props: block.getUniqueName('switch_props')
        };
        var expression = (this.name === ':Self' ? generator.name :
            isDynamicComponent ? switch_vars.value :
                "%components-" + this.name);
        if (isDynamicComponent) {
            block.contextualise(this.expression);
            var _a = this.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
            var anchor = this.getOrCreateAnchor(block, parentNode, parentNodes);
            var params = block.params.join(', ');
            block.builders.init.addBlock(deindent(templateObject_8$2 || (templateObject_8$2 = __makeTemplateObject(["\n\t\t\t\tvar ", " = ", ";\n\n\t\t\t\tfunction ", "(", ") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t", "\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (", ") {\n\t\t\t\t\t", "\n\t\t\t\t\tvar ", " = new ", "(", "(", "));\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\n\t\t\t\t", "\n\t\t\t"], ["\n\t\t\t\tvar ", " = ", ";\n\n\t\t\t\tfunction ", "(", ") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\t", "\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (", ") {\n\t\t\t\t\t", "\n\t\t\t\t\tvar ", " = new ", "(", "(", "));\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\n\t\t\t\t",
                "\n\t\t\t"])), switch_vars.value, snippet, switch_vars.props, params, componentInitProperties.join(',\n'), switch_vars.value, statements.length > 0 && statements.join('\n'), name, expression, switch_vars.props, params, beforecreate, eventHandlers.map(function (handler) { return deindent(templateObject_9$1 || (templateObject_9$1 = __makeTemplateObject(["\n\t\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\n\t\t\t\t\tif (", ") ", ".on(\"", "\", ", ");\n\t\t\t\t"], ["\n\t\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\n\t\t\t\t\tif (", ") ", ".on(\"", "\", ", ");\n\t\t\t\t"])), handler["var"], handler.body, name, name, handler.name, handler["var"]); })));
            block.builders.create.addLine("if (" + name + ") " + name + "._fragment.c();");
            if (parentNodes) {
                block.builders.claim.addLine("if (" + name + ") " + name + "._fragment.l(" + parentNodes + ");");
            }
            block.builders.mount.addLine("if (" + name + ") " + name + "._mount(" + (parentNode || '#target') + ", " + (parentNode ? 'null' : 'anchor') + ");");
            var updateMountNode = this.getUpdateMountNode(anchor);
            block.builders.update.addBlock(deindent(templateObject_10$1 || (templateObject_10$1 = __makeTemplateObject(["\n\t\t\t\tif (", " !== (", " = ", ")) {\n\t\t\t\t\tif (", ") ", ".destroy();\n\n\t\t\t\t\tif (", ") {\n\t\t\t\t\t\t", " = new ", "(", "(", "));\n\t\t\t\t\t\t", "._fragment.c();\n\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", "._mount(", ", ", ");\n\n\t\t\t\t\t\t", "\n\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", " !== (", " = ", ")) {\n\t\t\t\t\tif (", ") ", ".destroy();\n\n\t\t\t\t\tif (", ") {\n\t\t\t\t\t\t", " = new ", "(", "(", "));\n\t\t\t\t\t\t", "._fragment.c();\n\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", "._mount(", ", ", ");\n\n\t\t\t\t\t\t",
                "\n\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\n\t\t\t\t\t",
                "\n\t\t\t\t}\n\t\t\t"])), switch_vars.value, switch_vars.value, snippet, name, name, switch_vars.value, name, switch_vars.value, switch_vars.props, params, name, this.children.map(function (child) { return remount(generator, child, name); }), name, updateMountNode, anchor, eventHandlers.map(function (handler) { return deindent(templateObject_11$1 || (templateObject_11$1 = __makeTemplateObject(["\n\t\t\t\t\t\t\t", ".on(\"", "\", ", ");\n\t\t\t\t\t\t"], ["\n\t\t\t\t\t\t\t", ".on(\"", "\", ", ");\n\t\t\t\t\t\t"])), name, handler.name, handler["var"]); }), ref && "#component.refs." + ref.name + " = " + name + ";", ref && deindent(templateObject_12$1 || (templateObject_12$1 = __makeTemplateObject(["\n\t\t\t\t\t\telse if (#component.refs.", " === ", ") {\n\t\t\t\t\t\t\t#component.refs.", " = null;\n\t\t\t\t\t\t}"], ["\n\t\t\t\t\t\telse if (#component.refs.", " === ", ") {\n\t\t\t\t\t\t\t#component.refs.", " = null;\n\t\t\t\t\t\t}"])), ref.name, name, ref.name)));
            if (updates.length) {
                block.builders.update.addBlock(deindent(templateObject_13$1 || (templateObject_13$1 = __makeTemplateObject(["\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar ", "_changes = {};\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", "._set(", "_changes);\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\t\t\t\t"], ["\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar ", "_changes = {};\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", "._set(", "_changes);\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\t\t\t\t"])), name, updates.join('\n'), name, name, bindings.length && name_updating + " = {};"));
            }
            if (!parentNode)
                block.builders.unmount.addLine("if (" + name + ") " + name + "._unmount();");
            block.builders.destroy.addLine("if (" + name + ") " + name + ".destroy(false);");
        }
        else {
            block.builders.init.addBlock(deindent(templateObject_14$1 || (templateObject_14$1 = __makeTemplateObject(["\n\t\t\t\t", "\n\t\t\t\tvar ", " = new ", "({\n\t\t\t\t\t", "\n\t\t\t\t});\n\n\t\t\t\t", "\n\n\t\t\t\t", "\n\n\t\t\t\t", "\n\t\t\t"], ["\n\t\t\t\t", "\n\t\t\t\tvar ", " = new ", "({\n\t\t\t\t\t", "\n\t\t\t\t});\n\n\t\t\t\t", "\n\n\t\t\t\t",
                "\n\n\t\t\t\t", "\n\t\t\t"])), statements.join('\n'), name, expression, componentInitProperties.join(',\n'), beforecreate, eventHandlers.map(function (handler) { return deindent(templateObject_15$1 || (templateObject_15$1 = __makeTemplateObject(["\n\t\t\t\t\t", ".on(\"", "\", function(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t});\n\t\t\t\t"], ["\n\t\t\t\t\t", ".on(\"", "\", function(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t});\n\t\t\t\t"])), name, handler.name, handler.body); }), ref && "#component.refs." + ref.name + " = " + name + ";"));
            block.builders.create.addLine(name + "._fragment.c();");
            if (parentNodes) {
                block.builders.claim.addLine(name + "._fragment.l(" + parentNodes + ");");
            }
            block.builders.mount.addLine(name + "._mount(" + (parentNode || '#target') + ", " + (parentNode ? 'null' : 'anchor') + ");");
            if (updates.length) {
                block.builders.update.addBlock(deindent(templateObject_16$1 || (templateObject_16$1 = __makeTemplateObject(["\n\t\t\t\t\tvar ", "_changes = {};\n\t\t\t\t\t", "\n\t\t\t\t\t", "._set(", "_changes);\n\t\t\t\t\t", "\n\t\t\t\t"], ["\n\t\t\t\t\tvar ", "_changes = {};\n\t\t\t\t\t", "\n\t\t\t\t\t", "._set(", "_changes);\n\t\t\t\t\t", "\n\t\t\t\t"])), name, updates.join('\n'), name, name, bindings.length && name_updating + " = {};"));
            }
            if (!parentNode)
                block.builders.unmount.addLine(name + "._unmount();");
            block.builders.destroy.addLine(deindent(templateObject_17$1 || (templateObject_17$1 = __makeTemplateObject(["\n\t\t\t\t", ".destroy(false);\n\t\t\t\t", "\n\t\t\t"], ["\n\t\t\t\t", ".destroy(false);\n\t\t\t\t", "\n\t\t\t"])), name, ref && "if (#component.refs." + ref.name + " === " + name + ") #component.refs." + ref.name + " = null;"));
        }
        // maintain component context
        if (allContexts.size) {
            var contexts = Array.from(allContexts);
            var initialProps = contexts
                .map(function (contextName) {
                if (contextName === 'state')
                    return "state: state";
                var listName = block.listNames.get(contextName);
                var indexName = block.indexNames.get(contextName);
                return listName + ": " + listName + ",\n" + indexName + ": " + indexName;
            })
                .join(',\n');
            var updates_1 = contexts
                .map(function (contextName) {
                if (contextName === 'state')
                    return name_context + ".state = state;";
                var listName = block.listNames.get(contextName);
                var indexName = block.indexNames.get(contextName);
                return name_context + "." + listName + " = " + listName + ";\n" + name_context + "." + indexName + " = " + indexName + ";";
            })
                .join('\n');
            block.builders.init.addBlock(deindent(templateObject_18$1 || (templateObject_18$1 = __makeTemplateObject(["\n\t\t\t\tvar ", " = {\n\t\t\t\t\t", "\n\t\t\t\t};\n\t\t\t"], ["\n\t\t\t\tvar ", " = {\n\t\t\t\t\t", "\n\t\t\t\t};\n\t\t\t"])), name_context, initialProps));
            block.builders.update.addBlock(updates_1);
        }
    };
    return Component;
}(Node$1));
function mungeAttribute(attribute, block) {
    if (attribute.value === true) {
        // attributes without values, e.g. <textarea readonly>
        return {
            name: attribute.name,
            value: true,
            dynamic: false
        };
    }
    if (attribute.value.length === 0) {
        return {
            name: attribute.name,
            value: "''",
            dynamic: false
        };
    }
    if (attribute.value.length === 1) {
        var value_1 = attribute.value[0];
        if (value_1.type === 'Text') {
            // static attributes
            return {
                name: attribute.name,
                value: isNaN(value_1.data) ? stringify(value_1.data) : value_1.data,
                dynamic: false
            };
        }
        // simple dynamic attributes
        block.contextualise(value_1.expression); // TODO remove
        var _a = value_1.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
        // TODO only update attributes that have changed
        return {
            name: attribute.name,
            value: snippet,
            dependencies: dependencies,
            dynamic: true
        };
    }
    // otherwise we're dealing with a complex dynamic attribute
    var allDependencies = new Set();
    var value = (attribute.value[0].type === 'Text' ? '' : "\"\" + ") +
        attribute.value
            .map(function (chunk) {
            if (chunk.type === 'Text') {
                return stringify(chunk.data);
            }
            else {
                block.contextualise(chunk.expression); // TODO remove
                var _a = chunk.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
                dependencies.forEach(function (dependency) {
                    allDependencies.add(dependency);
                });
                return getExpressionPrecedence(chunk.expression) <= 13 ? "(" + snippet + ")" : snippet;
            }
        })
            .join(' + ');
    return {
        name: attribute.name,
        value: value,
        dependencies: Array.from(allDependencies),
        dynamic: true
    };
}
function mungeBinding(binding, block) {
    var name = getObject(binding.value).name;
    var contexts = block.contextualise(binding.value).contexts;
    var _a = binding.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
    var contextual = block.contexts.has(name);
    var obj;
    var prop;
    if (contextual) {
        obj = block.listNames.get(name);
        prop = block.indexNames.get(name);
    }
    else if (binding.value.type === 'MemberExpression') {
        prop = "[\u2702" + binding.value.property.start + "-" + binding.value.property.end + "\u2702]";
        if (!binding.value.computed)
            prop = "'" + prop + "'";
        obj = "[\u2702" + binding.value.object.start + "-" + binding.value.object.end + "\u2702]";
    }
    else {
        obj = 'state';
        prop = "'" + name + "'";
    }
    return {
        name: binding.name,
        value: binding.value,
        contexts: contexts,
        snippet: snippet,
        obj: obj,
        prop: prop,
        dependencies: dependencies
    };
}
function mungeEventHandler(generator, node, handler, block, name_context, allContexts) {
    var body;
    if (handler.expression) {
        generator.addSourcemapLocations(handler.expression);
        generator.code.prependRight(handler.expression.start, block.alias('component') + ".");
        var usedContexts_1 = [];
        handler.expression.arguments.forEach(function (arg) {
            var contexts = block.contextualise(arg, null, true).contexts;
            contexts.forEach(function (context) {
                if (!~usedContexts_1.indexOf(context))
                    usedContexts_1.push(context);
                allContexts.add(context);
            });
        });
        // TODO hoist event handlers? can do `this.__component.method(...)`
        var declarations = usedContexts_1.map(function (name) {
            if (name === 'state')
                return "var state = " + name_context + ".state;";
            var listName = block.listNames.get(name);
            var indexName = block.indexNames.get(name);
            return "var " + listName + " = " + name_context + "." + listName + ", " + indexName + " = " + name_context + "." + indexName + ", " + name + " = " + listName + "[" + indexName + "]";
        });
        body = deindent(templateObject_19$1 || (templateObject_19$1 = __makeTemplateObject(["\n\t\t\t", "\n\n\t\t\t[\u2702", "-", "\u2702];\n\t\t"], ["\n\t\t\t", "\n\n\t\t\t[\u2702", "-", "\u2702];\n\t\t"])), declarations, handler.expression.start, handler.expression.end);
    }
    else {
        body = deindent(templateObject_20 || (templateObject_20 = __makeTemplateObject(["\n\t\t\t", ".fire('", "', event);\n\t\t"], ["\n\t\t\t", ".fire('", "', event);\n\t\t"])), block.alias('component'), handler.name);
    }
    return {
        name: handler.name,
        "var": block.getUniqueName(node["var"] + "_" + handler.name),
        body: body
    };
}
function isComputed$1(node) {
    while (node.type === 'MemberExpression') {
        if (node.computed)
            return true;
        node = node.object;
    }
    return false;
}
function remount(generator, node, name) {
    // TODO make this a method of the nodes
    if (node.type === 'Component') {
        return node["var"] + "._mount(" + name + "._slotted.default, null);";
    }
    if (node.type === 'Element') {
        var slot = node.attributes.find(function (attribute) { return attribute.name === 'slot'; });
        if (slot) {
            return "@appendNode(" + node["var"] + ", " + name + "._slotted." + node.getStaticAttributeValue('slot') + ");";
        }
        return "@appendNode(" + node["var"] + ", " + name + "._slotted.default);";
    }
    if (node.type === 'Text' || node.type === 'MustacheTag' || node.type === 'RawMustacheTag') {
        return "@appendNode(" + node["var"] + ", " + name + "._slotted.default);";
    }
    if (node.type === 'EachBlock') {
        // TODO consider keyed blocks
        return "for (var #i = 0; #i < " + node.iterations + ".length; #i += 1) " + node.iterations + "[#i].m(" + name + "._slotted.default, null);";
    }
    return node["var"] + ".m(" + name + "._slotted.default, null);";
}
var templateObject_1$5;
var templateObject_2$5;
var templateObject_3$5;
var templateObject_4$5;
var templateObject_5$3;
var templateObject_6$3;
var templateObject_7$2;
var templateObject_9$1;
var templateObject_8$2;
var templateObject_11$1;
var templateObject_12$1;
var templateObject_10$1;
var templateObject_13$1;
var templateObject_15$1;
var templateObject_14$1;
var templateObject_16$1;
var templateObject_17$1;
var templateObject_18$1;
var templateObject_19$1;
var templateObject_20;

var EachBlock = /** @class */ (function (_super) {
    __extends(EachBlock, _super);
    function EachBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    EachBlock.prototype.init = function (block, stripWhitespace, nextSibling) {
        this.cannotUseInnerHTML();
        this["var"] = block.getUniqueName("each");
        this.iterations = block.getUniqueName(this["var"] + "_blocks");
        var dependencies = this.metadata.dependencies;
        block.addDependencies(dependencies);
        var indexNames = new Map(block.indexNames);
        var indexName = this.index || block.getUniqueName(this.context + "_index");
        indexNames.set(this.context, indexName);
        var listNames = new Map(block.listNames);
        var listName = block.getUniqueName((this.expression.type === 'MemberExpression' && !this.expression.computed) ? this.expression.property.name :
            this.expression.type === 'Identifier' ? this.expression.name :
                "each_value");
        listNames.set(this.context, listName);
        var context = block.getUniqueName(this.context);
        var contexts = new Map(block.contexts);
        contexts.set(this.context, context);
        var indexes = new Map(block.indexes);
        if (this.index)
            indexes.set(this.index, this.context);
        var changeableIndexes = new Map(block.changeableIndexes);
        if (this.index)
            changeableIndexes.set(this.index, this.key);
        if (this.destructuredContexts) {
            for (var i = 0; i < this.destructuredContexts.length; i += 1) {
                contexts.set(this.destructuredContexts[i], context + "[" + i + "]");
            }
        }
        this.block = block.child({
            comment: createDebuggingComment(this, this.generator),
            name: this.generator.getUniqueName('create_each_block'),
            context: this.context,
            key: this.key,
            contexts: contexts,
            indexes: indexes,
            changeableIndexes: changeableIndexes,
            listName: listName,
            indexName: indexName,
            indexNames: indexNames,
            listNames: listNames,
            params: block.params.concat(listName, context, indexName)
        });
        this.generator.blocks.push(this.block);
        this.initChildren(this.block, stripWhitespace, nextSibling);
        block.addDependencies(this.block.dependencies);
        this.block.hasUpdateMethod = this.block.dependencies.size > 0;
        if (this["else"]) {
            this["else"].block = block.child({
                comment: createDebuggingComment(this["else"], this.generator),
                name: this.generator.getUniqueName(this.block.name + "_else")
            });
            this.generator.blocks.push(this["else"].block);
            this["else"].initChildren(this["else"].block, stripWhitespace, nextSibling);
            this["else"].block.hasUpdateMethod = this["else"].block.dependencies.size > 0;
        }
    };
    EachBlock.prototype.build = function (block, parentNode, parentNodes) {
        var _this = this;
        var generator = this.generator;
        var each = this["var"];
        var create_each_block = this.block.name;
        var each_block_value = this.block.listName;
        var iterations = this.iterations;
        var params = block.params.join(', ');
        var needsAnchor = this.next ? !this.next.isDomNode() : !parentNode || !this.parent.isDomNode();
        var anchor = needsAnchor
            ? block.getUniqueName(each + "_anchor")
            : (this.next && this.next["var"]) || 'null';
        // hack the sourcemap, so that if data is missing the bug
        // is easy to find
        var c = this.start + 3;
        while (generator.source[c] !== 'e')
            c += 1;
        generator.code.overwrite(c, c + 4, 'length');
        var length = "[\u2702" + c + "-" + (c + 4) + "\u2702]";
        var mountOrIntro = this.block.hasIntroMethod ? 'i' : 'm';
        var vars = {
            each: each,
            create_each_block: create_each_block,
            each_block_value: each_block_value,
            length: length,
            iterations: iterations,
            params: params,
            anchor: anchor,
            mountOrIntro: mountOrIntro
        };
        block.contextualise(this.expression);
        var snippet = this.metadata.snippet;
        block.builders.init.addLine("var " + each_block_value + " = " + snippet + ";");
        if (this.key) {
            this.buildKeyed(block, parentNode, parentNodes, snippet, vars);
        }
        else {
            this.buildUnkeyed(block, parentNode, parentNodes, snippet, vars);
        }
        if (needsAnchor) {
            block.addElement(anchor, "@createComment()", parentNodes && "@createComment()", parentNode);
        }
        if (this["else"]) {
            var each_block_else = generator.getUniqueName(each + "_else");
            block.builders.init.addLine("var " + each_block_else + " = null;");
            // TODO neaten this up... will end up with an empty line in the block
            block.builders.init.addBlock(deindent(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject(["\n\t\t\t\tif (!", ".", ") {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t", ".c();\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (!", ".", ") {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t", ".c();\n\t\t\t\t}\n\t\t\t"])), each_block_value, length, each_block_else, this["else"].block.name, params, each_block_else));
            block.builders.mount.addBlock(deindent(templateObject_2$6 || (templateObject_2$6 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".", "(", ", null);\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".", "(", ", null);\n\t\t\t\t}\n\t\t\t"])), each_block_else, each_block_else, mountOrIntro, parentNode || '#target'));
            var initialMountNode = parentNode || anchor + ".parentNode";
            if (this["else"].block.hasUpdateMethod) {
                block.builders.update.addBlock(deindent(templateObject_3$6 || (templateObject_3$6 = __makeTemplateObject(["\n\t\t\t\t\tif (!", ".", " && ", ") {\n\t\t\t\t\t\t", ".p( changed, ", " );\n\t\t\t\t\t} else if (!", ".", ") {\n\t\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t\t", ".c();\n\t\t\t\t\t\t", ".", "(", ", ", ");\n\t\t\t\t\t} else if (", ") {\n\t\t\t\t\t\t", ".u();\n\t\t\t\t\t\t", ".d();\n\t\t\t\t\t\t", " = null;\n\t\t\t\t\t}\n\t\t\t\t"], ["\n\t\t\t\t\tif (!", ".", " && ", ") {\n\t\t\t\t\t\t", ".p( changed, ", " );\n\t\t\t\t\t} else if (!", ".", ") {\n\t\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t\t", ".c();\n\t\t\t\t\t\t", ".", "(", ", ", ");\n\t\t\t\t\t} else if (", ") {\n\t\t\t\t\t\t", ".u();\n\t\t\t\t\t\t", ".d();\n\t\t\t\t\t\t", " = null;\n\t\t\t\t\t}\n\t\t\t\t"])), each_block_value, length, each_block_else, each_block_else, params, each_block_value, length, each_block_else, this["else"].block.name, params, each_block_else, each_block_else, mountOrIntro, initialMountNode, anchor, each_block_else, each_block_else, each_block_else, each_block_else));
            }
            else {
                block.builders.update.addBlock(deindent(templateObject_4$6 || (templateObject_4$6 = __makeTemplateObject(["\n\t\t\t\t\tif (", ".", ") {\n\t\t\t\t\t\tif (", ") {\n\t\t\t\t\t\t\t", ".u();\n\t\t\t\t\t\t\t", ".d();\n\t\t\t\t\t\t\t", " = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!", ") {\n\t\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t\t", ".c();\n\t\t\t\t\t\t", ".", "(", ", ", ");\n\t\t\t\t\t}\n\t\t\t\t"], ["\n\t\t\t\t\tif (", ".", ") {\n\t\t\t\t\t\tif (", ") {\n\t\t\t\t\t\t\t", ".u();\n\t\t\t\t\t\t\t", ".d();\n\t\t\t\t\t\t\t", " = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (!", ") {\n\t\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t\t", ".c();\n\t\t\t\t\t\t", ".", "(", ", ", ");\n\t\t\t\t\t}\n\t\t\t\t"])), each_block_value, length, each_block_else, each_block_else, each_block_else, each_block_else, each_block_else, each_block_else, this["else"].block.name, params, each_block_else, each_block_else, mountOrIntro, initialMountNode, anchor));
            }
            block.builders.unmount.addLine("if (" + each_block_else + ") " + each_block_else + ".u()");
            block.builders.destroy.addBlock(deindent(templateObject_5$4 || (templateObject_5$4 = __makeTemplateObject(["\n\t\t\t\tif (", ") ", ".d();\n\t\t\t"], ["\n\t\t\t\tif (", ") ", ".d();\n\t\t\t"])), each_block_else, each_block_else));
        }
        this.children.forEach(function (child) {
            child.build(_this.block, null, 'nodes');
        });
        if (this["else"]) {
            this["else"].children.forEach(function (child) {
                child.build(_this["else"].block, null, 'nodes');
            });
        }
    };
    EachBlock.prototype.buildKeyed = function (block, parentNode, parentNodes, snippet, _a) {
        var each = _a.each, create_each_block = _a.create_each_block, each_block_value = _a.each_block_value, length = _a.length, params = _a.params, anchor = _a.anchor, mountOrIntro = _a.mountOrIntro;
        var key = block.getUniqueName('key');
        var lookup = block.getUniqueName(each + "_lookup");
        var iteration = block.getUniqueName(each + "_iteration");
        var head = block.getUniqueName(each + "_head");
        var last = block.getUniqueName(each + "_last");
        var expected = block.getUniqueName(each + "_expected");
        block.addVariable(lookup, "@blankObject()");
        block.addVariable(head);
        block.addVariable(last);
        if (this.children[0].isDomNode()) {
            this.block.first = this.children[0]["var"];
        }
        else {
            this.block.first = this.block.getUniqueName('first');
            this.block.addElement(this.block.first, "@createComment()", parentNodes && "@createComment()", null);
        }
        block.builders.init.addBlock(deindent(templateObject_6$4 || (templateObject_6$4 = __makeTemplateObject(["\n\t\t\tfor (var #i = 0; #i < ", ".", "; #i += 1) {\n\t\t\t\tvar ", " = ", "[#i].", ";\n\t\t\t\tvar ", " = ", "[", "] = ", "(", ", ", ", ", "[#i], #i, #component, ", ");\n\n\t\t\t\tif (", ") ", ".next = ", ";\n\t\t\t\t", ".last = ", ";\n\t\t\t\t", " = ", ";\n\n\t\t\t\tif (#i === 0) ", " = ", ";\n\t\t\t}\n\t\t"], ["\n\t\t\tfor (var #i = 0; #i < ", ".", "; #i += 1) {\n\t\t\t\tvar ", " = ", "[#i].", ";\n\t\t\t\tvar ", " = ", "[", "] = ", "(", ", ", ", ", "[#i], #i, #component, ", ");\n\n\t\t\t\tif (", ") ", ".next = ", ";\n\t\t\t\t", ".last = ", ";\n\t\t\t\t", " = ", ";\n\n\t\t\t\tif (#i === 0) ", " = ", ";\n\t\t\t}\n\t\t"])), each_block_value, length, key, each_block_value, this.key, iteration, lookup, key, create_each_block, params, each_block_value, each_block_value, key, last, last, iteration, iteration, last, last, iteration, head, iteration));
        var initialMountNode = parentNode || '#target';
        var updateMountNode = this.getUpdateMountNode(anchor);
        var anchorNode = parentNode ? 'null' : 'anchor';
        block.builders.create.addBlock(deindent(templateObject_7$3 || (templateObject_7$3 = __makeTemplateObject(["\n\t\t\tvar ", " = ", ";\n\t\t\twhile (", ") {\n\t\t\t\t", ".c();\n\t\t\t\t", " = ", ".next;\n\t\t\t}\n\t\t"], ["\n\t\t\tvar ", " = ", ";\n\t\t\twhile (", ") {\n\t\t\t\t", ".c();\n\t\t\t\t", " = ", ".next;\n\t\t\t}\n\t\t"])), iteration, head, iteration, iteration, iteration, iteration));
        if (parentNodes) {
            block.builders.claim.addBlock(deindent(templateObject_8$3 || (templateObject_8$3 = __makeTemplateObject(["\n\t\t\t\tvar ", " = ", ";\n\t\t\t\twhile (", ") {\n\t\t\t\t\t", ".l(", ");\n\t\t\t\t\t", " = ", ".next;\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tvar ", " = ", ";\n\t\t\t\twhile (", ") {\n\t\t\t\t\t", ".l(", ");\n\t\t\t\t\t", " = ", ".next;\n\t\t\t\t}\n\t\t\t"])), iteration, head, iteration, iteration, parentNodes, iteration, iteration));
        }
        block.builders.mount.addBlock(deindent(templateObject_9$2 || (templateObject_9$2 = __makeTemplateObject(["\n\t\t\tvar ", " = ", ";\n\t\t\twhile (", ") {\n\t\t\t\t", ".", "(", ", ", ");\n\t\t\t\t", " = ", ".next;\n\t\t\t}\n\t\t"], ["\n\t\t\tvar ", " = ", ";\n\t\t\twhile (", ") {\n\t\t\t\t", ".", "(", ", ", ");\n\t\t\t\t", " = ", ".next;\n\t\t\t}\n\t\t"])), iteration, head, iteration, iteration, mountOrIntro, initialMountNode, anchorNode, iteration, iteration));
        var dynamic = this.block.hasUpdateMethod;
        var destroy;
        if (this.block.hasOutroMethod) {
            var fn = block.getUniqueName(each + "_outro");
            block.builders.init.addBlock(deindent(templateObject_10$2 || (templateObject_10$2 = __makeTemplateObject(["\n\t\t\t\tfunction ", "(iteration) {\n\t\t\t\t\titeration.o(function() {\n\t\t\t\t\t\titeration.u();\n\t\t\t\t\t\titeration.d();\n\t\t\t\t\t\t", "[iteration.key] = null;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tfunction ", "(iteration) {\n\t\t\t\t\titeration.o(function() {\n\t\t\t\t\t\titeration.u();\n\t\t\t\t\t\titeration.d();\n\t\t\t\t\t\t", "[iteration.key] = null;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t"])), fn, lookup));
            destroy = deindent(templateObject_11$2 || (templateObject_11$2 = __makeTemplateObject(["\n\t\t\t\twhile (", ") {\n\t\t\t\t\t", "(", ");\n\t\t\t\t\t", " = ", ".next;\n\t\t\t\t}\n\n\t\t\t\tfor (#i = 0; #i < discard_pile.length; #i += 1) {\n\t\t\t\t\tif (discard_pile[#i].discard) {\n\t\t\t\t\t\t", "(discard_pile[#i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\twhile (", ") {\n\t\t\t\t\t", "(", ");\n\t\t\t\t\t", " = ", ".next;\n\t\t\t\t}\n\n\t\t\t\tfor (#i = 0; #i < discard_pile.length; #i += 1) {\n\t\t\t\t\tif (discard_pile[#i].discard) {\n\t\t\t\t\t\t", "(discard_pile[#i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t"])), expected, fn, expected, expected, expected, fn);
        }
        else {
            var fn = block.getUniqueName(each + "_destroy");
            block.builders.init.addBlock(deindent(templateObject_12$2 || (templateObject_12$2 = __makeTemplateObject(["\n\t\t\t\tfunction ", "(iteration) {\n\t\t\t\t\titeration.u();\n\t\t\t\t\titeration.d();\n\t\t\t\t\t", "[iteration.key] = null;\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tfunction ", "(iteration) {\n\t\t\t\t\titeration.u();\n\t\t\t\t\titeration.d();\n\t\t\t\t\t", "[iteration.key] = null;\n\t\t\t\t}\n\t\t\t"])), fn, lookup));
            destroy = deindent(templateObject_13$2 || (templateObject_13$2 = __makeTemplateObject(["\n\t\t\t\twhile (", ") {\n\t\t\t\t\t", "(", ");\n\t\t\t\t\t", " = ", ".next;\n\t\t\t\t}\n\n\t\t\t\tfor (#i = 0; #i < discard_pile.length; #i += 1) {\n\t\t\t\t\tvar ", " = discard_pile[#i];\n\t\t\t\t\tif (", ".discard) {\n\t\t\t\t\t\t", "(", ");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\twhile (", ") {\n\t\t\t\t\t", "(", ");\n\t\t\t\t\t", " = ", ".next;\n\t\t\t\t}\n\n\t\t\t\tfor (#i = 0; #i < discard_pile.length; #i += 1) {\n\t\t\t\t\tvar ", " = discard_pile[#i];\n\t\t\t\t\tif (", ".discard) {\n\t\t\t\t\t\t", "(", ");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t"])), expected, fn, expected, expected, expected, iteration, iteration, fn, iteration);
        }
        block.builders.update.addBlock(deindent(templateObject_14$2 || (templateObject_14$2 = __makeTemplateObject(["\n\t\t\tvar ", " = ", ";\n\n\t\t\tvar ", " = ", ";\n\t\t\tvar ", " = null;\n\n\t\t\tvar discard_pile = [];\n\n\t\t\tfor (#i = 0; #i < ", ".", "; #i += 1) {\n\t\t\t\tvar ", " = ", "[#i].", ";\n\t\t\t\tvar ", " = ", "[", "];\n\n\t\t\t\t", "\n\n\t\t\t\tif (", ") {\n\t\t\t\t\tif (", " === ", ".key) {\n\t\t\t\t\t\t", " = ", ".next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (", ") {\n\t\t\t\t\t\t\t// probably a deletion\n\t\t\t\t\t\t\twhile (", " && ", ".key !== ", ") {\n\t\t\t\t\t\t\t\t", ".discard = true;\n\t\t\t\t\t\t\t\tdiscard_pile.push(", ");\n\t\t\t\t\t\t\t\t", " = ", ".next;\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t", " = ", " && ", ".next;\n\t\t\t\t\t\t\t", ".discard = false;\n\t\t\t\t\t\t\t", ".last = ", ";\n\n\t\t\t\t\t\t\tif (!", ") ", ".m(", ", ", ");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// key is being inserted\n\t\t\t\t\t\t\t", " = ", "[", "] = ", "(", ", ", ", ", "[#i], #i, #component, ", ");\n\t\t\t\t\t\t\t", ".c();\n\t\t\t\t\t\t\t", ".", "(", ", ", ".first);\n\n\t\t\t\t\t\t\t", ".last = ", ";\n\t\t\t\t\t\t\t", ".next = ", ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// we're appending from this point forward\n\t\t\t\t\tif (", ") {\n\t\t\t\t\t\t", ".discard = false;\n\t\t\t\t\t\t", ".next = null;\n\t\t\t\t\t\t", ".m(", ", ", ");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t", " = ", "[", "] = ", "(", ", ", ", ", "[#i], #i, #component, ", ");\n\t\t\t\t\t\t", ".c();\n\t\t\t\t\t\t", ".", "(", ", ", ");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (", ") ", ".next = ", ";\n\t\t\t\t", ".last = ", ";\n\t\t\t\t", "\n\t\t\t\t", " = ", ";\n\t\t\t}\n\n\t\t\tif (", ") ", ".next = null;\n\n\t\t\t", "\n\n\t\t\t", " = ", "[", "[0] && ", "[0].", "];\n\t\t"], ["\n\t\t\tvar ", " = ", ";\n\n\t\t\tvar ", " = ", ";\n\t\t\tvar ", " = null;\n\n\t\t\tvar discard_pile = [];\n\n\t\t\tfor (#i = 0; #i < ", ".", "; #i += 1) {\n\t\t\t\tvar ", " = ", "[#i].", ";\n\t\t\t\tvar ", " = ", "[", "];\n\n\t\t\t\t",
            "\n\n\t\t\t\tif (", ") {\n\t\t\t\t\tif (", " === ", ".key) {\n\t\t\t\t\t\t", " = ", ".next;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (", ") {\n\t\t\t\t\t\t\t// probably a deletion\n\t\t\t\t\t\t\twhile (", " && ", ".key !== ", ") {\n\t\t\t\t\t\t\t\t", ".discard = true;\n\t\t\t\t\t\t\t\tdiscard_pile.push(", ");\n\t\t\t\t\t\t\t\t", " = ", ".next;\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t", " = ", " && ", ".next;\n\t\t\t\t\t\t\t", ".discard = false;\n\t\t\t\t\t\t\t", ".last = ", ";\n\n\t\t\t\t\t\t\tif (!", ") ", ".m(", ", ", ");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// key is being inserted\n\t\t\t\t\t\t\t", " = ", "[", "] = ", "(", ", ", ", ", "[#i], #i, #component, ", ");\n\t\t\t\t\t\t\t", ".c();\n\t\t\t\t\t\t\t", ".", "(", ", ", ".first);\n\n\t\t\t\t\t\t\t", ".last = ", ";\n\t\t\t\t\t\t\t", ".next = ", ";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// we're appending from this point forward\n\t\t\t\t\tif (", ") {\n\t\t\t\t\t\t", ".discard = false;\n\t\t\t\t\t\t", ".next = null;\n\t\t\t\t\t\t", ".m(", ", ", ");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t", " = ", "[", "] = ", "(", ", ", ", ", "[#i], #i, #component, ", ");\n\t\t\t\t\t\t", ".c();\n\t\t\t\t\t\t", ".", "(", ", ", ");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (", ") ", ".next = ", ";\n\t\t\t\t", ".last = ", ";\n\t\t\t\t", "\n\t\t\t\t", " = ", ";\n\t\t\t}\n\n\t\t\tif (", ") ", ".next = null;\n\n\t\t\t", "\n\n\t\t\t", " = ", "[", "[0] && ", "[0].", "];\n\t\t"])), each_block_value, snippet, expected, head, last, each_block_value, length, key, each_block_value, this.key, iteration, lookup, key, dynamic &&
            "if (" + iteration + ") " + iteration + ".p(changed, " + params + ", " + each_block_value + ", " + each_block_value + "[#i], #i);", expected, key, expected, expected, expected, iteration, expected, expected, key, expected, expected, expected, expected, expected, expected, expected, iteration, iteration, last, expected, iteration, updateMountNode, anchor, iteration, lookup, key, create_each_block, params, each_block_value, each_block_value, key, iteration, iteration, mountOrIntro, updateMountNode, expected, expected, iteration, iteration, expected, iteration, iteration, iteration, iteration, updateMountNode, anchor, iteration, lookup, key, create_each_block, params, each_block_value, each_block_value, key, iteration, iteration, mountOrIntro, updateMountNode, anchor, last, last, iteration, iteration, last, this.block.hasIntroMethod && iteration + ".i(" + updateMountNode + ", " + anchor + ");", last, iteration, last, last, destroy, head, lookup, each_block_value, each_block_value, this.key));
        if (!parentNode) {
            block.builders.unmount.addBlock(deindent(templateObject_15$2 || (templateObject_15$2 = __makeTemplateObject(["\n\t\t\t\tvar ", " = ", ";\n\t\t\t\twhile (", ") {\n\t\t\t\t\t", ".u();\n\t\t\t\t\t", " = ", ".next;\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tvar ", " = ", ";\n\t\t\t\twhile (", ") {\n\t\t\t\t\t", ".u();\n\t\t\t\t\t", " = ", ".next;\n\t\t\t\t}\n\t\t\t"])), iteration, head, iteration, iteration, iteration, iteration));
        }
        block.builders.destroy.addBlock(deindent(templateObject_16$2 || (templateObject_16$2 = __makeTemplateObject(["\n\t\t\tvar ", " = ", ";\n\t\t\twhile (", ") {\n\t\t\t\t", ".d();\n\t\t\t\t", " = ", ".next;\n\t\t\t}\n\t\t"], ["\n\t\t\tvar ", " = ", ";\n\t\t\twhile (", ") {\n\t\t\t\t", ".d();\n\t\t\t\t", " = ", ".next;\n\t\t\t}\n\t\t"])), iteration, head, iteration, iteration, iteration, iteration));
    };
    EachBlock.prototype.buildUnkeyed = function (block, parentNode, parentNodes, snippet, _a) {
        var create_each_block = _a.create_each_block, each_block_value = _a.each_block_value, length = _a.length, iterations = _a.iterations, params = _a.params, anchor = _a.anchor, mountOrIntro = _a.mountOrIntro;
        block.builders.init.addBlock(deindent(templateObject_17$2 || (templateObject_17$2 = __makeTemplateObject(["\n\t\t\tvar ", " = [];\n\n\t\t\tfor (var #i = 0; #i < ", ".", "; #i += 1) {\n\t\t\t\t", "[#i] = ", "(", ", ", ", ", "[#i], #i, #component);\n\t\t\t}\n\t\t"], ["\n\t\t\tvar ", " = [];\n\n\t\t\tfor (var #i = 0; #i < ", ".", "; #i += 1) {\n\t\t\t\t", "[#i] = ", "(", ", ", ", ", "[#i], #i, #component);\n\t\t\t}\n\t\t"])), iterations, each_block_value, length, iterations, create_each_block, params, each_block_value, each_block_value));
        var initialMountNode = parentNode || '#target';
        var updateMountNode = this.getUpdateMountNode(anchor);
        var anchorNode = parentNode ? 'null' : 'anchor';
        block.builders.create.addBlock(deindent(templateObject_18$2 || (templateObject_18$2 = __makeTemplateObject(["\n\t\t\tfor (var #i = 0; #i < ", ".length; #i += 1) {\n\t\t\t\t", "[#i].c();\n\t\t\t}\n\t\t"], ["\n\t\t\tfor (var #i = 0; #i < ", ".length; #i += 1) {\n\t\t\t\t", "[#i].c();\n\t\t\t}\n\t\t"])), iterations, iterations));
        if (parentNodes) {
            block.builders.claim.addBlock(deindent(templateObject_19$2 || (templateObject_19$2 = __makeTemplateObject(["\n\t\t\t\tfor (var #i = 0; #i < ", ".length; #i += 1) {\n\t\t\t\t\t", "[#i].l(", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tfor (var #i = 0; #i < ", ".length; #i += 1) {\n\t\t\t\t\t", "[#i].l(", ");\n\t\t\t\t}\n\t\t\t"])), iterations, iterations, parentNodes));
        }
        block.builders.mount.addBlock(deindent(templateObject_20$1 || (templateObject_20$1 = __makeTemplateObject(["\n\t\t\tfor (var #i = 0; #i < ", ".length; #i += 1) {\n\t\t\t\t", "[#i].", "(", ", ", ");\n\t\t\t}\n\t\t"], ["\n\t\t\tfor (var #i = 0; #i < ", ".length; #i += 1) {\n\t\t\t\t", "[#i].", "(", ", ", ");\n\t\t\t}\n\t\t"])), iterations, iterations, mountOrIntro, initialMountNode, anchorNode));
        var allDependencies = new Set(this.block.dependencies);
        var dependencies = this.metadata.dependencies;
        dependencies.forEach(function (dependency) {
            allDependencies.add(dependency);
        });
        // TODO do this for keyed blocks as well
        var condition = Array.from(allDependencies)
            .map(function (dependency) { return "changed." + dependency; })
            .join(' || ');
        if (condition !== '') {
            var forLoopBody = this.block.hasUpdateMethod
                ? this.block.hasIntroMethod
                    ? deindent(templateObject_21 || (templateObject_21 = __makeTemplateObject(["\n\t\t\t\t\t\tif (", "[#i]) {\n\t\t\t\t\t\t\t", "[#i].p(changed, ", ", ", ", ", "[#i], #i);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t", "[#i] = ", "(", ", ", ", ", "[#i], #i, #component);\n\t\t\t\t\t\t\t", "[#i].c();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t", "[#i].i(", ", ", ");\n\t\t\t\t\t"], ["\n\t\t\t\t\t\tif (", "[#i]) {\n\t\t\t\t\t\t\t", "[#i].p(changed, ", ", ", ", ", "[#i], #i);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t", "[#i] = ", "(", ", ", ", ", "[#i], #i, #component);\n\t\t\t\t\t\t\t", "[#i].c();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t", "[#i].i(", ", ", ");\n\t\t\t\t\t"])), iterations, iterations, params, each_block_value, each_block_value, iterations, create_each_block, params, each_block_value, each_block_value, iterations, iterations, updateMountNode, anchor) : deindent(templateObject_22 || (templateObject_22 = __makeTemplateObject(["\n\t\t\t\t\t\tif (", "[#i]) {\n\t\t\t\t\t\t\t", "[#i].p(changed, ", ", ", ", ", "[#i], #i);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t", "[#i] = ", "(", ", ", ", ", "[#i], #i, #component);\n\t\t\t\t\t\t\t", "[#i].c();\n\t\t\t\t\t\t\t", "[#i].m(", ", ", ");\n\t\t\t\t\t\t}\n\t\t\t\t\t"], ["\n\t\t\t\t\t\tif (", "[#i]) {\n\t\t\t\t\t\t\t", "[#i].p(changed, ", ", ", ", ", "[#i], #i);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t", "[#i] = ", "(", ", ", ", ", "[#i], #i, #component);\n\t\t\t\t\t\t\t", "[#i].c();\n\t\t\t\t\t\t\t", "[#i].m(", ", ", ");\n\t\t\t\t\t\t}\n\t\t\t\t\t"])), iterations, iterations, params, each_block_value, each_block_value, iterations, create_each_block, params, each_block_value, each_block_value, iterations, iterations, updateMountNode, anchor)
                : deindent(templateObject_23 || (templateObject_23 = __makeTemplateObject(["\n\t\t\t\t\t", "[#i] = ", "(", ", ", ", ", "[#i], #i, #component);\n\t\t\t\t\t", "[#i].c();\n\t\t\t\t\t", "[#i].", "(", ", ", ");\n\t\t\t\t"], ["\n\t\t\t\t\t", "[#i] = ", "(", ", ", ", ", "[#i], #i, #component);\n\t\t\t\t\t", "[#i].c();\n\t\t\t\t\t", "[#i].", "(", ", ", ");\n\t\t\t\t"])), iterations, create_each_block, params, each_block_value, each_block_value, iterations, iterations, mountOrIntro, updateMountNode, anchor);
            var start = this.block.hasUpdateMethod ? '0' : iterations + ".length";
            var outro = block.getUniqueName('outro');
            var destroy = this.block.hasOutroMethod
                ? deindent(templateObject_24 || (templateObject_24 = __makeTemplateObject(["\n\t\t\t\t\tfunction ", "(i) {\n\t\t\t\t\t\tif (", "[i]) {\n\t\t\t\t\t\t\t", "[i].o(function() {\n\t\t\t\t\t\t\t\t", "[i].u();\n\t\t\t\t\t\t\t\t", "[i].d();\n\t\t\t\t\t\t\t\t", "[i] = null;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (; #i < ", ".length; #i += 1) ", "(#i);\n\t\t\t\t"], ["\n\t\t\t\t\tfunction ", "(i) {\n\t\t\t\t\t\tif (", "[i]) {\n\t\t\t\t\t\t\t", "[i].o(function() {\n\t\t\t\t\t\t\t\t", "[i].u();\n\t\t\t\t\t\t\t\t", "[i].d();\n\t\t\t\t\t\t\t\t", "[i] = null;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (; #i < ", ".length; #i += 1) ", "(#i);\n\t\t\t\t"])), outro, iterations, iterations, iterations, iterations, iterations, iterations, outro) : deindent(templateObject_25 || (templateObject_25 = __makeTemplateObject(["\n\t\t\t\t\tfor (; #i < ", ".length; #i += 1) {\n\t\t\t\t\t\t", "[#i].u();\n\t\t\t\t\t\t", "[#i].d();\n\t\t\t\t\t}\n\t\t\t\t\t", ".length = ", ".", ";\n\t\t\t\t"], ["\n\t\t\t\t\tfor (; #i < ", ".length; #i += 1) {\n\t\t\t\t\t\t", "[#i].u();\n\t\t\t\t\t\t", "[#i].d();\n\t\t\t\t\t}\n\t\t\t\t\t", ".length = ", ".", ";\n\t\t\t\t"])), iterations, iterations, iterations, iterations, each_block_value, length);
            block.builders.update.addBlock(deindent(templateObject_26 || (templateObject_26 = __makeTemplateObject(["\n\t\t\t\tvar ", " = ", ";\n\n\t\t\t\tif (", ") {\n\t\t\t\t\tfor (var #i = ", "; #i < ", ".", "; #i += 1) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tvar ", " = ", ";\n\n\t\t\t\tif (", ") {\n\t\t\t\t\tfor (var #i = ", "; #i < ", ".", "; #i += 1) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"])), each_block_value, snippet, condition, start, each_block_value, length, forLoopBody, destroy));
        }
        block.builders.unmount.addBlock(deindent(templateObject_27 || (templateObject_27 = __makeTemplateObject(["\n\t\t\tfor (var #i = 0; #i < ", ".length; #i += 1) {\n\t\t\t\t", "[#i].u();\n\t\t\t}\n\t\t"], ["\n\t\t\tfor (var #i = 0; #i < ", ".length; #i += 1) {\n\t\t\t\t", "[#i].u();\n\t\t\t}\n\t\t"])), iterations, iterations));
        block.builders.destroy.addBlock("@destroyEach(" + iterations + ");");
    };
    return EachBlock;
}(Node$1));
var templateObject_1$6;
var templateObject_2$6;
var templateObject_3$6;
var templateObject_4$6;
var templateObject_5$4;
var templateObject_6$4;
var templateObject_7$3;
var templateObject_8$3;
var templateObject_9$2;
var templateObject_10$2;
var templateObject_11$2;
var templateObject_12$2;
var templateObject_13$2;
var templateObject_14$2;
var templateObject_15$2;
var templateObject_16$2;
var templateObject_17$2;
var templateObject_18$2;
var templateObject_19$2;
var templateObject_20$1;
var templateObject_21;
var templateObject_22;
var templateObject_23;
var templateObject_24;
var templateObject_25;
var templateObject_26;
var templateObject_27;

var Element = /** @class */ (function (_super) {
    __extends(Element, _super);
    function Element() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Element.prototype.init = function (block, stripWhitespace, nextSibling) {
        var _this = this;
        if (this.name === 'slot' || this.name === 'option') {
            this.cannotUseInnerHTML();
        }
        var parentElement = this.parent && this.parent.findNearest(/^Element/);
        this.namespace = this.name === 'svg' ?
            svg :
            parentElement ? parentElement.namespace : this.generator.namespace;
        this.attributes.forEach(function (attribute) {
            if (attribute.type === 'Attribute' && attribute.value !== true) {
                // special case — xmlns
                if (attribute.name === 'xmlns') {
                    // TODO this attribute must be static – enforce at compile time
                    _this.namespace = attribute.value[0].data;
                }
                attribute.value.forEach(function (chunk) {
                    if (chunk.type !== 'Text') {
                        if (_this.parent)
                            _this.parent.cannotUseInnerHTML();
                        var dependencies_1 = chunk.metadata.dependencies;
                        block.addDependencies(dependencies_1);
                        // special case — <option value='{{foo}}'> — see below
                        if (_this.name === 'option' &&
                            attribute.name === 'value') {
                            var select = _this.parent;
                            while (select && select.type !== 'Element' || select.name !== 'select')
                                select = select.parent;
                            if (select && select.selectBindingDependencies) {
                                select.selectBindingDependencies.forEach(function (prop) {
                                    dependencies_1.forEach(function (dependency) {
                                        _this.generator.indirectDependencies.get(prop).add(dependency);
                                    });
                                });
                            }
                        }
                    }
                });
            }
            else {
                if (_this.parent)
                    _this.parent.cannotUseInnerHTML();
                if (attribute.type === 'EventHandler' && attribute.expression) {
                    attribute.expression.arguments.forEach(function (arg) {
                        block.addDependencies(arg.metadata.dependencies);
                    });
                }
                else if (attribute.type === 'Binding') {
                    block.addDependencies(attribute.metadata.dependencies);
                }
                else if (attribute.type === 'Transition') {
                    if (attribute.intro)
                        _this.generator.hasIntroTransitions = block.hasIntroMethod = true;
                    if (attribute.outro) {
                        _this.generator.hasOutroTransitions = block.hasOutroMethod = true;
                        block.outros += 1;
                    }
                }
            }
        });
        var valueAttribute = this.attributes.find(function (attribute) { return attribute.name === 'value'; });
        if (this.name === 'textarea') {
            // this is an egregious hack, but it's the easiest way to get <textarea>
            // children treated the same way as a value attribute
            if (this.children.length > 0) {
                this.attributes.push(new Attribute({
                    generator: this.generator,
                    name: 'value',
                    value: this.children,
                    parent: this
                }));
                this.children = [];
            }
        }
        // special case — in a case like this...
        //
        //   <select bind:value='foo'>
        //     <option value='{{bar}}'>bar</option>
        //     <option value='{{baz}}'>baz</option>
        //   </option>
        //
        // ...we need to know that `foo` depends on `bar` and `baz`,
        // so that if `foo.qux` changes, we know that we need to
        // mark `bar` and `baz` as dirty too
        if (this.name === 'select') {
            var binding = this.attributes.find(function (node) { return node.type === 'Binding' && node.name === 'value'; });
            if (binding) {
                // TODO does this also apply to e.g. `<input type='checkbox' bind:group='foo'>`?
                var dependencies = binding.metadata.dependencies;
                this.selectBindingDependencies = dependencies;
                dependencies.forEach(function (prop) {
                    _this.generator.indirectDependencies.set(prop, new Set());
                });
            }
            else {
                this.selectBindingDependencies = null;
            }
        }
        var slot = this.getStaticAttributeValue('slot');
        if (slot && this.hasAncestor('Component')) {
            this.cannotUseInnerHTML();
            this.slotted = true;
            // TODO validate slots — no nesting, no dynamic names...
            var component = this.findNearest(/^Component/);
            component._slots.add(slot);
        }
        this["var"] = block.getUniqueName(this.name.replace(/[^a-zA-Z0-9_$]/g, '_'));
        this.generator.stylesheet.apply(this);
        if (this.children.length) {
            if (this.name === 'pre' || this.name === 'textarea')
                stripWhitespace = false;
            this.initChildren(block, stripWhitespace, nextSibling);
        }
    };
    Element.prototype.build = function (block, parentNode, parentNodes) {
        var _this = this;
        var generator = this.generator;
        if (this.name === 'slot') {
            var slotName = this.getStaticAttributeValue('name') || 'default';
            this.generator.slots.add(slotName);
        }
        var childState = {
            parentNode: this["var"],
            parentNodes: parentNodes && block.getUniqueName(this["var"] + "_nodes") // if we're in unclaimable territory, i.e. <head>, parentNodes is null
        };
        var name = this["var"];
        var allUsedContexts = new Set();
        var slot = this.attributes.find(function (attribute) { return attribute.name === 'slot'; });
        var initialMountNode = this.slotted ?
            this.findNearest(/^Component/)["var"] + "._slotted." + slot.value[0].data : // TODO this looks bonkers
            parentNode;
        block.addVariable(name);
        var renderStatement = getRenderStatement(this.generator, this.namespace, this.name);
        block.builders.create.addLine(name + " = " + renderStatement + ";");
        if (this.generator.hydratable) {
            if (parentNodes) {
                block.builders.claim.addBlock(deindent(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject(["\n\t\t\t\t\t", " = ", ";\n\t\t\t\t\tvar ", " = @children(", ");\n\t\t\t\t"], ["\n\t\t\t\t\t", " = ", ";\n\t\t\t\t\tvar ", " = @children(", ");\n\t\t\t\t"])), name, getClaimStatement(generator, this.namespace, parentNodes, this), childState.parentNodes, name));
            }
            else {
                block.builders.claim.addLine(name + " = " + renderStatement + ";");
            }
        }
        if (initialMountNode) {
            block.builders.mount.addLine("@appendNode(" + name + ", " + initialMountNode + ");");
            if (initialMountNode === 'document.head') {
                block.builders.unmount.addLine("@detachNode(" + name + ");");
            }
        }
        else {
            block.builders.mount.addLine("@insertNode(" + name + ", #target, anchor);");
            // TODO we eventually need to consider what happens to elements
            // that belong to the same outgroup as an outroing element...
            block.builders.unmount.addLine("@detachNode(" + name + ");");
        }
        // add CSS encapsulation attribute
        if (this._needsCssAttribute && !this.generator.customElement) {
            this.generator.needsEncapsulateHelper = true;
            block.builders.hydrate.addLine("@encapsulateStyles(" + name + ");");
            if (this._cssRefAttribute) {
                block.builders.hydrate.addLine("@setAttribute(" + name + ", \"svelte-ref-" + this._cssRefAttribute + "\", \"\");");
            }
        }
        // insert static children with textContent or innerHTML
        if (!this.namespace && this.canUseInnerHTML && this.children.length > 0) {
            if (this.children.length === 1 && this.children[0].type === 'Text') {
                block.builders.create.addLine(name + ".textContent = " + stringify(this.children[0].data) + ";");
            }
            else {
                block.builders.create.addLine(name + ".innerHTML = " + stringify(this.children.map(toHTML).join('')) + ";");
            }
        }
        else {
            this.children.forEach(function (child) {
                child.build(block, childState.parentNode, childState.parentNodes);
            });
        }
        this.addBindings(block, allUsedContexts);
        this.attributes.filter(function (a) { return a.type === 'Attribute'; }).forEach(function (attribute) {
            attribute.render(block);
        });
        // event handlers
        var eventHandlerUsesComponent = false;
        this.attributes.filter(function (a) { return a.type === 'EventHandler'; }).forEach(function (attribute) {
            var isCustomEvent = generator.events.has(attribute.name);
            var shouldHoist = !isCustomEvent && _this.hasAncestor('EachBlock');
            var context = shouldHoist ? null : name;
            var usedContexts = [];
            if (attribute.expression) {
                generator.addSourcemapLocations(attribute.expression);
                var flattened = flatten(attribute.expression.callee);
                if (!validCalleeObjects.has(flattened.name)) {
                    // allow event.stopPropagation(), this.select() etc
                    // TODO verify that it's a valid callee (i.e. built-in or declared method)
                    generator.code.prependRight(attribute.expression.start, block.alias('component') + ".");
                    if (shouldHoist)
                        eventHandlerUsesComponent = true; // this feels a bit hacky but it works!
                }
                attribute.expression.arguments.forEach(function (arg) {
                    var contexts = block.contextualise(arg, context, true).contexts;
                    contexts.forEach(function (context) {
                        if (!~usedContexts.indexOf(context))
                            usedContexts.push(context);
                        allUsedContexts.add(context);
                    });
                });
            }
            var ctx = context || 'this';
            var declarations = usedContexts.map(function (name) {
                if (name === 'state') {
                    if (shouldHoist)
                        eventHandlerUsesComponent = true;
                    return "var state = " + block.alias('component') + ".get();";
                }
                var listName = block.listNames.get(name);
                var indexName = block.indexNames.get(name);
                var contextName = block.contexts.get(name);
                return "var " + listName + " = " + ctx + "._svelte." + listName + ", " + indexName + " = " + ctx + "._svelte." + indexName + ", " + contextName + " = " + listName + "[" + indexName + "];";
            });
            // get a name for the event handler that is globally unique
            // if hoisted, locally unique otherwise
            var handlerName = (shouldHoist ? generator : block).getUniqueName(attribute.name.replace(/[^a-zA-Z0-9_$]/g, '_') + "_handler");
            // create the handler body
            var handlerBody = deindent(templateObject_2$7 || (templateObject_2$7 = __makeTemplateObject(["\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t"], ["\n\t\t\t\t",
                "\n\t\t\t\t", "\n\t\t\t\t",
                "\n\t\t\t"])), eventHandlerUsesComponent &&
                "var " + block.alias('component') + " = " + ctx + "._svelte.component;", declarations, attribute.expression ?
                "[\u2702" + attribute.expression.start + "-" + attribute.expression.end + "\u2702];" :
                block.alias('component') + ".fire(\"" + attribute.name + "\", event);");
            if (isCustomEvent) {
                block.addVariable(handlerName);
                block.builders.hydrate.addBlock(deindent(templateObject_3$7 || (templateObject_3$7 = __makeTemplateObject(["\n\t\t\t\t\t", " = %events-", ".call(#component, ", ", function(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t});\n\t\t\t\t"], ["\n\t\t\t\t\t", " = %events-", ".call(#component, ", ", function(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t});\n\t\t\t\t"])), handlerName, attribute.name, name, handlerBody));
                block.builders.destroy.addLine(deindent(templateObject_4$7 || (templateObject_4$7 = __makeTemplateObject(["\n\t\t\t\t\t", ".teardown();\n\t\t\t\t"], ["\n\t\t\t\t\t", ".teardown();\n\t\t\t\t"])), handlerName));
            }
            else {
                var handler = deindent(templateObject_5$5 || (templateObject_5$5 = __makeTemplateObject(["\n\t\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\t\t\t\t"], ["\n\t\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\t\t\t\t"])), handlerName, handlerBody);
                if (shouldHoist) {
                    generator.blocks.push(handler);
                }
                else {
                    block.builders.init.addBlock(handler);
                }
                block.builders.hydrate.addLine("@addListener(" + name + ", \"" + attribute.name + "\", " + handlerName + ");");
                block.builders.destroy.addLine("@removeListener(" + name + ", \"" + attribute.name + "\", " + handlerName + ");");
            }
        });
        // refs
        this.attributes.filter(function (a) { return a.type === 'Ref'; }).forEach(function (attribute) {
            var ref = "#component.refs." + attribute.name;
            block.builders.mount.addLine(ref + " = " + name + ";");
            block.builders.destroy.addLine("if (" + ref + " === " + name + ") " + ref + " = null;");
            generator.usesRefs = true; // so component.refs object is created
        });
        this.addTransitions(block);
        if (allUsedContexts.size || eventHandlerUsesComponent) {
            var initialProps_1 = [];
            var updates_1 = [];
            if (eventHandlerUsesComponent) {
                initialProps_1.push("component: #component");
            }
            allUsedContexts.forEach(function (contextName) {
                if (contextName === 'state')
                    return;
                var listName = block.listNames.get(contextName);
                var indexName = block.indexNames.get(contextName);
                initialProps_1.push(listName + ": " + listName + ",\n" + indexName + ": " + indexName);
                updates_1.push(name + "._svelte." + listName + " = " + listName + ";\n" + name + "._svelte." + indexName + " = " + indexName + ";");
            });
            if (initialProps_1.length) {
                block.builders.hydrate.addBlock(deindent(templateObject_6$5 || (templateObject_6$5 = __makeTemplateObject(["\n\t\t\t\t\t", "._svelte = {\n\t\t\t\t\t\t", "\n\t\t\t\t\t};\n\t\t\t\t"], ["\n\t\t\t\t\t", "._svelte = {\n\t\t\t\t\t\t", "\n\t\t\t\t\t};\n\t\t\t\t"])), name, initialProps_1.join(',\n')));
            }
            if (updates_1.length) {
                block.builders.update.addBlock(updates_1.join('\n'));
            }
        }
        if (this.initialUpdate) {
            block.builders.mount.addBlock(this.initialUpdate);
        }
        if (childState.parentNodes) {
            block.builders.claim.addLine(childState.parentNodes + ".forEach(@detachNode);");
        }
        function toHTML(node) {
            if (node.type === 'Text')
                return node.data;
            var open = "<" + node.name;
            if (node._needsCssAttribute) {
                open += " " + generator.stylesheet.id;
            }
            if (node._cssRefAttribute) {
                open += " svelte-ref-" + node._cssRefAttribute;
            }
            node.attributes.forEach(function (attr) {
                open += " " + attr.name + stringifyAttributeValue(attr.value);
            });
            if (isVoidElementName(node.name))
                return open + '>';
            return open + ">" + node.children.map(toHTML).join('') + "</" + node.name + ">";
        }
    };
    Element.prototype.addBindings = function (block, allUsedContexts) {
        var _this = this;
        var bindings = this.attributes.filter(function (a) { return a.type === 'Binding'; });
        if (bindings.length === 0)
            return;
        if (this.name === 'select' || this.isMediaNode())
            this.generator.hasComplexBindings = true;
        var needsLock = this.name !== 'input' || !/radio|checkbox|range|color/.test(this.getStaticAttributeValue('type'));
        var mungedBindings = bindings.map(function (binding) { return binding.munge(block, allUsedContexts); });
        var lock = mungedBindings.some(function (binding) { return binding.needsLock; }) ?
            block.getUniqueName(this["var"] + "_updating") :
            null;
        if (lock)
            block.addVariable(lock, 'false');
        var groups = events$1
            .map(function (event) {
            return {
                events: event.eventNames,
                bindings: mungedBindings.filter(function (binding) { return event.filter(_this, binding.name); })
            };
        })
            .filter(function (group) { return group.bindings.length; });
        groups.forEach(function (group) {
            var handler = block.getUniqueName(_this["var"] + "_" + group.events.join('_') + "_handler");
            var needsLock = group.bindings.some(function (binding) { return binding.needsLock; });
            group.bindings.forEach(function (binding) {
                if (!binding.updateDom)
                    return;
                var updateConditions = needsLock ? ["!" + lock] : [];
                if (binding.updateCondition)
                    updateConditions.push(binding.updateCondition);
                block.builders.update.addLine(updateConditions.length ? "if (" + updateConditions.join(' && ') + ") " + binding.updateDom : binding.updateDom);
            });
            var usesContext = group.bindings.some(function (binding) { return binding.handler.usesContext; });
            var usesState = group.bindings.some(function (binding) { return binding.handler.usesState; });
            var usesStore = group.bindings.some(function (binding) { return binding.handler.usesStore; });
            var mutations = group.bindings.map(function (binding) { return binding.handler.mutation; }).filter(Boolean).join('\n');
            var props = new Set();
            var storeProps = new Set();
            group.bindings.forEach(function (binding) {
                binding.handler.props.forEach(function (prop) {
                    props.add(prop);
                });
                binding.handler.storeProps.forEach(function (prop) {
                    storeProps.add(prop);
                });
            }); // TODO use stringifyProps here, once indenting is fixed
            // media bindings — awkward special case. The native timeupdate events
            // fire too infrequently, so we need to take matters into our
            // own hands
            var animation_frame;
            if (group.events[0] === 'timeupdate') {
                animation_frame = block.getUniqueName(_this["var"] + "_animationframe");
                block.addVariable(animation_frame);
            }
            block.builders.init.addBlock(deindent(templateObject_7$4 || (templateObject_7$4 = __makeTemplateObject(["\n\t\t\t\tfunction ", "() {\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tfunction ", "() {\n\t\t\t\t\t",
                "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"])), handler, animation_frame && deindent(templateObject_8$4 || (templateObject_8$4 = __makeTemplateObject(["\n\t\t\t\t\t\t\tcancelAnimationFrame(", ");\n\t\t\t\t\t\t\tif (!", ".paused) ", " = requestAnimationFrame(", ");"], ["\n\t\t\t\t\t\t\tcancelAnimationFrame(", ");\n\t\t\t\t\t\t\tif (!", ".paused) ", " = requestAnimationFrame(", ");"])), animation_frame, _this["var"], animation_frame, handler), usesContext && "var context = " + _this["var"] + "._svelte;", usesState && "var state = #component.get();", usesStore && "var $ = #component.store.get();", needsLock && lock + " = true;", mutations.length > 0 && mutations, props.size > 0 && "#component.set({ " + Array.from(props).join(', ') + " });", storeProps.size > 0 && "#component.store.set({ " + Array.from(storeProps).join(', ') + " });", needsLock && lock + " = false;"));
            group.events.forEach(function (name) {
                block.builders.hydrate.addLine("@addListener(" + _this["var"] + ", \"" + name + "\", " + handler + ");");
                block.builders.destroy.addLine("@removeListener(" + _this["var"] + ", \"" + name + "\", " + handler + ");");
            });
            var allInitialStateIsDefined = group.bindings
                .map(function (binding) { return "'" + binding.object + "' in state"; })
                .join(' && ');
            if (_this.name === 'select' || group.bindings.find(function (binding) { return binding.name === 'indeterminate' || binding.isReadOnlyMediaAttribute; })) {
                _this.generator.hasComplexBindings = true;
                block.builders.hydrate.addLine("if (!(" + allInitialStateIsDefined + ")) #component.root._beforecreate.push(" + handler + ");");
            }
        });
        this.initialUpdate = mungedBindings.map(function (binding) { return binding.initialUpdate; }).filter(Boolean).join('\n');
    };
    Element.prototype.addTransitions = function (block) {
        var intro = this.attributes.find(function (a) { return a.type === 'Transition' && a.intro; });
        var outro = this.attributes.find(function (a) { return a.type === 'Transition' && a.outro; });
        if (!intro && !outro)
            return;
        if (intro === outro) {
            block.contextualise(intro.expression); // TODO remove all these
            var name = block.getUniqueName(this["var"] + "_transition");
            var snippet = intro.expression
                ? intro.metadata.snippet
                : '{}';
            block.addVariable(name);
            var fn = "%transitions-" + intro.name;
            block.builders.intro.addBlock(deindent(templateObject_9$3 || (templateObject_9$3 = __makeTemplateObject(["\n\t\t\t\t#component.root._aftercreate.push(function() {\n\t\t\t\t\tif (!", ") ", " = @wrapTransition(#component, ", ", ", ", ", ", true, null);\n\t\t\t\t\t", ".run(true, function() {\n\t\t\t\t\t\t#component.fire(\"intro.end\", { node: ", " });\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t"], ["\n\t\t\t\t#component.root._aftercreate.push(function() {\n\t\t\t\t\tif (!", ") ", " = @wrapTransition(#component, ", ", ", ", ", ", true, null);\n\t\t\t\t\t", ".run(true, function() {\n\t\t\t\t\t\t#component.fire(\"intro.end\", { node: ", " });\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t"])), name, name, this["var"], fn, snippet, name, this["var"]));
            block.builders.outro.addBlock(deindent(templateObject_10$3 || (templateObject_10$3 = __makeTemplateObject(["\n\t\t\t\t", ".run(false, function() {\n\t\t\t\t\t#component.fire(\"outro.end\", { node: ", " });\n\t\t\t\t\tif (--#outros === 0) #outrocallback();\n\t\t\t\t\t", " = null;\n\t\t\t\t});\n\t\t\t"], ["\n\t\t\t\t", ".run(false, function() {\n\t\t\t\t\t#component.fire(\"outro.end\", { node: ", " });\n\t\t\t\t\tif (--#outros === 0) #outrocallback();\n\t\t\t\t\t", " = null;\n\t\t\t\t});\n\t\t\t"])), name, this["var"], name));
        }
        else {
            var introName = intro && block.getUniqueName(this["var"] + "_intro");
            var outroName = outro && block.getUniqueName(this["var"] + "_outro");
            if (intro) {
                block.contextualise(intro.expression);
                block.addVariable(introName);
                var snippet = intro.expression
                    ? intro.metadata.snippet
                    : '{}';
                var fn = "%transitions-" + intro.name; // TODO add built-in transitions?
                if (outro) {
                    block.builders.intro.addBlock(deindent(templateObject_11$3 || (templateObject_11$3 = __makeTemplateObject(["\n\t\t\t\t\t\tif (", ") ", ".abort();\n\t\t\t\t\t\tif (", ") ", ".abort();\n\t\t\t\t\t"], ["\n\t\t\t\t\t\tif (", ") ", ".abort();\n\t\t\t\t\t\tif (", ") ", ".abort();\n\t\t\t\t\t"])), introName, introName, outroName, outroName));
                }
                block.builders.intro.addBlock(deindent(templateObject_12$3 || (templateObject_12$3 = __makeTemplateObject(["\n\t\t\t\t\t#component.root._aftercreate.push(function() {\n\t\t\t\t\t\t", " = @wrapTransition(#component, ", ", ", ", ", ", true, null);\n\t\t\t\t\t\t", ".run(true, function() {\n\t\t\t\t\t\t\t#component.fire(\"intro.end\", { node: ", " });\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t"], ["\n\t\t\t\t\t#component.root._aftercreate.push(function() {\n\t\t\t\t\t\t", " = @wrapTransition(#component, ", ", ", ", ", ", true, null);\n\t\t\t\t\t\t", ".run(true, function() {\n\t\t\t\t\t\t\t#component.fire(\"intro.end\", { node: ", " });\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t"])), introName, this["var"], fn, snippet, introName, this["var"]));
            }
            if (outro) {
                block.contextualise(outro.expression);
                block.addVariable(outroName);
                var snippet = outro.expression
                    ? outro.metadata.snippet
                    : '{}';
                var fn = "%transitions-" + outro.name;
                // TODO hide elements that have outro'd (unless they belong to a still-outroing
                // group) prior to their removal from the DOM
                block.builders.outro.addBlock(deindent(templateObject_13$3 || (templateObject_13$3 = __makeTemplateObject(["\n\t\t\t\t\t", " = @wrapTransition(#component, ", ", ", ", ", ", false, null);\n\t\t\t\t\t", ".run(false, function() {\n\t\t\t\t\t\t#component.fire(\"outro.end\", { node: ", " });\n\t\t\t\t\t\tif (--#outros === 0) #outrocallback();\n\t\t\t\t\t});\n\t\t\t\t"], ["\n\t\t\t\t\t", " = @wrapTransition(#component, ", ", ", ", ", ", false, null);\n\t\t\t\t\t", ".run(false, function() {\n\t\t\t\t\t\t#component.fire(\"outro.end\", { node: ", " });\n\t\t\t\t\t\tif (--#outros === 0) #outrocallback();\n\t\t\t\t\t});\n\t\t\t\t"])), outroName, this["var"], fn, snippet, outroName, this["var"]));
            }
        }
    };
    Element.prototype.getStaticAttributeValue = function (name) {
        var attribute = this.attributes.find(function (attr) { return attr.type === 'Attribute' && attr.name.toLowerCase() === name; });
        if (!attribute)
            return null;
        if (attribute.value === true)
            return true;
        if (attribute.value.length === 0)
            return '';
        if (attribute.value.length === 1 && attribute.value[0].type === 'Text') {
            return attribute.value[0].data;
        }
        return null;
    };
    Element.prototype.isMediaNode = function () {
        return this.name === 'audio' || this.name === 'video';
    };
    return Element;
}(Node$1));
function getRenderStatement(generator, namespace, name) {
    if (namespace === 'http://www.w3.org/2000/svg') {
        return "@createSvgElement(\"" + name + "\")";
    }
    if (namespace) {
        return "document.createElementNS(\"" + namespace + "\", \"" + name + "\")";
    }
    return "@createElement(\"" + name + "\")";
}
function getClaimStatement(generator, namespace, nodes, node) {
    var attributes = node.attributes
        .filter(function (attr) { return attr.type === 'Attribute'; })
        .map(function (attr) { return quoteProp(attr.name, generator.legacy) + ": true"; })
        .join(', ');
    var name = namespace ? node.name : node.name.toUpperCase();
    return "@claimElement(" + nodes + ", \"" + name + "\", " + (attributes
        ? "{ " + attributes + " }"
        : "{}") + ", " + (namespace === svg ? true : false) + ")";
}
function quoteProp(name, legacy) {
    var isLegacyPropName = legacy && reservedNames.has(name);
    if (/[^a-zA-Z_$0-9]/.test(name) || isLegacyPropName)
        return "\"" + name + "\"";
    return name;
}
function stringifyAttributeValue(value) {
    if (value === true)
        return '';
    if (value.length === 0)
        return "=\"\"";
    var data = value[0].data;
    return "=" + JSON.stringify(data);
}
var events$1 = [
    {
        eventNames: ['input'],
        filter: function (node, name) {
            return node.name === 'textarea' ||
                node.name === 'input' && !/radio|checkbox/.test(node.getStaticAttributeValue('type'));
        }
    },
    {
        eventNames: ['change'],
        filter: function (node, name) {
            return node.name === 'select' ||
                node.name === 'input' && /radio|checkbox|range/.test(node.getStaticAttributeValue('type'));
        }
    },
    // media events
    {
        eventNames: ['timeupdate'],
        filter: function (node, name) {
            return node.isMediaNode() &&
                (name === 'currentTime' || name === 'played');
        }
    },
    {
        eventNames: ['durationchange'],
        filter: function (node, name) {
            return node.isMediaNode() &&
                name === 'duration';
        }
    },
    {
        eventNames: ['play', 'pause'],
        filter: function (node, name) {
            return node.isMediaNode() &&
                name === 'paused';
        }
    },
    {
        eventNames: ['progress'],
        filter: function (node, name) {
            return node.isMediaNode() &&
                name === 'buffered';
        }
    },
    {
        eventNames: ['loadedmetadata'],
        filter: function (node, name) {
            return node.isMediaNode() &&
                (name === 'buffered' || name === 'seekable');
        }
    }
];
var templateObject_1$7;
var templateObject_2$7;
var templateObject_3$7;
var templateObject_4$7;
var templateObject_5$5;
var templateObject_6$5;
var templateObject_8$4;
var templateObject_7$4;
var templateObject_9$3;
var templateObject_10$3;
var templateObject_11$3;
var templateObject_12$3;
var templateObject_13$3;

var ElseBlock = /** @class */ (function (_super) {
    __extends(ElseBlock, _super);
    function ElseBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ElseBlock;
}(Node$1));

var EventHandler = /** @class */ (function (_super) {
    __extends(EventHandler, _super);
    function EventHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return EventHandler;
}(Node$1));

var Block$2 = /** @class */ (function () {
    function Block(options) {
        this.generator = options.generator;
        this.name = options.name;
        this.expression = options.expression;
        this.context = options.context;
        this.destructuredContexts = options.destructuredContexts;
        this.comment = options.comment;
        // for keyed each blocks
        this.key = options.key;
        this.first = null;
        this.contexts = options.contexts;
        this.indexes = options.indexes;
        this.changeableIndexes = options.changeableIndexes;
        this.dependencies = new Set();
        this.params = options.params;
        this.indexNames = options.indexNames;
        this.listNames = options.listNames;
        this.listName = options.listName;
        this.builders = {
            init: new CodeBuilder(),
            create: new CodeBuilder(),
            claim: new CodeBuilder(),
            hydrate: new CodeBuilder(),
            mount: new CodeBuilder(),
            intro: new CodeBuilder(),
            update: new CodeBuilder(),
            outro: new CodeBuilder(),
            unmount: new CodeBuilder(),
            detachRaw: new CodeBuilder(),
            destroy: new CodeBuilder()
        };
        this.hasIntroMethod = false; // a block could have an intro method but not intro transitions, e.g. if a sibling block has intros
        this.hasOutroMethod = false;
        this.outros = 0;
        this.aliases = new Map();
        this.variables = new Map();
        this.getUniqueName = this.generator.getUniqueNameMaker(options.params);
        this.hasUpdateMethod = false; // determined later
    }
    Block.prototype.addDependencies = function (dependencies) {
        var _this = this;
        dependencies.forEach(function (dependency) {
            _this.dependencies.add(dependency);
        });
    };
    Block.prototype.addElement = function (name, renderStatement, claimStatement, parentNode) {
        this.addVariable(name);
        this.builders.create.addLine(name + " = " + renderStatement + ";");
        this.builders.claim.addLine(name + " = " + (claimStatement || renderStatement) + ";");
        if (parentNode) {
            this.builders.mount.addLine("@appendNode(" + name + ", " + parentNode + ");");
            if (parentNode === 'document.head')
                this.builders.unmount.addLine("@detachNode(" + name + ");");
        }
        else {
            this.builders.mount.addLine("@insertNode(" + name + ", #target, anchor);");
            this.builders.unmount.addLine("@detachNode(" + name + ");");
        }
    };
    Block.prototype.addVariable = function (name, init) {
        if (this.variables.has(name) && this.variables.get(name) !== init) {
            throw new Error("Variable '" + name + "' already initialised with a different value");
        }
        this.variables.set(name, init);
    };
    Block.prototype.alias = function (name) {
        if (!this.aliases.has(name)) {
            this.aliases.set(name, this.getUniqueName(name));
        }
        return this.aliases.get(name);
    };
    Block.prototype.child = function (options) {
        return new Block(Object.assign({}, this, options, { parent: this }));
    };
    Block.prototype.contextualise = function (expression, context, isEventHandler) {
        return this.generator.contextualise(this.contexts, this.indexes, expression, context, isEventHandler);
    };
    Block.prototype.toString = function () {
        var _this = this;
        var introing;
        var hasIntros = !this.builders.intro.isEmpty();
        if (hasIntros) {
            introing = this.getUniqueName('introing');
            this.addVariable(introing);
        }
        var outroing;
        var hasOutros = !this.builders.outro.isEmpty();
        if (hasOutros) {
            outroing = this.alias('outroing');
            this.addVariable(outroing);
        }
        if (this.autofocus) {
            this.builders.mount.addLine(this.autofocus + ".focus();");
        }
        // minor hack – we need to ensure that any {{{triples}}} are detached first
        this.builders.unmount.addBlockAtStart(this.builders.detachRaw.toString());
        var properties = new CodeBuilder();
        var localKey;
        if (this.key) {
            localKey = this.getUniqueName('key');
            properties.addBlock("key: " + localKey + ",");
        }
        if (this.first) {
            properties.addBlock("first: null,");
            this.builders.hydrate.addLine("this.first = " + this.first + ";");
        }
        if (this.builders.create.isEmpty() && this.builders.hydrate.isEmpty()) {
            properties.addBlock("c: @noop,");
        }
        else {
            properties.addBlock(deindent(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject(["\n\t\t\t\tc: function create() {\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t},\n\t\t\t"], ["\n\t\t\t\tc: function create() {\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t},\n\t\t\t"])), this.builders.create, !this.builders.hydrate.isEmpty() && "this.h();"));
        }
        if (this.generator.hydratable) {
            if (this.builders.claim.isEmpty() && this.builders.hydrate.isEmpty()) {
                properties.addBlock("l: @noop,");
            }
            else {
                properties.addBlock(deindent(templateObject_2$8 || (templateObject_2$8 = __makeTemplateObject(["\n\t\t\t\t\tl: function claim(nodes) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", "\n\t\t\t\t\t},\n\t\t\t\t"], ["\n\t\t\t\t\tl: function claim(nodes) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t\t", "\n\t\t\t\t\t},\n\t\t\t\t"])), this.builders.claim, !this.builders.hydrate.isEmpty() && "this.h();"));
            }
        }
        if (!this.builders.hydrate.isEmpty()) {
            properties.addBlock(deindent(templateObject_3$8 || (templateObject_3$8 = __makeTemplateObject(["\n\t\t\t\th: function hydrate() {\n\t\t\t\t\t", "\n\t\t\t\t},\n\t\t\t"], ["\n\t\t\t\th: function hydrate() {\n\t\t\t\t\t", "\n\t\t\t\t},\n\t\t\t"])), this.builders.hydrate));
        }
        if (this.builders.mount.isEmpty()) {
            properties.addBlock("m: @noop,");
        }
        else {
            properties.addBlock(deindent(templateObject_4$8 || (templateObject_4$8 = __makeTemplateObject(["\n\t\t\t\tm: function mount(#target, anchor) {\n\t\t\t\t\t", "\n\t\t\t\t},\n\t\t\t"], ["\n\t\t\t\tm: function mount(#target, anchor) {\n\t\t\t\t\t", "\n\t\t\t\t},\n\t\t\t"])), this.builders.mount));
        }
        if (this.hasUpdateMethod) {
            if (this.builders.update.isEmpty()) {
                properties.addBlock("p: @noop,");
            }
            else {
                properties.addBlock(deindent(templateObject_5$6 || (templateObject_5$6 = __makeTemplateObject(["\n\t\t\t\t\tp: function update(changed, ", ") {\n\t\t\t\t\t\t", "\n\t\t\t\t\t},\n\t\t\t\t"], ["\n\t\t\t\t\tp: function update(changed, ", ") {\n\t\t\t\t\t\t", "\n\t\t\t\t\t},\n\t\t\t\t"])), this.params.join(', '), this.builders.update));
            }
        }
        if (this.hasIntroMethod) {
            if (hasIntros) {
                properties.addBlock(deindent(templateObject_6$6 || (templateObject_6$6 = __makeTemplateObject(["\n\t\t\t\t\ti: function intro(#target, anchor) {\n\t\t\t\t\t\tif (", ") return;\n\t\t\t\t\t\t", " = true;\n\t\t\t\t\t\t", "\n\n\t\t\t\t\t\t", "\n\n\t\t\t\t\t\tthis.m(#target, anchor);\n\t\t\t\t\t},\n\t\t\t\t"], ["\n\t\t\t\t\ti: function intro(#target, anchor) {\n\t\t\t\t\t\tif (", ") return;\n\t\t\t\t\t\t", " = true;\n\t\t\t\t\t\t", "\n\n\t\t\t\t\t\t", "\n\n\t\t\t\t\t\tthis.m(#target, anchor);\n\t\t\t\t\t},\n\t\t\t\t"])), introing, introing, hasOutros && outroing + " = false;", this.builders.intro));
            }
            else {
                properties.addBlock(deindent(templateObject_7$5 || (templateObject_7$5 = __makeTemplateObject(["\n\t\t\t\t\ti: function intro(#target, anchor) {\n\t\t\t\t\t\tthis.m(#target, anchor);\n\t\t\t\t\t},\n\t\t\t\t"], ["\n\t\t\t\t\ti: function intro(#target, anchor) {\n\t\t\t\t\t\tthis.m(#target, anchor);\n\t\t\t\t\t},\n\t\t\t\t"]))));
            }
        }
        if (this.hasOutroMethod) {
            if (hasOutros) {
                properties.addBlock(deindent(templateObject_8$5 || (templateObject_8$5 = __makeTemplateObject(["\n\t\t\t\t\to: function outro(", ") {\n\t\t\t\t\t\tif (", ") return;\n\t\t\t\t\t\t", " = true;\n\t\t\t\t\t\t", "\n\n\t\t\t\t\t\tvar ", " = ", ";\n\n\t\t\t\t\t\t", "\n\t\t\t\t\t},\n\t\t\t\t"], ["\n\t\t\t\t\to: function outro(", ") {\n\t\t\t\t\t\tif (", ") return;\n\t\t\t\t\t\t", " = true;\n\t\t\t\t\t\t", "\n\n\t\t\t\t\t\tvar ", " = ", ";\n\n\t\t\t\t\t\t", "\n\t\t\t\t\t},\n\t\t\t\t"])), this.alias('outrocallback'), outroing, outroing, hasIntros && introing + " = false;", this.alias('outros'), this.outros, this.builders.outro));
            }
            else {
                // TODO should this be a helper?
                properties.addBlock(deindent(templateObject_9$4 || (templateObject_9$4 = __makeTemplateObject(["\n\t\t\t\t\to: function outro(outrocallback) {\n\t\t\t\t\t\toutrocallback();\n\t\t\t\t\t},\n\t\t\t\t"], ["\n\t\t\t\t\to: function outro(outrocallback) {\n\t\t\t\t\t\toutrocallback();\n\t\t\t\t\t},\n\t\t\t\t"]))));
            }
        }
        if (this.builders.unmount.isEmpty()) {
            properties.addBlock("u: @noop,");
        }
        else {
            properties.addBlock(deindent(templateObject_10$4 || (templateObject_10$4 = __makeTemplateObject(["\n\t\t\t\tu: function unmount() {\n\t\t\t\t\t", "\n\t\t\t\t},\n\t\t\t"], ["\n\t\t\t\tu: function unmount() {\n\t\t\t\t\t", "\n\t\t\t\t},\n\t\t\t"])), this.builders.unmount));
        }
        if (this.builders.destroy.isEmpty()) {
            properties.addBlock("d: @noop");
        }
        else {
            properties.addBlock(deindent(templateObject_11$4 || (templateObject_11$4 = __makeTemplateObject(["\n\t\t\t\td: function destroy() {\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\td: function destroy() {\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"])), this.builders.destroy));
        }
        return deindent(templateObject_12$4 || (templateObject_12$4 = __makeTemplateObject(["\n\t\t\t", "\n\t\t\tfunction ", "(", ", #component", ") {\n\t\t\t\t", "\n\n\t\t\t\t", "\n\n\t\t\t\treturn {\n\t\t\t\t\t", "\n\t\t\t\t};\n\t\t\t}\n\t\t"], ["\n\t\t\t", "\n\t\t\tfunction ", "(", ", #component", ") {\n\t\t\t\t",
            "\n\n\t\t\t\t", "\n\n\t\t\t\treturn {\n\t\t\t\t\t", "\n\t\t\t\t};\n\t\t\t}\n\t\t"])), this.comment && "// " + escape(this.comment), this.name, this.params.join(', '), this.key ? ", " + localKey : '', this.variables.size > 0 &&
            "var " + Array.from(this.variables.keys())
                .map(function (key) {
                var init = _this.variables.get(key);
                return init !== undefined ? key + " = " + init : key;
            })
                .join(', ') + ";", !this.builders.init.isEmpty() && this.builders.init, properties).replace(/(#+)(\w*)/g, function (match, sigil, name) {
            return sigil === '#' ? _this.alias(name) : sigil.slice(1) + name;
        });
    };
    return Block;
}());
var templateObject_1$8;
var templateObject_2$8;
var templateObject_3$8;
var templateObject_4$8;
var templateObject_5$6;
var templateObject_6$6;
var templateObject_7$5;
var templateObject_8$5;
var templateObject_9$4;
var templateObject_10$4;
var templateObject_11$4;
var templateObject_12$4;

var Fragment = /** @class */ (function (_super) {
    __extends(Fragment, _super);
    function Fragment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Fragment.prototype.init = function () {
        this.block = new Block$2({
            generator: this.generator,
            name: '@create_main_fragment',
            key: null,
            contexts: new Map(),
            indexes: new Map(),
            changeableIndexes: new Map(),
            params: ['state'],
            indexNames: new Map(),
            listNames: new Map(),
            dependencies: new Set()
        });
        this.generator.blocks.push(this.block);
        this.initChildren(this.block, true, null);
        this.block.hasUpdateMethod = true;
    };
    Fragment.prototype.build = function () {
        var _this = this;
        this.init();
        this.children.forEach(function (child) {
            child.build(_this.block, null, 'nodes');
        });
    };
    return Fragment;
}(Node$1));

var Head = /** @class */ (function (_super) {
    __extends(Head, _super);
    function Head() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Head.prototype.init = function (block, stripWhitespace, nextSibling) {
        this.initChildren(block, true, null);
    };
    Head.prototype.build = function (block, parentNode, parentNodes) {
        var generator = this.generator;
        this["var"] = 'document.head';
        this.children.forEach(function (child) {
            child.build(block, 'document.head', null);
        });
    };
    return Head;
}(Node$1));

function isElseIf(node) {
    return (node && node.children.length === 1 && node.children[0].type === 'IfBlock');
}
function isElseBranch(branch) {
    return branch.block && !branch.condition;
}
var IfBlock = /** @class */ (function (_super) {
    __extends(IfBlock, _super);
    function IfBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IfBlock.prototype.init = function (block, stripWhitespace, nextSibling) {
        var generator = this.generator;
        this.cannotUseInnerHTML();
        var blocks = [];
        var dynamic = false;
        var hasIntros = false;
        var hasOutros = false;
        function attachBlocks(node) {
            node["var"] = block.getUniqueName("if_block");
            block.addDependencies(node.metadata.dependencies);
            node.block = block.child({
                comment: createDebuggingComment(node, generator),
                name: generator.getUniqueName("create_if_block")
            });
            blocks.push(node.block);
            node.initChildren(node.block, stripWhitespace, nextSibling);
            if (node.block.dependencies.size > 0) {
                dynamic = true;
                block.addDependencies(node.block.dependencies);
            }
            if (node.block.hasIntroMethod)
                hasIntros = true;
            if (node.block.hasOutroMethod)
                hasOutros = true;
            if (isElseIf(node["else"])) {
                attachBlocks(node["else"].children[0]);
            }
            else if (node["else"]) {
                node["else"].block = block.child({
                    comment: createDebuggingComment(node["else"], generator),
                    name: generator.getUniqueName("create_if_block")
                });
                blocks.push(node["else"].block);
                node["else"].initChildren(node["else"].block, stripWhitespace, nextSibling);
                if (node["else"].block.dependencies.size > 0) {
                    dynamic = true;
                    block.addDependencies(node["else"].block.dependencies);
                }
            }
        }
        attachBlocks(this);
        blocks.forEach(function (block) {
            block.hasUpdateMethod = dynamic;
            block.hasIntroMethod = hasIntros;
            block.hasOutroMethod = hasOutros;
        });
        (_a = generator.blocks).push.apply(_a, blocks);
        var _a;
    };
    IfBlock.prototype.build = function (block, parentNode, parentNodes) {
        var name = this["var"];
        var needsAnchor = this.next ? !this.next.isDomNode() : !parentNode || !this.parent.isDomNode();
        var anchor = needsAnchor
            ? block.getUniqueName(name + "_anchor")
            : (this.next && this.next["var"]) || 'null';
        var params = block.params.join(', ');
        var branches = getBranches(this.generator, block, parentNode, parentNodes, this);
        var hasElse = isElseBranch(branches[branches.length - 1]);
        var if_name = hasElse ? '' : "if (" + name + ") ";
        var dynamic = branches[0].hasUpdateMethod; // can use [0] as proxy for all, since they necessarily have the same value
        var hasOutros = branches[0].hasOutroMethod;
        var vars = { name: name, anchor: anchor, params: params, if_name: if_name, hasElse: hasElse };
        if (this["else"]) {
            if (hasOutros) {
                compoundWithOutros(this.generator, block, parentNode, parentNodes, this, branches, dynamic, vars);
            }
            else {
                compound(this.generator, block, parentNode, parentNodes, this, branches, dynamic, vars);
            }
        }
        else {
            simple(this.generator, block, parentNode, parentNodes, this, branches[0], dynamic, vars);
        }
        block.builders.create.addLine("" + if_name + name + ".c();");
        if (parentNodes) {
            block.builders.claim.addLine("" + if_name + name + ".l(" + parentNodes + ");");
        }
        if (needsAnchor) {
            block.addElement(anchor, "@createComment()", parentNodes && "@createComment()", parentNode);
        }
    };
    return IfBlock;
}(Node$1));
// TODO move all this into the class
function getBranches(generator, block, parentNode, parentNodes, node) {
    block.contextualise(node.expression); // TODO remove
    var branches = [
        {
            condition: node.metadata.snippet,
            block: node.block.name,
            hasUpdateMethod: node.block.hasUpdateMethod,
            hasIntroMethod: node.block.hasIntroMethod,
            hasOutroMethod: node.block.hasOutroMethod
        },
    ];
    visitChildren(generator, block, node);
    if (isElseIf(node["else"])) {
        branches.push.apply(branches, getBranches(generator, block, parentNode, parentNodes, node["else"].children[0]));
    }
    else {
        branches.push({
            condition: null,
            block: node["else"] ? node["else"].block.name : null,
            hasUpdateMethod: node["else"] ? node["else"].block.hasUpdateMethod : false,
            hasIntroMethod: node["else"] ? node["else"].block.hasIntroMethod : false,
            hasOutroMethod: node["else"] ? node["else"].block.hasOutroMethod : false
        });
        if (node["else"]) {
            visitChildren(generator, block, node["else"]);
        }
    }
    return branches;
}
function visitChildren(generator, block, node) {
    node.children.forEach(function (child) {
        child.build(node.block, null, 'nodes');
    });
}
function simple(generator, block, parentNode, parentNodes, node, branch, dynamic, _a) {
    var name = _a.name, anchor = _a.anchor, params = _a.params, if_name = _a.if_name;
    block.builders.init.addBlock(deindent(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject(["\n\t\tvar ", " = (", ") && ", "(", ", #component);\n\t"], ["\n\t\tvar ", " = (", ") && ", "(", ", #component);\n\t"])), name, branch.condition, branch.block, params));
    var mountOrIntro = branch.hasIntroMethod ? 'i' : 'm';
    var initialMountNode = parentNode || '#target';
    var anchorNode = parentNode ? 'null' : 'anchor';
    block.builders.mount.addLine("if (" + name + ") " + name + "." + mountOrIntro + "(" + initialMountNode + ", " + anchorNode + ");");
    var updateMountNode = node.getUpdateMountNode(anchor);
    var enter = dynamic
        ? branch.hasIntroMethod
            ? deindent(templateObject_2$9 || (templateObject_2$9 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".p(changed, ", ");\n\t\t\t\t} else {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\tif (", ") ", ".c();\n\t\t\t\t}\n\n\t\t\t\t", ".i(", ", ", ");\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".p(changed, ", ");\n\t\t\t\t} else {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\tif (", ") ", ".c();\n\t\t\t\t}\n\n\t\t\t\t", ".i(", ", ", ");\n\t\t\t"])), name, name, params, name, branch.block, params, name, name, name, updateMountNode, anchor) : deindent(templateObject_3$9 || (templateObject_3$9 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".p(changed, ", ");\n\t\t\t\t} else {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t", ".c();\n\t\t\t\t\t", ".m(", ", ", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".p(changed, ", ");\n\t\t\t\t} else {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t", ".c();\n\t\t\t\t\t", ".m(", ", ", ");\n\t\t\t\t}\n\t\t\t"])), name, name, params, name, branch.block, params, name, name, updateMountNode, anchor)
        : branch.hasIntroMethod
            ? deindent(templateObject_4$9 || (templateObject_4$9 = __makeTemplateObject(["\n\t\t\t\tif (!", ") {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t", ".c();\n\t\t\t\t}\n\t\t\t\t", ".i(", ", ", ");\n\t\t\t"], ["\n\t\t\t\tif (!", ") {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t", ".c();\n\t\t\t\t}\n\t\t\t\t", ".i(", ", ", ");\n\t\t\t"])), name, name, branch.block, params, name, name, updateMountNode, anchor) : deindent(templateObject_5$7 || (templateObject_5$7 = __makeTemplateObject(["\n\t\t\t\tif (!", ") {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t", ".c();\n\t\t\t\t\t", ".m(", ", ", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (!", ") {\n\t\t\t\t\t", " = ", "(", ", #component);\n\t\t\t\t\t", ".c();\n\t\t\t\t\t", ".m(", ", ", ");\n\t\t\t\t}\n\t\t\t"])), name, name, branch.block, params, name, name, updateMountNode, anchor);
    // no `p()` here — we don't want to update outroing nodes,
    // as that will typically result in glitching
    var exit = branch.hasOutroMethod
        ? deindent(templateObject_6$7 || (templateObject_6$7 = __makeTemplateObject(["\n\t\t\t", ".o(function() {\n\t\t\t\t", ".u();\n\t\t\t\t", ".d();\n\t\t\t\t", " = null;\n\t\t\t});\n\t\t"], ["\n\t\t\t", ".o(function() {\n\t\t\t\t", ".u();\n\t\t\t\t", ".d();\n\t\t\t\t", " = null;\n\t\t\t});\n\t\t"])), name, name, name, name) : deindent(templateObject_7$6 || (templateObject_7$6 = __makeTemplateObject(["\n\t\t\t", ".u();\n\t\t\t", ".d();\n\t\t\t", " = null;\n\t\t"], ["\n\t\t\t", ".u();\n\t\t\t", ".d();\n\t\t\t", " = null;\n\t\t"])), name, name, name);
    block.builders.update.addBlock(deindent(templateObject_8$6 || (templateObject_8$6 = __makeTemplateObject(["\n\t\tif (", ") {\n\t\t\t", "\n\t\t} else if (", ") {\n\t\t\t", "\n\t\t}\n\t"], ["\n\t\tif (", ") {\n\t\t\t", "\n\t\t} else if (", ") {\n\t\t\t", "\n\t\t}\n\t"])), branch.condition, enter, name, exit));
    block.builders.unmount.addLine("" + if_name + name + ".u();");
    block.builders.destroy.addLine("" + if_name + name + ".d();");
}
function compound(generator, block, parentNode, parentNodes, node, branches, dynamic, _a) {
    var name = _a.name, anchor = _a.anchor, params = _a.params, hasElse = _a.hasElse, if_name = _a.if_name;
    var select_block_type = generator.getUniqueName("select_block_type");
    var current_block_type = block.getUniqueName("current_block_type");
    var current_block_type_and = hasElse ? '' : current_block_type + " && ";
    generator.blocks.push(deindent(templateObject_9$5 || (templateObject_9$5 = __makeTemplateObject(["\n\t\tfunction ", "(", ") {\n\t\t\t", "\n\t\t}\n\t"], ["\n\t\tfunction ", "(", ") {\n\t\t\t",
        "\n\t\t}\n\t"])), select_block_type, params, branches
        .map(function (_a) {
        var condition = _a.condition, block = _a.block;
        return (condition ? "if (" + condition + ") " : '') + "return " + block + ";";
    })
        .join('\n')));
    block.builders.init.addBlock(deindent(templateObject_10$5 || (templateObject_10$5 = __makeTemplateObject(["\n\t\tvar ", " = ", "(", ");\n\t\tvar ", " = ", "", "(", ", #component);\n\t"], ["\n\t\tvar ", " = ", "(", ");\n\t\tvar ", " = ", "", "(", ", #component);\n\t"])), current_block_type, select_block_type, params, name, current_block_type_and, current_block_type, params));
    var mountOrIntro = branches[0].hasIntroMethod ? 'i' : 'm';
    var initialMountNode = parentNode || '#target';
    var anchorNode = parentNode ? 'null' : 'anchor';
    block.builders.mount.addLine("" + if_name + name + "." + mountOrIntro + "(" + initialMountNode + ", " + anchorNode + ");");
    var updateMountNode = node.getUpdateMountNode(anchor);
    var changeBlock = deindent(templateObject_11$5 || (templateObject_11$5 = __makeTemplateObject(["\n\t\t", "\n\t\t", " = ", "", "(", ", #component);\n\t\t", "", ".c();\n\t\t", "", ".", "(", ", ", ");\n\t"], ["\n\t\t",
        "\n\t\t", " = ", "", "(", ", #component);\n\t\t", "", ".c();\n\t\t", "", ".", "(", ", ", ");\n\t"])), hasElse
        ? deindent(templateObject_12$5 || (templateObject_12$5 = __makeTemplateObject(["\n\t\t\t\t", ".u();\n\t\t\t\t", ".d();\n\t\t\t"], ["\n\t\t\t\t", ".u();\n\t\t\t\t", ".d();\n\t\t\t"])), name, name) : deindent(templateObject_13$4 || (templateObject_13$4 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".u();\n\t\t\t\t\t", ".d();\n\t\t\t\t}"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", ".u();\n\t\t\t\t\t", ".d();\n\t\t\t\t}"])), name, name, name), name, current_block_type_and, current_block_type, params, if_name, name, if_name, name, mountOrIntro, updateMountNode, anchor);
    if (dynamic) {
        block.builders.update.addBlock(deindent(templateObject_14$3 || (templateObject_14$3 = __makeTemplateObject(["\n\t\t\tif (", " === (", " = ", "(", ")) && ", ") {\n\t\t\t\t", ".p(changed, ", ");\n\t\t\t} else {\n\t\t\t\t", "\n\t\t\t}\n\t\t"], ["\n\t\t\tif (", " === (", " = ", "(", ")) && ", ") {\n\t\t\t\t", ".p(changed, ", ");\n\t\t\t} else {\n\t\t\t\t", "\n\t\t\t}\n\t\t"])), current_block_type, current_block_type, select_block_type, params, name, name, params, changeBlock));
    }
    else {
        block.builders.update.addBlock(deindent(templateObject_15$3 || (templateObject_15$3 = __makeTemplateObject(["\n\t\t\tif (", " !== (", " = ", "(", "))) {\n\t\t\t\t", "\n\t\t\t}\n\t\t"], ["\n\t\t\tif (", " !== (", " = ", "(", "))) {\n\t\t\t\t", "\n\t\t\t}\n\t\t"])), current_block_type, current_block_type, select_block_type, params, changeBlock));
    }
    block.builders.unmount.addLine("" + if_name + name + ".u();");
    block.builders.destroy.addLine("" + if_name + name + ".d();");
}
// if any of the siblings have outros, we need to keep references to the blocks
// (TODO does this only apply to bidi transitions?)
function compoundWithOutros(generator, block, parentNode, parentNodes, node, branches, dynamic, _a) {
    var name = _a.name, anchor = _a.anchor, params = _a.params, hasElse = _a.hasElse;
    var select_block_type = block.getUniqueName("select_block_type");
    var current_block_type_index = block.getUniqueName("current_block_type_index");
    var previous_block_index = block.getUniqueName("previous_block_index");
    var if_block_creators = block.getUniqueName("if_block_creators");
    var if_blocks = block.getUniqueName("if_blocks");
    var if_current_block_type_index = hasElse
        ? ''
        : "if (~" + current_block_type_index + ") ";
    block.addVariable(current_block_type_index);
    block.addVariable(name);
    block.builders.init.addBlock(deindent(templateObject_16$3 || (templateObject_16$3 = __makeTemplateObject(["\n\t\tvar ", " = [\n\t\t\t", "\n\t\t];\n\n\t\tvar ", " = [];\n\n\t\tfunction ", "(", ") {\n\t\t\t", "\n\t\t}\n\t"], ["\n\t\tvar ", " = [\n\t\t\t", "\n\t\t];\n\n\t\tvar ", " = [];\n\n\t\tfunction ", "(", ") {\n\t\t\t",
        "\n\t\t}\n\t"])), if_block_creators, branches.map(function (branch) { return branch.block; }).join(',\n'), if_blocks, select_block_type, params, branches
        .map(function (_a, i) {
        var condition = _a.condition, block = _a.block;
        return (condition ? "if (" + condition + ") " : '') + "return " + (block ? i : -1) + ";";
    })
        .join('\n')));
    if (hasElse) {
        block.builders.init.addBlock(deindent(templateObject_17$3 || (templateObject_17$3 = __makeTemplateObject(["\n\t\t\t", " = ", "(", ");\n\t\t\t", " = ", "[", "] = ", "[", "](", ", #component);\n\t\t"], ["\n\t\t\t", " = ", "(", ");\n\t\t\t", " = ", "[", "] = ", "[", "](", ", #component);\n\t\t"])), current_block_type_index, select_block_type, params, name, if_blocks, current_block_type_index, if_block_creators, current_block_type_index, params));
    }
    else {
        block.builders.init.addBlock(deindent(templateObject_18$3 || (templateObject_18$3 = __makeTemplateObject(["\n\t\t\tif (~(", " = ", "(", "))) {\n\t\t\t\t", " = ", "[", "] = ", "[", "](", ", #component);\n\t\t\t}\n\t\t"], ["\n\t\t\tif (~(", " = ", "(", "))) {\n\t\t\t\t", " = ", "[", "] = ", "[", "](", ", #component);\n\t\t\t}\n\t\t"])), current_block_type_index, select_block_type, params, name, if_blocks, current_block_type_index, if_block_creators, current_block_type_index, params));
    }
    var mountOrIntro = branches[0].hasIntroMethod ? 'i' : 'm';
    var initialMountNode = parentNode || '#target';
    var anchorNode = parentNode ? 'null' : 'anchor';
    block.builders.mount.addLine("" + if_current_block_type_index + if_blocks + "[" + current_block_type_index + "]." + mountOrIntro + "(" + initialMountNode + ", " + anchorNode + ");");
    var updateMountNode = node.getUpdateMountNode(anchor);
    var destroyOldBlock = deindent(templateObject_19$3 || (templateObject_19$3 = __makeTemplateObject(["\n\t\t", ".o(function() {\n\t\t\t", "[ ", " ].u();\n\t\t\t", "[ ", " ].d();\n\t\t\t", "[ ", " ] = null;\n\t\t});\n\t"], ["\n\t\t", ".o(function() {\n\t\t\t", "[ ", " ].u();\n\t\t\t", "[ ", " ].d();\n\t\t\t", "[ ", " ] = null;\n\t\t});\n\t"])), name, if_blocks, previous_block_index, if_blocks, previous_block_index, if_blocks, previous_block_index);
    var createNewBlock = deindent(templateObject_20$2 || (templateObject_20$2 = __makeTemplateObject(["\n\t\t", " = ", "[", "];\n\t\tif (!", ") {\n\t\t\t", " = ", "[", "] = ", "[", "](", ", #component);\n\t\t\t", ".c();\n\t\t}\n\t\t", ".", "(", ", ", ");\n\t"], ["\n\t\t", " = ", "[", "];\n\t\tif (!", ") {\n\t\t\t", " = ", "[", "] = ", "[", "](", ", #component);\n\t\t\t", ".c();\n\t\t}\n\t\t", ".", "(", ", ", ");\n\t"])), name, if_blocks, current_block_type_index, name, name, if_blocks, current_block_type_index, if_block_creators, current_block_type_index, params, name, name, mountOrIntro, updateMountNode, anchor);
    var changeBlock = hasElse
        ? deindent(templateObject_21$1 || (templateObject_21$1 = __makeTemplateObject(["\n\t\t\t", "\n\n\t\t\t", "\n\t\t"], ["\n\t\t\t", "\n\n\t\t\t", "\n\t\t"])), destroyOldBlock, createNewBlock) : deindent(templateObject_22$1 || (templateObject_22$1 = __makeTemplateObject(["\n\t\t\tif (", ") {\n\t\t\t\t", "\n\t\t\t}\n\n\t\t\tif (~", ") {\n\t\t\t\t", "\n\t\t\t} else {\n\t\t\t\t", " = null;\n\t\t\t}\n\t\t"], ["\n\t\t\tif (", ") {\n\t\t\t\t", "\n\t\t\t}\n\n\t\t\tif (~", ") {\n\t\t\t\t", "\n\t\t\t} else {\n\t\t\t\t", " = null;\n\t\t\t}\n\t\t"])), name, destroyOldBlock, current_block_type_index, createNewBlock, name);
    if (dynamic) {
        block.builders.update.addBlock(deindent(templateObject_23$1 || (templateObject_23$1 = __makeTemplateObject(["\n\t\t\tvar ", " = ", ";\n\t\t\t", " = ", "(", ");\n\t\t\tif (", " === ", ") {\n\t\t\t\t", "", "[", "].p(changed, ", ");\n\t\t\t} else {\n\t\t\t\t", "\n\t\t\t}\n\t\t"], ["\n\t\t\tvar ", " = ", ";\n\t\t\t", " = ", "(", ");\n\t\t\tif (", " === ", ") {\n\t\t\t\t", "", "[", "].p(changed, ", ");\n\t\t\t} else {\n\t\t\t\t", "\n\t\t\t}\n\t\t"])), previous_block_index, current_block_type_index, current_block_type_index, select_block_type, params, current_block_type_index, previous_block_index, if_current_block_type_index, if_blocks, current_block_type_index, params, changeBlock));
    }
    else {
        block.builders.update.addBlock(deindent(templateObject_24$1 || (templateObject_24$1 = __makeTemplateObject(["\n\t\t\tvar ", " = ", ";\n\t\t\t", " = ", "(", ");\n\t\t\tif (", " !== ", ") {\n\t\t\t\t", "\n\t\t\t}\n\t\t"], ["\n\t\t\tvar ", " = ", ";\n\t\t\t", " = ", "(", ");\n\t\t\tif (", " !== ", ") {\n\t\t\t\t", "\n\t\t\t}\n\t\t"])), previous_block_index, current_block_type_index, current_block_type_index, select_block_type, params, current_block_type_index, previous_block_index, changeBlock));
    }
    block.builders.destroy.addLine(deindent(templateObject_25$1 || (templateObject_25$1 = __makeTemplateObject(["\n\t\t", "{\n\t\t\t", "[", "].u();\n\t\t\t", "[", "].d();\n\t\t}\n\t"], ["\n\t\t", "{\n\t\t\t", "[", "].u();\n\t\t\t", "[", "].d();\n\t\t}\n\t"])), if_current_block_type_index, if_blocks, current_block_type_index, if_blocks, current_block_type_index));
}
var templateObject_1$9;
var templateObject_2$9;
var templateObject_3$9;
var templateObject_4$9;
var templateObject_5$7;
var templateObject_6$7;
var templateObject_7$6;
var templateObject_8$6;
var templateObject_9$5;
var templateObject_10$5;
var templateObject_12$5;
var templateObject_13$4;
var templateObject_11$5;
var templateObject_14$3;
var templateObject_15$3;
var templateObject_16$3;
var templateObject_17$3;
var templateObject_18$3;
var templateObject_19$3;
var templateObject_20$2;
var templateObject_21$1;
var templateObject_22$1;
var templateObject_23$1;
var templateObject_24$1;
var templateObject_25$1;

var Tag = /** @class */ (function (_super) {
    __extends(Tag, _super);
    function Tag() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tag.prototype.renameThisMethod = function (block, update) {
        var indexes = block.contextualise(this.expression).indexes;
        var _a = this.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
        var hasChangeableIndex = Array.from(indexes).some(function (index) { return block.changeableIndexes.get(index); });
        var shouldCache = (this.expression.type !== 'Identifier' ||
            block.contexts.has(this.expression.name) ||
            hasChangeableIndex);
        var value = shouldCache && block.getUniqueName(this["var"] + "_value");
        var content = shouldCache ? value : snippet;
        if (shouldCache)
            block.addVariable(value, snippet);
        if (dependencies.length || hasChangeableIndex) {
            var changedCheck = ((block.hasOutroMethod ? "#outroing || " : '') +
                dependencies.map(function (dependency) { return "changed." + dependency; }).join(' || '));
            var updateCachedValue = value + " !== (" + value + " = " + snippet + ")";
            var condition = shouldCache ?
                (dependencies.length ? "(" + changedCheck + ") && " + updateCachedValue : updateCachedValue) :
                changedCheck;
            block.builders.update.addConditional(condition, update(content));
        }
        return { init: content };
    };
    return Tag;
}(Node$1));

var MustacheTag = /** @class */ (function (_super) {
    __extends(MustacheTag, _super);
    function MustacheTag() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MustacheTag.prototype.init = function (block) {
        this.cannotUseInnerHTML();
        this["var"] = block.getUniqueName('text');
        block.addDependencies(this.metadata.dependencies);
    };
    MustacheTag.prototype.build = function (block, parentNode, parentNodes) {
        var _this = this;
        var init = this.renameThisMethod(block, function (value) { return _this["var"] + ".data = " + value + ";"; }).init;
        block.addElement(this["var"], "@createText(" + init + ")", parentNodes && "@claimText(" + parentNodes + ", " + init + ")", parentNode);
    };
    return MustacheTag;
}(Tag));

var PendingBlock = /** @class */ (function (_super) {
    __extends(PendingBlock, _super);
    function PendingBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return PendingBlock;
}(Node$1));

var RawMustacheTag = /** @class */ (function (_super) {
    __extends(RawMustacheTag, _super);
    function RawMustacheTag() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RawMustacheTag.prototype.init = function (block) {
        this.cannotUseInnerHTML();
        this["var"] = block.getUniqueName('raw');
        block.addDependencies(this.metadata.dependencies);
    };
    RawMustacheTag.prototype.build = function (block, parentNode, parentNodes) {
        var name = this["var"];
        var needsAnchorBefore = this.prev ? this.prev.type !== 'Element' : !parentNode;
        var needsAnchorAfter = this.next ? this.next.type !== 'Element' : !parentNode;
        var anchorBefore = needsAnchorBefore
            ? block.getUniqueName(name + "_before")
            : (this.prev && this.prev["var"]) || 'null';
        var anchorAfter = needsAnchorAfter
            ? block.getUniqueName(name + "_after")
            : (this.next && this.next["var"]) || 'null';
        var detach;
        var insert;
        var useInnerHTML = false;
        if (anchorBefore === 'null' && anchorAfter === 'null') {
            useInnerHTML = true;
            detach = parentNode + ".innerHTML = '';";
            insert = function (content) { return parentNode + ".innerHTML = " + content + ";"; };
        }
        else if (anchorBefore === 'null') {
            detach = "@detachBefore(" + anchorAfter + ");";
            insert = function (content) { return anchorAfter + ".insertAdjacentHTML(\"beforebegin\", " + content + ");"; };
        }
        else if (anchorAfter === 'null') {
            detach = "@detachAfter(" + anchorBefore + ");";
            insert = function (content) { return anchorBefore + ".insertAdjacentHTML(\"afterend\", " + content + ");"; };
        }
        else {
            detach = "@detachBetween(" + anchorBefore + ", " + anchorAfter + ");";
            insert = function (content) { return anchorBefore + ".insertAdjacentHTML(\"afterend\", " + content + ");"; };
        }
        var init = this.renameThisMethod(block, function (content) { return deindent(templateObject_1$10 || (templateObject_1$10 = __makeTemplateObject(["\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t"], ["\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t"])), !useInnerHTML && detach, insert(content)); }).init;
        // we would have used comments here, but the `insertAdjacentHTML` api only
        // exists for `Element`s.
        if (needsAnchorBefore) {
            block.addElement(anchorBefore, "@createElement('noscript')", parentNodes && "@createElement('noscript')", parentNode);
        }
        function addAnchorAfter() {
            block.addElement(anchorAfter, "@createElement('noscript')", parentNodes && "@createElement('noscript')", parentNode);
        }
        if (needsAnchorAfter && anchorBefore === 'null') {
            // anchorAfter needs to be in the DOM before we
            // insert the HTML...
            addAnchorAfter();
        }
        block.builders.mount.addLine(insert(init));
        block.builders.detachRaw.addBlock(detach);
        if (needsAnchorAfter && anchorBefore !== 'null') {
            // ...otherwise it should go afterwards
            addAnchorAfter();
        }
    };
    return RawMustacheTag;
}(Tag));
var templateObject_1$10;

var Ref = /** @class */ (function (_super) {
    __extends(Ref, _super);
    function Ref() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Ref;
}(Node$1));

var Slot = /** @class */ (function (_super) {
    __extends(Slot, _super);
    function Slot() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Slot.prototype.init = function (block, stripWhitespace, nextSibling) {
        this.cannotUseInnerHTML();
        this["var"] = block.getUniqueName('slot');
        if (this.children.length) {
            this.initChildren(block, stripWhitespace, nextSibling);
        }
    };
    Slot.prototype.build = function (block, parentNode, parentNodes) {
        var generator = this.generator;
        var slotName = this.getStaticAttributeValue('name') || 'default';
        generator.slots.add(slotName);
        var content_name = block.getUniqueName("slot_content_" + slotName);
        block.addVariable(content_name, "#component._slotted." + slotName);
        var needsAnchorBefore = this.prev ? this.prev.type !== 'Element' : !parentNode;
        var needsAnchorAfter = this.next ? this.next.type !== 'Element' : !parentNode;
        var anchorBefore = needsAnchorBefore
            ? block.getUniqueName(content_name + "_before")
            : (this.prev && this.prev["var"]) || 'null';
        var anchorAfter = needsAnchorAfter
            ? block.getUniqueName(content_name + "_after")
            : (this.next && this.next["var"]) || 'null';
        if (needsAnchorBefore)
            block.addVariable(anchorBefore);
        if (needsAnchorAfter)
            block.addVariable(anchorAfter);
        block.builders.create.pushCondition("!" + content_name);
        block.builders.hydrate.pushCondition("!" + content_name);
        block.builders.mount.pushCondition("!" + content_name);
        block.builders.unmount.pushCondition("!" + content_name);
        block.builders.destroy.pushCondition("!" + content_name);
        this.children.forEach(function (child) {
            child.build(block, parentNode, parentNodes);
        });
        block.builders.create.popCondition();
        block.builders.hydrate.popCondition();
        block.builders.mount.popCondition();
        block.builders.unmount.popCondition();
        block.builders.destroy.popCondition();
        // TODO can we use an else here?
        if (parentNode) {
            block.builders.mount.addBlock(deindent(templateObject_1$11 || (templateObject_1$11 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", "\n\t\t\t\t\t@appendNode(", ", ", ");\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", "\n\t\t\t\t\t@appendNode(", ", ", ");\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"])), content_name, needsAnchorBefore && "@appendNode(" + anchorBefore + " || (" + anchorBefore + " = @createComment()), " + parentNode + ");", content_name, parentNode, needsAnchorAfter && "@appendNode(" + anchorAfter + " || (" + anchorAfter + " = @createComment()), " + parentNode + ");"));
        }
        else {
            block.builders.mount.addBlock(deindent(templateObject_2$10 || (templateObject_2$10 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", "\n\t\t\t\t\t@insertNode(", ", #target, anchor);\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t", "\n\t\t\t\t\t@insertNode(", ", #target, anchor);\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"])), content_name, needsAnchorBefore && "@insertNode(" + anchorBefore + " || (" + anchorBefore + " = @createComment()), #target, anchor);", content_name, needsAnchorAfter && "@insertNode(" + anchorAfter + " || (" + anchorAfter + " = @createComment()), #target, anchor);"));
        }
        // if the slot is unmounted, move nodes back into the document fragment,
        // so that it can be reinserted later
        // TODO so that this can work with public API, component._slotted should
        // be all fragments, derived from options.slots. Not === options.slots
        // TODO can we use an else here?
        if (anchorBefore === 'null' && anchorAfter === 'null') {
            block.builders.unmount.addBlock(deindent(templateObject_3$10 || (templateObject_3$10 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t@reinsertChildren(", ", ", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t@reinsertChildren(", ", ", ");\n\t\t\t\t}\n\t\t\t"])), content_name, parentNode, content_name));
        }
        else if (anchorBefore === 'null') {
            block.builders.unmount.addBlock(deindent(templateObject_4$10 || (templateObject_4$10 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t@reinsertBefore(", ", ", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t@reinsertBefore(", ", ", ");\n\t\t\t\t}\n\t\t\t"])), content_name, anchorAfter, content_name));
        }
        else if (anchorAfter === 'null') {
            block.builders.unmount.addBlock(deindent(templateObject_5$8 || (templateObject_5$8 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t@reinsertAfter(", ", ", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t@reinsertAfter(", ", ", ");\n\t\t\t\t}\n\t\t\t"])), content_name, anchorBefore, content_name));
        }
        else {
            block.builders.unmount.addBlock(deindent(templateObject_6$8 || (templateObject_6$8 = __makeTemplateObject(["\n\t\t\t\tif (", ") {\n\t\t\t\t\t@reinsertBetween(", ", ", ", ", ");\n\t\t\t\t\t@detachNode(", ");\n\t\t\t\t\t@detachNode(", ");\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tif (", ") {\n\t\t\t\t\t@reinsertBetween(", ", ", ", ", ");\n\t\t\t\t\t@detachNode(", ");\n\t\t\t\t\t@detachNode(", ");\n\t\t\t\t}\n\t\t\t"])), content_name, anchorBefore, anchorAfter, content_name, anchorBefore, anchorAfter));
        }
    };
    Slot.prototype.getStaticAttributeValue = function (name) {
        var attribute = this.attributes.find(function (attr) { return attr.name.toLowerCase() === name; });
        if (!attribute)
            return null;
        if (attribute.value === true)
            return true;
        if (attribute.value.length === 0)
            return '';
        if (attribute.value.length === 1 && attribute.value[0].type === 'Text') {
            return attribute.value[0].data;
        }
        return null;
    };
    return Slot;
}(Element));
var templateObject_1$11;
var templateObject_2$10;
var templateObject_3$10;
var templateObject_4$10;
var templateObject_5$8;
var templateObject_6$8;

// Whitespace inside one of these elements will not result in
// a whitespace node being created in any circumstances. (This
// list is almost certainly very incomplete)
var elementsWithoutText = new Set([
    'audio',
    'datalist',
    'dl',
    'ol',
    'optgroup',
    'select',
    'ul',
    'video',
]);
function shouldSkip$1(node) {
    if (/\S/.test(node.data))
        return false;
    var parentElement = node.findNearest(/(?:Element|Component)/);
    if (!parentElement)
        return false;
    if (parentElement.type === 'Component')
        return parentElement.children.length === 1 && node === parentElement.children[0];
    return parentElement.namespace || elementsWithoutText.has(parentElement.name);
}
var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Text.prototype.init = function (block) {
        var parentElement = this.findNearest(/(?:Element|Component)/);
        if (shouldSkip$1(this)) {
            this.shouldSkip = true;
            return;
        }
        this["var"] = block.getUniqueName("text");
    };
    Text.prototype.build = function (block, parentNode, parentNodes) {
        if (this.shouldSkip)
            return;
        block.addElement(this["var"], "@createText(" + stringify(this.data) + ")", parentNodes && "@claimText(" + parentNodes + ", " + stringify(this.data) + ")", parentNode);
    };
    return Text;
}(Node$1));

var ThenBlock = /** @class */ (function (_super) {
    __extends(ThenBlock, _super);
    function ThenBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ThenBlock;
}(Node$1));

var Transition = /** @class */ (function (_super) {
    __extends(Transition, _super);
    function Transition() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Transition;
}(Node$1));

var associatedEvents = {
    innerWidth: 'resize',
    innerHeight: 'resize',
    outerWidth: 'resize',
    outerHeight: 'resize',
    scrollX: 'scroll',
    scrollY: 'scroll'
};
var readonly = new Set([
    'innerWidth',
    'innerHeight',
    'outerWidth',
    'outerHeight',
    'online',
]);
var Window = /** @class */ (function (_super) {
    __extends(Window, _super);
    function Window() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Window.prototype.build = function (block, parentNode, parentNodes) {
        var generator = this.generator;
        var events = {};
        var bindings = {};
        this.attributes.forEach(function (attribute) {
            if (attribute.type === 'EventHandler') {
                // TODO verify that it's a valid callee (i.e. built-in or declared method)
                generator.addSourcemapLocations(attribute.expression);
                var usesState_1 = false;
                attribute.expression.arguments.forEach(function (arg) {
                    block.contextualise(arg, null, true);
                    var dependencies = arg.metadata.dependencies;
                    if (dependencies.length)
                        usesState_1 = true;
                });
                var flattened = flatten(attribute.expression.callee);
                if (flattened.name !== 'event' && flattened.name !== 'this') {
                    // allow event.stopPropagation(), this.select() etc
                    generator.code.prependRight(attribute.expression.start, block.alias('component') + ".");
                }
                var handlerName = block.getUniqueName("onwindow" + attribute.name);
                var handlerBody = deindent(templateObject_1$12 || (templateObject_1$12 = __makeTemplateObject(["\n\t\t\t\t\t", "\n\t\t\t\t\t[\u2702", "-", "\u2702];\n\t\t\t\t"], ["\n\t\t\t\t\t", "\n\t\t\t\t\t[\u2702", "-", "\u2702];\n\t\t\t\t"])), usesState_1 && "var state = #component.get();", attribute.expression.start, attribute.expression.end);
                block.builders.init.addBlock(deindent(templateObject_2$11 || (templateObject_2$11 = __makeTemplateObject(["\n\t\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\t\t\t\t\twindow.addEventListener(\"", "\", ", ");\n\t\t\t\t"], ["\n\t\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t\t", "\n\t\t\t\t\t}\n\t\t\t\t\twindow.addEventListener(\"", "\", ", ");\n\t\t\t\t"])), handlerName, handlerBody, attribute.name, handlerName));
                block.builders.destroy.addBlock(deindent(templateObject_3$11 || (templateObject_3$11 = __makeTemplateObject(["\n\t\t\t\t\twindow.removeEventListener(\"", "\", ", ");\n\t\t\t\t"], ["\n\t\t\t\t\twindow.removeEventListener(\"", "\", ", ");\n\t\t\t\t"])), attribute.name, handlerName));
            }
            if (attribute.type === 'Binding') {
                // in dev mode, throw if read-only values are written to
                if (readonly.has(attribute.name)) {
                    generator.readonly.add(attribute.value.name);
                }
                bindings[attribute.name] = attribute.value.name;
                // bind:online is a special case, we need to listen for two separate events
                if (attribute.name === 'online')
                    return;
                var associatedEvent = associatedEvents[attribute.name];
                if (!events[associatedEvent])
                    events[associatedEvent] = [];
                events[associatedEvent].push(attribute.value.name + ": this." + attribute.name);
                // add initial value
                generator.metaBindings.push("this._state." + attribute.value.name + " = window." + attribute.name + ";");
            }
        });
        var lock = block.getUniqueName("window_updating");
        Object.keys(events).forEach(function (event) {
            var handlerName = block.getUniqueName("onwindow" + event);
            var props = events[event].join(',\n');
            if (event === 'scroll') {
                // TODO other bidirectional bindings...
                block.addVariable(lock, 'false');
            }
            var handlerBody = deindent(templateObject_4$11 || (templateObject_4$11 = __makeTemplateObject(["\n\t\t\t\t", "\n\t\t\t\t", "\n\n\t\t\t\t#component.set({\n\t\t\t\t\t", "\n\t\t\t\t});\n\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t"], ["\n\t\t\t\t", "\n\t\t\t\t", "\n\n\t\t\t\t#component.set({\n\t\t\t\t\t", "\n\t\t\t\t});\n\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t"])), event === 'scroll' && lock + " = true;", generator.options.dev && "component._updatingReadonlyProperty = true;", props, generator.options.dev && "component._updatingReadonlyProperty = false;", event === 'scroll' && lock + " = false;");
            block.builders.init.addBlock(deindent(templateObject_5$9 || (templateObject_5$9 = __makeTemplateObject(["\n\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t\twindow.addEventListener(\"", "\", ", ");\n\t\t\t"], ["\n\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t\twindow.addEventListener(\"", "\", ", ");\n\t\t\t"])), handlerName, handlerBody, event, handlerName));
            block.builders.destroy.addBlock(deindent(templateObject_6$9 || (templateObject_6$9 = __makeTemplateObject(["\n\t\t\t\twindow.removeEventListener(\"", "\", ", ");\n\t\t\t"], ["\n\t\t\t\twindow.removeEventListener(\"", "\", ", ");\n\t\t\t"])), event, handlerName));
        });
        // special case... might need to abstract this out if we add more special cases
        if (bindings.scrollX && bindings.scrollY) {
            var observerCallback = block.getUniqueName("scrollobserver");
            block.builders.init.addBlock(deindent(templateObject_7$7 || (templateObject_7$7 = __makeTemplateObject(["\n\t\t\t\tfunction ", "() {\n\t\t\t\t\tif (", ") return;\n\t\t\t\t\tvar x = ", ";\n\t\t\t\t\tvar y = ", ";\n\t\t\t\t\twindow.scrollTo(x, y);\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tfunction ", "() {\n\t\t\t\t\tif (", ") return;\n\t\t\t\t\tvar x = ",
                ";\n\t\t\t\t\tvar y = ",
                ";\n\t\t\t\t\twindow.scrollTo(x, y);\n\t\t\t\t}\n\t\t\t"])), observerCallback, lock, bindings.scrollX
                ? "#component.get(\"" + bindings.scrollX + "\")"
                : "window.scrollX", bindings.scrollY
                ? "#component.get(\"" + bindings.scrollY + "\")"
                : "window.scrollY"));
            if (bindings.scrollX)
                block.builders.init.addLine("#component.observe(\"" + bindings.scrollX + "\", " + observerCallback + ");");
            if (bindings.scrollY)
                block.builders.init.addLine("#component.observe(\"" + bindings.scrollY + "\", " + observerCallback + ");");
        }
        else if (bindings.scrollX || bindings.scrollY) {
            var isX = !!bindings.scrollX;
            block.builders.init.addBlock(deindent(templateObject_8$7 || (templateObject_8$7 = __makeTemplateObject(["\n\t\t\t\t#component.observe(\"", "\", function(", ") {\n\t\t\t\t\tif (", ") return;\n\t\t\t\t\twindow.scrollTo(", ");\n\t\t\t\t});\n\t\t\t"], ["\n\t\t\t\t#component.observe(\"", "\", function(", ") {\n\t\t\t\t\tif (", ") return;\n\t\t\t\t\twindow.scrollTo(", ");\n\t\t\t\t});\n\t\t\t"])), bindings.scrollX || bindings.scrollY, isX ? 'x' : 'y', lock, isX ? 'x, window.scrollY' : 'window.scrollX, y'));
        }
        // another special case. (I'm starting to think these are all special cases.)
        if (bindings.online) {
            var handlerName = block.getUniqueName("onlinestatuschanged");
            block.builders.init.addBlock(deindent(templateObject_9$6 || (templateObject_9$6 = __makeTemplateObject(["\n\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t#component.set({ ", ": navigator.onLine });\n\t\t\t\t}\n\t\t\t\twindow.addEventListener(\"online\", ", ");\n\t\t\t\twindow.addEventListener(\"offline\", ", ");\n\t\t\t"], ["\n\t\t\t\tfunction ", "(event) {\n\t\t\t\t\t#component.set({ ", ": navigator.onLine });\n\t\t\t\t}\n\t\t\t\twindow.addEventListener(\"online\", ", ");\n\t\t\t\twindow.addEventListener(\"offline\", ", ");\n\t\t\t"])), handlerName, bindings.online, handlerName, handlerName));
            // add initial value
            generator.metaBindings.push("this._state." + bindings.online + " = navigator.onLine;");
            block.builders.destroy.addBlock(deindent(templateObject_10$6 || (templateObject_10$6 = __makeTemplateObject(["\n\t\t\t\twindow.removeEventListener(\"online\", ", ");\n\t\t\t\twindow.removeEventListener(\"offline\", ", ");\n\t\t\t"], ["\n\t\t\t\twindow.removeEventListener(\"online\", ", ");\n\t\t\t\twindow.removeEventListener(\"offline\", ", ");\n\t\t\t"])), handlerName, handlerName));
        }
    };
    return Window;
}(Node$1));
var templateObject_1$12;
var templateObject_2$11;
var templateObject_3$11;
var templateObject_4$11;
var templateObject_5$9;
var templateObject_6$9;
var templateObject_7$7;
var templateObject_8$7;
var templateObject_9$6;
var templateObject_10$6;

var nodes = {
    Attribute: Attribute,
    AwaitBlock: AwaitBlock,
    Binding: Binding,
    CatchBlock: CatchBlock,
    Comment: Comment$2,
    Component: Component,
    EachBlock: EachBlock,
    Element: Element,
    ElseBlock: ElseBlock,
    EventHandler: EventHandler,
    Fragment: Fragment,
    Head: Head,
    IfBlock: IfBlock,
    MustacheTag: MustacheTag,
    PendingBlock: PendingBlock,
    RawMustacheTag: RawMustacheTag,
    Ref: Ref,
    Slot: Slot,
    Text: Text,
    ThenBlock: ThenBlock,
    Transition: Transition,
    Window: Window
};

function detectIndentation(str) {
    var pattern = /^[\t\s]{1,4}/gm;
    var match;
    while (match = pattern.exec(str)) {
        if (match[0][0] === '\t')
            return '\t';
        if (match[0].length === 2)
            return '  ';
    }
    return '    ';
}
function getIndentationLevel(str, b) {
    var a = b;
    while (a > 0 && str[a - 1] !== '\n')
        a -= 1;
    return /^\s*/.exec(str.slice(a, b))[0];
}
function getIndentExclusionRanges(node) {
    var ranges = [];
    walk(node, {
        enter: function (node) {
            if (node.type === 'TemplateElement')
                ranges.push(node);
        }
    });
    return ranges;
}
function removeIndentation(code, start, end, indentationLevel, ranges) {
    var str = code.original.slice(start, end);
    var pattern = new RegExp("^" + indentationLevel, 'gm');
    var match;
    while (match = pattern.exec(str)) {
        // TODO bail if we're inside an exclusion range
        code.remove(start + match.index, start + match.index + indentationLevel.length);
    }
}
// We need to tell estree-walker that it should always
// look for an `else` block, otherwise it might get
// the wrong idea about the shape of each/if blocks
childKeys.EachBlock = childKeys.IfBlock = ['children', 'else'];
childKeys.Attribute = ['value'];
var Generator = /** @class */ (function () {
    function Generator(parsed, source, name, stylesheet, options, dom) {
        this.ast = clone(parsed);
        this.parsed = parsed;
        this.source = source;
        this.options = options;
        this.imports = [];
        this.helpers = new Set();
        this.components = new Set();
        this.events = new Set();
        this.transitions = new Set();
        this.importedComponents = new Map();
        this.slots = new Set();
        this.bindingGroups = [];
        this.indirectDependencies = new Map();
        this.locate = getLocator(this.source);
        // track which properties are needed, so we can provide useful info
        // in dev mode
        this.expectedProperties = new Set();
        this.code = new MagicString$1(source);
        this.usesRefs = false;
        // styles
        this.stylesheet = stylesheet;
        // allow compiler to deconflict user's `import { get } from 'whatever'` and
        // Svelte's builtin `import { get, ... } from 'svelte/shared.ts'`;
        this.userVars = new Set();
        this.templateVars = new Map();
        this.aliases = new Map();
        this.usedNames = new Set();
        this.computations = [];
        this.templateProperties = {};
        this.walkJs(dom);
        this.name = this.alias(name);
        if (options.customElement === true) {
            this.customElement = {
                tag: this.tag,
                props: this.props // TODO autofill this in
            };
        }
        else {
            this.customElement = options.customElement;
        }
        if (this.customElement && !this.customElement.tag) {
            throw new Error("No tag name specified"); // TODO better error
        }
        this.walkTemplate();
    }
    Generator.prototype.addSourcemapLocations = function (node) {
        var _this = this;
        walk(node, {
            enter: function (node) {
                _this.code.addSourcemapLocation(node.start);
                _this.code.addSourcemapLocation(node.end);
            }
        });
    };
    Generator.prototype.alias = function (name) {
        if (!this.aliases.has(name)) {
            this.aliases.set(name, this.getUniqueName(name));
        }
        return this.aliases.get(name);
    };
    Generator.prototype.contextualise = function (contexts, indexes, expression, context, isEventHandler) {
        // this.addSourcemapLocations(expression);
        var usedContexts = new Set();
        var usedIndexes = new Set();
        var _a = this, code = _a.code, helpers = _a.helpers;
        var scope;
        var lexicalDepth = 0;
        var self = this;
        walk(expression, {
            enter: function (node, parent, key) {
                if (/^Function/.test(node.type))
                    lexicalDepth += 1;
                if (node._scope) {
                    scope = node._scope;
                    return;
                }
                if (node.type === 'ThisExpression') {
                    if (lexicalDepth === 0 && context)
                        code.overwrite(node.start, node.end, context, {
                            storeName: true,
                            contentOnly: false
                        });
                }
                else if (isReference(node, parent)) {
                    var name = flatten(node).name;
                    if (scope && scope.has(name))
                        return;
                    if (name === 'event' && isEventHandler) {
                        // noop
                    }
                    else if (contexts.has(name)) {
                        var contextName = contexts.get(name);
                        if (contextName !== name) {
                            // this is true for 'reserved' names like `state` and `component`
                            code.overwrite(node.start, node.start + name.length, contextName, { storeName: true, contentOnly: false });
                        }
                        usedContexts.add(name);
                    }
                    else if (helpers.has(name)) {
                        var object = node;
                        while (object.type === 'MemberExpression')
                            object = object.object;
                        var alias = self.templateVars.get("helpers-" + name);
                        if (alias !== name)
                            code.overwrite(object.start, object.end, alias);
                    }
                    else if (indexes.has(name)) {
                        var context_1 = indexes.get(name);
                        usedContexts.add(context_1); // TODO is this right?
                        usedIndexes.add(name);
                    }
                    else {
                        // handle shorthand properties
                        if (parent && parent.type === 'Property' && parent.shorthand) {
                            if (key === 'key') {
                                code.appendLeft(node.start, name + ": ");
                                return;
                            }
                        }
                        code.prependRight(node.start, "state.");
                        usedContexts.add('state');
                    }
                    this.skip();
                }
            },
            leave: function (node) {
                if (/^Function/.test(node.type))
                    lexicalDepth -= 1;
                if (node._scope)
                    scope = scope.parent;
            }
        });
        return {
            contexts: usedContexts,
            indexes: usedIndexes
        };
    };
    Generator.prototype.generate = function (result, options, _a) {
        var _this = this;
        var _b = _a.banner, banner = _b === void 0 ? '' : _b, sharedPath = _a.sharedPath, helpers = _a.helpers, name = _a.name, format = _a.format;
        var pattern = /\[✂(\d+)-(\d+)$/;
        var module = wrapModule(result, format, name, options, banner, sharedPath, helpers, this.imports, this.source);
        var parts = module.split('✂]');
        var finalChunk = parts.pop();
        var compiled = new Bundle({ separator: '' });
        function addString(str) {
            compiled.addSource({
                content: new MagicString$1(str)
            });
        }
        var filename = options.filename;
        // special case — the source file doesn't actually get used anywhere. we need
        // to add an empty file to populate map.sources and map.sourcesContent
        if (!parts.length) {
            compiled.addSource({
                filename: filename,
                content: new MagicString$1(this.source).remove(0, this.source.length)
            });
        }
        parts.forEach(function (str) {
            var chunk = str.replace(pattern, '');
            if (chunk)
                addString(chunk);
            var match = pattern.exec(str);
            var snippet = _this.code.snip(+match[1], +match[2]);
            compiled.addSource({
                filename: filename,
                content: snippet
            });
        });
        addString(finalChunk);
        var _c = this.customElement ?
            { css: null, cssMap: null } :
            this.stylesheet.render(options.cssOutputFilename, true), css = _c.css, cssMap = _c.cssMap;
        return {
            ast: this.ast,
            code: compiled.toString(),
            map: compiled.generateMap({
                includeContent: true,
                file: options.outputFilename
            }),
            css: css,
            cssMap: cssMap
        };
    };
    Generator.prototype.getUniqueName = function (name) {
        if (test)
            name = name + "$";
        var alias = name;
        for (var i = 1; reservedNames.has(alias) ||
            this.userVars.has(alias) ||
            this.usedNames.has(alias); alias = name + "_" + i++)
            ;
        this.usedNames.add(alias);
        return alias;
    };
    Generator.prototype.getUniqueNameMaker = function (params) {
        var _this = this;
        var localUsedNames = new Set(params);
        function add(name) {
            localUsedNames.add(name);
        }
        reservedNames.forEach(add);
        this.userVars.forEach(add);
        return function (name) {
            if (test)
                name = name + "$";
            var alias = name;
            for (var i = 1; _this.usedNames.has(alias) ||
                localUsedNames.has(alias); alias = name + "_" + i++)
                ;
            localUsedNames.add(alias);
            return alias;
        };
    };
    Generator.prototype.walkJs = function (dom) {
        var _this = this;
        var _a = this, code = _a.code, source = _a.source, computations = _a.computations, templateProperties = _a.templateProperties, imports = _a.imports;
        var js = this.parsed.js;
        var componentDefinition = new CodeBuilder();
        if (js) {
            this.addSourcemapLocations(js.content);
            var indentation = detectIndentation(source.slice(js.start, js.end));
            var indentationLevel = getIndentationLevel(source, js.content.body[0].start);
            var indentExclusionRanges_1 = getIndentExclusionRanges(js.content);
            var scope = annotateWithScopes(js.content);
            scope.declarations.forEach(function (name) {
                _this.userVars.add(name);
            });
            var body = js.content.body.slice(); // slice, because we're going to be mutating the original
            // imports need to be hoisted out of the IIFE
            for (var i = 0; i < body.length; i += 1) {
                var node = body[i];
                if (node.type === 'ImportDeclaration') {
                    removeNode(code, js.content, node);
                    imports.push(node);
                    node.specifiers.forEach(function (specifier) {
                        _this.userVars.add(specifier.local.name);
                    });
                }
            }
            var defaultExport = this.defaultExport = body.find(function (node) { return node.type === 'ExportDefaultDeclaration'; });
            if (defaultExport) {
                defaultExport.declaration.properties.forEach(function (prop) {
                    templateProperties[getMethodName(prop.key)] = prop;
                });
                ['helpers', 'events', 'components', 'transitions'].forEach(function (key) {
                    if (templateProperties[key]) {
                        templateProperties[key].value.properties.forEach(function (prop) {
                            _this[key].add(getMethodName(prop.key));
                        });
                    }
                });
                var addArrowFunctionExpression_1 = function (name, node) {
                    var body = node.body, params = node.params, async = node.async;
                    var fnKeyword = async ? 'async function' : 'function';
                    var paramString = params.length ?
                        "[\u2702" + params[0].start + "-" + params[params.length - 1].end + "\u2702]" :
                        "";
                    if (body.type === 'BlockStatement') {
                        componentDefinition.addBlock(deindent(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["\n\t\t\t\t\t\t\t", " ", "(", ") [\u2702", "-", "\u2702]\n\t\t\t\t\t\t"], ["\n\t\t\t\t\t\t\t", " ", "(", ") [\u2702", "-", "\u2702]\n\t\t\t\t\t\t"])), fnKeyword, name, paramString, body.start, body.end));
                    }
                    else {
                        componentDefinition.addBlock(deindent(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject(["\n\t\t\t\t\t\t\t", " ", "(", ") {\n\t\t\t\t\t\t\t\treturn [\u2702", "-", "\u2702];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t"], ["\n\t\t\t\t\t\t\t", " ", "(", ") {\n\t\t\t\t\t\t\t\treturn [\u2702", "-", "\u2702];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t"])), fnKeyword, name, paramString, body.start, body.end));
                    }
                };
                var addFunctionExpression_1 = function (name, node) {
                    var async = node.async;
                    var fnKeyword = async ? 'async function' : 'function';
                    var c = node.start;
                    while (_this.source[c] !== '(')
                        c += 1;
                    componentDefinition.addBlock(deindent(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject(["\n\t\t\t\t\t\t", " ", "[\u2702", "-", "\u2702];\n\t\t\t\t\t"], ["\n\t\t\t\t\t\t", " ", "[\u2702", "-", "\u2702];\n\t\t\t\t\t"])), fnKeyword, name, c, node.end));
                };
                var addValue_1 = function (name, node) {
                    componentDefinition.addBlock(deindent(templateObject_4$1 || (templateObject_4$1 = __makeTemplateObject(["\n\t\t\t\t\t\tvar ", " = [\u2702", "-", "\u2702];\n\t\t\t\t\t"], ["\n\t\t\t\t\t\tvar ", " = [\u2702", "-", "\u2702];\n\t\t\t\t\t"])), name, node.start, node.end));
                };
                var addDeclaration_1 = function (key, node, disambiguator, conflicts) {
                    var qualified = disambiguator ? disambiguator + "-" + key : key;
                    if (node.type === 'Identifier' && node.name === key) {
                        _this.templateVars.set(qualified, key);
                        return;
                    }
                    var deconflicted = key;
                    if (conflicts)
                        while (deconflicted in conflicts)
                            deconflicted += '_';
                    var name = _this.getUniqueName(deconflicted);
                    _this.templateVars.set(qualified, name);
                    // deindent
                    var indentationLevel = getIndentationLevel(source, node.start);
                    if (indentationLevel) {
                        removeIndentation(code, node.start, node.end, indentationLevel, indentExclusionRanges_1);
                    }
                    if (node.type === 'ArrowFunctionExpression') {
                        addArrowFunctionExpression_1(name, node);
                    }
                    else if (node.type === 'FunctionExpression') {
                        addFunctionExpression_1(name, node);
                    }
                    else {
                        addValue_1(name, node);
                    }
                };
                if (templateProperties.components) {
                    templateProperties.components.value.properties.forEach(function (property) {
                        addDeclaration_1(getMethodName(property.key), property.value, 'components');
                    });
                }
                if (templateProperties.computed) {
                    var dependencies_1 = new Map();
                    templateProperties.computed.value.properties.forEach(function (prop) {
                        var key = getMethodName(prop.key);
                        var value = prop.value;
                        var deps = value.params.map(function (param) {
                            return param.type === 'AssignmentPattern' ? param.left.name : param.name;
                        });
                        deps.forEach(function (dep) {
                            _this.expectedProperties.add(dep);
                        });
                        dependencies_1.set(key, deps);
                    });
                    var visited_1 = new Set();
                    var visit_1 = function (key) {
                        if (!dependencies_1.has(key))
                            return; // not a computation
                        if (visited_1.has(key))
                            return;
                        visited_1.add(key);
                        var deps = dependencies_1.get(key);
                        deps.forEach(visit_1);
                        computations.push({ key: key, deps: deps });
                        var prop = templateProperties.computed.value.properties.find(function (prop) { return getMethodName(prop.key) === key; });
                        addDeclaration_1(key, prop.value, 'computed', {
                            state: true,
                            changed: true
                        });
                    };
                    templateProperties.computed.value.properties.forEach(function (prop) {
                        return visit_1(getMethodName(prop.key));
                    });
                }
                if (templateProperties.data) {
                    addDeclaration_1('data', templateProperties.data.value);
                }
                if (templateProperties.events && dom) {
                    templateProperties.events.value.properties.forEach(function (property) {
                        addDeclaration_1(getMethodName(property.key), property.value, 'events');
                    });
                }
                if (templateProperties.helpers) {
                    templateProperties.helpers.value.properties.forEach(function (property) {
                        addDeclaration_1(getMethodName(property.key), property.value, 'helpers');
                    });
                }
                if (templateProperties.methods && dom) {
                    addDeclaration_1('methods', templateProperties.methods.value);
                }
                if (templateProperties.namespace) {
                    var ns = templateProperties.namespace.value.value;
                    this.namespace = namespaces[ns] || ns;
                }
                if (templateProperties.onrender)
                    templateProperties.oncreate = templateProperties.onrender; // remove after v2
                if (templateProperties.oncreate && dom) {
                    addDeclaration_1('oncreate', templateProperties.oncreate.value);
                }
                if (templateProperties.onteardown)
                    templateProperties.ondestroy = templateProperties.onteardown; // remove after v2
                if (templateProperties.ondestroy && dom) {
                    addDeclaration_1('ondestroy', templateProperties.ondestroy.value);
                }
                if (templateProperties.preload) {
                    addDeclaration_1('preload', templateProperties.preload.value);
                }
                if (templateProperties.props) {
                    this.props = templateProperties.props.value.elements.map(function (element) { return element.value; });
                }
                if (templateProperties.setup) {
                    addDeclaration_1('setup', templateProperties.setup.value);
                }
                if (templateProperties.store) {
                    addDeclaration_1('store', templateProperties.store.value);
                }
                if (templateProperties.tag) {
                    this.tag = templateProperties.tag.value.value;
                }
                if (templateProperties.transitions) {
                    templateProperties.transitions.value.properties.forEach(function (property) {
                        addDeclaration_1(getMethodName(property.key), property.value, 'transitions');
                    });
                }
            }
            if (indentationLevel) {
                if (defaultExport) {
                    removeIndentation(code, js.content.start, defaultExport.start, indentationLevel, indentExclusionRanges_1);
                    removeIndentation(code, defaultExport.end, js.content.end, indentationLevel, indentExclusionRanges_1);
                }
                else {
                    removeIndentation(code, js.content.start, js.content.end, indentationLevel, indentExclusionRanges_1);
                }
            }
            var a = js.content.start;
            while (/\s/.test(source[a]))
                a += 1;
            var b = js.content.end;
            while (/\s/.test(source[b - 1]))
                b -= 1;
            if (defaultExport) {
                this.javascript = '';
                if (a !== defaultExport.start)
                    this.javascript += "[\u2702" + a + "-" + defaultExport.start + "\u2702]";
                if (!componentDefinition.isEmpty())
                    this.javascript += componentDefinition;
                if (defaultExport.end !== b)
                    this.javascript += "[\u2702" + defaultExport.end + "-" + b + "\u2702]";
            }
            else {
                this.javascript = a === b ? null : "[\u2702" + a + "-" + b + "\u2702]";
            }
        }
    };
    Generator.prototype.walkTemplate = function () {
        var _this = this;
        var generator = this;
        var _a = this, code = _a.code, expectedProperties = _a.expectedProperties, helpers = _a.helpers;
        var html$$1 = this.parsed.html;
        var contextualise = function (node, contextDependencies, indexes, isEventHandler) {
            _this.addSourcemapLocations(node); // TODO this involves an additional walk — can we roll it in somewhere else?
            var scope = annotateWithScopes(node);
            var dependencies = new Set();
            walk(node, {
                enter: function (node, parent) {
                    code.addSourcemapLocation(node.start);
                    code.addSourcemapLocation(node.end);
                    if (node._scope) {
                        scope = node._scope;
                        return;
                    }
                    if (isReference(node, parent)) {
                        var name = flatten(node).name;
                        if (scope && scope.has(name) || helpers.has(name) || (name === 'event' && isEventHandler))
                            return;
                        if (contextDependencies.has(name)) {
                            contextDependencies.get(name).forEach(function (dependency) {
                                dependencies.add(dependency);
                            });
                        }
                        else if (!indexes.has(name)) {
                            dependencies.add(name);
                        }
                        this.skip();
                    }
                },
                leave: function (node, parent) {
                    if (node._scope)
                        scope = scope.parent;
                }
            });
            dependencies.forEach(function (dependency) {
                expectedProperties.add(dependency);
            });
            return {
                snippet: "[\u2702" + node.start + "-" + node.end + "\u2702]",
                dependencies: Array.from(dependencies)
            };
        };
        var contextStack = [];
        var indexStack = [];
        var dependenciesStack = [];
        var contextDependencies = new Map();
        var contextDependenciesStack = [contextDependencies];
        var indexes = new Set();
        var indexesStack = [indexes];
        walk(html$$1, {
            enter: function (node, parent, key) {
                // TODO this is hacky as hell
                if (key === 'parent')
                    return this.skip();
                node.parent = parent;
                node.generator = generator;
                if (node.type === 'Element' && (node.name === ':Component' || node.name === ':Self' || generator.components.has(node.name))) {
                    node.type = 'Component';
                    node.__proto__ = nodes.Component.prototype;
                }
                else if (node.name === ':Window') {
                    node.type = 'Window';
                    node.__proto__ = nodes.Window.prototype;
                }
                else if (node.name === ':Head') {
                    node.type = 'Head';
                    node.__proto__ = nodes.Head.prototype;
                }
                else if (node.type === 'Element' && node.name === 'slot' && !generator.customElement) {
                    node.type = 'Slot';
                    node.__proto__ = nodes.Slot.prototype;
                }
                else if (node.type in nodes) {
                    node.__proto__ = nodes[node.type].prototype;
                }
                if (node.type === 'Element') {
                    generator.stylesheet.apply(node);
                }
                if (node.type === 'EachBlock') {
                    node.metadata = contextualise(node.expression, contextDependencies, indexes, false);
                    contextDependencies = new Map(contextDependencies);
                    contextDependencies.set(node.context, node.metadata.dependencies);
                    if (node.destructuredContexts) {
                        for (var i = 0; i < node.destructuredContexts.length; i += 1) {
                            var name = node.destructuredContexts[i];
                            var value = node.context + "[" + i + "]";
                            contextDependencies.set(name, node.metadata.dependencies);
                        }
                    }
                    contextDependenciesStack.push(contextDependencies);
                    if (node.index) {
                        indexes = new Set(indexes);
                        indexes.add(node.index);
                        indexesStack.push(indexes);
                    }
                }
                if (node.type === 'AwaitBlock') {
                    node.metadata = contextualise(node.expression, contextDependencies, indexes, false);
                    contextDependencies = new Map(contextDependencies);
                    contextDependencies.set(node.value, node.metadata.dependencies);
                    contextDependencies.set(node.error, node.metadata.dependencies);
                    contextDependenciesStack.push(contextDependencies);
                }
                if (node.type === 'IfBlock') {
                    node.metadata = contextualise(node.expression, contextDependencies, indexes, false);
                }
                if (node.type === 'MustacheTag' || node.type === 'RawMustacheTag' || node.type === 'AttributeShorthand') {
                    node.metadata = contextualise(node.expression, contextDependencies, indexes, false);
                    this.skip();
                }
                if (node.type === 'Binding') {
                    node.metadata = contextualise(node.value, contextDependencies, indexes, false);
                    this.skip();
                }
                if (node.type === 'EventHandler' && node.expression) {
                    node.expression.arguments.forEach(function (arg) {
                        arg.metadata = contextualise(arg, contextDependencies, indexes, true);
                    });
                    this.skip();
                }
                if (node.type === 'Transition' && node.expression) {
                    node.metadata = contextualise(node.expression, contextDependencies, indexes, false);
                    this.skip();
                }
                if (node.type === 'Component' && node.name === ':Component') {
                    node.metadata = contextualise(node.expression, contextDependencies, indexes, false);
                }
            },
            leave: function (node, parent) {
                if (node.type === 'EachBlock') {
                    contextDependenciesStack.pop();
                    contextDependencies = contextDependenciesStack[contextDependenciesStack.length - 1];
                    if (node.index) {
                        indexesStack.pop();
                        indexes = indexesStack[indexesStack.length - 1];
                    }
                }
                if (node.type === 'Element' && node.name === 'option') {
                    // Special case — treat these the same way:
                    //   <option>{{foo}}</option>
                    //   <option value='{{foo}}'>{{foo}}</option>
                    var valueAttribute = node.attributes.find(function (attribute) { return attribute.name === 'value'; });
                    if (!valueAttribute) {
                        node.attributes.push(new nodes.Attribute({
                            generator: generator,
                            name: 'value',
                            value: node.children,
                            parent: node
                        }));
                    }
                }
            }
        });
    };
    return Generator;
}());
var templateObject_1$1;
var templateObject_2$1;
var templateObject_3$1;
var templateObject_4$1;

var DomGenerator = /** @class */ (function (_super) {
    __extends(DomGenerator, _super);
    function DomGenerator(parsed, source, name, stylesheet, options) {
        var _this = _super.call(this, parsed, source, name, stylesheet, options, true) || this;
        _this.blocks = [];
        _this.readonly = new Set();
        _this.hydratable = options.hydratable;
        _this.legacy = options.legacy;
        _this.needsEncapsulateHelper = false;
        // initial values for e.g. window.innerWidth, if there's a <:Window> meta tag
        _this.metaBindings = [];
        return _this;
    }
    DomGenerator.prototype.getUniqueNameMaker = function (params) {
        var _this = this;
        var localUsedNames = new Set(params);
        function add(name) {
            localUsedNames.add(name);
        }
        reservedNames.forEach(add);
        this.userVars.forEach(add);
        for (var name in shared) {
            localUsedNames.add(test ? name + "$" : name);
        }
        return function (name) {
            if (test)
                name = name + "$";
            var alias = name;
            for (var i = 1; _this.usedNames.has(alias) ||
                localUsedNames.has(alias); alias = name + "_" + i++)
                ;
            localUsedNames.add(alias);
            return alias;
        };
    };
    return DomGenerator;
}(Generator));
function dom(parsed, source, stylesheet, options) {
    var format = options.format || 'es';
    var generator = new DomGenerator(parsed, source, options.name || 'SvelteComponent', stylesheet, options);
    var computations = generator.computations, name = generator.name, templateProperties = generator.templateProperties, namespace = generator.namespace;
    parsed.html.build();
    var block = parsed.html.block;
    generator.stylesheet.warnOnUnusedSelectors(options.onwarn);
    var builder = new CodeBuilder();
    var computationBuilder = new CodeBuilder();
    var computationDeps = new Set();
    if (computations.length) {
        computations.forEach(function (_a) {
            var key = _a.key, deps = _a.deps;
            deps.forEach(function (dep) {
                computationDeps.add(dep);
            });
            if (generator.readonly.has(key)) {
                // <:Window> bindings
                throw new Error("Cannot have a computed value '" + key + "' that clashes with a read-only property");
            }
            generator.readonly.add(key);
            var condition = "" + deps.map(function (dep) { return "changed." + dep; }).join(' || ');
            var statement = "if (@differs(state." + key + ", (state." + key + " = %computed-" + key + "(" + deps
                .map(function (dep) { return "state." + dep; })
                .join(', ') + ")))) changed." + key + " = true;";
            computationBuilder.addConditional(condition, statement);
        });
    }
    if (generator.javascript) {
        builder.addBlock(generator.javascript);
    }
    if (generator.needsEncapsulateHelper) {
        builder.addBlock(deindent(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n\t\t\tfunction @encapsulateStyles(node) {\n\t\t\t\t@setAttribute(node, \"", "\", \"\");\n\t\t\t}\n\t\t"], ["\n\t\t\tfunction @encapsulateStyles(node) {\n\t\t\t\t@setAttribute(node, \"", "\", \"\");\n\t\t\t}\n\t\t"])), generator.stylesheet.id));
    }
    var _a = generator.stylesheet.render(options.filename, !generator.customElement), css = _a.css, cssMap = _a.cssMap;
    var styles = generator.stylesheet.hasStyles && stringify(options.dev ?
        css + "\n/*# sourceMappingURL=" + cssMap.toUrl() + " */" :
        css, { onlyEscapeAtSymbol: true });
    if (styles && generator.options.css !== false && !generator.customElement) {
        builder.addBlock(deindent(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n\t\t\tfunction @add_css() {\n\t\t\t\tvar style = @createElement(\"style\");\n\t\t\t\tstyle.id = '", "-style';\n\t\t\t\tstyle.textContent = ", ";\n\t\t\t\t@appendNode(style, document.head);\n\t\t\t}\n\t\t"], ["\n\t\t\tfunction @add_css() {\n\t\t\t\tvar style = @createElement(\"style\");\n\t\t\t\tstyle.id = '", "-style';\n\t\t\t\tstyle.textContent = ", ";\n\t\t\t\t@appendNode(style, document.head);\n\t\t\t}\n\t\t"])), generator.stylesheet.id, styles));
    }
    generator.blocks.forEach(function (block) {
        builder.addBlock(block.toString());
    });
    var sharedPath = options.shared === true
        ? 'svelte/shared.js'
        : options.shared || '';
    var prototypeBase = name + ".prototype" +
        (templateProperties.methods ? ", %methods" : '');
    var proto = sharedPath
        ? "@proto"
        : deindent(templateObject_3 || (templateObject_3 = __makeTemplateObject(["\n\t\t{\n\t\t\t", "\n\t\t}"], ["\n\t\t{\n\t\t\t",
            "\n\t\t}"])), ['destroy', 'get', 'fire', 'observe', 'on', 'set', 'teardown', '_set', '_mount', '_unmount']
            .map(function (n) { return n + ": @" + (n === 'teardown' ? 'destroy' : n); })
            .join(',\n'));
    var debugName = "<" + (generator.customElement ? generator.tag : name) + ">";
    // generate initial state object
    var expectedProperties = Array.from(generator.expectedProperties);
    var globals = expectedProperties.filter(function (prop) { return globalWhitelist.has(prop); });
    var storeProps = options.store || templateProperties.store ? expectedProperties.filter(function (prop) { return prop[0] === '$'; }) : [];
    var initialState = [];
    if (globals.length > 0) {
        initialState.push("{ " + globals.map(function (prop) { return prop + " : " + prop; }).join(', ') + " }");
    }
    if (storeProps.length > 0) {
        initialState.push("this.store._init([" + storeProps.map(function (prop) { return "\"" + prop.slice(1) + "\""; }) + "])");
    }
    if (templateProperties.data) {
        initialState.push("%data()");
    }
    else if (globals.length === 0 && storeProps.length === 0) {
        initialState.push('{}');
    }
    initialState.push("options.data");
    var constructorBody = deindent(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n\t\t", "\n\t\t", "\n\t\t@init(this, options);\n\t\t", "\n\t\t", "\n\t\tthis._state = @assign(", ");\n\t\t", "\n\t\t", "\n\t\t", "\n\t\t", "\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\n\t\tthis._fragment = @create_main_fragment(this._state, this);\n\n\t\t", "\n\t"], ["\n\t\t", "\n\t\t",
        "\n\t\t@init(this, options);\n\t\t", "\n\t\t", "\n\t\tthis._state = @assign(", ");\n\t\t", "\n\t\t", "\n\t\t", "\n\t\t",
        "\n\t\t",
        "\n\n\t\t",
        "\n\n\t\t", "\n\n\t\t",
        "\n\n\t\t", "\n\n\t\t",
        "\n\n\t\t", "\n\n\t\tthis._fragment = @create_main_fragment(this._state, this);\n\n\t\t",
        "\n\t"])), options.dev && "this._debugName = '" + debugName + "';", options.dev && !generator.customElement &&
        "if (!options || (!options.target && !options.root)) throw new Error(\"'target' is a required option\");", templateProperties.store && "this.store = %store();", generator.usesRefs && "this.refs = {};", initialState.join(', '), storeProps.length > 0 && "this.store._add(this, [" + storeProps.map(function (prop) { return "\"" + prop.slice(1) + "\""; }) + "]);", generator.metaBindings, computations.length && "this._recompute({ " + Array.from(computationDeps).map(function (dep) { return dep + ": 1"; }).join(', ') + " }, this._state);", options.dev &&
        Array.from(generator.expectedProperties).map(function (prop) {
            return "if (!('" + prop + "' in this._state)) console.warn(\"" + debugName + " was created without expected data property '" + prop + "'\");";
        }), generator.bindingGroups.length &&
        "this._bindingGroups = [" + Array(generator.bindingGroups.length).fill('[]').join(', ') + "];", (templateProperties.ondestroy || storeProps.length) && ("this._handlers.destroy = [" + [templateProperties.ondestroy && "%ondestroy", storeProps.length && "@removeFromStore"].filter(Boolean).join(', ') + "];"), generator.slots.size && "this._slotted = options.slots || {};", generator.customElement ? deindent(templateObject_5 || (templateObject_5 = __makeTemplateObject(["\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t\t", "\n\t\t\t"], ["\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t\t", "\n\t\t\t"])), css && "this.shadowRoot.innerHTML = `<style>" + escape(css, { onlyEscapeAtSymbol: true }).replace(/\\/g, '\\\\') + (options.dev ? "\n/*# sourceMappingURL=" + cssMap.toUrl() + " */" : '') + "</style>`;") :
        (generator.stylesheet.hasStyles && options.css !== false &&
            "if (!document.getElementById(\"" + generator.stylesheet.id + "-style\")) @add_css();"), templateProperties.oncreate && "var _oncreate = %oncreate.bind(this);", (templateProperties.oncreate || generator.hasComponents || generator.hasComplexBindings || generator.hasIntroTransitions) && deindent(templateObject_6 || (templateObject_6 = __makeTemplateObject(["\n\t\t\tif (!options.root) {\n\t\t\t\tthis._oncreate = [", "];\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t} ", "\n\t\t"], ["\n\t\t\tif (!options.root) {\n\t\t\t\tthis._oncreate = [", "];\n\t\t\t\t", "\n\t\t\t\t", "\n\t\t\t} ",
        "\n\t\t"])), templateProperties.oncreate && "_oncreate", (generator.hasComponents || generator.hasComplexBindings) && "this._beforecreate = [];", (generator.hasComponents || generator.hasIntroTransitions) && "this._aftercreate = [];", templateProperties.oncreate && deindent(templateObject_7 || (templateObject_7 = __makeTemplateObject(["\n\t\t\t\telse {\n\t\t\t\t\tthis.root._oncreate.push(_oncreate);\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\telse {\n\t\t\t\t\tthis.root._oncreate.push(_oncreate);\n\t\t\t\t}\n\t\t\t"])))), generator.slots.size && "this.slots = {};", generator.customElement ? deindent(templateObject_8 || (templateObject_8 = __makeTemplateObject(["\n\t\t\tthis._fragment.c();\n\t\t\tthis._fragment.", "(this.shadowRoot, null);\n\n\t\t\tif (options.target) this._mount(options.target, options.anchor || null);\n\t\t"], ["\n\t\t\tthis._fragment.c();\n\t\t\tthis._fragment.", "(this.shadowRoot, null);\n\n\t\t\tif (options.target) this._mount(options.target, options.anchor || null);\n\t\t"])), block.hasIntroMethod ? 'i' : 'm') : deindent(templateObject_9 || (templateObject_9 = __makeTemplateObject(["\n\t\t\tif (options.target) {\n\t\t\t\t", "\n\t\t\t\tthis._fragment.", "(options.target, options.anchor || null);\n\n\t\t\t\t", "\n\t\t\t}\n\t\t"], ["\n\t\t\tif (options.target) {\n\t\t\t\t",
        "\n\t\t\t\tthis._fragment.", "(options.target, options.anchor || null);\n\n\t\t\t\t",
        "\n\t\t\t}\n\t\t"])), generator.hydratable
        ? deindent(templateObject_10 || (templateObject_10 = __makeTemplateObject(["\n\t\t\t\t\t\tvar nodes = @children(options.target);\n\t\t\t\t\t\toptions.hydrate ? this._fragment.l(nodes) : this._fragment.c();\n\t\t\t\t\t\tnodes.forEach(@detachNode);\n\t\t\t\t\t"], ["\n\t\t\t\t\t\tvar nodes = @children(options.target);\n\t\t\t\t\t\toptions.hydrate ? this._fragment.l(nodes) : this._fragment.c();\n\t\t\t\t\t\tnodes.forEach(@detachNode);\n\t\t\t\t\t"]))) : deindent(templateObject_11 || (templateObject_11 = __makeTemplateObject(["\n\t\t\t\t\t\t", "\n\t\t\t\t\t\tthis._fragment.c();\n\t\t\t\t\t"], ["\n\t\t\t\t\t\t", "\n\t\t\t\t\t\tthis._fragment.c();\n\t\t\t\t\t"])), options.dev && "if (options.hydrate) throw new Error(\"options.hydrate only works if the component was compiled with the `hydratable: true` option\");"), block.hasIntroMethod ? 'i' : 'm', (generator.hasComponents || generator.hasComplexBindings || templateProperties.oncreate || generator.hasIntroTransitions) && deindent(templateObject_12 || (templateObject_12 = __makeTemplateObject(["\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t"], ["\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t\t", "\n\t\t\t\t"])), generator.hasComponents && "this._lock = true;", (generator.hasComponents || generator.hasComplexBindings) && "@callAll(this._beforecreate);", (generator.hasComponents || templateProperties.oncreate) && "@callAll(this._oncreate);", (generator.hasComponents || generator.hasIntroTransitions) && "@callAll(this._aftercreate);", generator.hasComponents && "this._lock = false;")));
    if (generator.customElement) {
        var props = generator.props || Array.from(generator.expectedProperties);
        builder.addBlock(deindent(templateObject_13 || (templateObject_13 = __makeTemplateObject(["\n\t\t\tclass ", " extends HTMLElement {\n\t\t\t\tconstructor(options = {}) {\n\t\t\t\t\tsuper();\n\t\t\t\t\t", "\n\t\t\t\t}\n\n\t\t\t\tstatic get observedAttributes() {\n\t\t\t\t\treturn ", ";\n\t\t\t\t}\n\n\t\t\t\t", "\n\n\t\t\t\t", "\n\n\t\t\t\tattributeChangedCallback(attr, oldValue, newValue) {\n\t\t\t\t\tthis.set({ [attr]: newValue });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcustomElements.define(\"", "\", ", ");\n\t\t\t@assign(", ", ", ", {\n\t\t\t\t_mount(target, anchor) {\n\t\t\t\t\ttarget.insertBefore(this, anchor);\n\t\t\t\t},\n\n\t\t\t\t_unmount() {\n\t\t\t\t\tthis.parentNode.removeChild(this);\n\t\t\t\t}\n\t\t\t});\n\t\t"], ["\n\t\t\tclass ", " extends HTMLElement {\n\t\t\t\tconstructor(options = {}) {\n\t\t\t\t\tsuper();\n\t\t\t\t\t", "\n\t\t\t\t}\n\n\t\t\t\tstatic get observedAttributes() {\n\t\t\t\t\treturn ", ";\n\t\t\t\t}\n\n\t\t\t\t",
            "\n\n\t\t\t\t",
            "\n\n\t\t\t\tattributeChangedCallback(attr, oldValue, newValue) {\n\t\t\t\t\tthis.set({ [attr]: newValue });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcustomElements.define(\"", "\", ", ");\n\t\t\t@assign(", ", ", ", {\n\t\t\t\t_mount(target, anchor) {\n\t\t\t\t\ttarget.insertBefore(this, anchor);\n\t\t\t\t},\n\n\t\t\t\t_unmount() {\n\t\t\t\t\tthis.parentNode.removeChild(this);\n\t\t\t\t}\n\t\t\t});\n\t\t"])), name, constructorBody, JSON.stringify(props), props.map(function (prop) { return deindent(templateObject_14 || (templateObject_14 = __makeTemplateObject(["\n\t\t\t\t\tget ", "() {\n\t\t\t\t\t\treturn this.get('", "');\n\t\t\t\t\t}\n\n\t\t\t\t\tset ", "(value) {\n\t\t\t\t\t\tthis.set({ ", ": value });\n\t\t\t\t\t}\n\t\t\t\t"], ["\n\t\t\t\t\tget ", "() {\n\t\t\t\t\t\treturn this.get('", "');\n\t\t\t\t\t}\n\n\t\t\t\t\tset ", "(value) {\n\t\t\t\t\t\tthis.set({ ", ": value });\n\t\t\t\t\t}\n\t\t\t\t"])), prop, prop, prop, prop); }).join('\n\n'), generator.slots.size && deindent(templateObject_15 || (templateObject_15 = __makeTemplateObject(["\n\t\t\t\t\tconnectedCallback() {\n\t\t\t\t\t\tObject.keys(this._slotted).forEach(key => {\n\t\t\t\t\t\t\tthis.appendChild(this._slotted[key]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}"], ["\n\t\t\t\t\tconnectedCallback() {\n\t\t\t\t\t\tObject.keys(this._slotted).forEach(key => {\n\t\t\t\t\t\t\tthis.appendChild(this._slotted[key]);\n\t\t\t\t\t\t});\n\t\t\t\t\t}"]))), generator.tag, name, prototypeBase, proto));
    }
    else {
        builder.addBlock(deindent(templateObject_16 || (templateObject_16 = __makeTemplateObject(["\n\t\t\tfunction ", "(options) {\n\t\t\t\t", "\n\t\t\t}\n\n\t\t\t@assign(", ", ", ");\n\t\t"], ["\n\t\t\tfunction ", "(options) {\n\t\t\t\t", "\n\t\t\t}\n\n\t\t\t@assign(", ", ", ");\n\t\t"])), name, constructorBody, prototypeBase, proto));
    }
    builder.addBlock(deindent(templateObject_17 || (templateObject_17 = __makeTemplateObject(["\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\t"], ["\n\t\t",
        "\n\n\t\t",
        "\n\n\t\t", "\n\n\t\t", "\n\t"])), options.dev && deindent(templateObject_18 || (templateObject_18 = __makeTemplateObject(["\n\t\t\t", ".prototype._checkReadOnly = function _checkReadOnly(newState) {\n\t\t\t\t", "\n\t\t\t};\n\t\t"], ["\n\t\t\t", ".prototype._checkReadOnly = function _checkReadOnly(newState) {\n\t\t\t\t",
        "\n\t\t\t};\n\t\t"])), name, Array.from(generator.readonly).map(function (prop) {
        return "if ('" + prop + "' in newState && !this._updatingReadonlyProperty) throw new Error(\"" + debugName + ": Cannot set read-only property '" + prop + "'\");";
    })), computations.length ? deindent(templateObject_19 || (templateObject_19 = __makeTemplateObject(["\n\t\t\t", ".prototype._recompute = function _recompute(changed, state) {\n\t\t\t\t", "\n\t\t\t}\n\t\t"], ["\n\t\t\t", ".prototype._recompute = function _recompute(changed, state) {\n\t\t\t\t", "\n\t\t\t}\n\t\t"])), name, computationBuilder) : (!sharedPath && name + ".prototype._recompute = @noop;"), templateProperties.setup && "%setup(" + name + ");", templateProperties.preload && name + ".preload = %preload;"));
    var usedHelpers = new Set();
    var result = builder
        .toString()
        .replace(/(%+|@+)(\w*(?:-\w*)?)/g, function (match, sigil, name) {
        if (sigil === '@') {
            if (name in shared) {
                if (options.dev && name + "Dev" in shared)
                    name = name + "Dev";
                usedHelpers.add(name);
            }
            return generator.alias(name);
        }
        if (sigil === '%') {
            return generator.templateVars.get(name);
        }
        return sigil.slice(1) + name;
    });
    var helpers;
    if (sharedPath) {
        if (format !== 'es' && format !== 'cjs') {
            throw new Error("Components with shared helpers must be compiled with `format: 'es'` or `format: 'cjs'`");
        }
        var used = Array.from(usedHelpers).sort();
        helpers = used.map(function (name) {
            var alias = generator.alias(name);
            return { name: name, alias: alias };
        });
    }
    else {
        var inlineHelpers_1 = '';
        usedHelpers.forEach(function (key) {
            var str = shared[key];
            var code = new MagicString$1(str);
            var expression = parseExpressionAt(str, 0);
            var scope = annotateWithScopes(expression);
            walk(expression, {
                enter: function (node, parent) {
                    if (node._scope)
                        scope = node._scope;
                    if (node.type === 'Identifier' &&
                        isReference(node, parent) &&
                        !scope.has(node.name)) {
                        if (node.name in shared) {
                            // this helper function depends on another one
                            var dependency = node.name;
                            usedHelpers.add(dependency);
                            var alias = generator.alias(dependency);
                            if (alias !== node.name)
                                code.overwrite(node.start, node.end, alias);
                        }
                    }
                },
                leave: function (node) {
                    if (node._scope)
                        scope = scope.parent;
                }
            });
            if (key === 'transitionManager') {
                // special case
                var global = "_svelteTransitionManager";
                inlineHelpers_1 += "\n\nvar " + generator.alias('transitionManager') + " = window." + global + " || (window." + global + " = " + code + ");\n\n";
            }
            else {
                var alias = generator.alias(expression.id.name);
                if (alias !== expression.id.name)
                    code.overwrite(expression.id.start, expression.id.end, alias);
                inlineHelpers_1 += "\n\n" + code;
            }
        });
        result += inlineHelpers_1;
    }
    var filename = options.filename && (typeof process !== 'undefined' ? options.filename.replace(process.cwd(), '').replace(/^[\/\\]/, '') : options.filename);
    return generator.generate(result, options, {
        banner: "/* " + (filename ? filename + " " : "") + "generated by Svelte v" + "1.49.0" + " */",
        sharedPath: sharedPath,
        helpers: helpers,
        name: name,
        format: format
    });
}
var templateObject_1;
var templateObject_2;
var templateObject_3;
var templateObject_5;
var templateObject_7;
var templateObject_6;
var templateObject_8;
var templateObject_10;
var templateObject_11;
var templateObject_12;
var templateObject_9;
var templateObject_4;
var templateObject_14;
var templateObject_15;
var templateObject_13;
var templateObject_16;
var templateObject_18;
var templateObject_19;
var templateObject_17;

var Block$3 = /** @class */ (function () {
    function Block(options) {
        Object.assign(this, options);
    }
    Block.prototype.addBinding = function (binding, name) {
        var conditions = ["!('" + binding.name + "' in state)"].concat(
        // TODO handle contextual bindings...
        this.conditions.map(function (c) { return "(" + c + ")"; }));
        var prop = getObject(binding.value).name;
        this.generator.bindings.push(deindent(templateObject_1$14 || (templateObject_1$14 = __makeTemplateObject(["\n\t\t\tif (", ") {\n\t\t\t\ttmp = ", ".data();\n\t\t\t\tif ('", "' in tmp) {\n\t\t\t\t\tstate.", " = tmp.", ";\n\t\t\t\t\tsettled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t"], ["\n\t\t\tif (", ") {\n\t\t\t\ttmp = ", ".data();\n\t\t\t\tif ('", "' in tmp) {\n\t\t\t\t\tstate.", " = tmp.", ";\n\t\t\t\t\tsettled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t"])), conditions.join('&&'), name, prop, binding.name, prop));
    };
    Block.prototype.child = function (options) {
        return new Block(Object.assign({}, this, options, { parent: this }));
    };
    Block.prototype.contextualise = function (expression, context, isEventHandler) {
        return this.generator.contextualise(this.contexts, this.indexes, expression, context, isEventHandler);
    };
    return Block;
}());
var templateObject_1$14;

function visitAwaitBlock(generator, block, node) {
    block.contextualise(node.expression);
    var _a = node.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
    // TODO should this be the generator's job? It's duplicated between
    // here and the equivalent DOM compiler visitor
    var contexts = new Map(block.contexts);
    contexts.set(node.value, '__value');
    var contextDependencies = new Map(block.contextDependencies);
    contextDependencies.set(node.value, dependencies);
    var childBlock = block.child({
        contextDependencies: contextDependencies,
        contexts: contexts
    });
    generator.append('${(function(__value) { if(__isPromise(__value)) return `');
    node.pending.children.forEach(function (child) {
        visit$1(generator, childBlock, child);
    });
    generator.append('`; return `');
    node.then.children.forEach(function (child) {
        visit$1(generator, childBlock, child);
    });
    generator.append("`;}(" + snippet + ")) }");
}

function visitComment() {
    // do nothing
}

function visitComponent(generator, block, node) {
    function stringifyAttribute(chunk) {
        if (chunk.type === 'Text')
            return chunk.data;
        if (chunk.type === 'MustacheTag') {
            block.contextualise(chunk.expression);
            var snippet = chunk.metadata.snippet;
            return '${__escape( ' + snippet + ')}';
        }
    }
    var attributes = [];
    var bindings = [];
    node.attributes.forEach(function (attribute) {
        if (attribute.type === 'Attribute') {
            attributes.push(attribute);
        }
        else if (attribute.type === 'Binding') {
            bindings.push(attribute);
        }
    });
    var props = attributes
        .map(function (attribute) {
        var value;
        if (attribute.value === true) {
            value = "true";
        }
        else if (attribute.value.length === 0) {
            value = "''";
        }
        else if (attribute.value.length === 1) {
            var chunk = attribute.value[0];
            if (chunk.type === 'Text') {
                value = isNaN(chunk.data) ? stringify(chunk.data) : chunk.data;
            }
            else {
                block.contextualise(chunk.expression);
                var snippet = chunk.metadata.snippet;
                value = snippet;
            }
        }
        else {
            value = '`' + attribute.value.map(stringifyAttribute).join('') + '`';
        }
        return attribute.name + ": " + value;
    })
        .concat(bindings.map(function (binding) {
        var name = getObject(binding.value).name;
        var tail = binding.value.type === 'MemberExpression'
            ? getTailSnippet(binding.value)
            : '';
        var keypath = block.contexts.has(name)
            ? "" + name + tail
            : "state." + name + tail;
        return binding.name + ": " + keypath;
    }))
        .join(', ');
    var isDynamicComponent = node.name === ':Component';
    if (isDynamicComponent)
        block.contextualise(node.expression);
    var expression = (node.name === ':Self' ? generator.name :
        isDynamicComponent ? "((" + node.metadata.snippet + ") || __missingComponent)" :
            "%components-" + node.name);
    bindings.forEach(function (binding) {
        block.addBinding(binding, expression);
    });
    var open = "${" + expression + "._render(__result, {" + props + "}";
    var options = [];
    if (generator.options.store) {
        options.push("store: options.store");
    }
    if (node.children.length) {
        var appendTarget_1 = {
            slots: { "default": '' },
            slotStack: ['default']
        };
        generator.appendTargets.push(appendTarget_1);
        node.children.forEach(function (child) {
            visit$1(generator, block, child);
        });
        var slotted = Object.keys(appendTarget_1.slots)
            .map(function (name) { return name + ": () => `" + appendTarget_1.slots[name] + "`"; })
            .join(', ');
        options.push("slotted: { " + slotted + " }");
        generator.appendTargets.pop();
    }
    if (options.length) {
        open += ", { " + options.join(', ') + " }";
    }
    generator.append(open);
    generator.append(')}');
}

function visitEachBlock(generator, block, node) {
    block.contextualise(node.expression);
    var _a = node.metadata, dependencies = _a.dependencies, snippet = _a.snippet;
    var open = "${ " + (node["else"] ? snippet + ".length ? " : '') + snippet + ".map(" + (node.index ? "(" + node.context + ", " + node.index + ")" : node.context) + " => `";
    generator.append(open);
    // TODO should this be the generator's job? It's duplicated between
    // here and the equivalent DOM compiler visitor
    var contexts = new Map(block.contexts);
    contexts.set(node.context, node.context);
    var indexes = new Map(block.indexes);
    if (node.index)
        indexes.set(node.index, node.context);
    var contextDependencies = new Map(block.contextDependencies);
    contextDependencies.set(node.context, dependencies);
    if (node.destructuredContexts) {
        for (var i = 0; i < node.destructuredContexts.length; i += 1) {
            contexts.set(node.destructuredContexts[i], node.context + "[" + i + "]");
            contextDependencies.set(node.destructuredContexts[i], dependencies);
        }
    }
    var childBlock = block.child({
        contexts: contexts,
        indexes: indexes,
        contextDependencies: contextDependencies
    });
    node.children.forEach(function (child) {
        visit$1(generator, childBlock, child);
    });
    var close = "`).join(\"\")";
    generator.append(close);
    if (node["else"]) {
        generator.append(" : `");
        node["else"].children.forEach(function (child) {
            visit$1(generator, block, child);
        });
        generator.append("`");
    }
    generator.append('}');
}

function visitSlot(generator, block, node) {
    var name = node.attributes.find(function (attribute) { return attribute.name; });
    var slotName = name && name.value[0].data || 'default';
    generator.append("${options && options.slotted && options.slotted." + slotName + " ? options.slotted." + slotName + "() : `");
    node.children.forEach(function (child) {
        visit$1(generator, block, child);
    });
    generator.append("`}");
}

function stringifyAttributeValue$1(block, chunks) {
    return chunks
        .map(function (chunk) {
        if (chunk.type === 'Text') {
            return escape(chunk.data).replace(/"/g, '&quot;');
        }
        block.contextualise(chunk.expression);
        var snippet = chunk.metadata.snippet;
        return '${' + snippet + '}';
    })
        .join('');
}

function visitElement(generator, block, node) {
    if (node.name === 'slot') {
        visitSlot(generator, block, node);
        return;
    }
    var openingTag = "<" + node.name;
    var textareaContents; // awkward special case
    var slot = node.getStaticAttributeValue('slot');
    if (slot && node.hasAncestor('Component')) {
        var slot_1 = node.attributes.find(function (attribute) { return attribute.name === 'slot'; });
        var slotName = slot_1.value[0].data;
        var appendTarget = generator.appendTargets[generator.appendTargets.length - 1];
        appendTarget.slotStack.push(slotName);
        appendTarget.slots[slotName] = '';
    }
    node.attributes.forEach(function (attribute) {
        if (attribute.type !== 'Attribute')
            return;
        if (attribute.name === 'value' && node.name === 'textarea') {
            textareaContents = stringifyAttributeValue$1(block, attribute.value);
        }
        else {
            var str = " " + attribute.name;
            if (attribute.value !== true) {
                str += "=\"" + stringifyAttributeValue$1(block, attribute.value) + "\"";
            }
            openingTag += str;
        }
    });
    if (node._needsCssAttribute) {
        openingTag += " " + generator.stylesheet.id;
        if (node._cssRefAttribute) {
            openingTag += " svelte-ref-" + node._cssRefAttribute;
        }
    }
    openingTag += '>';
    generator.append(openingTag);
    if (node.name === 'textarea' && textareaContents !== undefined) {
        generator.append(textareaContents);
    }
    else {
        node.children.forEach(function (child) {
            visit$1(generator, block, child);
        });
    }
    if (!isVoidElementName(node.name)) {
        generator.append("</" + node.name + ">");
    }
}

function visitDocument(generator, block, node) {
    generator.append('${(__result.head += `');
    node.children.forEach(function (child) {
        visit$1(generator, block, child);
    });
    generator.append('`, "")}');
}

function visitIfBlock(generator, block, node) {
    block.contextualise(node.expression);
    var snippet = node.metadata.snippet;
    generator.append('${ ' + snippet + ' ? `');
    var childBlock = block.child({
        conditions: block.conditions.concat(snippet)
    });
    node.children.forEach(function (child) {
        visit$1(generator, childBlock, child);
    });
    generator.append('` : `');
    if (node["else"]) {
        node["else"].children.forEach(function (child) {
            visit$1(generator, childBlock, child);
        });
    }
    generator.append('` }');
}

function visitMustacheTag(generator, block, node) {
    block.contextualise(node.expression);
    var snippet = node.metadata.snippet;
    generator.append('${__escape(' + snippet + ')}');
}

function visitRawMustacheTag(generator, block, node) {
    block.contextualise(node.expression);
    var snippet = node.metadata.snippet;
    generator.append('${' + snippet + '}');
}

function visitText(generator, block, node) {
    generator.append(escape(node.data).replace(/(\${|`|\\)/g, '\\$1'));
}

function visitWindow() {
    // noop
}

var visitors = {
    AwaitBlock: visitAwaitBlock,
    Comment: visitComment,
    Component: visitComponent,
    EachBlock: visitEachBlock,
    Element: visitElement,
    Head: visitDocument,
    IfBlock: visitIfBlock,
    MustacheTag: visitMustacheTag,
    RawMustacheTag: visitRawMustacheTag,
    Slot: visitSlot,
    Text: visitText,
    Window: visitWindow
};

function visit$1(generator, block, node) {
    var visitor = visitors[node.type];
    visitor(generator, block, node);
}

var SsrGenerator = /** @class */ (function (_super) {
    __extends(SsrGenerator, _super);
    function SsrGenerator(parsed, source, name, stylesheet, options) {
        var _this = _super.call(this, parsed, source, name, stylesheet, options, false) || this;
        _this.bindings = [];
        _this.renderCode = '';
        _this.appendTargets = [];
        _this.stylesheet.warnOnUnusedSelectors(options.onwarn);
        return _this;
    }
    SsrGenerator.prototype.append = function (code) {
        if (this.appendTargets.length) {
            var appendTarget = this.appendTargets[this.appendTargets.length - 1];
            var slotName = appendTarget.slotStack[appendTarget.slotStack.length - 1];
            appendTarget.slots[slotName] += code;
        }
        else {
            this.renderCode += code;
        }
    };
    return SsrGenerator;
}(Generator));
function ssr(parsed, source, stylesheet, options) {
    var format = options.format || 'cjs';
    var generator = new SsrGenerator(parsed, source, options.name || 'SvelteComponent', stylesheet, options);
    var computations = generator.computations, name = generator.name, templateProperties = generator.templateProperties;
    // create main render() function
    var mainBlock = new Block$3({
        generator: generator,
        contexts: new Map(),
        indexes: new Map(),
        conditions: []
    });
    trim(parsed.html.children).forEach(function (node) {
        visit$1(generator, mainBlock, node);
    });
    var _a = generator.customElement ?
        { css: null, cssMap: null } :
        generator.stylesheet.render(options.filename, true), css = _a.css, cssMap = _a.cssMap;
    // generate initial state object
    var expectedProperties = Array.from(generator.expectedProperties);
    var globals = expectedProperties.filter(function (prop) { return globalWhitelist.has(prop); });
    var storeProps = options.store || templateProperties.store ? expectedProperties.filter(function (prop) { return prop[0] === '$'; }) : [];
    var initialState = [];
    if (globals.length > 0) {
        initialState.push("{ " + globals.map(function (prop) { return prop + " : " + prop; }).join(', ') + " }");
    }
    if (storeProps.length > 0) {
        var initialize = "_init([" + storeProps.map(function (prop) { return "\"" + prop.slice(1) + "\""; }) + "])";
        if (options.store || templateProperties.store) {
            initialState.push("options.store." + initialize);
        }
    }
    if (templateProperties.data) {
        initialState.push("%data()");
    }
    else if (globals.length === 0 && storeProps.length === 0) {
        initialState.push('{}');
    }
    initialState.push('state');
    // TODO concatenate CSS maps
    var result = deindent(templateObject_1$13 || (templateObject_1$13 = __makeTemplateObject(["\n\t\t", "\n\n\t\tvar ", " = {};\n\n\t\t", ";\n\n\t\t", ".data = function() {\n\t\t\treturn ", ";\n\t\t};\n\n\t\t", ".render = function(state, options = {}) {\n\t\t\tvar components = new Set();\n\n\t\t\tfunction addComponent(component) {\n\t\t\t\tcomponents.add(component);\n\t\t\t}\n\n\t\t\tvar result = { head: '', addComponent };\n\t\t\t", "\n\t\t\tvar html = ", "._render(result, state, options);\n\n\t\t\tvar cssCode = Array.from(components).map(c => c.css && c.css.code).filter(Boolean).join('\\n');\n\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\thead: result.head,\n\t\t\t\tcss: { code: cssCode, map: null },\n\t\t\t\ttoString() {\n\t\t\t\t\treturn result.html;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t", "._render = function(__result, state, options) {\n\t\t\t__result.addComponent(", ");\n\n\t\t\tstate = Object.assign(", ");\n\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\treturn `", "`;\n\t\t};\n\n\t\t", ".css = {\n\t\t\tcode: ", ",\n\t\t\tmap: ", "\n\t\t};\n\n\t\tvar warned = false;\n\t\t", ".renderCss = function() {\n\t\t\tif (!warned) {\n\t\t\t\tconsole.error('Component.renderCss(...) is deprecated and will be removed in v2 \u2014 use Component.render(...).css instead');\n\t\t\t\twarned = true;\n\t\t\t}\n\n\t\t\tvar components = [];\n\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\treturn {\n\t\t\t\tcss: components.map(x => x.css).join('\\n'),\n\t\t\t\tmap: null,\n\t\t\t\tcomponents\n\t\t\t};\n\t\t};\n\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\n\t\t", "\n\t"], ["\n\t\t", "\n\n\t\tvar ", " = {};\n\n\t\t", ";\n\n\t\t", ".data = function() {\n\t\t\treturn ", ";\n\t\t};\n\n\t\t", ".render = function(state, options = {}) {\n\t\t\tvar components = new Set();\n\n\t\t\tfunction addComponent(component) {\n\t\t\t\tcomponents.add(component);\n\t\t\t}\n\n\t\t\tvar result = { head: '', addComponent };\n\t\t\t", "\n\t\t\tvar html = ", "._render(result, state, options);\n\n\t\t\tvar cssCode = Array.from(components).map(c => c.css && c.css.code).filter(Boolean).join('\\\\n');\n\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\thead: result.head,\n\t\t\t\tcss: { code: cssCode, map: null },\n\t\t\t\ttoString() {\n\t\t\t\t\treturn result.html;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t", "._render = function(__result, state, options) {\n\t\t\t__result.addComponent(", ");\n\n\t\t\tstate = Object.assign(", ");\n\n\t\t\t",
        "\n\n\t\t\t",
        "\n\n\t\t\treturn \\`", "\\`;\n\t\t};\n\n\t\t", ".css = {\n\t\t\tcode: ", ",\n\t\t\tmap: ", "\n\t\t};\n\n\t\tvar warned = false;\n\t\t", ".renderCss = function() {\n\t\t\tif (!warned) {\n\t\t\t\tconsole.error('Component.renderCss(...) is deprecated and will be removed in v2 \u2014 use Component.render(...).css instead');\n\t\t\t\twarned = true;\n\t\t\t}\n\n\t\t\tvar components = [];\n\n\t\t\t",
        "\n\n\t\t\t",
        "\n\n\t\t\treturn {\n\t\t\t\tcss: components.map(x => x.css).join('\\\\n'),\n\t\t\t\tmap: null,\n\t\t\t\tcomponents\n\t\t\t};\n\t\t};\n\n\t\t", "\n\n\t\t"
        // TODO this is a bit hacky
        ,
        "\n\n\t\t",
        "\n\n\t\t",
        "\n\t"])), generator.javascript, name, options.filename && name + ".filename = " + stringify(options.filename), name, templateProperties.data ? "%data()" : "{}", name, templateProperties.store && "options.store = %store();", name, name, name, initialState.join(', '), computations.map(function (_a) {
        var key = _a.key, deps = _a.deps;
        return "state." + key + " = %computed-" + key + "(" + deps.map(function (dep) { return "state." + dep; }).join(', ') + ");";
    }), generator.bindings.length && deindent(templateObject_2$12 || (templateObject_2$12 = __makeTemplateObject(["\n\t\t\t\tvar settled = false;\n\t\t\t\tvar tmp;\n\n\t\t\t\twhile (!settled) {\n\t\t\t\t\tsettled = true;\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tvar settled = false;\n\t\t\t\tvar tmp;\n\n\t\t\t\twhile (!settled) {\n\t\t\t\t\tsettled = true;\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"])), generator.bindings.join('\n\n')), generator.renderCode, name, css ? stringify(css) : "''", cssMap ? stringify(cssMap.toString()) : 'null', name, generator.stylesheet.hasStyles && deindent(templateObject_3$12 || (templateObject_3$12 = __makeTemplateObject(["\n\t\t\t\tcomponents.push({\n\t\t\t\t\tfilename: ", ".filename,\n\t\t\t\t\tcss: ", ".css && ", ".css.code,\n\t\t\t\t\tmap: ", ".css && ", ".css.map\n\t\t\t\t});\n\t\t\t"], ["\n\t\t\t\tcomponents.push({\n\t\t\t\t\tfilename: ", ".filename,\n\t\t\t\t\tcss: ", ".css && ", ".css.code,\n\t\t\t\t\tmap: ", ".css && ", ".css.map\n\t\t\t\t});\n\t\t\t"])), name, name, name, name, name), templateProperties.components && deindent(templateObject_4$12 || (templateObject_4$12 = __makeTemplateObject(["\n\t\t\t\tvar seen = {};\n\n\t\t\t\tfunction addComponent(component) {\n\t\t\t\t\tvar result = component.renderCss();\n\t\t\t\t\tresult.components.forEach(x => {\n\t\t\t\t\t\tif (seen[x.filename]) return;\n\t\t\t\t\t\tseen[x.filename] = true;\n\t\t\t\t\t\tcomponents.push(x);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t", "\n\t\t\t"], ["\n\t\t\t\tvar seen = {};\n\n\t\t\t\tfunction addComponent(component) {\n\t\t\t\t\tvar result = component.renderCss();\n\t\t\t\t\tresult.components.forEach(x => {\n\t\t\t\t\t\tif (seen[x.filename]) return;\n\t\t\t\t\t\tseen[x.filename] = true;\n\t\t\t\t\t\tcomponents.push(x);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t",
        "\n\t\t\t"])), templateProperties.components.value.properties.map(function (prop) {
        return "addComponent(%components-" + getMethodName(prop.key) + ");";
    })), templateProperties.preload && name + ".preload = %preload;", 
    // TODO this is a bit hacky
    /__escape/.test(generator.renderCode) && deindent(templateObject_5$10 || (templateObject_5$10 = __makeTemplateObject(["\n\t\t\t\tvar escaped = {\n\t\t\t\t\t'\"': '&quot;',\n\t\t\t\t\t\"'\": '&##39;',\n\t\t\t\t\t'&': '&amp;',\n\t\t\t\t\t'<': '&lt;',\n\t\t\t\t\t'>': '&gt;'\n\t\t\t\t};\n\n\t\t\t\tfunction __escape(html) {\n\t\t\t\t\treturn String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tvar escaped = {\n\t\t\t\t\t'\"': '&quot;',\n\t\t\t\t\t\"'\": '&##39;',\n\t\t\t\t\t'&': '&amp;',\n\t\t\t\t\t'<': '&lt;',\n\t\t\t\t\t'>': '&gt;'\n\t\t\t\t};\n\n\t\t\t\tfunction __escape(html) {\n\t\t\t\t\treturn String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n\t\t\t\t}\n\t\t\t"]))), /__isPromise/.test(generator.renderCode) && deindent(templateObject_6$10 || (templateObject_6$10 = __makeTemplateObject(["\n\t\t\t\tfunction __isPromise(value) {\n\t\t\t\t\treturn value && typeof value.then === 'function';\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tfunction __isPromise(value) {\n\t\t\t\t\treturn value && typeof value.then === 'function';\n\t\t\t\t}\n\t\t\t"]))), /__missingComponent/.test(generator.renderCode) && deindent(templateObject_7$8 || (templateObject_7$8 = __makeTemplateObject(["\n\t\t\t\tvar __missingComponent = {\n\t\t\t\t\trender: () => ''\n\t\t\t\t};\n\t\t\t"], ["\n\t\t\t\tvar __missingComponent = {\n\t\t\t\t\trender: () => ''\n\t\t\t\t};\n\t\t\t"])))).replace(/(@+|#+|%+)(\w*(?:-\w*)?)/g, function (match, sigil, name) {
        if (sigil === '@')
            return generator.alias(name);
        if (sigil === '%')
            return generator.templateVars.get(name);
        return sigil.slice(1) + name;
    });
    return generator.generate(result, options, { name: name, format: format });
}
function trim(nodes) {
    var start = 0;
    for (; start < nodes.length; start += 1) {
        var node = nodes[start];
        if (node.type !== 'Text')
            break;
        node.data = node.data.replace(/^\s+/, '');
        if (node.data)
            break;
    }
    var end = nodes.length;
    for (; end > start; end -= 1) {
        var node = nodes[end - 1];
        if (node.type !== 'Text')
            break;
        node.data = node.data.replace(/\s+$/, '');
        if (node.data)
            break;
    }
    return nodes.slice(start, end);
}
var templateObject_2$12;
var templateObject_3$12;
var templateObject_4$12;
var templateObject_5$10;
var templateObject_6$10;
var templateObject_7$8;
var templateObject_1$13;

function assign$1(target) {
	var k,
		source,
		i = 1,
		len = arguments.length;
	for (; i < len; i++) {
		source = arguments[i];
		for (k in source) target[k] = source[k];
	}

	return target;
}

// https://github.com/darkskyapp/string-hash/blob/master/index.js

var UNKNOWN = {};
function gatherPossibleValues(node, set) {
    if (node.type === 'Literal') {
        set.add(node.value);
    }
    else if (node.type === 'ConditionalExpression') {
        gatherPossibleValues(node.consequent, set);
        gatherPossibleValues(node.alternate, set);
    }
    else {
        set.add(UNKNOWN);
    }
}

var Selector$2 = /** @class */ (function () {
    function Selector(node) {
        this.node = node;
        this.blocks = groupSelectors(node);
        // take trailing :global(...) selectors out of consideration
        var i = this.blocks.length;
        while (i > 0) {
            if (!this.blocks[i - 1].global)
                break;
            i -= 1;
        }
        this.localBlocks = this.blocks.slice(0, i);
        this.used = this.blocks[0].global;
    }
    Selector.prototype.apply = function (node, stack) {
        var toEncapsulate = [];
        applySelector(this.localBlocks.slice(), node, stack.slice(), toEncapsulate);
        if (toEncapsulate.length > 0) {
            toEncapsulate.filter(function (_, i) { return i === 0 || i === toEncapsulate.length - 1; }).forEach(function (_a) {
                var node = _a.node, block = _a.block;
                node._needsCssAttribute = true;
                block.shouldEncapsulate = true;
            });
            this.used = true;
        }
    };
    Selector.prototype.minify = function (code) {
        var c = null;
        this.blocks.forEach(function (block, i) {
            if (i > 0) {
                if (block.start - c > 1) {
                    code.overwrite(c, block.start, block.combinator.name || ' ');
                }
            }
            c = block.end;
        });
    };
    Selector.prototype.transform = function (code, attr) {
        function encapsulateBlock(block) {
            var i = block.selectors.length;
            while (i--) {
                var selector = block.selectors[i];
                if (selector.type === 'PseudoElementSelector' || selector.type === 'PseudoClassSelector')
                    continue;
                if (selector.type === 'TypeSelector' && selector.name === '*') {
                    code.overwrite(selector.start, selector.end, attr);
                }
                else {
                    code.appendLeft(selector.end, attr);
                }
                break;
            }
            i = block.selectors.length;
            while (i--) {
                var selector = block.selectors[i];
                if (selector.type === 'RefSelector') {
                    code.overwrite(selector.start, selector.end, "[svelte-ref-" + selector.name + "]", {
                        contentOnly: true,
                        storeName: false
                    });
                }
            }
        }
        this.blocks.forEach(function (block, i) {
            if (block.global) {
                var selector = block.selectors[0];
                var first = selector.children[0];
                var last = selector.children[selector.children.length - 1];
                code.remove(selector.start, first.start).remove(last.end, selector.end);
            }
            if (block.shouldEncapsulate)
                encapsulateBlock(block);
        });
    };
    Selector.prototype.validate = function (validator) {
        this.blocks.forEach(function (block) {
            var i = block.selectors.length;
            while (i-- > 1) {
                var selector = block.selectors[i];
                if (selector.type === 'PseudoClassSelector' && selector.name === 'global') {
                    validator.error(":global(...) must be the first element in a compound selector", selector.start);
                }
            }
        });
        var start = 0;
        var end = this.blocks.length;
        for (; start < end; start += 1) {
            if (!this.blocks[start].global)
                break;
        }
        for (; end > start; end -= 1) {
            if (!this.blocks[end - 1].global)
                break;
        }
        for (var i = start; i < end; i += 1) {
            if (this.blocks[i].global) {
                validator.error(":global(...) can be at the start or end of a selector sequence, but not in the middle", this.blocks[i].selectors[0].start);
            }
        }
    };
    return Selector;
}());
function applySelector(blocks, node, stack, toEncapsulate) {
    var block = blocks.pop();
    if (!block)
        return false;
    if (!node) {
        return blocks.every(function (block) { return block.global; });
    }
    var i = block.selectors.length;
    var j = stack.length;
    var _loop_1 = function () {
        var selector = block.selectors[i];
        if (selector.type === 'PseudoClassSelector' && selector.name === 'global') {
            return { value: false };
        }
        if (selector.type === 'PseudoClassSelector' || selector.type === 'PseudoElementSelector') {
            return "continue";
        }
        if (selector.type === 'ClassSelector') {
            if (!attributeMatches(node, 'class', selector.name, '~=', false))
                return { value: false };
        }
        else if (selector.type === 'IdSelector') {
            if (!attributeMatches(node, 'id', selector.name, '=', false))
                return { value: false };
        }
        else if (selector.type === 'AttributeSelector') {
            if (!attributeMatches(node, selector.name.name, selector.value && unquote(selector.value), selector.matcher, selector.flags))
                return { value: false };
        }
        else if (selector.type === 'TypeSelector') {
            if (node.name !== selector.name && selector.name !== '*')
                return { value: false };
        }
        else if (selector.type === 'RefSelector') {
            if (node.attributes.some(function (attr) { return attr.type === 'Ref' && attr.name === selector.name; })) {
                node._cssRefAttribute = selector.name;
                toEncapsulate.push({ node: node, block: block });
                return { value: true };
            }
            return { value: void 0 };
        }
        else {
            // bail. TODO figure out what these could be
            toEncapsulate.push({ node: node, block: block });
            return { value: true };
        }
    };
    while (i--) {
        var state_1 = _loop_1();
        if (typeof state_1 === "object")
            return state_1.value;
    }
    if (block.combinator) {
        if (block.combinator.type === 'WhiteSpace') {
            while (stack.length) {
                if (applySelector(blocks.slice(), stack.pop(), stack, toEncapsulate)) {
                    toEncapsulate.push({ node: node, block: block });
                    return true;
                }
            }
            return false;
        }
        else if (block.combinator.name === '>') {
            if (applySelector(blocks, stack.pop(), stack, toEncapsulate)) {
                toEncapsulate.push({ node: node, block: block });
                return true;
            }
            return false;
        }
        // TODO other combinators
        toEncapsulate.push({ node: node, block: block });
        return true;
    }
    toEncapsulate.push({ node: node, block: block });
    return true;
}
var operators = {
    '=': function (value, flags) { return new RegExp("^" + value + "$", flags); },
    '~=': function (value, flags) { return new RegExp("\\b" + value + "\\b", flags); },
    '|=': function (value, flags) { return new RegExp("^" + value + "(-.+)?$", flags); },
    '^=': function (value, flags) { return new RegExp("^" + value, flags); },
    '$=': function (value, flags) { return new RegExp(value + "$", flags); },
    '*=': function (value, flags) { return new RegExp(value, flags); }
};
function attributeMatches(node, name, expectedValue, operator, caseInsensitive) {
    var attr = node.attributes.find(function (attr) { return attr.name === name; });
    if (!attr)
        return false;
    if (attr.value === true)
        return operator === null;
    if (attr.value.length > 1)
        return true;
    if (!expectedValue)
        return true;
    var pattern = operators[operator](expectedValue, caseInsensitive ? 'i' : '');
    var value = attr.value[0];
    if (!value)
        return false;
    if (value.type === 'Text')
        return pattern.test(value.data);
    var possibleValues = new Set();
    gatherPossibleValues(value.expression, possibleValues);
    if (possibleValues.has(UNKNOWN))
        return true;
    for (var _i = 0, _a = Array.from(possibleValues); _i < _a.length; _i++) {
        var x = _a[_i];
        if (pattern.test(x))
            return true;
    }
    return false;
}
function unquote(value) {
    if (value.type === 'Identifier')
        return value.name;
    var str = value.value;
    if (str[0] === str[str.length - 1] && str[0] === "'" || str[0] === '"') {
        return str.slice(1, str.length - 1);
    }
    return str;
}
var Block$4 = /** @class */ (function () {
    function Block(combinator) {
        this.combinator = combinator;
        this.global = false;
        this.selectors = [];
        this.start = null;
        this.end = null;
        this.shouldEncapsulate = false;
    }
    Block.prototype.add = function (selector) {
        if (this.selectors.length === 0) {
            this.start = selector.start;
            this.global = selector.type === 'PseudoClassSelector' && selector.name === 'global';
        }
        this.selectors.push(selector);
        this.end = selector.end;
    };
    return Block;
}());
function groupSelectors(selector) {
    var block = new Block$4(null);
    var blocks = [block];
    selector.children.forEach(function (child, i) {
        if (child.type === 'WhiteSpace' || child.type === 'Combinator') {
            block = new Block$4(child);
            blocks.push(block);
        }
        else {
            block.add(child);
        }
    });
    return blocks;
}

var Rule$2 = /** @class */ (function () {
    function Rule(node, parent) {
        this.node = node;
        this.parent = parent;
        this.selectors = node.selector.children.map(function (node) { return new Selector$2(node); });
        this.declarations = node.block.children.map(function (node) { return new Declaration$2(node); });
    }
    Rule.prototype.apply = function (node, stack) {
        this.selectors.forEach(function (selector) { return selector.apply(node, stack); }); // TODO move the logic in here?
    };
    Rule.prototype.isUsed = function () {
        if (this.parent && this.parent.node.type === 'Atrule' && this.parent.node.name === 'keyframes')
            return true;
        return this.selectors.some(function (s) { return s.used; });
    };
    Rule.prototype.minify = function (code, cascade) {
        var c = this.node.start;
        var started = false;
        this.selectors.forEach(function (selector, i) {
            if (cascade || selector.used) {
                var separator = started ? ',' : '';
                if ((selector.node.start - c) > separator.length) {
                    code.overwrite(c, selector.node.start, separator);
                }
                if (!cascade)
                    selector.minify(code);
                c = selector.node.end;
                started = true;
            }
        });
        code.remove(c, this.node.block.start);
        c = this.node.block.start + 1;
        this.declarations.forEach(function (declaration, i) {
            var separator = i > 0 ? ';' : '';
            if ((declaration.node.start - c) > separator.length) {
                code.overwrite(c, declaration.node.start, separator);
            }
            declaration.minify(code);
            c = declaration.node.end;
        });
        code.remove(c, this.node.block.end - 1);
    };
    Rule.prototype.transform = function (code, id, keyframes, cascade) {
        if (this.parent && this.parent.node.type === 'Atrule' && this.parent.node.name === 'keyframes')
            return true;
        var attr = "[" + id + "]";
        if (cascade) {
            this.selectors.forEach(function (selector) {
                // TODO disable cascading (without :global(...)) in v2
                var _a = selector.node, start = _a.start, end = _a.end, children = _a.children;
                var css = code.original;
                var selectorString = css.slice(start, end);
                var firstToken = children[0];
                var transformed;
                if (firstToken.type === 'TypeSelector') {
                    var insert = firstToken.end;
                    var head = firstToken.name === '*' ? '' : css.slice(start, insert);
                    var tail = css.slice(insert, end);
                    transformed = "" + head + attr + tail + "," + attr + " " + selectorString;
                }
                else {
                    transformed = "" + attr + selectorString + "," + attr + " " + selectorString;
                }
                code.overwrite(start, end, transformed);
            });
        }
        else {
            this.selectors.forEach(function (selector) { return selector.transform(code, attr); });
        }
        this.declarations.forEach(function (declaration) { return declaration.transform(code, keyframes); });
    };
    Rule.prototype.validate = function (validator) {
        this.selectors.forEach(function (selector) {
            selector.validate(validator);
        });
    };
    Rule.prototype.warnOnUnusedSelector = function (handler) {
        this.selectors.forEach(function (selector) {
            if (!selector.used)
                handler(selector);
        });
    };
    return Rule;
}());
var Declaration$2 = /** @class */ (function () {
    function Declaration(node) {
        this.node = node;
    }
    Declaration.prototype.transform = function (code, keyframes) {
        var property = this.node.property && this.node.property.toLowerCase();
        if (property === 'animation' || property === 'animation-name') {
            this.node.value.children.forEach(function (block) {
                if (block.type === 'Identifier') {
                    var name = block.name;
                    if (keyframes.has(name)) {
                        code.overwrite(block.start, block.end, keyframes.get(name));
                    }
                }
            });
        }
    };
    Declaration.prototype.minify = function (code) {
        if (!this.node.property)
            return; // @apply, and possibly other weird cases?
        var c = this.node.start + this.node.property.length;
        var first = this.node.value.children ?
            this.node.value.children[0] :
            this.node.value;
        var start = first.start;
        while (/\s/.test(code.original[start]))
            start += 1;
        if (start - c > 1) {
            code.overwrite(c, start, ':');
        }
    };
    return Declaration;
}());
var Atrule$2 = /** @class */ (function () {
    function Atrule(node) {
        this.node = node;
        this.children = [];
    }
    Atrule.prototype.apply = function (node, stack) {
        if (this.node.name === 'media') {
            this.children.forEach(function (child) {
                child.apply(node, stack);
            });
        }
        else if (this.node.name === 'keyframes') {
            this.children.forEach(function (rule) {
                rule.selectors.forEach(function (selector) {
                    selector.used = true;
                });
            });
        }
    };
    Atrule.prototype.isUsed = function () {
        return true; // TODO
    };
    Atrule.prototype.minify = function (code, cascade) {
        if (this.node.name === 'media') {
            var expressionChar = code.original[this.node.expression.start];
            var c_1 = this.node.start + (expressionChar === '(' ? 6 : 7);
            if (this.node.expression.start > c_1)
                code.remove(c_1, this.node.expression.start);
            this.node.expression.children.forEach(function (query) {
                // TODO minify queries
                c_1 = query.end;
            });
            code.remove(c_1, this.node.block.start);
        }
        else if (this.node.name === 'keyframes') {
            var c = this.node.start + 10;
            if (this.node.expression.start - c > 1)
                code.overwrite(c, this.node.expression.start, ' ');
            c = this.node.expression.end;
            if (this.node.block.start - c > 0)
                code.remove(c, this.node.block.start);
        }
        // TODO other atrules
        if (this.node.block) {
            var c_2 = this.node.block.start + 1;
            this.children.forEach(function (child) {
                if (cascade || child.isUsed()) {
                    code.remove(c_2, child.node.start);
                    child.minify(code, cascade);
                    c_2 = child.node.end;
                }
            });
            code.remove(c_2, this.node.block.end - 1);
        }
    };
    Atrule.prototype.transform = function (code, id, keyframes, cascade) {
        if (this.node.name === 'keyframes') {
            this.node.expression.children.forEach(function (_a) {
                var type = _a.type, name = _a.name, start = _a.start, end = _a.end;
                if (type === 'Identifier') {
                    if (name.startsWith('-global-')) {
                        code.remove(start, start + 8);
                    }
                    else {
                        code.overwrite(start, end, keyframes.get(name));
                    }
                }
            });
        }
        this.children.forEach(function (child) {
            child.transform(code, id, keyframes, cascade);
        });
    };
    Atrule.prototype.validate = function (validator) {
        this.children.forEach(function (child) {
            child.validate(validator);
        });
    };
    Atrule.prototype.warnOnUnusedSelector = function (handler) {
        if (this.node.name !== 'media')
            return;
        this.children.forEach(function (child) {
            child.warnOnUnusedSelector(handler);
        });
    };
    return Atrule;
}());
var Stylesheet = /** @class */ (function () {
    function Stylesheet(source, parsed, filename, cascade) {
        var _this = this;
        this.source = source;
        this.parsed = parsed;
        this.cascade = cascade;
        this.filename = filename;
        this.id = "svelte-" + parsed.hash;
        this.children = [];
        this.keyframes = new Map();
        if (parsed.css && parsed.css.children.length) {
            this.hasStyles = true;
            var stack_1 = [];
            var currentAtrule_1 = null;
            walk(this.parsed.css, {
                enter: function (node) {
                    if (node.type === 'Atrule') {
                        var last = stack_1[stack_1.length - 1];
                        var atrule = new Atrule$2(node);
                        stack_1.push(atrule);
                        // this is an awkward special case — @apply (and
                        // possibly other future constructs)
                        if (last && !(last instanceof Atrule$2))
                            return;
                        if (currentAtrule_1) {
                            currentAtrule_1.children.push(atrule);
                        }
                        else {
                            _this.children.push(atrule);
                        }
                        if (node.name === 'keyframes') {
                            node.expression.children.forEach(function (expression) {
                                if (expression.type === 'Identifier' && !expression.name.startsWith('-global-')) {
                                    _this.keyframes.set(expression.name, _this.id + "-" + expression.name);
                                }
                            });
                        }
                        currentAtrule_1 = atrule;
                    }
                    if (node.type === 'Rule') {
                        var rule = new Rule$2(node, currentAtrule_1);
                        stack_1.push(rule);
                        if (currentAtrule_1) {
                            currentAtrule_1.children.push(rule);
                        }
                        else {
                            _this.children.push(rule);
                        }
                    }
                },
                leave: function (node) {
                    if (node.type === 'Rule' || node.type === 'Atrule')
                        stack_1.pop();
                    if (node.type === 'Atrule')
                        currentAtrule_1 = stack_1[stack_1.length - 1];
                }
            });
        }
        else {
            this.hasStyles = false;
        }
    }
    Stylesheet.prototype.apply = function (node) {
        if (!this.hasStyles)
            return;
        var stack = [];
        var parent = node;
        while (parent = parent.parent) {
            if (parent.type === 'Element')
                stack.unshift(parent);
        }
        if (this.cascade) {
            if (stack.length === 0)
                node._needsCssAttribute = true;
            return;
        }
        for (var i = 0; i < this.children.length; i += 1) {
            var child = this.children[i];
            child.apply(node, stack);
        }
    };
    Stylesheet.prototype.render = function (cssOutputFilename, shouldTransformSelectors) {
        var _this = this;
        if (!this.hasStyles) {
            return { css: null, cssMap: null };
        }
        var code = new MagicString$1(this.source);
        walk(this.parsed.css, {
            enter: function (node) {
                code.addSourcemapLocation(node.start);
                code.addSourcemapLocation(node.end);
            }
        });
        if (shouldTransformSelectors) {
            this.children.forEach(function (child) {
                child.transform(code, _this.id, _this.keyframes, _this.cascade);
            });
        }
        var c = 0;
        this.children.forEach(function (child) {
            if (_this.cascade || child.isUsed()) {
                code.remove(c, child.node.start);
                child.minify(code, _this.cascade);
                c = child.node.end;
            }
        });
        code.remove(c, this.source.length);
        return {
            css: code.toString(),
            cssMap: code.generateMap({
                includeContent: true,
                source: this.filename,
                file: cssOutputFilename
            })
        };
    };
    Stylesheet.prototype.validate = function (validator) {
        this.children.forEach(function (child) {
            child.validate(validator);
        });
    };
    Stylesheet.prototype.warnOnUnusedSelectors = function (onwarn) {
        var _this = this;
        if (this.cascade)
            return;
        var locator;
        var handler = function (selector) {
            var pos = selector.node.start;
            if (!locator)
                locator = getLocator(_this.source);
            var _a = locator(pos), line = _a.line, column = _a.column;
            var frame = getCodeFrame(_this.source, line, column);
            var message = "Unused CSS selector";
            onwarn({
                message: message,
                frame: frame,
                loc: { line: line + 1, column: column },
                pos: pos,
                filename: _this.filename,
                toString: function () { return message + " (" + (line + 1) + ":" + column + ")\n" + frame; }
            });
        };
        this.children.forEach(function (child) {
            child.warnOnUnusedSelector(handler);
        });
    };
    return Stylesheet;
}());

var version = '1.49.0';
function normalizeOptions(options) {
    var normalizedOptions = assign$1({ generate: 'dom' }, options);
    var onwarn = normalizedOptions.onwarn, onerror = normalizedOptions.onerror;
    normalizedOptions.onwarn = onwarn
        ? function (warning) { return onwarn(warning, defaultOnwarn); }
        : defaultOnwarn;
    normalizedOptions.onerror = onerror
        ? function (error) { return onerror(error, defaultOnerror); }
        : defaultOnerror;
    return normalizedOptions;
}
function defaultOnwarn(warning) {
    if (warning.loc) {
        console.warn("(" + warning.loc.line + ":" + warning.loc.column + ") \u2013 " + warning.message); // eslint-disable-line no-console
    }
    else {
        console.warn(warning.message); // eslint-disable-line no-console
    }
}
function defaultOnerror(error) {
    throw error;
}
function parseAttributeValue(value) {
    return /^['"]/.test(value) ?
        value.slice(1, -1) :
        value;
}
function parseAttributes(str) {
    var attrs = {};
    str.split(/\s+/).filter(Boolean).forEach(function (attr) {
        var _a = attr.split('='), name = _a[0], value = _a[1];
        attrs[name] = value ? parseAttributeValue(value) : true;
    });
    return attrs;
}
function replaceTagContents(source, type, preprocessor, options) {
    return __awaiter(this, void 0, void 0, function () {
        var exp, match, attributes, content, processed;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    exp = new RegExp("<" + type + "([\\S\\s]*?)>([\\S\\s]*?)<\\/" + type + ">", 'ig');
                    match = exp.exec(source);
                    if (!match) return [3 /*break*/, 2];
                    attributes = parseAttributes(match[1]);
                    content = match[2];
                    return [4 /*yield*/, preprocessor({
                            content: content,
                            attributes: attributes,
                            filename: options.filename
                        })];
                case 1:
                    processed = _a.sent();
                    if (processed && processed.code) {
                        return [2 /*return*/, (source.slice(0, match.index) +
                                ("<" + type + ">" + processed.code + "</" + type + ">") +
                                source.slice(match.index + match[0].length))];
                    }
                    _a.label = 2;
                case 2: return [2 /*return*/, source];
            }
        });
    });
}
function preprocess(source, options) {
    return __awaiter(this, void 0, void 0, function () {
        var markup, style, script, processed;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    markup = options.markup, style = options.style, script = options.script;
                    if (!!!markup) return [3 /*break*/, 2];
                    return [4 /*yield*/, markup({
                            content: source,
                            filename: options.filename
                        })];
                case 1:
                    processed = _a.sent();
                    source = processed.code;
                    _a.label = 2;
                case 2:
                    if (!!!style) return [3 /*break*/, 4];
                    return [4 /*yield*/, replaceTagContents(source, 'style', style, options)];
                case 3:
                    source = _a.sent();
                    _a.label = 4;
                case 4:
                    if (!!!script) return [3 /*break*/, 6];
                    return [4 /*yield*/, replaceTagContents(source, 'script', script, options)];
                case 5:
                    source = _a.sent();
                    _a.label = 6;
                case 6: return [2 /*return*/, {
                        // TODO return separated output, in future version where svelte.compile supports it:
                        // style: { code: styleCode, map: styleMap },
                        // script { code: scriptCode, map: scriptMap },
                        // markup { code: markupCode, map: markupMap },
                        toString: function () {
                            return source;
                        }
                    }];
            }
        });
    });
}
function compile(source, _options) {
    var options = normalizeOptions(_options);
    var parsed;
    try {
        parsed = parse(source, options);
    }
    catch (err) {
        options.onerror(err);
        return;
    }
    var stylesheet = new Stylesheet(source, parsed, options.filename, options.cascade !== false);
    validate(parsed, source, stylesheet, options);
    var compiler = options.generate === 'ssr' ? ssr : dom;
    return compiler(parsed, source, stylesheet, options);
}

function create(source, _options) {
    if (_options === void 0) { _options = {}; }
    _options.format = 'eval';
    var compiled = compile(source, _options);
    if (!compiled || !compiled.code) {
        return;
    }
    try {
        return (0, eval)(compiled.code);
    }
    catch (err) {
        if (_options.onerror) {
            _options.onerror(err);
            return;
        }
        else {
            throw err;
        }
    }
}

exports.preprocess = preprocess;
exports.compile = compile;
exports.create = create;
exports.parse = parse;
exports.validate = validate;
exports.VERSION = version;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=svelte.js.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26).Buffer, __webpack_require__(27)))

/***/ }),

/***/ 12:
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ 26:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(34)
var ieee754 = __webpack_require__(35)
var isArray = __webpack_require__(31)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(12)))

/***/ }),

/***/ 27:
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ 31:
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ 34:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}


/***/ }),

/***/ 35:
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ })

});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3ZlbHRlL2NvbXBpbGVyL3N2ZWx0ZS5qcyIsIndlYnBhY2s6Ly8vLi4vc2FwcGVyL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uLi9zYXBwZXIvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vc2FwcGVyL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL3NhcHBlci9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vc2FwcGVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL3NhcHBlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixDQUFDLDRCQUE0Qjs7QUFFN0I7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxnQkFBZ0Isc0NBQXNDLGlCQUFpQixFQUFFO0FBQy9FLHFCQUFxQix1REFBdUQ7O0FBRTVFO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IsaUVBQWlFLHVCQUF1QixFQUFFLDRCQUE0QjtBQUNySjtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGFBQWEsNkJBQTZCLDBCQUEwQixhQUFhLEVBQUUscUJBQXFCO0FBQ3hHLGdCQUFnQixxREFBcUQsb0VBQW9FLGFBQWEs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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUk7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7O0FBRUEsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsU0FBUztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7O0FBRUEscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLElBQUk7QUFDaEI7QUFDQSxtQkFBbUIscUNBQXFDO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSx3QkFBd0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVUsd0JBQXdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixrQkFBa0I7QUFDekM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDBCQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0JBQXNCLDBCQUEwQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EscURBQXFELFdBQVcsT0FBTyxPQUFPLG9CQUFvQjs7QUFFbEc7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixpQkFBaUI7QUFDakIsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBLGlCQUFpQjtBQUNqQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLHdDQUF3QztBQUN0RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVCwyQkFBMkI7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLHVCQUF1QjtBQUN2QixLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyx3QkFBd0I7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyx3QkFBd0I7QUFDbEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixJQUFJLFFBQVEsSUFBSSxHQUFHO0FBQzNDO0FBQ0Esa0RBQWtELHdCQUF3QjtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYywrQkFBK0I7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLG1DQUFtQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsb0JBQW9CLDBCQUEwQixFQUFFOztBQUUvRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFFBQVE7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsUUFBUTtBQUMxQjs7QUFFQTtBQUNBLHVFQUF1RSx3Q0FBd0MsRUFBRTtBQUNqSDs7QUFFQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBCQUEwQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0Esa0VBQWtFLGlCQUFpQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxHQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLEtBQUs7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUssTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVksb0JBQW9CLFNBQVM7QUFDcEY7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxNQUFNLG9CQUFvQixTQUFTLE1BQU0sV0FBVztBQUMvRjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLE1BQU07QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTyxtQ0FBbUM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQjtBQUMxQixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx1Q0FBdUM7QUFDaEY7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlELHFDQUFxQyxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw2QkFBNkIsY0FBYztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVyxvQkFBb0IsYUFBYTtBQUNoRjtBQUNBO0FBQ0EsOENBQThDLFNBQVMsSUFBSSxFQUFFO0FBQzdEO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNDQUFzQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHlCQUF5QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsbUJBQW1CO0FBQy9HO0FBQ0E7QUFDQSx1RUFBdUUsa0NBQWtDLEVBQUU7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsK0RBQStELGtDQUFrQyxFQUFFO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQseUNBQXlDLEVBQUU7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCLGtCQUFrQjtBQUNoRCx5RUFBeUUsK0JBQStCLEVBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0EsbUNBQW1DLG1FQUFtRTtBQUN0RyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFh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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsTUFBTTtBQUM5RCxxQ0FBcUMsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLHNDQUFzQztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjOztBQUU1RCxDQUFDO0FBQ0Q7Ozs7Ozs7OztBQ2x5bkJBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDOzs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFD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U0FBUztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBIiwiZmlsZSI6IjcuNy5mYjFjODRkNzI5ZmRkNGE5ZGZhNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcblx0KGZhY3RvcnkoKGdsb2JhbC5zdmVsdGUgPSB7fSkpKTtcbn0odGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59XG5cbi8vIFJlc2VydmVkIHdvcmQgbGlzdHMgZm9yIHZhcmlvdXMgZGlhbGVjdHMgb2YgdGhlIGxhbmd1YWdlXG5cbnZhciByZXNlcnZlZFdvcmRzID0ge1xuICAzOiBcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIixcbiAgNTogXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiLFxuICA2OiBcImVudW1cIixcbiAgc3RyaWN0OiBcImltcGxlbWVudHMgaW50ZXJmYWNlIGxldCBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzdGF0aWMgeWllbGRcIixcbiAgc3RyaWN0QmluZDogXCJldmFsIGFyZ3VtZW50c1wiXG59O1xuXG4vLyBBbmQgdGhlIGtleXdvcmRzXG5cbnZhciBlY21hNUFuZExlc3NLZXl3b3JkcyA9IFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCI7XG5cbnZhciBrZXl3b3JkcyA9IHtcbiAgNTogZWNtYTVBbmRMZXNzS2V5d29yZHMsXG4gIDY6IGVjbWE1QW5kTGVzc0tleXdvcmRzICsgXCIgY29uc3QgY2xhc3MgZXh0ZW5kcyBleHBvcnQgaW1wb3J0IHN1cGVyXCJcbn07XG5cbi8vICMjIENoYXJhY3RlciBjYXRlZ29yaWVzXG5cbi8vIEJpZyB1Z2x5IHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdCBtYXRjaCBjaGFyYWN0ZXJzIGluIHRoZVxuLy8gd2hpdGVzcGFjZSwgaWRlbnRpZmllciwgYW5kIGlkZW50aWZpZXItc3RhcnQgY2F0ZWdvcmllcy4gVGhlc2Vcbi8vIGFyZSBvbmx5IGFwcGxpZWQgd2hlbiBhIGNoYXJhY3RlciBpcyBmb3VuZCB0byBhY3R1YWxseSBoYXZlIGFcbi8vIGNvZGUgcG9pbnQgYWJvdmUgMTI4LlxuLy8gR2VuZXJhdGVkIGJ5IGBiaW4vZ2VuZXJhdGUtaWRlbnRpZmllci1yZWdleC5qc2AuXG5cbnZhciBub25BU0NJSWlkZW50aWZpZXJTdGFydENoYXJzID0gXCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzdmXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MmZcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTAtXFx1MDhiNFxcdTA4YjYtXFx1MDhiZFxcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTgwXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGFmOVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzM5XFx1MGMzZFxcdTBjNTgtXFx1MGM1YVxcdTBjNjBcXHUwYzYxXFx1MGM4MFxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ1NC1cXHUwZDU2XFx1MGQ1Zi1cXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNVxcdTEzZjgtXFx1MTNmZFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmOFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxZVxcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YjAtXFx1MTljOVxcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjODAtXFx1MWM4OFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5Yi1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmQ1XFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OWRcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3YWVcXHVhN2IwLVxcdWE3YjdcXHVhN2Y3LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YThmZFxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhOWUwLVxcdWE5ZTRcXHVhOWU2LVxcdWE5ZWZcXHVhOWZhLVxcdWE5ZmVcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE3ZS1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYjMwLVxcdWFiNWFcXHVhYjVjLVxcdWFiNjVcXHVhYjcwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIjtcbnZhciBub25BU0NJSWlkZW50aWZpZXJDaGFycyA9IFwiXFx1MjAwY1xcdTIwMGRcXHhiN1xcdTAzMDAtXFx1MDM2ZlxcdTAzODdcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjRiLVxcdTA2NjlcXHUwNjcwXFx1MDZkNi1cXHUwNmRjXFx1MDZkZi1cXHUwNmU0XFx1MDZlN1xcdTA2ZThcXHUwNmVhLVxcdTA2ZWRcXHUwNmYwLVxcdTA2ZjlcXHUwNzExXFx1MDczMC1cXHUwNzRhXFx1MDdhNi1cXHUwN2IwXFx1MDdjMC1cXHUwN2M5XFx1MDdlYi1cXHUwN2YzXFx1MDgxNi1cXHUwODE5XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg1OS1cXHUwODViXFx1MDhkNC1cXHUwOGUxXFx1MDhlMy1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWNiLVxcdTA5Y2RcXHUwOWQ3XFx1MDllMlxcdTA5ZTNcXHUwOWU2LVxcdTA5ZWZcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI2MlxcdTBiNjNcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDAtXFx1MGMwM1xcdTBjM2UtXFx1MGM0NFxcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2MlxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgxLVxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDEtXFx1MGQwM1xcdTBkM2UtXFx1MGQ0NFxcdTBkNDYtXFx1MGQ0OFxcdTBkNGEtXFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGU2LVxcdTBkZWZcXHUwZGYyXFx1MGRmM1xcdTBlMzFcXHUwZTM0LVxcdTBlM2FcXHUwZTQ3LVxcdTBlNGVcXHUwZTUwLVxcdTBlNTlcXHUwZWIxXFx1MGViNC1cXHUwZWI5XFx1MGViYlxcdTBlYmNcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmM2VcXHUwZjNmXFx1MGY3MS1cXHUwZjg0XFx1MGY4NlxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAyYi1cXHUxMDNlXFx1MTA0MC1cXHUxMDQ5XFx1MTA1Ni1cXHUxMDU5XFx1MTA1ZS1cXHUxMDYwXFx1MTA2Mi1cXHUxMDY0XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTM2OS1cXHUxMzcxXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3YjQtXFx1MTdkM1xcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOGE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk0Ni1cXHUxOTRmXFx1MTlkMC1cXHUxOWRhXFx1MWExNy1cXHUxYTFiXFx1MWE1NS1cXHUxYTVlXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWFiMC1cXHUxYWJkXFx1MWIwMC1cXHUxYjA0XFx1MWIzNC1cXHUxYjQ0XFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWI4MC1cXHUxYjgyXFx1MWJhMS1cXHUxYmFkXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMyNC1cXHUxYzM3XFx1MWM0MC1cXHUxYzQ5XFx1MWM1MC1cXHUxYzU5XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2U4XFx1MWNlZFxcdTFjZjItXFx1MWNmNFxcdTFjZjhcXHUxY2Y5XFx1MWRjMC1cXHUxZGY1XFx1MWRmYi1cXHUxZGZmXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJjZWYtXFx1MmNmMVxcdTJkN2ZcXHUyZGUwLVxcdTJkZmZcXHUzMDJhLVxcdTMwMmZcXHUzMDk5XFx1MzA5YVxcdWE2MjAtXFx1YTYyOVxcdWE2NmZcXHVhNjc0LVxcdWE2N2RcXHVhNjllXFx1YTY5ZlxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MFxcdWE4ODFcXHVhOGI0LVxcdWE4YzVcXHVhOGQwLVxcdWE4ZDlcXHVhOGUwLVxcdWE4ZjFcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTQ3LVxcdWE5NTNcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhOWQwLVxcdWE5ZDlcXHVhOWU1XFx1YTlmMC1cXHVhOWY5XFx1YWEyOS1cXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3Yi1cXHVhYTdkXFx1YWFiMFxcdWFhYjItXFx1YWFiNFxcdWFhYjdcXHVhYWI4XFx1YWFiZVxcdWFhYmZcXHVhYWMxXFx1YWFlYi1cXHVhYWVmXFx1YWFmNVxcdWFhZjZcXHVhYmUzLVxcdWFiZWFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMWVcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMmZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIjtcblxudmFyIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0ID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBcIl1cIik7XG52YXIgbm9uQVNDSUlpZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIltcIiArIG5vbkFTQ0lJaWRlbnRpZmllclN0YXJ0Q2hhcnMgKyBub25BU0NJSWlkZW50aWZpZXJDaGFycyArIFwiXVwiKTtcblxubm9uQVNDSUlpZGVudGlmaWVyU3RhcnRDaGFycyA9IG5vbkFTQ0lJaWRlbnRpZmllckNoYXJzID0gbnVsbDtcblxuLy8gVGhlc2UgYXJlIGEgcnVuLWxlbmd0aCBhbmQgb2Zmc2V0IGVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4vLyA+MHhmZmZmIGNvZGUgcG9pbnRzIHRoYXQgYXJlIGEgdmFsaWQgcGFydCBvZiBpZGVudGlmaWVycy4gVGhlXG4vLyBvZmZzZXQgc3RhcnRzIGF0IDB4MTAwMDAsIGFuZCBlYWNoIHBhaXIgb2YgbnVtYmVycyByZXByZXNlbnRzIGFuXG4vLyBvZmZzZXQgdG8gdGhlIG5leHQgcmFuZ2UsIGFuZCB0aGVuIGEgc2l6ZSBvZiB0aGUgcmFuZ2UuIFRoZXkgd2VyZVxuLy8gZ2VuZXJhdGVkIGJ5IGJpbi9nZW5lcmF0ZS1pZGVudGlmaWVyLXJlZ2V4LmpzXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMgPSBbMCwxMSwyLDI1LDIsMTgsMiwxLDIsMTQsMywxMywzNSwxMjIsNzAsNTIsMjY4LDI4LDQsNDgsNDgsMzEsMTcsMjYsNiwzNywxMSwyOSwzLDM1LDUsNywyLDQsNDMsMTU3LDE5LDM1LDUsMzUsNSwzOSw5LDUxLDE1NywzMTAsMTAsMjEsMTEsNywxNTMsNSwzLDAsMiw0MywyLDEsNCwwLDMsMjIsMTEsMjIsMTAsMzAsNjYsMTgsMiwxLDExLDIxLDExLDI1LDcxLDU1LDcsMSw2NSwwLDE2LDMsMiwyLDIsMjYsNDUsMjgsNCwyOCwzNiw3LDIsMjcsMjgsNTMsMTEsMjEsMTEsMTgsMTQsMTcsMTExLDcyLDU2LDUwLDE0LDUwLDc4NSw1Miw3Niw0NCwzMywyNCwyNywzNSw0MiwzNCw0LDAsMTMsNDcsMTUsMywyMiwwLDIsMCwzNiwxNywyLDI0LDg1LDYsMiwwLDIsMywyLDE0LDIsOSw4LDQ2LDM5LDcsMywxLDMsMjEsMiw2LDIsMSwyLDQsNCwwLDE5LDAsMTMsNCwxNTksNTIsMTksMyw1NCw0NywyMSwxLDIsMCwxODUsNDYsNDIsMywzNyw0NywyMSwwLDYwLDQyLDg2LDI1LDM5MSw2MywzMiwwLDQ0OSw1NiwyNjQsOCwyLDM2LDE4LDAsNTAsMjksODgxLDkyMSwxMDMsMTEwLDE4LDE5NSwyNzQ5LDEwNzAsNDA1MCw1ODIsODYzNCw1NjgsOCwzMCwxMTQsMjksMTksNDcsMTcsMywzMiwyMCw2LDE4LDg4MSw2OCwxMiwwLDY3LDEyLDY1LDAsMzIsNjEyNCwyMCw3NTQsOTQ4NiwxLDMwNzEsMTA2LDYsMTIsNCw4LDgsOSw1OTkxLDg0LDIsNzAsMiwxLDMsMCwzLDEsMywzLDIsMTEsMiwwLDIsNiwyLDY0LDIsMywzLDcsMiw2LDIsMjcsMiwzLDIsNCwyLDAsNCw2LDIsMzM5LDMsMjQsMiwyNCwyLDMwLDIsMjQsMiwzMCwyLDI0LDIsMzAsMiwyNCwyLDMwLDIsMjQsMiw3LDQxNDksMTk2LDYwLDY3LDEyMTMsMywyLDI2LDIsMSwyLDAsMywwLDIsOSwyLDMsMiwwLDIsMCw3LDAsNSwwLDIsMCwyLDAsMiwyLDIsMSwyLDAsMywwLDIsMCwyLDAsMiwwLDIsMCwyLDEsMiwwLDMsMywyLDYsMiwzLDIsMywyLDAsMiw5LDIsMTYsNiwyLDIsNCwyLDE2LDQ0MjEsNDI3MTAsNDIsNDE0OCwxMiwyMjEsMyw1NzYxLDEwNTkxLDU0MV07XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21tYS1zcGFjaW5nXG52YXIgYXN0cmFsSWRlbnRpZmllckNvZGVzID0gWzUwOSwwLDIyNywwLDE1MCw0LDI5NCw5LDEzNjgsMiwyLDEsNiwzLDQxLDIsNSwwLDE2NiwxLDEzMDYsMiw1NCwxNCwzMiw5LDE2LDMsNDYsMTAsNTQsOSw3LDIsMzcsMTMsMiw5LDUyLDAsMTMsMiw0OSwxMywxMCwyLDQsOSw4MywxMSw3LDAsMTYxLDExLDYsOSw3LDMsNTcsMCwyLDYsMywxLDMsMiwxMCwwLDExLDEsMyw2LDQsNCwxOTMsMTcsMTAsOSw4NywxOSwxMyw5LDIxNCw2LDMsOCwyOCwxLDgzLDE2LDE2LDksODIsMTIsOSw5LDg0LDE0LDUsOSw0MjMsOSw4MzgsNywyLDcsMTcsOSw1NywyMSwyLDEzLDE5ODgyLDksMTM1LDQsNjAsNiwyNiw5LDEwMTYsNDUsMTcsMywxOTcyMywxLDUzMTksNCw0LDUsOSw3LDMsNiwzMSwzLDE0OSwyLDE0MTgsNDksNTEzLDU0LDUsNDksOSwwLDE1LDAsMjMsNCwyLDE0LDEzNjEsNiwyLDE2LDMsNiwyLDEsMiw0LDIyMTQsNiwxMTAsNiw2LDksNzkyNDg3LDIzOV07XG5cbi8vIFRoaXMgaGFzIGEgY29tcGxleGl0eSBsaW5lYXIgdG8gdGhlIHZhbHVlIG9mIHRoZSBjb2RlLiBUaGVcbi8vIGFzc3VtcHRpb24gaXMgdGhhdCBsb29raW5nIHVwIGFzdHJhbCBpZGVudGlmaWVyIGNoYXJhY3RlcnMgaXNcbi8vIHJhcmUuXG5mdW5jdGlvbiBpc0luQXN0cmFsU2V0KGNvZGUsIHNldCkge1xuICB2YXIgcG9zID0gMHgxMDAwMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICBwb3MgKz0gc2V0W2ldO1xuICAgIGlmIChwb3MgPiBjb2RlKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcG9zICs9IHNldFtpICsgMV07XG4gICAgaWYgKHBvcyA+PSBjb2RlKSB7IHJldHVybiB0cnVlIH1cbiAgfVxufVxuXG4vLyBUZXN0IHdoZXRoZXIgYSBnaXZlbiBjaGFyYWN0ZXIgY29kZSBzdGFydHMgYW4gaWRlbnRpZmllci5cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyU3RhcnQoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXJTdGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkpIH1cbiAgaWYgKGFzdHJhbCA9PT0gZmFsc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIGlzSW5Bc3RyYWxTZXQoY29kZSwgYXN0cmFsSWRlbnRpZmllclN0YXJ0Q29kZXMpXG59XG5cbi8vIFRlc3Qgd2hldGhlciBhIGdpdmVuIGNoYXJhY3RlciBpcyBwYXJ0IG9mIGFuIGlkZW50aWZpZXIuXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllckNoYXIoY29kZSwgYXN0cmFsKSB7XG4gIGlmIChjb2RlIDwgNDgpIHsgcmV0dXJuIGNvZGUgPT09IDM2IH1cbiAgaWYgKGNvZGUgPCA1OCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgNjUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKGNvZGUgPCA5MSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChjb2RlIDwgOTcpIHsgcmV0dXJuIGNvZGUgPT09IDk1IH1cbiAgaWYgKGNvZGUgPCAxMjMpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAoY29kZSA8PSAweGZmZmYpIHsgcmV0dXJuIGNvZGUgPj0gMHhhYSAmJiBub25BU0NJSWlkZW50aWZpZXIudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpKSB9XG4gIGlmIChhc3RyYWwgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJTdGFydENvZGVzKSB8fCBpc0luQXN0cmFsU2V0KGNvZGUsIGFzdHJhbElkZW50aWZpZXJDb2Rlcylcbn1cblxuLy8gIyMgVG9rZW4gdHlwZXNcblxuLy8gVGhlIGFzc2lnbm1lbnQgb2YgZmluZS1ncmFpbmVkLCBpbmZvcm1hdGlvbi1jYXJyeWluZyB0eXBlIG9iamVjdHNcbi8vIGFsbG93cyB0aGUgdG9rZW5pemVyIHRvIHN0b3JlIHRoZSBpbmZvcm1hdGlvbiBpdCBoYXMgYWJvdXQgYVxuLy8gdG9rZW4gaW4gYSB3YXkgdGhhdCBpcyB2ZXJ5IGNoZWFwIGZvciB0aGUgcGFyc2VyIHRvIGxvb2sgdXAuXG5cbi8vIEFsbCB0b2tlbiB0eXBlIHZhcmlhYmxlcyBzdGFydCB3aXRoIGFuIHVuZGVyc2NvcmUsIHRvIG1ha2UgdGhlbVxuLy8gZWFzeSB0byByZWNvZ25pemUuXG5cbi8vIFRoZSBgYmVmb3JlRXhwcmAgcHJvcGVydHkgaXMgdXNlZCB0byBkaXNhbWJpZ3VhdGUgYmV0d2VlbiByZWd1bGFyXG4vLyBleHByZXNzaW9ucyBhbmQgZGl2aXNpb25zLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgY2FuXG4vLyBiZSBmb2xsb3dlZCBieSBhbiBleHByZXNzaW9uICh0aHVzLCBhIHNsYXNoIGFmdGVyIHRoZW0gd291bGQgYmUgYVxuLy8gcmVndWxhciBleHByZXNzaW9uKS5cbi8vXG4vLyBUaGUgYHN0YXJ0c0V4cHJgIHByb3BlcnR5IGlzIHVzZWQgdG8gY2hlY2sgaWYgdGhlIHRva2VuIGVuZHMgYVxuLy8gYHlpZWxkYCBleHByZXNzaW9uLiBJdCBpcyBzZXQgb24gYWxsIHRva2VuIHR5cGVzIHRoYXQgZWl0aGVyIGNhblxuLy8gZGlyZWN0bHkgc3RhcnQgYW4gZXhwcmVzc2lvbiAobGlrZSBhIHF1b3RhdGlvbiBtYXJrKSBvciBjYW5cbi8vIGNvbnRpbnVlIGFuIGV4cHJlc3Npb24gKGxpa2UgdGhlIGJvZHkgb2YgYSBzdHJpbmcpLlxuLy9cbi8vIGBpc0xvb3BgIG1hcmtzIGEga2V5d29yZCBhcyBzdGFydGluZyBhIGxvb3AsIHdoaWNoIGlzIGltcG9ydGFudFxuLy8gdG8ga25vdyB3aGVuIHBhcnNpbmcgYSBsYWJlbCwgaW4gb3JkZXIgdG8gYWxsb3cgb3IgZGlzYWxsb3dcbi8vIGNvbnRpbnVlIGp1bXBzIHRvIHRoYXQgbGFiZWwuXG5cbnZhciBUb2tlblR5cGUgPSBmdW5jdGlvbiBUb2tlblR5cGUobGFiZWwsIGNvbmYpIHtcbiAgaWYgKCBjb25mID09PSB2b2lkIDAgKSBjb25mID0ge307XG5cbiAgdGhpcy5sYWJlbCA9IGxhYmVsO1xuICB0aGlzLmtleXdvcmQgPSBjb25mLmtleXdvcmQ7XG4gIHRoaXMuYmVmb3JlRXhwciA9ICEhY29uZi5iZWZvcmVFeHByO1xuICB0aGlzLnN0YXJ0c0V4cHIgPSAhIWNvbmYuc3RhcnRzRXhwcjtcbiAgdGhpcy5pc0xvb3AgPSAhIWNvbmYuaXNMb29wO1xuICB0aGlzLmlzQXNzaWduID0gISFjb25mLmlzQXNzaWduO1xuICB0aGlzLnByZWZpeCA9ICEhY29uZi5wcmVmaXg7XG4gIHRoaXMucG9zdGZpeCA9ICEhY29uZi5wb3N0Zml4O1xuICB0aGlzLmJpbm9wID0gY29uZi5iaW5vcCB8fCBudWxsO1xuICB0aGlzLnVwZGF0ZUNvbnRleHQgPSBudWxsO1xufTtcblxuZnVuY3Rpb24gYmlub3AobmFtZSwgcHJlYykge1xuICByZXR1cm4gbmV3IFRva2VuVHlwZShuYW1lLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IHByZWN9KVxufVxudmFyIGJlZm9yZUV4cHIgPSB7YmVmb3JlRXhwcjogdHJ1ZX07XG52YXIgc3RhcnRzRXhwciA9IHtzdGFydHNFeHByOiB0cnVlfTtcblxuLy8gTWFwIGtleXdvcmQgbmFtZXMgdG8gdG9rZW4gdHlwZXMuXG5cbnZhciBrZXl3b3JkcyQxID0ge307XG5cbi8vIFN1Y2NpbmN0IGRlZmluaXRpb25zIG9mIGtleXdvcmQgdG9rZW4gdHlwZXNcbmZ1bmN0aW9uIGt3KG5hbWUsIG9wdGlvbnMpIHtcbiAgaWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cbiAgb3B0aW9ucy5rZXl3b3JkID0gbmFtZTtcbiAgcmV0dXJuIGtleXdvcmRzJDFbbmFtZV0gPSBuZXcgVG9rZW5UeXBlKG5hbWUsIG9wdGlvbnMpXG59XG5cbnZhciB0eXBlcyA9IHtcbiAgbnVtOiBuZXcgVG9rZW5UeXBlKFwibnVtXCIsIHN0YXJ0c0V4cHIpLFxuICByZWdleHA6IG5ldyBUb2tlblR5cGUoXCJyZWdleHBcIiwgc3RhcnRzRXhwciksXG4gIHN0cmluZzogbmV3IFRva2VuVHlwZShcInN0cmluZ1wiLCBzdGFydHNFeHByKSxcbiAgbmFtZTogbmV3IFRva2VuVHlwZShcIm5hbWVcIiwgc3RhcnRzRXhwciksXG4gIGVvZjogbmV3IFRva2VuVHlwZShcImVvZlwiKSxcblxuICAvLyBQdW5jdHVhdGlvbiB0b2tlbiB0eXBlcy5cbiAgYnJhY2tldEw6IG5ldyBUb2tlblR5cGUoXCJbXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIGJyYWNrZXRSOiBuZXcgVG9rZW5UeXBlKFwiXVwiKSxcbiAgYnJhY2VMOiBuZXcgVG9rZW5UeXBlKFwie1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBicmFjZVI6IG5ldyBUb2tlblR5cGUoXCJ9XCIpLFxuICBwYXJlbkw6IG5ldyBUb2tlblR5cGUoXCIoXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBzdGFydHNFeHByOiB0cnVlfSksXG4gIHBhcmVuUjogbmV3IFRva2VuVHlwZShcIilcIiksXG4gIGNvbW1hOiBuZXcgVG9rZW5UeXBlKFwiLFwiLCBiZWZvcmVFeHByKSxcbiAgc2VtaTogbmV3IFRva2VuVHlwZShcIjtcIiwgYmVmb3JlRXhwciksXG4gIGNvbG9uOiBuZXcgVG9rZW5UeXBlKFwiOlwiLCBiZWZvcmVFeHByKSxcbiAgZG90OiBuZXcgVG9rZW5UeXBlKFwiLlwiKSxcbiAgcXVlc3Rpb246IG5ldyBUb2tlblR5cGUoXCI/XCIsIGJlZm9yZUV4cHIpLFxuICBhcnJvdzogbmV3IFRva2VuVHlwZShcIj0+XCIsIGJlZm9yZUV4cHIpLFxuICB0ZW1wbGF0ZTogbmV3IFRva2VuVHlwZShcInRlbXBsYXRlXCIpLFxuICBpbnZhbGlkVGVtcGxhdGU6IG5ldyBUb2tlblR5cGUoXCJpbnZhbGlkVGVtcGxhdGVcIiksXG4gIGVsbGlwc2lzOiBuZXcgVG9rZW5UeXBlKFwiLi4uXCIsIGJlZm9yZUV4cHIpLFxuICBiYWNrUXVvdGU6IG5ldyBUb2tlblR5cGUoXCJgXCIsIHN0YXJ0c0V4cHIpLFxuICBkb2xsYXJCcmFjZUw6IG5ldyBUb2tlblR5cGUoXCIke1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIE9wZXJhdG9ycy4gVGhlc2UgY2Fycnkgc2V2ZXJhbCBraW5kcyBvZiBwcm9wZXJ0aWVzIHRvIGhlbHAgdGhlXG4gIC8vIHBhcnNlciB1c2UgdGhlbSBwcm9wZXJseSAodGhlIHByZXNlbmNlIG9mIHRoZXNlIHByb3BlcnRpZXMgaXNcbiAgLy8gd2hhdCBjYXRlZ29yaXplcyB0aGVtIGFzIG9wZXJhdG9ycykuXG4gIC8vXG4gIC8vIGBiaW5vcGAsIHdoZW4gcHJlc2VudCwgc3BlY2lmaWVzIHRoYXQgdGhpcyBvcGVyYXRvciBpcyBhIGJpbmFyeVxuICAvLyBvcGVyYXRvciwgYW5kIHdpbGwgcmVmZXIgdG8gaXRzIHByZWNlZGVuY2UuXG4gIC8vXG4gIC8vIGBwcmVmaXhgIGFuZCBgcG9zdGZpeGAgbWFyayB0aGUgb3BlcmF0b3IgYXMgYSBwcmVmaXggb3IgcG9zdGZpeFxuICAvLyB1bmFyeSBvcGVyYXRvci5cbiAgLy9cbiAgLy8gYGlzQXNzaWduYCBtYXJrcyBhbGwgb2YgYD1gLCBgKz1gLCBgLT1gIGV0Y2V0ZXJhLCB3aGljaCBhY3QgYXNcbiAgLy8gYmluYXJ5IG9wZXJhdG9ycyB3aXRoIGEgdmVyeSBsb3cgcHJlY2VkZW5jZSwgdGhhdCBzaG91bGQgcmVzdWx0XG4gIC8vIGluIEFzc2lnbm1lbnRFeHByZXNzaW9uIG5vZGVzLlxuXG4gIGVxOiBuZXcgVG9rZW5UeXBlKFwiPVwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgaXNBc3NpZ246IHRydWV9KSxcbiAgYXNzaWduOiBuZXcgVG9rZW5UeXBlKFwiXz1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGlzQXNzaWduOiB0cnVlfSksXG4gIGluY0RlYzogbmV3IFRva2VuVHlwZShcIisrLy0tXCIsIHtwcmVmaXg6IHRydWUsIHBvc3RmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgcHJlZml4OiBuZXcgVG9rZW5UeXBlKFwiIS9+XCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbG9naWNhbE9SOiBiaW5vcChcInx8XCIsIDEpLFxuICBsb2dpY2FsQU5EOiBiaW5vcChcIiYmXCIsIDIpLFxuICBiaXR3aXNlT1I6IGJpbm9wKFwifFwiLCAzKSxcbiAgYml0d2lzZVhPUjogYmlub3AoXCJeXCIsIDQpLFxuICBiaXR3aXNlQU5EOiBiaW5vcChcIiZcIiwgNSksXG4gIGVxdWFsaXR5OiBiaW5vcChcIj09LyE9Lz09PS8hPT1cIiwgNiksXG4gIHJlbGF0aW9uYWw6IGJpbm9wKFwiPC8+Lzw9Lz49XCIsIDcpLFxuICBiaXRTaGlmdDogYmlub3AoXCI8PC8+Pi8+Pj5cIiwgOCksXG4gIHBsdXNNaW46IG5ldyBUb2tlblR5cGUoXCIrLy1cIiwge2JlZm9yZUV4cHI6IHRydWUsIGJpbm9wOiA5LCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgbW9kdWxvOiBiaW5vcChcIiVcIiwgMTApLFxuICBzdGFyOiBiaW5vcChcIipcIiwgMTApLFxuICBzbGFzaDogYmlub3AoXCIvXCIsIDEwKSxcbiAgc3RhcnN0YXI6IG5ldyBUb2tlblR5cGUoXCIqKlwiLCB7YmVmb3JlRXhwcjogdHJ1ZX0pLFxuXG4gIC8vIEtleXdvcmQgdG9rZW4gdHlwZXMuXG4gIF9icmVhazoga3coXCJicmVha1wiKSxcbiAgX2Nhc2U6IGt3KFwiY2FzZVwiLCBiZWZvcmVFeHByKSxcbiAgX2NhdGNoOiBrdyhcImNhdGNoXCIpLFxuICBfY29udGludWU6IGt3KFwiY29udGludWVcIiksXG4gIF9kZWJ1Z2dlcjoga3coXCJkZWJ1Z2dlclwiKSxcbiAgX2RlZmF1bHQ6IGt3KFwiZGVmYXVsdFwiLCBiZWZvcmVFeHByKSxcbiAgX2RvOiBrdyhcImRvXCIsIHtpc0xvb3A6IHRydWUsIGJlZm9yZUV4cHI6IHRydWV9KSxcbiAgX2Vsc2U6IGt3KFwiZWxzZVwiLCBiZWZvcmVFeHByKSxcbiAgX2ZpbmFsbHk6IGt3KFwiZmluYWxseVwiKSxcbiAgX2Zvcjoga3coXCJmb3JcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICBfZnVuY3Rpb246IGt3KFwiZnVuY3Rpb25cIiwgc3RhcnRzRXhwciksXG4gIF9pZjoga3coXCJpZlwiKSxcbiAgX3JldHVybjoga3coXCJyZXR1cm5cIiwgYmVmb3JlRXhwciksXG4gIF9zd2l0Y2g6IGt3KFwic3dpdGNoXCIpLFxuICBfdGhyb3c6IGt3KFwidGhyb3dcIiwgYmVmb3JlRXhwciksXG4gIF90cnk6IGt3KFwidHJ5XCIpLFxuICBfdmFyOiBrdyhcInZhclwiKSxcbiAgX2NvbnN0OiBrdyhcImNvbnN0XCIpLFxuICBfd2hpbGU6IGt3KFwid2hpbGVcIiwge2lzTG9vcDogdHJ1ZX0pLFxuICBfd2l0aDoga3coXCJ3aXRoXCIpLFxuICBfbmV3OiBrdyhcIm5ld1wiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfdGhpczoga3coXCJ0aGlzXCIsIHN0YXJ0c0V4cHIpLFxuICBfc3VwZXI6IGt3KFwic3VwZXJcIiwgc3RhcnRzRXhwciksXG4gIF9jbGFzczoga3coXCJjbGFzc1wiLCBzdGFydHNFeHByKSxcbiAgX2V4dGVuZHM6IGt3KFwiZXh0ZW5kc1wiLCBiZWZvcmVFeHByKSxcbiAgX2V4cG9ydDoga3coXCJleHBvcnRcIiksXG4gIF9pbXBvcnQ6IGt3KFwiaW1wb3J0XCIpLFxuICBfbnVsbDoga3coXCJudWxsXCIsIHN0YXJ0c0V4cHIpLFxuICBfdHJ1ZToga3coXCJ0cnVlXCIsIHN0YXJ0c0V4cHIpLFxuICBfZmFsc2U6IGt3KFwiZmFsc2VcIiwgc3RhcnRzRXhwciksXG4gIF9pbjoga3coXCJpblwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgX2luc3RhbmNlb2Y6IGt3KFwiaW5zdGFuY2VvZlwiLCB7YmVmb3JlRXhwcjogdHJ1ZSwgYmlub3A6IDd9KSxcbiAgX3R5cGVvZjoga3coXCJ0eXBlb2ZcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pLFxuICBfdm9pZDoga3coXCJ2b2lkXCIsIHtiZWZvcmVFeHByOiB0cnVlLCBwcmVmaXg6IHRydWUsIHN0YXJ0c0V4cHI6IHRydWV9KSxcbiAgX2RlbGV0ZToga3coXCJkZWxldGVcIiwge2JlZm9yZUV4cHI6IHRydWUsIHByZWZpeDogdHJ1ZSwgc3RhcnRzRXhwcjogdHJ1ZX0pXG59O1xuXG4vLyBNYXRjaGVzIGEgd2hvbGUgbGluZSBicmVhayAod2hlcmUgQ1JMRiBpcyBjb25zaWRlcmVkIGEgc2luZ2xlXG4vLyBsaW5lIGJyZWFrKS4gVXNlZCB0byBjb3VudCBsaW5lcy5cblxudmFyIGxpbmVCcmVhayA9IC9cXHJcXG4/fFxcbnxcXHUyMDI4fFxcdTIwMjkvO1xudmFyIGxpbmVCcmVha0cgPSBuZXcgUmVnRXhwKGxpbmVCcmVhay5zb3VyY2UsIFwiZ1wiKTtcblxuZnVuY3Rpb24gaXNOZXdMaW5lKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPT09IDEwIHx8IGNvZGUgPT09IDEzIHx8IGNvZGUgPT09IDB4MjAyOCB8fCBjb2RlID09PSAweDIwMjlcbn1cblxudmFyIG5vbkFTQ0lJd2hpdGVzcGFjZSA9IC9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS87XG5cbnZhciBza2lwV2hpdGVTcGFjZSA9IC8oPzpcXHN8XFwvXFwvLip8XFwvXFwqW15dKj9cXCpcXC8pKi9nO1xuXG52YXIgcmVmID0gT2JqZWN0LnByb3RvdHlwZTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHJlZi5oYXNPd25Qcm9wZXJ0eTtcbnZhciB0b1N0cmluZyA9IHJlZi50b1N0cmluZztcblxuLy8gQ2hlY2tzIGlmIGFuIG9iamVjdCBoYXMgYSBwcm9wZXJ0eS5cblxuZnVuY3Rpb24gaGFzKG9iaiwgcHJvcE5hbWUpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wTmFtZSlcbn1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IChmdW5jdGlvbiAob2JqKSB7IHJldHVybiAoXG4gIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiXG4pOyB9KTtcblxuLy8gVGhlc2UgYXJlIHVzZWQgd2hlbiBgb3B0aW9ucy5sb2NhdGlvbnNgIGlzIG9uLCBmb3IgdGhlXG4vLyBgc3RhcnRMb2NgIGFuZCBgZW5kTG9jYCBwcm9wZXJ0aWVzLlxuXG52YXIgUG9zaXRpb24gPSBmdW5jdGlvbiBQb3NpdGlvbihsaW5lLCBjb2wpIHtcbiAgdGhpcy5saW5lID0gbGluZTtcbiAgdGhpcy5jb2x1bW4gPSBjb2w7XG59O1xuXG5Qb3NpdGlvbi5wcm90b3R5cGUub2Zmc2V0ID0gZnVuY3Rpb24gb2Zmc2V0IChuKSB7XG4gIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lLCB0aGlzLmNvbHVtbiArIG4pXG59O1xuXG52YXIgU291cmNlTG9jYXRpb24gPSBmdW5jdGlvbiBTb3VyY2VMb2NhdGlvbihwLCBzdGFydCwgZW5kKSB7XG4gIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgdGhpcy5lbmQgPSBlbmQ7XG4gIGlmIChwLnNvdXJjZUZpbGUgIT09IG51bGwpIHsgdGhpcy5zb3VyY2UgPSBwLnNvdXJjZUZpbGU7IH1cbn07XG5cbi8vIFRoZSBgZ2V0TGluZUluZm9gIGZ1bmN0aW9uIGlzIG1vc3RseSB1c2VmdWwgd2hlbiB0aGVcbi8vIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvZmYgKGZvciBwZXJmb3JtYW5jZSByZWFzb25zKSBhbmQgeW91XG4vLyB3YW50IHRvIGZpbmQgdGhlIGxpbmUvY29sdW1uIHBvc2l0aW9uIGZvciBhIGdpdmVuIGNoYXJhY3RlclxuLy8gb2Zmc2V0LiBgaW5wdXRgIHNob3VsZCBiZSB0aGUgY29kZSBzdHJpbmcgdGhhdCB0aGUgb2Zmc2V0IHJlZmVyc1xuLy8gaW50by5cblxuZnVuY3Rpb24gZ2V0TGluZUluZm8oaW5wdXQsIG9mZnNldCkge1xuICBmb3IgKHZhciBsaW5lID0gMSwgY3VyID0gMDs7KSB7XG4gICAgbGluZUJyZWFrRy5sYXN0SW5kZXggPSBjdXI7XG4gICAgdmFyIG1hdGNoID0gbGluZUJyZWFrRy5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggJiYgbWF0Y2guaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICsrbGluZTtcbiAgICAgIGN1ciA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKGxpbmUsIG9mZnNldCAtIGN1cilcbiAgICB9XG4gIH1cbn1cblxuLy8gQSBzZWNvbmQgb3B0aW9uYWwgYXJndW1lbnQgY2FuIGJlIGdpdmVuIHRvIGZ1cnRoZXIgY29uZmlndXJlXG4vLyB0aGUgcGFyc2VyIHByb2Nlc3MuIFRoZXNlIG9wdGlvbnMgYXJlIHJlY29nbml6ZWQ6XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgLy8gYGVjbWFWZXJzaW9uYCBpbmRpY2F0ZXMgdGhlIEVDTUFTY3JpcHQgdmVyc2lvbiB0byBwYXJzZS4gTXVzdFxuICAvLyBiZSBlaXRoZXIgMywgNSwgNiAoMjAxNSksIDcgKDIwMTYpLCBvciA4ICgyMDE3KS4gVGhpcyBpbmZsdWVuY2VzIHN1cHBvcnRcbiAgLy8gZm9yIHN0cmljdCBtb2RlLCB0aGUgc2V0IG9mIHJlc2VydmVkIHdvcmRzLCBhbmQgc3VwcG9ydCBmb3JcbiAgLy8gbmV3IHN5bnRheCBmZWF0dXJlcy4gVGhlIGRlZmF1bHQgaXMgNy5cbiAgZWNtYVZlcnNpb246IDcsXG4gIC8vIGBzb3VyY2VUeXBlYCBpbmRpY2F0ZXMgdGhlIG1vZGUgdGhlIGNvZGUgc2hvdWxkIGJlIHBhcnNlZCBpbi5cbiAgLy8gQ2FuIGJlIGVpdGhlciBgXCJzY3JpcHRcImAgb3IgYFwibW9kdWxlXCJgLiBUaGlzIGluZmx1ZW5jZXMgZ2xvYmFsXG4gIC8vIHN0cmljdCBtb2RlIGFuZCBwYXJzaW5nIG9mIGBpbXBvcnRgIGFuZCBgZXhwb3J0YCBkZWNsYXJhdGlvbnMuXG4gIHNvdXJjZVR5cGU6IFwic2NyaXB0XCIsXG4gIC8vIGBvbkluc2VydGVkU2VtaWNvbG9uYCBjYW4gYmUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkXG4gIC8vIHdoZW4gYSBzZW1pY29sb24gaXMgYXV0b21hdGljYWxseSBpbnNlcnRlZC4gSXQgd2lsbCBiZSBwYXNzZWRcbiAgLy8gdGggcG9zaXRpb24gb2YgdGhlIGNvbW1hIGFzIGFuIG9mZnNldCwgYW5kIGlmIGBsb2NhdGlvbnNgIGlzXG4gIC8vIGVuYWJsZWQsIGl0IGlzIGdpdmVuIHRoZSBsb2NhdGlvbiBhcyBhIGB7bGluZSwgY29sdW1ufWAgb2JqZWN0XG4gIC8vIGFzIHNlY29uZCBhcmd1bWVudC5cbiAgb25JbnNlcnRlZFNlbWljb2xvbjogbnVsbCxcbiAgLy8gYG9uVHJhaWxpbmdDb21tYWAgaXMgc2ltaWxhciB0byBgb25JbnNlcnRlZFNlbWljb2xvbmAsIGJ1dCBmb3JcbiAgLy8gdHJhaWxpbmcgY29tbWFzLlxuICBvblRyYWlsaW5nQ29tbWE6IG51bGwsXG4gIC8vIEJ5IGRlZmF1bHQsIHJlc2VydmVkIHdvcmRzIGFyZSBvbmx5IGVuZm9yY2VkIGlmIGVjbWFWZXJzaW9uID49IDUuXG4gIC8vIFNldCBgYWxsb3dSZXNlcnZlZGAgdG8gYSBib29sZWFuIHZhbHVlIHRvIGV4cGxpY2l0bHkgdHVybiB0aGlzIG9uXG4gIC8vIGFuIG9mZi4gV2hlbiB0aGlzIG9wdGlvbiBoYXMgdGhlIHZhbHVlIFwibmV2ZXJcIiwgcmVzZXJ2ZWQgd29yZHNcbiAgLy8gYW5kIGtleXdvcmRzIGNhbiBhbHNvIG5vdCBiZSB1c2VkIGFzIHByb3BlcnR5IG5hbWVzLlxuICBhbGxvd1Jlc2VydmVkOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIGEgcmV0dXJuIGF0IHRoZSB0b3AgbGV2ZWwgaXMgbm90IGNvbnNpZGVyZWQgYW5cbiAgLy8gZXJyb3IuXG4gIGFsbG93UmV0dXJuT3V0c2lkZUZ1bmN0aW9uOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBpbXBvcnQvZXhwb3J0IHN0YXRlbWVudHMgYXJlIG5vdCBjb25zdHJhaW5lZCB0b1xuICAvLyBhcHBlYXJpbmcgYXQgdGhlIHRvcCBvZiB0aGUgcHJvZ3JhbS5cbiAgYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlOiBmYWxzZSxcbiAgLy8gV2hlbiBlbmFibGVkLCBoYXNoYmFuZyBkaXJlY3RpdmUgaW4gdGhlIGJlZ2lubmluZyBvZiBmaWxlXG4gIC8vIGlzIGFsbG93ZWQgYW5kIHRyZWF0ZWQgYXMgYSBsaW5lIGNvbW1lbnQuXG4gIGFsbG93SGFzaEJhbmc6IGZhbHNlLFxuICAvLyBXaGVuIGBsb2NhdGlvbnNgIGlzIG9uLCBgbG9jYCBwcm9wZXJ0aWVzIGhvbGRpbmcgb2JqZWN0cyB3aXRoXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgaW4gYHtsaW5lLCBjb2x1bW59YCBmb3JtICh3aXRoXG4gIC8vIGxpbmUgYmVpbmcgMS1iYXNlZCBhbmQgY29sdW1uIDAtYmFzZWQpIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlXG4gIC8vIG5vZGVzLlxuICBsb2NhdGlvbnM6IGZhbHNlLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uVG9rZW5gIG9wdGlvbiwgd2hpY2ggd2lsbFxuICAvLyBjYXVzZSBBY29ybiB0byBjYWxsIHRoYXQgZnVuY3Rpb24gd2l0aCBvYmplY3QgaW4gdGhlIHNhbWVcbiAgLy8gZm9ybWF0IGFzIHRva2VucyByZXR1cm5lZCBmcm9tIGB0b2tlbml6ZXIoKS5nZXRUb2tlbigpYC4gTm90ZVxuICAvLyB0aGF0IHlvdSBhcmUgbm90IGFsbG93ZWQgdG8gY2FsbCB0aGUgcGFyc2VyIGZyb20gdGhlXG4gIC8vIGNhbGxiYWNr4oCUdGhhdCB3aWxsIGNvcnJ1cHQgaXRzIGludGVybmFsIHN0YXRlLlxuICBvblRva2VuOiBudWxsLFxuICAvLyBBIGZ1bmN0aW9uIGNhbiBiZSBwYXNzZWQgYXMgYG9uQ29tbWVudGAgb3B0aW9uLCB3aGljaCB3aWxsXG4gIC8vIGNhdXNlIEFjb3JuIHRvIGNhbGwgdGhhdCBmdW5jdGlvbiB3aXRoIGAoYmxvY2ssIHRleHQsIHN0YXJ0LFxuICAvLyBlbmQpYCBwYXJhbWV0ZXJzIHdoZW5ldmVyIGEgY29tbWVudCBpcyBza2lwcGVkLiBgYmxvY2tgIGlzIGFcbiAgLy8gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBpcyBhIGJsb2NrIChgLyogKi9gKSBjb21tZW50LFxuICAvLyBgdGV4dGAgaXMgdGhlIGNvbnRlbnQgb2YgdGhlIGNvbW1lbnQsIGFuZCBgc3RhcnRgIGFuZCBgZW5kYCBhcmVcbiAgLy8gY2hhcmFjdGVyIG9mZnNldHMgdGhhdCBkZW5vdGUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgdGhlIGNvbW1lbnQuXG4gIC8vIFdoZW4gdGhlIGBsb2NhdGlvbnNgIG9wdGlvbiBpcyBvbiwgdHdvIG1vcmUgcGFyYW1ldGVycyBhcmVcbiAgLy8gcGFzc2VkLCB0aGUgZnVsbCBge2xpbmUsIGNvbHVtbn1gIGxvY2F0aW9ucyBvZiB0aGUgc3RhcnQgYW5kXG4gIC8vIGVuZCBvZiB0aGUgY29tbWVudHMuIE5vdGUgdGhhdCB5b3UgYXJlIG5vdCBhbGxvd2VkIHRvIGNhbGwgdGhlXG4gIC8vIHBhcnNlciBmcm9tIHRoZSBjYWxsYmFja+KAlHRoYXQgd2lsbCBjb3JydXB0IGl0cyBpbnRlcm5hbCBzdGF0ZS5cbiAgb25Db21tZW50OiBudWxsLFxuICAvLyBOb2RlcyBoYXZlIHRoZWlyIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVycyBvZmZzZXRzIHJlY29yZGVkIGluXG4gIC8vIGBzdGFydGAgYW5kIGBlbmRgIHByb3BlcnRpZXMgKGRpcmVjdGx5IG9uIHRoZSBub2RlLCByYXRoZXIgdGhhblxuICAvLyB0aGUgYGxvY2Agb2JqZWN0LCB3aGljaCBob2xkcyBsaW5lL2NvbHVtbiBkYXRhLiBUbyBhbHNvIGFkZCBhXG4gIC8vIFtzZW1pLXN0YW5kYXJkaXplZF1bcmFuZ2VdIGByYW5nZWAgcHJvcGVydHkgaG9sZGluZyBhIGBbc3RhcnQsXG4gIC8vIGVuZF1gIGFycmF5IHdpdGggdGhlIHNhbWUgbnVtYmVycywgc2V0IHRoZSBgcmFuZ2VzYCBvcHRpb24gdG9cbiAgLy8gYHRydWVgLlxuICAvL1xuICAvLyBbcmFuZ2VdOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD03NDU2NzhcbiAgcmFuZ2VzOiBmYWxzZSxcbiAgLy8gSXQgaXMgcG9zc2libGUgdG8gcGFyc2UgbXVsdGlwbGUgZmlsZXMgaW50byBhIHNpbmdsZSBBU1QgYnlcbiAgLy8gcGFzc2luZyB0aGUgdHJlZSBwcm9kdWNlZCBieSBwYXJzaW5nIHRoZSBmaXJzdCBmaWxlIGFzXG4gIC8vIGBwcm9ncmFtYCBvcHRpb24gaW4gc3Vic2VxdWVudCBwYXJzZXMuIFRoaXMgd2lsbCBhZGQgdGhlXG4gIC8vIHRvcGxldmVsIGZvcm1zIG9mIHRoZSBwYXJzZWQgZmlsZSB0byB0aGUgYFByb2dyYW1gICh0b3ApIG5vZGVcbiAgLy8gb2YgYW4gZXhpc3RpbmcgcGFyc2UgdHJlZS5cbiAgcHJvZ3JhbTogbnVsbCxcbiAgLy8gV2hlbiBgbG9jYXRpb25zYCBpcyBvbiwgeW91IGNhbiBwYXNzIHRoaXMgdG8gcmVjb3JkIHRoZSBzb3VyY2VcbiAgLy8gZmlsZSBpbiBldmVyeSBub2RlJ3MgYGxvY2Agb2JqZWN0LlxuICBzb3VyY2VGaWxlOiBudWxsLFxuICAvLyBUaGlzIHZhbHVlLCBpZiBnaXZlbiwgaXMgc3RvcmVkIGluIGV2ZXJ5IG5vZGUsIHdoZXRoZXJcbiAgLy8gYGxvY2F0aW9uc2AgaXMgb24gb3Igb2ZmLlxuICBkaXJlY3RTb3VyY2VGaWxlOiBudWxsLFxuICAvLyBXaGVuIGVuYWJsZWQsIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbnMgYXJlIHJlcHJlc2VudGVkIGJ5XG4gIC8vIChub24tc3RhbmRhcmQpIFBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIG5vZGVzXG4gIHByZXNlcnZlUGFyZW5zOiBmYWxzZSxcbiAgcGx1Z2luczoge31cbn07XG5cbi8vIEludGVycHJldCBhbmQgZGVmYXVsdCBhbiBvcHRpb25zIG9iamVjdFxuXG5mdW5jdGlvbiBnZXRPcHRpb25zKG9wdHMpIHtcbiAgdmFyIG9wdGlvbnMgPSB7fTtcblxuICBmb3IgKHZhciBvcHQgaW4gZGVmYXVsdE9wdGlvbnMpXG4gICAgeyBvcHRpb25zW29wdF0gPSBvcHRzICYmIGhhcyhvcHRzLCBvcHQpID8gb3B0c1tvcHRdIDogZGVmYXVsdE9wdGlvbnNbb3B0XTsgfVxuXG4gIGlmIChvcHRpb25zLmVjbWFWZXJzaW9uID49IDIwMTUpXG4gICAgeyBvcHRpb25zLmVjbWFWZXJzaW9uIC09IDIwMDk7IH1cblxuICBpZiAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09IG51bGwpXG4gICAgeyBvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPSBvcHRpb25zLmVjbWFWZXJzaW9uIDwgNTsgfVxuXG4gIGlmIChpc0FycmF5KG9wdGlvbnMub25Ub2tlbikpIHtcbiAgICB2YXIgdG9rZW5zID0gb3B0aW9ucy5vblRva2VuO1xuICAgIG9wdGlvbnMub25Ub2tlbiA9IGZ1bmN0aW9uICh0b2tlbikgeyByZXR1cm4gdG9rZW5zLnB1c2godG9rZW4pOyB9O1xuICB9XG4gIGlmIChpc0FycmF5KG9wdGlvbnMub25Db21tZW50KSlcbiAgICB7IG9wdGlvbnMub25Db21tZW50ID0gcHVzaENvbW1lbnQob3B0aW9ucywgb3B0aW9ucy5vbkNvbW1lbnQpOyB9XG5cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcHVzaENvbW1lbnQob3B0aW9ucywgYXJyYXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGJsb2NrLCB0ZXh0LCBzdGFydCwgZW5kLCBzdGFydExvYywgZW5kTG9jKSB7XG4gICAgdmFyIGNvbW1lbnQgPSB7XG4gICAgICB0eXBlOiBibG9jayA/IFwiQmxvY2tcIiA6IFwiTGluZVwiLFxuICAgICAgdmFsdWU6IHRleHQsXG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb25zKVxuICAgICAgeyBjb21tZW50LmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbih0aGlzLCBzdGFydExvYywgZW5kTG9jKTsgfVxuICAgIGlmIChvcHRpb25zLnJhbmdlcylcbiAgICAgIHsgY29tbWVudC5yYW5nZSA9IFtzdGFydCwgZW5kXTsgfVxuICAgIGFycmF5LnB1c2goY29tbWVudCk7XG4gIH1cbn1cblxuLy8gUmVnaXN0ZXJlZCBwbHVnaW5zXG52YXIgcGx1Z2lucyA9IHt9O1xuXG5mdW5jdGlvbiBrZXl3b3JkUmVnZXhwKHdvcmRzKSB7XG4gIHJldHVybiBuZXcgUmVnRXhwKFwiXig/OlwiICsgd29yZHMucmVwbGFjZSgvIC9nLCBcInxcIikgKyBcIikkXCIpXG59XG5cbnZhciBQYXJzZXIkMSA9IGZ1bmN0aW9uIFBhcnNlcihvcHRpb25zLCBpbnB1dCwgc3RhcnRQb3MpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIHRoaXMuc291cmNlRmlsZSA9IG9wdGlvbnMuc291cmNlRmlsZTtcbiAgdGhpcy5rZXl3b3JkcyA9IGtleXdvcmRSZWdleHAoa2V5d29yZHNbb3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ID8gNiA6IDVdKTtcbiAgdmFyIHJlc2VydmVkID0gXCJcIjtcbiAgaWYgKCFvcHRpb25zLmFsbG93UmVzZXJ2ZWQpIHtcbiAgICBmb3IgKHZhciB2ID0gb3B0aW9ucy5lY21hVmVyc2lvbjs7IHYtLSlcbiAgICAgIHsgaWYgKHJlc2VydmVkID0gcmVzZXJ2ZWRXb3Jkc1t2XSkgeyBicmVhayB9IH1cbiAgICBpZiAob3B0aW9ucy5zb3VyY2VUeXBlID09IFwibW9kdWxlXCIpIHsgcmVzZXJ2ZWQgKz0gXCIgYXdhaXRcIjsgfVxuICB9XG4gIHRoaXMucmVzZXJ2ZWRXb3JkcyA9IGtleXdvcmRSZWdleHAocmVzZXJ2ZWQpO1xuICB2YXIgcmVzZXJ2ZWRTdHJpY3QgPSAocmVzZXJ2ZWQgPyByZXNlcnZlZCArIFwiIFwiIDogXCJcIikgKyByZXNlcnZlZFdvcmRzLnN0cmljdDtcbiAgdGhpcy5yZXNlcnZlZFdvcmRzU3RyaWN0ID0ga2V5d29yZFJlZ2V4cChyZXNlcnZlZFN0cmljdCk7XG4gIHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdEJpbmQgPSBrZXl3b3JkUmVnZXhwKHJlc2VydmVkU3RyaWN0ICsgXCIgXCIgKyByZXNlcnZlZFdvcmRzLnN0cmljdEJpbmQpO1xuICB0aGlzLmlucHV0ID0gU3RyaW5nKGlucHV0KTtcblxuICAvLyBVc2VkIHRvIHNpZ25hbCB0byBjYWxsZXJzIG9mIGByZWFkV29yZDFgIHdoZXRoZXIgdGhlIHdvcmRcbiAgLy8gY29udGFpbmVkIGFueSBlc2NhcGUgc2VxdWVuY2VzLiBUaGlzIGlzIG5lZWRlZCBiZWNhdXNlIHdvcmRzIHdpdGhcbiAgLy8gZXNjYXBlIHNlcXVlbmNlcyBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBrZXl3b3Jkcy5cbiAgdGhpcy5jb250YWluc0VzYyA9IGZhbHNlO1xuXG4gIC8vIExvYWQgcGx1Z2luc1xuICB0aGlzLmxvYWRQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG5cbiAgLy8gU2V0IHVwIHRva2VuIHN0YXRlXG5cbiAgLy8gVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHRva2VuaXplciBpbiB0aGUgaW5wdXQuXG4gIGlmIChzdGFydFBvcykge1xuICAgIHRoaXMucG9zID0gc3RhcnRQb3M7XG4gICAgdGhpcy5saW5lU3RhcnQgPSB0aGlzLmlucHV0Lmxhc3RJbmRleE9mKFwiXFxuXCIsIHN0YXJ0UG9zIC0gMSkgKyAxO1xuICAgIHRoaXMuY3VyTGluZSA9IHRoaXMuaW5wdXQuc2xpY2UoMCwgdGhpcy5saW5lU3RhcnQpLnNwbGl0KGxpbmVCcmVhaykubGVuZ3RoO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucG9zID0gdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMuY3VyTGluZSA9IDE7XG4gIH1cblxuICAvLyBQcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHRva2VuOlxuICAvLyBJdHMgdHlwZVxuICB0aGlzLnR5cGUgPSB0eXBlcy5lb2Y7XG4gIC8vIEZvciB0b2tlbnMgdGhhdCBpbmNsdWRlIG1vcmUgaW5mb3JtYXRpb24gdGhhbiB0aGVpciB0eXBlLCB0aGUgdmFsdWVcbiAgdGhpcy52YWx1ZSA9IG51bGw7XG4gIC8vIEl0cyBzdGFydCBhbmQgZW5kIG9mZnNldFxuICB0aGlzLnN0YXJ0ID0gdGhpcy5lbmQgPSB0aGlzLnBvcztcbiAgLy8gQW5kLCBpZiBsb2NhdGlvbnMgYXJlIHVzZWQsIHRoZSB7bGluZSwgY29sdW1ufSBvYmplY3RcbiAgLy8gY29ycmVzcG9uZGluZyB0byB0aG9zZSBvZmZzZXRzXG4gIHRoaXMuc3RhcnRMb2MgPSB0aGlzLmVuZExvYyA9IHRoaXMuY3VyUG9zaXRpb24oKTtcblxuICAvLyBQb3NpdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIHByZXZpb3VzIHRva2VuXG4gIHRoaXMubGFzdFRva0VuZExvYyA9IHRoaXMubGFzdFRva1N0YXJ0TG9jID0gbnVsbDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLnBvcztcblxuICAvLyBUaGUgY29udGV4dCBzdGFjayBpcyB1c2VkIHRvIHN1cGVyZmljaWFsbHkgdHJhY2sgc3ludGFjdGljXG4gIC8vIGNvbnRleHQgdG8gcHJlZGljdCB3aGV0aGVyIGEgcmVndWxhciBleHByZXNzaW9uIGlzIGFsbG93ZWQgaW4gYVxuICAvLyBnaXZlbiBwb3NpdGlvbi5cbiAgdGhpcy5jb250ZXh0ID0gdGhpcy5pbml0aWFsQ29udGV4dCgpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcblxuICAvLyBGaWd1cmUgb3V0IGlmIGl0J3MgYSBtb2R1bGUgY29kZS5cbiAgdGhpcy5pbk1vZHVsZSA9IG9wdGlvbnMuc291cmNlVHlwZSA9PT0gXCJtb2R1bGVcIjtcbiAgdGhpcy5zdHJpY3QgPSB0aGlzLmluTW9kdWxlIHx8IHRoaXMuc3RyaWN0RGlyZWN0aXZlKHRoaXMucG9zKTtcblxuICAvLyBVc2VkIHRvIHNpZ25pZnkgdGhlIHN0YXJ0IG9mIGEgcG90ZW50aWFsIGFycm93IGZ1bmN0aW9uXG4gIHRoaXMucG90ZW50aWFsQXJyb3dBdCA9IC0xO1xuXG4gIC8vIEZsYWdzIHRvIHRyYWNrIHdoZXRoZXIgd2UgYXJlIGluIGEgZnVuY3Rpb24sIGEgZ2VuZXJhdG9yLCBhbiBhc3luYyBmdW5jdGlvbi5cbiAgdGhpcy5pbkZ1bmN0aW9uID0gdGhpcy5pbkdlbmVyYXRvciA9IHRoaXMuaW5Bc3luYyA9IGZhbHNlO1xuICAvLyBQb3NpdGlvbnMgdG8gZGVsYXllZC1jaGVjayB0aGF0IHlpZWxkL2F3YWl0IGRvZXMgbm90IGV4aXN0IGluIGRlZmF1bHQgcGFyYW1ldGVycy5cbiAgdGhpcy55aWVsZFBvcyA9IHRoaXMuYXdhaXRQb3MgPSAwO1xuICAvLyBMYWJlbHMgaW4gc2NvcGUuXG4gIHRoaXMubGFiZWxzID0gW107XG5cbiAgLy8gSWYgZW5hYmxlZCwgc2tpcCBsZWFkaW5nIGhhc2hiYW5nIGxpbmUuXG4gIGlmICh0aGlzLnBvcyA9PT0gMCAmJiBvcHRpb25zLmFsbG93SGFzaEJhbmcgJiYgdGhpcy5pbnB1dC5zbGljZSgwLCAyKSA9PT0gXCIjIVwiKVxuICAgIHsgdGhpcy5za2lwTGluZUNvbW1lbnQoMik7IH1cblxuICAvLyBTY29wZSB0cmFja2luZyBmb3IgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzIChzZWUgc2NvcGUuanMpXG4gIHRoaXMuc2NvcGVTdGFjayA9IFtdO1xuICB0aGlzLmVudGVyRnVuY3Rpb25TY29wZSgpO1xufTtcblxuLy8gREVQUkVDQVRFRCBLZXB0IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB1bnRpbCAzLjAgaW4gY2FzZSBhIHBsdWdpbiB1c2VzIHRoZW1cblBhcnNlciQxLnByb3RvdHlwZS5pc0tleXdvcmQgPSBmdW5jdGlvbiBpc0tleXdvcmQgKHdvcmQpIHsgcmV0dXJuIHRoaXMua2V5d29yZHMudGVzdCh3b3JkKSB9O1xuUGFyc2VyJDEucHJvdG90eXBlLmlzUmVzZXJ2ZWRXb3JkID0gZnVuY3Rpb24gaXNSZXNlcnZlZFdvcmQgKHdvcmQpIHsgcmV0dXJuIHRoaXMucmVzZXJ2ZWRXb3Jkcy50ZXN0KHdvcmQpIH07XG5cblBhcnNlciQxLnByb3RvdHlwZS5leHRlbmQgPSBmdW5jdGlvbiBleHRlbmQgKG5hbWUsIGYpIHtcbiAgdGhpc1tuYW1lXSA9IGYodGhpc1tuYW1lXSk7XG59O1xuXG5QYXJzZXIkMS5wcm90b3R5cGUubG9hZFBsdWdpbnMgPSBmdW5jdGlvbiBsb2FkUGx1Z2lucyAocGx1Z2luQ29uZmlncykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luQ29uZmlncykge1xuICAgIHZhciBwbHVnaW4gPSBwbHVnaW5zW25hbWVdO1xuICAgIGlmICghcGx1Z2luKSB7IHRocm93IG5ldyBFcnJvcihcIlBsdWdpbiAnXCIgKyBuYW1lICsgXCInIG5vdCBmb3VuZFwiKSB9XG4gICAgcGx1Z2luKHRoaXMkMSwgcGx1Z2luQ29uZmlnc1tuYW1lXSk7XG4gIH1cbn07XG5cblBhcnNlciQxLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLm9wdGlvbnMucHJvZ3JhbSB8fCB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHRUb2tlbigpO1xuICByZXR1cm4gdGhpcy5wYXJzZVRvcExldmVsKG5vZGUpXG59O1xuXG52YXIgcHAgPSBQYXJzZXIkMS5wcm90b3R5cGU7XG5cbi8vICMjIFBhcnNlciB1dGlsaXRpZXNcblxudmFyIGxpdGVyYWwgPSAvXig/OicoKD86XFxcXC58W14nXSkqPyknfFwiKCg/OlxcXFwufFteXCJdKSo/KVwifDspLztcbnBwLnN0cmljdERpcmVjdGl2ZSA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAoOzspIHtcbiAgICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSBzdGFydDtcbiAgICBzdGFydCArPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMkMS5pbnB1dClbMF0ubGVuZ3RoO1xuICAgIHZhciBtYXRjaCA9IGxpdGVyYWwuZXhlYyh0aGlzJDEuaW5wdXQuc2xpY2Uoc3RhcnQpKTtcbiAgICBpZiAoIW1hdGNoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKChtYXRjaFsxXSB8fCBtYXRjaFsyXSkgPT0gXCJ1c2Ugc3RyaWN0XCIpIHsgcmV0dXJuIHRydWUgfVxuICAgIHN0YXJ0ICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxufTtcblxuLy8gUHJlZGljYXRlIHRoYXQgdGVzdHMgd2hldGhlciB0aGUgbmV4dCB0b2tlbiBpcyBvZiB0aGUgZ2l2ZW5cbi8vIHR5cGUsIGFuZCBpZiB5ZXMsIGNvbnN1bWVzIGl0IGFzIGEgc2lkZSBlZmZlY3QuXG5cbnBwLmVhdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZSkge1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5cbi8vIFRlc3RzIHdoZXRoZXIgcGFyc2VkIHRva2VuIGlzIGEgY29udGV4dHVhbCBrZXl3b3JkLlxuXG5wcC5pc0NvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUgJiYgdGhpcy52YWx1ZSA9PT0gbmFtZVxufTtcblxuLy8gQ29uc3VtZXMgY29udGV4dHVhbCBrZXl3b3JkIGlmIHBvc3NpYmxlLlxuXG5wcC5lYXRDb250ZXh0dWFsID0gZnVuY3Rpb24obmFtZSkge1xuICByZXR1cm4gdGhpcy52YWx1ZSA9PT0gbmFtZSAmJiB0aGlzLmVhdCh0eXBlcy5uYW1lKVxufTtcblxuLy8gQXNzZXJ0cyB0aGF0IGZvbGxvd2luZyB0b2tlbiBpcyBnaXZlbiBjb250ZXh0dWFsIGtleXdvcmQuXG5cbnBwLmV4cGVjdENvbnRleHR1YWwgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGlmICghdGhpcy5lYXRDb250ZXh0dWFsKG5hbWUpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG4vLyBUZXN0IHdoZXRoZXIgYSBzZW1pY29sb24gY2FuIGJlIGluc2VydGVkIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuXG5wcC5jYW5JbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZSA9PT0gdHlwZXMuZW9mIHx8XG4gICAgdGhpcy50eXBlID09PSB0eXBlcy5icmFjZVIgfHxcbiAgICBsaW5lQnJlYWsudGVzdCh0aGlzLmlucHV0LnNsaWNlKHRoaXMubGFzdFRva0VuZCwgdGhpcy5zdGFydCkpXG59O1xuXG5wcC5pbnNlcnRTZW1pY29sb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9uSW5zZXJ0ZWRTZW1pY29sb24pXG4gICAgICB7IHRoaXMub3B0aW9ucy5vbkluc2VydGVkU2VtaWNvbG9uKHRoaXMubGFzdFRva0VuZCwgdGhpcy5sYXN0VG9rRW5kTG9jKTsgfVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn07XG5cbi8vIENvbnN1bWUgYSBzZW1pY29sb24sIG9yLCBmYWlsaW5nIHRoYXQsIHNlZSBpZiB3ZSBhcmUgYWxsb3dlZCB0b1xuLy8gcHJldGVuZCB0aGF0IHRoZXJlIGlzIGEgc2VtaWNvbG9uIGF0IHRoaXMgcG9zaXRpb24uXG5cbnBwLnNlbWljb2xvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuZWF0KHR5cGVzLnNlbWkpICYmICF0aGlzLmluc2VydFNlbWljb2xvbigpKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG59O1xuXG5wcC5hZnRlclRyYWlsaW5nQ29tbWEgPSBmdW5jdGlvbih0b2tUeXBlLCBub3ROZXh0KSB7XG4gIGlmICh0aGlzLnR5cGUgPT0gdG9rVHlwZSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKVxuICAgICAgeyB0aGlzLm9wdGlvbnMub25UcmFpbGluZ0NvbW1hKHRoaXMubGFzdFRva1N0YXJ0LCB0aGlzLmxhc3RUb2tTdGFydExvYyk7IH1cbiAgICBpZiAoIW5vdE5leHQpXG4gICAgICB7IHRoaXMubmV4dCgpOyB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcblxuLy8gRXhwZWN0IGEgdG9rZW4gb2YgYSBnaXZlbiB0eXBlLiBJZiBmb3VuZCwgY29uc3VtZSBpdCwgb3RoZXJ3aXNlLFxuLy8gcmFpc2UgYW4gdW5leHBlY3RlZCB0b2tlbiBlcnJvci5cblxucHAuZXhwZWN0ID0gZnVuY3Rpb24odHlwZSkge1xuICB0aGlzLmVhdCh0eXBlKSB8fCB0aGlzLnVuZXhwZWN0ZWQoKTtcbn07XG5cbi8vIFJhaXNlIGFuIHVuZXhwZWN0ZWQgdG9rZW4gZXJyb3IuXG5cbnBwLnVuZXhwZWN0ZWQgPSBmdW5jdGlvbihwb3MpIHtcbiAgdGhpcy5yYWlzZShwb3MgIT0gbnVsbCA/IHBvcyA6IHRoaXMuc3RhcnQsIFwiVW5leHBlY3RlZCB0b2tlblwiKTtcbn07XG5cbmZ1bmN0aW9uIERlc3RydWN0dXJpbmdFcnJvcnMoKSB7XG4gIHRoaXMuc2hvcnRoYW5kQXNzaWduID1cbiAgdGhpcy50cmFpbGluZ0NvbW1hID1cbiAgdGhpcy5wYXJlbnRoZXNpemVkQXNzaWduID1cbiAgdGhpcy5wYXJlbnRoZXNpemVkQmluZCA9XG4gICAgLTE7XG59XG5cbnBwLmNoZWNrUGF0dGVybkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGlzQXNzaWduKSB7XG4gIGlmICghcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykgeyByZXR1cm4gfVxuICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hID4gLTEpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy50cmFpbGluZ0NvbW1hLCBcIkNvbW1hIGlzIG5vdCBwZXJtaXR0ZWQgYWZ0ZXIgdGhlIHJlc3QgZWxlbWVudFwiKTsgfVxuICB2YXIgcGFyZW5zID0gaXNBc3NpZ24gPyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gOiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRCaW5kO1xuICBpZiAocGFyZW5zID4gLTEpIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHBhcmVucywgXCJQYXJlbnRoZXNpemVkIHBhdHRlcm5cIik7IH1cbn07XG5cbnBwLmNoZWNrRXhwcmVzc2lvbkVycm9ycyA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFuZFRocm93KSB7XG4gIHZhciBwb3MgPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID8gcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gOiAtMTtcbiAgaWYgKCFhbmRUaHJvdykgeyByZXR1cm4gcG9zID49IDAgfVxuICBpZiAocG9zID4gLTEpIHsgdGhpcy5yYWlzZShwb3MsIFwiU2hvcnRoYW5kIHByb3BlcnR5IGFzc2lnbm1lbnRzIGFyZSB2YWxpZCBvbmx5IGluIGRlc3RydWN0dXJpbmcgcGF0dGVybnNcIik7IH1cbn07XG5cbnBwLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy55aWVsZFBvcyAmJiAoIXRoaXMuYXdhaXRQb3MgfHwgdGhpcy55aWVsZFBvcyA8IHRoaXMuYXdhaXRQb3MpKVxuICAgIHsgdGhpcy5yYWlzZSh0aGlzLnlpZWxkUG9zLCBcIllpZWxkIGV4cHJlc3Npb24gY2Fubm90IGJlIGEgZGVmYXVsdCB2YWx1ZVwiKTsgfVxuICBpZiAodGhpcy5hd2FpdFBvcylcbiAgICB7IHRoaXMucmFpc2UodGhpcy5hd2FpdFBvcywgXCJBd2FpdCBleHByZXNzaW9uIGNhbm5vdCBiZSBhIGRlZmF1bHQgdmFsdWVcIik7IH1cbn07XG5cbnBwLmlzU2ltcGxlQXNzaWduVGFyZ2V0ID0gZnVuY3Rpb24oZXhwcikge1xuICBpZiAoZXhwci50eXBlID09PSBcIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uXCIpXG4gICAgeyByZXR1cm4gdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByLmV4cHJlc3Npb24pIH1cbiAgcmV0dXJuIGV4cHIudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgfHwgZXhwci50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIlxufTtcblxudmFyIHBwJDEgPSBQYXJzZXIkMS5wcm90b3R5cGU7XG5cbi8vICMjIyBTdGF0ZW1lbnQgcGFyc2luZ1xuXG4vLyBQYXJzZSBhIHByb2dyYW0uIEluaXRpYWxpemVzIHRoZSBwYXJzZXIsIHJlYWRzIGFueSBudW1iZXIgb2Zcbi8vIHN0YXRlbWVudHMsIGFuZCB3cmFwcyB0aGVtIGluIGEgUHJvZ3JhbSBub2RlLiAgT3B0aW9uYWxseSB0YWtlcyBhXG4vLyBgcHJvZ3JhbWAgYXJndW1lbnQuICBJZiBwcmVzZW50LCB0aGUgc3RhdGVtZW50cyB3aWxsIGJlIGFwcGVuZGVkXG4vLyB0byBpdHMgYm9keSBpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IG5vZGUuXG5cbnBwJDEucGFyc2VUb3BMZXZlbCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgaWYgKCFub2RlLmJvZHkpIHsgbm9kZS5ib2R5ID0gW107IH1cbiAgd2hpbGUgKHRoaXMudHlwZSAhPT0gdHlwZXMuZW9mKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzJDEucGFyc2VTdGF0ZW1lbnQodHJ1ZSwgdHJ1ZSwgZXhwb3J0cyk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgdGhpcy5hZGFwdERpcmVjdGl2ZVByb2xvZ3VlKG5vZGUuYm9keSk7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBub2RlLnNvdXJjZVR5cGUgPSB0aGlzLm9wdGlvbnMuc291cmNlVHlwZTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUHJvZ3JhbVwiKVxufTtcblxudmFyIGxvb3BMYWJlbCA9IHtraW5kOiBcImxvb3BcIn07XG52YXIgc3dpdGNoTGFiZWwgPSB7a2luZDogXCJzd2l0Y2hcIn07XG5cbnBwJDEuaXNMZXQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2IHx8IHRoaXMudmFsdWUgIT0gXCJsZXRcIikgeyByZXR1cm4gZmFsc2UgfVxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGgsIG5leHRDaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdChuZXh0KTtcbiAgaWYgKG5leHRDaCA9PT0gOTEgfHwgbmV4dENoID09IDEyMykgeyByZXR1cm4gdHJ1ZSB9IC8vICd7JyBhbmQgJ1snXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChuZXh0Q2gsIHRydWUpKSB7XG4gICAgdmFyIHBvcyA9IG5leHQgKyAxO1xuICAgIHdoaWxlIChpc0lkZW50aWZpZXJDaGFyKHRoaXMuaW5wdXQuY2hhckNvZGVBdChwb3MpLCB0cnVlKSkgeyArK3BvczsgfVxuICAgIHZhciBpZGVudCA9IHRoaXMuaW5wdXQuc2xpY2UobmV4dCwgcG9zKTtcbiAgICBpZiAoIXRoaXMuaXNLZXl3b3JkKGlkZW50KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG4vLyBjaGVjayAnYXN5bmMgW25vIExpbmVUZXJtaW5hdG9yIGhlcmVdIGZ1bmN0aW9uJ1xuLy8gLSAnYXN5bmMgLypmb28qLyBmdW5jdGlvbicgaXMgT0suXG4vLyAtICdhc3luYyAvKlxcbiovIGZ1bmN0aW9uJyBpcyBpbnZhbGlkLlxucHAkMS5pc0FzeW5jRnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSB8fCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA4IHx8IHRoaXMudmFsdWUgIT0gXCJhc3luY1wiKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICBza2lwV2hpdGVTcGFjZS5sYXN0SW5kZXggPSB0aGlzLnBvcztcbiAgdmFyIHNraXAgPSBza2lwV2hpdGVTcGFjZS5leGVjKHRoaXMuaW5wdXQpO1xuICB2YXIgbmV4dCA9IHRoaXMucG9zICsgc2tpcFswXS5sZW5ndGg7XG4gIHJldHVybiAhbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLnBvcywgbmV4dCkpICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShuZXh0LCBuZXh0ICsgOCkgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgIChuZXh0ICsgOCA9PSB0aGlzLmlucHV0Lmxlbmd0aCB8fCAhaXNJZGVudGlmaWVyQ2hhcih0aGlzLmlucHV0LmNoYXJBdChuZXh0ICsgOCkpKVxufTtcblxuLy8gUGFyc2UgYSBzaW5nbGUgc3RhdGVtZW50LlxuLy9cbi8vIElmIGV4cGVjdGluZyBhIHN0YXRlbWVudCBhbmQgZmluZGluZyBhIHNsYXNoIG9wZXJhdG9yLCBwYXJzZSBhXG4vLyByZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbC4gVGhpcyBpcyB0byBoYW5kbGUgY2FzZXMgbGlrZVxuLy8gYGlmIChmb28pIC9ibGFoLy5leGVjKGZvbylgLCB3aGVyZSBsb29raW5nIGF0IHRoZSBwcmV2aW91cyB0b2tlblxuLy8gZG9lcyBub3QgaGVscC5cblxucHAkMS5wYXJzZVN0YXRlbWVudCA9IGZ1bmN0aW9uKGRlY2xhcmF0aW9uLCB0b3BMZXZlbCwgZXhwb3J0cykge1xuICB2YXIgc3RhcnR0eXBlID0gdGhpcy50eXBlLCBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwga2luZDtcblxuICBpZiAodGhpcy5pc0xldCgpKSB7XG4gICAgc3RhcnR0eXBlID0gdHlwZXMuX3ZhcjtcbiAgICBraW5kID0gXCJsZXRcIjtcbiAgfVxuXG4gIC8vIE1vc3QgdHlwZXMgb2Ygc3RhdGVtZW50cyBhcmUgcmVjb2duaXplZCBieSB0aGUga2V5d29yZCB0aGV5XG4gIC8vIHN0YXJ0IHdpdGguIE1hbnkgYXJlIHRyaXZpYWwgdG8gcGFyc2UsIHNvbWUgcmVxdWlyZSBhIGJpdCBvZlxuICAvLyBjb21wbGV4aXR5LlxuXG4gIHN3aXRjaCAoc3RhcnR0eXBlKSB7XG4gIGNhc2UgdHlwZXMuX2JyZWFrOiBjYXNlIHR5cGVzLl9jb250aW51ZTogcmV0dXJuIHRoaXMucGFyc2VCcmVha0NvbnRpbnVlU3RhdGVtZW50KG5vZGUsIHN0YXJ0dHlwZS5rZXl3b3JkKVxuICBjYXNlIHR5cGVzLl9kZWJ1Z2dlcjogcmV0dXJuIHRoaXMucGFyc2VEZWJ1Z2dlclN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9kbzogcmV0dXJuIHRoaXMucGFyc2VEb1N0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9mb3I6IHJldHVybiB0aGlzLnBhcnNlRm9yU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgIGlmICghZGVjbGFyYXRpb24gJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIGZhbHNlKVxuICBjYXNlIHR5cGVzLl9jbGFzczpcbiAgICBpZiAoIWRlY2xhcmF0aW9uKSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyhub2RlLCB0cnVlKVxuICBjYXNlIHR5cGVzLl9pZjogcmV0dXJuIHRoaXMucGFyc2VJZlN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9yZXR1cm46IHJldHVybiB0aGlzLnBhcnNlUmV0dXJuU3RhdGVtZW50KG5vZGUpXG4gIGNhc2UgdHlwZXMuX3N3aXRjaDogcmV0dXJuIHRoaXMucGFyc2VTd2l0Y2hTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fdGhyb3c6IHJldHVybiB0aGlzLnBhcnNlVGhyb3dTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fdHJ5OiByZXR1cm4gdGhpcy5wYXJzZVRyeVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl9jb25zdDogY2FzZSB0eXBlcy5fdmFyOlxuICAgIGtpbmQgPSBraW5kIHx8IHRoaXMudmFsdWU7XG4gICAgaWYgKCFkZWNsYXJhdGlvbiAmJiBraW5kICE9IFwidmFyXCIpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5wYXJzZVZhclN0YXRlbWVudChub2RlLCBraW5kKVxuICBjYXNlIHR5cGVzLl93aGlsZTogcmV0dXJuIHRoaXMucGFyc2VXaGlsZVN0YXRlbWVudChub2RlKVxuICBjYXNlIHR5cGVzLl93aXRoOiByZXR1cm4gdGhpcy5wYXJzZVdpdGhTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5icmFjZUw6IHJldHVybiB0aGlzLnBhcnNlQmxvY2soKVxuICBjYXNlIHR5cGVzLnNlbWk6IHJldHVybiB0aGlzLnBhcnNlRW1wdHlTdGF0ZW1lbnQobm9kZSlcbiAgY2FzZSB0eXBlcy5fZXhwb3J0OlxuICBjYXNlIHR5cGVzLl9pbXBvcnQ6XG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dJbXBvcnRFeHBvcnRFdmVyeXdoZXJlKSB7XG4gICAgICBpZiAoIXRvcExldmVsKVxuICAgICAgICB7IHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCInaW1wb3J0JyBhbmQgJ2V4cG9ydCcgbWF5IG9ubHkgYXBwZWFyIGF0IHRoZSB0b3AgbGV2ZWxcIik7IH1cbiAgICAgIGlmICghdGhpcy5pbk1vZHVsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ2ltcG9ydCcgYW5kICdleHBvcnQnIG1heSBhcHBlYXIgb25seSB3aXRoICdzb3VyY2VUeXBlOiBtb2R1bGUnXCIpOyB9XG4gICAgfVxuICAgIHJldHVybiBzdGFydHR5cGUgPT09IHR5cGVzLl9pbXBvcnQgPyB0aGlzLnBhcnNlSW1wb3J0KG5vZGUpIDogdGhpcy5wYXJzZUV4cG9ydChub2RlLCBleHBvcnRzKVxuXG4gICAgLy8gSWYgdGhlIHN0YXRlbWVudCBkb2VzIG5vdCBzdGFydCB3aXRoIGEgc3RhdGVtZW50IGtleXdvcmQgb3IgYVxuICAgIC8vIGJyYWNlLCBpdCdzIGFuIEV4cHJlc3Npb25TdGF0ZW1lbnQgb3IgTGFiZWxlZFN0YXRlbWVudC4gV2VcbiAgICAvLyBzaW1wbHkgc3RhcnQgcGFyc2luZyBhbiBleHByZXNzaW9uLCBhbmQgYWZ0ZXJ3YXJkcywgaWYgdGhlXG4gICAgLy8gbmV4dCB0b2tlbiBpcyBhIGNvbG9uIGFuZCB0aGUgZXhwcmVzc2lvbiB3YXMgYSBzaW1wbGVcbiAgICAvLyBJZGVudGlmaWVyIG5vZGUsIHdlIHN3aXRjaCB0byBpbnRlcnByZXRpbmcgaXQgYXMgYSBsYWJlbC5cbiAgZGVmYXVsdDpcbiAgICBpZiAodGhpcy5pc0FzeW5jRnVuY3Rpb24oKSAmJiBkZWNsYXJhdGlvbikge1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uU3RhdGVtZW50KG5vZGUsIHRydWUpXG4gICAgfVxuXG4gICAgdmFyIG1heWJlTmFtZSA9IHRoaXMudmFsdWUsIGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgIGlmIChzdGFydHR5cGUgPT09IHR5cGVzLm5hbWUgJiYgZXhwci50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiB0aGlzLmVhdCh0eXBlcy5jb2xvbikpXG4gICAgICB7IHJldHVybiB0aGlzLnBhcnNlTGFiZWxlZFN0YXRlbWVudChub2RlLCBtYXliZU5hbWUsIGV4cHIpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpIH1cbiAgfVxufTtcblxucHAkMS5wYXJzZUJyZWFrQ29udGludWVTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBrZXl3b3JkKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpc0JyZWFrID0ga2V5d29yZCA9PSBcImJyZWFrXCI7XG4gIHRoaXMubmV4dCgpO1xuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmxhYmVsID0gbnVsbDsgfVxuICBlbHNlIGlmICh0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgZWxzZSB7XG4gICAgbm9kZS5sYWJlbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuc2VtaWNvbG9uKCk7XG4gIH1cblxuICAvLyBWZXJpZnkgdGhhdCB0aGVyZSBpcyBhbiBhY3R1YWwgZGVzdGluYXRpb24gdG8gYnJlYWsgb3JcbiAgLy8gY29udGludWUgdG8uXG4gIHZhciBpID0gMDtcbiAgZm9yICg7IGkgPCB0aGlzLmxhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsYWIgPSB0aGlzJDEubGFiZWxzW2ldO1xuICAgIGlmIChub2RlLmxhYmVsID09IG51bGwgfHwgbGFiLm5hbWUgPT09IG5vZGUubGFiZWwubmFtZSkge1xuICAgICAgaWYgKGxhYi5raW5kICE9IG51bGwgJiYgKGlzQnJlYWsgfHwgbGFiLmtpbmQgPT09IFwibG9vcFwiKSkgeyBicmVhayB9XG4gICAgICBpZiAobm9kZS5sYWJlbCAmJiBpc0JyZWFrKSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cbiAgaWYgKGkgPT09IHRoaXMubGFiZWxzLmxlbmd0aCkgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiVW5zeW50YWN0aWMgXCIgKyBrZXl3b3JkKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIGlzQnJlYWsgPyBcIkJyZWFrU3RhdGVtZW50XCIgOiBcIkNvbnRpbnVlU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRGVidWdnZXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnNlbWljb2xvbigpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRGVidWdnZXJTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VEb1N0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHRoaXMubGFiZWxzLnBvcCgpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5fd2hpbGUpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNilcbiAgICB7IHRoaXMuZWF0KHR5cGVzLnNlbWkpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkRvV2hpbGVTdGF0ZW1lbnRcIilcbn07XG5cbi8vIERpc2FtYmlndWF0aW5nIGJldHdlZW4gYSBgZm9yYCBhbmQgYSBgZm9yYC9gaW5gIG9yIGBmb3JgL2BvZmBcbi8vIGxvb3AgaXMgbm9uLXRyaXZpYWwuIEJhc2ljYWxseSwgd2UgaGF2ZSB0byBwYXJzZSB0aGUgaW5pdCBgdmFyYFxuLy8gc3RhdGVtZW50IG9yIGV4cHJlc3Npb24sIGRpc2FsbG93aW5nIHRoZSBgaW5gIG9wZXJhdG9yIChzZWVcbi8vIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGBwYXJzZUV4cHJlc3Npb25gKSwgYW5kIHRoZW4gY2hlY2tcbi8vIHdoZXRoZXIgdGhlIG5leHQgdG9rZW4gaXMgYGluYCBvciBgb2ZgLiBXaGVuIHRoZXJlIGlzIG5vIGluaXRcbi8vIHBhcnQgKHNlbWljb2xvbiBpbW1lZGlhdGVseSBhZnRlciB0aGUgb3BlbmluZyBwYXJlbnRoZXNpcyksIGl0XG4vLyBpcyBhIHJlZ3VsYXIgYGZvcmAgbG9vcC5cblxucHAkMS5wYXJzZUZvclN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIHRoaXMubGFiZWxzLnB1c2gobG9vcExhYmVsKTtcbiAgdGhpcy5lbnRlckxleGljYWxTY29wZSgpO1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5zZW1pKSB7IHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIG51bGwpIH1cbiAgdmFyIGlzTGV0ID0gdGhpcy5pc0xldCgpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fdmFyIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuX2NvbnN0IHx8IGlzTGV0KSB7XG4gICAgdmFyIGluaXQkMSA9IHRoaXMuc3RhcnROb2RlKCksIGtpbmQgPSBpc0xldCA/IFwibGV0XCIgOiB0aGlzLnZhbHVlO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMucGFyc2VWYXIoaW5pdCQxLCB0cnVlLCBraW5kKTtcbiAgICB0aGlzLmZpbmlzaE5vZGUoaW5pdCQxLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7XG4gICAgaWYgKCh0aGlzLnR5cGUgPT09IHR5cGVzLl9pbiB8fCAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5pc0NvbnRleHR1YWwoXCJvZlwiKSkpICYmIGluaXQkMS5kZWNsYXJhdGlvbnMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICEoa2luZCAhPT0gXCJ2YXJcIiAmJiBpbml0JDEuZGVjbGFyYXRpb25zWzBdLmluaXQpKVxuICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUZvckluKG5vZGUsIGluaXQkMSkgfVxuICAgIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQkMSlcbiAgfVxuICB2YXIgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IG5ldyBEZXN0cnVjdHVyaW5nRXJyb3JzO1xuICB2YXIgaW5pdCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKHRydWUsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5faW4gfHwgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMuaXNDb250ZXh0dWFsKFwib2ZcIikpKSB7XG4gICAgdGhpcy50b0Fzc2lnbmFibGUoaW5pdCk7XG4gICAgdGhpcy5jaGVja0xWYWwoaW5pdCk7XG4gICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VGb3JJbihub2RlLCBpbml0KVxuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICB9XG4gIHJldHVybiB0aGlzLnBhcnNlRm9yKG5vZGUsIGluaXQpXG59O1xuXG5wcCQxLnBhcnNlRnVuY3Rpb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBpc0FzeW5jKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKG5vZGUsIHRydWUsIGZhbHNlLCBpc0FzeW5jKVxufTtcblxucHAkMS5pc0Z1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbiB8fCB0aGlzLmlzQXN5bmNGdW5jdGlvbigpXG59O1xuXG5wcCQxLnBhcnNlSWZTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLnRlc3QgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIC8vIGFsbG93IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBpbiBicmFuY2hlcywgYnV0IG9ubHkgaW4gbm9uLXN0cmljdCBtb2RlXG4gIG5vZGUuY29uc2VxdWVudCA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoIXRoaXMuc3RyaWN0ICYmIHRoaXMuaXNGdW5jdGlvbigpKTtcbiAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLmVhdCh0eXBlcy5fZWxzZSkgPyB0aGlzLnBhcnNlU3RhdGVtZW50KCF0aGlzLnN0cmljdCAmJiB0aGlzLmlzRnVuY3Rpb24oKSkgOiBudWxsO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWZTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VSZXR1cm5TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICghdGhpcy5pbkZ1bmN0aW9uICYmICF0aGlzLm9wdGlvbnMuYWxsb3dSZXR1cm5PdXRzaWRlRnVuY3Rpb24pXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKTsgfVxuICB0aGlzLm5leHQoKTtcblxuICAvLyBJbiBgcmV0dXJuYCAoYW5kIGBicmVha2AvYGNvbnRpbnVlYCksIHRoZSBrZXl3b3JkcyB3aXRoXG4gIC8vIG9wdGlvbmFsIGFyZ3VtZW50cywgd2UgZWFnZXJseSBsb29rIGZvciBhIHNlbWljb2xvbiBvciB0aGVcbiAgLy8gcG9zc2liaWxpdHkgdG8gaW5zZXJ0IG9uZS5cblxuICBpZiAodGhpcy5lYXQodHlwZXMuc2VtaSkgfHwgdGhpcy5pbnNlcnRTZW1pY29sb24oKSkgeyBub2RlLmFyZ3VtZW50ID0gbnVsbDsgfVxuICBlbHNlIHsgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7IHRoaXMuc2VtaWNvbG9uKCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlJldHVyblN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVN3aXRjaFN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUuZGlzY3JpbWluYW50ID0gdGhpcy5wYXJzZVBhcmVuRXhwcmVzc2lvbigpO1xuICBub2RlLmNhc2VzID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHRoaXMubGFiZWxzLnB1c2goc3dpdGNoTGFiZWwpO1xuICB0aGlzLmVudGVyTGV4aWNhbFNjb3BlKCk7XG5cbiAgLy8gU3RhdGVtZW50cyB1bmRlciBtdXN0IGJlIGdyb3VwZWQgKGJ5IGxhYmVsKSBpbiBTd2l0Y2hDYXNlXG4gIC8vIG5vZGVzLiBgY3VyYCBpcyB1c2VkIHRvIGtlZXAgdGhlIG5vZGUgdGhhdCB3ZSBhcmUgY3VycmVudGx5XG4gIC8vIGFkZGluZyBzdGF0ZW1lbnRzIHRvLlxuXG4gIHZhciBjdXI7XG4gIGZvciAodmFyIHNhd0RlZmF1bHQgPSBmYWxzZTsgdGhpcy50eXBlICE9IHR5cGVzLmJyYWNlUjspIHtcbiAgICBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLl9jYXNlIHx8IHRoaXMkMS50eXBlID09PSB0eXBlcy5fZGVmYXVsdCkge1xuICAgICAgdmFyIGlzQ2FzZSA9IHRoaXMkMS50eXBlID09PSB0eXBlcy5fY2FzZTtcbiAgICAgIGlmIChjdXIpIHsgdGhpcyQxLmZpbmlzaE5vZGUoY3VyLCBcIlN3aXRjaENhc2VcIik7IH1cbiAgICAgIG5vZGUuY2FzZXMucHVzaChjdXIgPSB0aGlzJDEuc3RhcnROb2RlKCkpO1xuICAgICAgY3VyLmNvbnNlcXVlbnQgPSBbXTtcbiAgICAgIHRoaXMkMS5uZXh0KCk7XG4gICAgICBpZiAoaXNDYXNlKSB7XG4gICAgICAgIGN1ci50ZXN0ID0gdGhpcyQxLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNhd0RlZmF1bHQpIHsgdGhpcyQxLnJhaXNlUmVjb3ZlcmFibGUodGhpcyQxLmxhc3RUb2tTdGFydCwgXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIik7IH1cbiAgICAgICAgc2F3RGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGN1ci50ZXN0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMkMS5leHBlY3QodHlwZXMuY29sb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWN1cikgeyB0aGlzJDEudW5leHBlY3RlZCgpOyB9XG4gICAgICBjdXIuY29uc2VxdWVudC5wdXNoKHRoaXMkMS5wYXJzZVN0YXRlbWVudCh0cnVlKSk7XG4gICAgfVxuICB9XG4gIHRoaXMuZXhpdExleGljYWxTY29wZSgpO1xuICBpZiAoY3VyKSB7IHRoaXMuZmluaXNoTm9kZShjdXIsIFwiU3dpdGNoQ2FzZVwiKTsgfVxuICB0aGlzLm5leHQoKTsgLy8gQ2xvc2luZyBicmFjZVxuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlN3aXRjaFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVRocm93U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSkpXG4gICAgeyB0aGlzLnJhaXNlKHRoaXMubGFzdFRva0VuZCwgXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIik7IH1cbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaHJvd1N0YXRlbWVudFwiKVxufTtcblxuLy8gUmV1c2VkIGVtcHR5IGFycmF5IGFkZGVkIGZvciBub2RlIGZpZWxkcyB0aGF0IGFyZSBhbHdheXMgZW1wdHkuXG5cbnZhciBlbXB0eSA9IFtdO1xuXG5wcCQxLnBhcnNlVHJ5U3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5ibG9jayA9IHRoaXMucGFyc2VCbG9jaygpO1xuICBub2RlLmhhbmRsZXIgPSBudWxsO1xuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5fY2F0Y2gpIHtcbiAgICB2YXIgY2xhdXNlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICAgIGNsYXVzZS5wYXJhbSA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbSgpO1xuICAgIHRoaXMuZW50ZXJMZXhpY2FsU2NvcGUoKTtcbiAgICB0aGlzLmNoZWNrTFZhbChjbGF1c2UucGFyYW0sIFwibGV0XCIpO1xuICAgIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gICAgY2xhdXNlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgIHRoaXMuZXhpdExleGljYWxTY29wZSgpO1xuICAgIG5vZGUuaGFuZGxlciA9IHRoaXMuZmluaXNoTm9kZShjbGF1c2UsIFwiQ2F0Y2hDbGF1c2VcIik7XG4gIH1cbiAgbm9kZS5maW5hbGl6ZXIgPSB0aGlzLmVhdCh0eXBlcy5fZmluYWxseSkgPyB0aGlzLnBhcnNlQmxvY2soKSA6IG51bGw7XG4gIGlmICghbm9kZS5oYW5kbGVyICYmICFub2RlLmZpbmFsaXplcilcbiAgICB7IHRoaXMucmFpc2Uobm9kZS5zdGFydCwgXCJNaXNzaW5nIGNhdGNoIG9yIGZpbmFsbHkgY2xhdXNlXCIpOyB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUcnlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VWYXJTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBraW5kKSB7XG4gIHRoaXMubmV4dCgpO1xuICB0aGlzLnBhcnNlVmFyKG5vZGUsIGZhbHNlLCBraW5kKTtcbiAgdGhpcy5zZW1pY29sb24oKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbn07XG5cbnBwJDEucGFyc2VXaGlsZVN0YXRlbWVudCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgdGhpcy5uZXh0KCk7XG4gIG5vZGUudGVzdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgdGhpcy5sYWJlbHMucHVzaChsb29wTGFiZWwpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaGlsZVN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZVdpdGhTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHRoaXMuc3RhcnQsIFwiJ3dpdGgnIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLm9iamVjdCA9IHRoaXMucGFyc2VQYXJlbkV4cHJlc3Npb24oKTtcbiAgbm9kZS5ib2R5ID0gdGhpcy5wYXJzZVN0YXRlbWVudChmYWxzZSk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJXaXRoU3RhdGVtZW50XCIpXG59O1xuXG5wcCQxLnBhcnNlRW1wdHlTdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRW1wdHlTdGF0ZW1lbnRcIilcbn07XG5cbnBwJDEucGFyc2VMYWJlbGVkU3RhdGVtZW50ID0gZnVuY3Rpb24obm9kZSwgbWF5YmVOYW1lLCBleHByKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkkMSA9IDAsIGxpc3QgPSB0aGlzJDEubGFiZWxzOyBpJDEgPCBsaXN0Lmxlbmd0aDsgaSQxICs9IDEpXG4gICAge1xuICAgIHZhciBsYWJlbCA9IGxpc3RbaSQxXTtcblxuICAgIGlmIChsYWJlbC5uYW1lID09PSBtYXliZU5hbWUpXG4gICAgICB7IHRoaXMkMS5yYWlzZShleHByLnN0YXJ0LCBcIkxhYmVsICdcIiArIG1heWJlTmFtZSArIFwiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO1xuICB9IH1cbiAgdmFyIGtpbmQgPSB0aGlzLnR5cGUuaXNMb29wID8gXCJsb29wXCIgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl9zd2l0Y2ggPyBcInN3aXRjaFwiIDogbnVsbDtcbiAgZm9yICh2YXIgaSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhYmVsJDEgPSB0aGlzJDEubGFiZWxzW2ldO1xuICAgIGlmIChsYWJlbCQxLnN0YXRlbWVudFN0YXJ0ID09IG5vZGUuc3RhcnQpIHtcbiAgICAgIGxhYmVsJDEuc3RhdGVtZW50U3RhcnQgPSB0aGlzJDEuc3RhcnQ7XG4gICAgICBsYWJlbCQxLmtpbmQgPSBraW5kO1xuICAgIH0gZWxzZSB7IGJyZWFrIH1cbiAgfVxuICB0aGlzLmxhYmVscy5wdXNoKHtuYW1lOiBtYXliZU5hbWUsIGtpbmQ6IGtpbmQsIHN0YXRlbWVudFN0YXJ0OiB0aGlzLnN0YXJ0fSk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gIGlmIChub2RlLmJvZHkudHlwZSA9PSBcIkNsYXNzRGVjbGFyYXRpb25cIiB8fFxuICAgICAgbm9kZS5ib2R5LnR5cGUgPT0gXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIgJiYgbm9kZS5ib2R5LmtpbmQgIT0gXCJ2YXJcIiB8fFxuICAgICAgbm9kZS5ib2R5LnR5cGUgPT0gXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIgJiYgKHRoaXMuc3RyaWN0IHx8IG5vZGUuYm9keS5nZW5lcmF0b3IpKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuYm9keS5zdGFydCwgXCJJbnZhbGlkIGxhYmVsZWQgZGVjbGFyYXRpb25cIik7IH1cbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIG5vZGUubGFiZWwgPSBleHByO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGFiZWxlZFN0YXRlbWVudFwiKVxufTtcblxucHAkMS5wYXJzZUV4cHJlc3Npb25TdGF0ZW1lbnQgPSBmdW5jdGlvbihub2RlLCBleHByKSB7XG4gIG5vZGUuZXhwcmVzc2lvbiA9IGV4cHI7XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpXG59O1xuXG4vLyBQYXJzZSBhIHNlbWljb2xvbi1lbmNsb3NlZCBibG9jayBvZiBzdGF0ZW1lbnRzLCBoYW5kbGluZyBgXCJ1c2Vcbi8vIHN0cmljdFwiYCBkZWNsYXJhdGlvbnMgd2hlbiBgYWxsb3dTdHJpY3RgIGlzIHRydWUgKHVzZWQgZm9yXG4vLyBmdW5jdGlvbiBib2RpZXMpLlxuXG5wcCQxLnBhcnNlQmxvY2sgPSBmdW5jdGlvbihjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG4gIGlmICggY3JlYXRlTmV3TGV4aWNhbFNjb3BlID09PSB2b2lkIDAgKSBjcmVhdGVOZXdMZXhpY2FsU2NvcGUgPSB0cnVlO1xuXG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgbm9kZS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIGlmIChjcmVhdGVOZXdMZXhpY2FsU2NvcGUpIHtcbiAgICB0aGlzLmVudGVyTGV4aWNhbFNjb3BlKCk7XG4gIH1cbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgdmFyIHN0bXQgPSB0aGlzJDEucGFyc2VTdGF0ZW1lbnQodHJ1ZSk7XG4gICAgbm9kZS5ib2R5LnB1c2goc3RtdCk7XG4gIH1cbiAgaWYgKGNyZWF0ZU5ld0xleGljYWxTY29wZSkge1xuICAgIHRoaXMuZXhpdExleGljYWxTY29wZSgpO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJCbG9ja1N0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSByZWd1bGFyIGBmb3JgIGxvb3AuIFRoZSBkaXNhbWJpZ3VhdGlvbiBjb2RlIGluXG4vLyBgcGFyc2VTdGF0ZW1lbnRgIHdpbGwgYWxyZWFkeSBoYXZlIHBhcnNlZCB0aGUgaW5pdCBzdGF0ZW1lbnQgb3Jcbi8vIGV4cHJlc3Npb24uXG5cbnBwJDEucGFyc2VGb3IgPSBmdW5jdGlvbihub2RlLCBpbml0KSB7XG4gIG5vZGUuaW5pdCA9IGluaXQ7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnNlbWkpO1xuICBub2RlLnRlc3QgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnNlbWkgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMuc2VtaSk7XG4gIG5vZGUudXBkYXRlID0gdGhpcy50eXBlID09PSB0eXBlcy5wYXJlblIgPyBudWxsIDogdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgdGhpcy5leGl0TGV4aWNhbFNjb3BlKCk7XG4gIG5vZGUuYm9keSA9IHRoaXMucGFyc2VTdGF0ZW1lbnQoZmFsc2UpO1xuICB0aGlzLmxhYmVscy5wb3AoKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkZvclN0YXRlbWVudFwiKVxufTtcblxuLy8gUGFyc2UgYSBgZm9yYC9gaW5gIGFuZCBgZm9yYC9gb2ZgIGxvb3AsIHdoaWNoIGFyZSBhbG1vc3Rcbi8vIHNhbWUgZnJvbSBwYXJzZXIncyBwZXJzcGVjdGl2ZS5cblxucHAkMS5wYXJzZUZvckluID0gZnVuY3Rpb24obm9kZSwgaW5pdCkge1xuICB2YXIgdHlwZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuX2luID8gXCJGb3JJblN0YXRlbWVudFwiIDogXCJGb3JPZlN0YXRlbWVudFwiO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5sZWZ0ID0gaW5pdDtcbiAgbm9kZS5yaWdodCA9IHRoaXMucGFyc2VFeHByZXNzaW9uKCk7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuUik7XG4gIHRoaXMuZXhpdExleGljYWxTY29wZSgpO1xuICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlU3RhdGVtZW50KGZhbHNlKTtcbiAgdGhpcy5sYWJlbHMucG9wKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgdHlwZSlcbn07XG5cbi8vIFBhcnNlIGEgbGlzdCBvZiB2YXJpYWJsZSBkZWNsYXJhdGlvbnMuXG5cbnBwJDEucGFyc2VWYXIgPSBmdW5jdGlvbihub2RlLCBpc0Zvciwga2luZCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBub2RlLmRlY2xhcmF0aW9ucyA9IFtdO1xuICBub2RlLmtpbmQgPSBraW5kO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGRlY2wgPSB0aGlzJDEuc3RhcnROb2RlKCk7XG4gICAgdGhpcyQxLnBhcnNlVmFySWQoZGVjbCwga2luZCk7XG4gICAgaWYgKHRoaXMkMS5lYXQodHlwZXMuZXEpKSB7XG4gICAgICBkZWNsLmluaXQgPSB0aGlzJDEucGFyc2VNYXliZUFzc2lnbihpc0Zvcik7XG4gICAgfSBlbHNlIGlmIChraW5kID09PSBcImNvbnN0XCIgJiYgISh0aGlzJDEudHlwZSA9PT0gdHlwZXMuX2luIHx8ICh0aGlzJDEub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMkMS5pc0NvbnRleHR1YWwoXCJvZlwiKSkpKSB7XG4gICAgICB0aGlzJDEudW5leHBlY3RlZCgpO1xuICAgIH0gZWxzZSBpZiAoZGVjbC5pZC50eXBlICE9IFwiSWRlbnRpZmllclwiICYmICEoaXNGb3IgJiYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5faW4gfHwgdGhpcyQxLmlzQ29udGV4dHVhbChcIm9mXCIpKSkpIHtcbiAgICAgIHRoaXMkMS5yYWlzZSh0aGlzJDEubGFzdFRva0VuZCwgXCJDb21wbGV4IGJpbmRpbmcgcGF0dGVybnMgcmVxdWlyZSBhbiBpbml0aWFsaXphdGlvbiB2YWx1ZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVjbC5pbml0ID0gbnVsbDtcbiAgICB9XG4gICAgbm9kZS5kZWNsYXJhdGlvbnMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShkZWNsLCBcIlZhcmlhYmxlRGVjbGFyYXRvclwiKSk7XG4gICAgaWYgKCF0aGlzJDEuZWF0KHR5cGVzLmNvbW1hKSkgeyBicmVhayB9XG4gIH1cbiAgcmV0dXJuIG5vZGVcbn07XG5cbnBwJDEucGFyc2VWYXJJZCA9IGZ1bmN0aW9uKGRlY2wsIGtpbmQpIHtcbiAgZGVjbC5pZCA9IHRoaXMucGFyc2VCaW5kaW5nQXRvbShraW5kKTtcbiAgdGhpcy5jaGVja0xWYWwoZGVjbC5pZCwga2luZCwgZmFsc2UpO1xufTtcblxuLy8gUGFyc2UgYSBmdW5jdGlvbiBkZWNsYXJhdGlvbiBvciBsaXRlcmFsIChkZXBlbmRpbmcgb24gdGhlXG4vLyBgaXNTdGF0ZW1lbnRgIHBhcmFtZXRlcikuXG5cbnBwJDEucGFyc2VGdW5jdGlvbiA9IGZ1bmN0aW9uKG5vZGUsIGlzU3RhdGVtZW50LCBhbGxvd0V4cHJlc3Npb25Cb2R5LCBpc0FzeW5jKSB7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgIWlzQXN5bmMpXG4gICAgeyBub2RlLmdlbmVyYXRvciA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSAhIWlzQXN5bmM7IH1cblxuICBpZiAoaXNTdGF0ZW1lbnQpIHtcbiAgICBub2RlLmlkID0gaXNTdGF0ZW1lbnQgPT09IFwibnVsbGFibGVJRFwiICYmIHRoaXMudHlwZSAhPSB0eXBlcy5uYW1lID8gbnVsbCA6IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIGlmIChub2RlLmlkKSB7XG4gICAgICB0aGlzLmNoZWNrTFZhbChub2RlLmlkLCBcInZhclwiKTtcbiAgICB9XG4gIH1cblxuICB2YXIgb2xkSW5HZW4gPSB0aGlzLmluR2VuZXJhdG9yLCBvbGRJbkFzeW5jID0gdGhpcy5pbkFzeW5jLFxuICAgICAgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEluRnVuYyA9IHRoaXMuaW5GdW5jdGlvbjtcbiAgdGhpcy5pbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yO1xuICB0aGlzLmluQXN5bmMgPSBub2RlLmFzeW5jO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuaW5GdW5jdGlvbiA9IHRydWU7XG4gIHRoaXMuZW50ZXJGdW5jdGlvblNjb3BlKCk7XG5cbiAgaWYgKCFpc1N0YXRlbWVudClcbiAgICB7IG5vZGUuaWQgPSB0aGlzLnR5cGUgPT0gdHlwZXMubmFtZSA/IHRoaXMucGFyc2VJZGVudCgpIDogbnVsbDsgfVxuXG4gIHRoaXMucGFyc2VGdW5jdGlvblBhcmFtcyhub2RlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCBhbGxvd0V4cHJlc3Npb25Cb2R5KTtcblxuICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gIHRoaXMuaW5Bc3luYyA9IG9sZEluQXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNTdGF0ZW1lbnQgPyBcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiA6IFwiRnVuY3Rpb25FeHByZXNzaW9uXCIpXG59O1xuXG5wcCQxLnBhcnNlRnVuY3Rpb25QYXJhbXMgPSBmdW5jdGlvbihub2RlKSB7XG4gIHRoaXMuZXhwZWN0KHR5cGVzLnBhcmVuTCk7XG4gIG5vZGUucGFyYW1zID0gdGhpcy5wYXJzZUJpbmRpbmdMaXN0KHR5cGVzLnBhcmVuUiwgZmFsc2UsIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4KTtcbiAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbn07XG5cbi8vIFBhcnNlIGEgY2xhc3MgZGVjbGFyYXRpb24gb3IgbGl0ZXJhbCAoZGVwZW5kaW5nIG9uIHRoZVxuLy8gYGlzU3RhdGVtZW50YCBwYXJhbWV0ZXIpLlxuXG5wcCQxLnBhcnNlQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLm5leHQoKTtcblxuICB0aGlzLnBhcnNlQ2xhc3NJZChub2RlLCBpc1N0YXRlbWVudCk7XG4gIHRoaXMucGFyc2VDbGFzc1N1cGVyKG5vZGUpO1xuICB2YXIgY2xhc3NCb2R5ID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgdmFyIGhhZENvbnN0cnVjdG9yID0gZmFsc2U7XG4gIGNsYXNzQm9keS5ib2R5ID0gW107XG4gIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNlTCk7XG4gIHdoaWxlICghdGhpcy5lYXQodHlwZXMuYnJhY2VSKSkge1xuICAgIGlmICh0aGlzJDEuZWF0KHR5cGVzLnNlbWkpKSB7IGNvbnRpbnVlIH1cbiAgICB2YXIgbWV0aG9kID0gdGhpcyQxLnN0YXJ0Tm9kZSgpO1xuICAgIHZhciBpc0dlbmVyYXRvciA9IHRoaXMkMS5lYXQodHlwZXMuc3Rhcik7XG4gICAgdmFyIGlzQXN5bmMgPSBmYWxzZTtcbiAgICB2YXIgaXNNYXliZVN0YXRpYyA9IHRoaXMkMS50eXBlID09PSB0eXBlcy5uYW1lICYmIHRoaXMkMS52YWx1ZSA9PT0gXCJzdGF0aWNcIjtcbiAgICB0aGlzJDEucGFyc2VQcm9wZXJ0eU5hbWUobWV0aG9kKTtcbiAgICBtZXRob2Quc3RhdGljID0gaXNNYXliZVN0YXRpYyAmJiB0aGlzJDEudHlwZSAhPT0gdHlwZXMucGFyZW5MO1xuICAgIGlmIChtZXRob2Quc3RhdGljKSB7XG4gICAgICBpZiAoaXNHZW5lcmF0b3IpIHsgdGhpcyQxLnVuZXhwZWN0ZWQoKTsgfVxuICAgICAgaXNHZW5lcmF0b3IgPSB0aGlzJDEuZWF0KHR5cGVzLnN0YXIpO1xuICAgICAgdGhpcyQxLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgfVxuICAgIGlmICh0aGlzJDEub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmICFpc0dlbmVyYXRvciAmJiAhbWV0aG9kLmNvbXB1dGVkICYmXG4gICAgICAgIG1ldGhvZC5rZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgbWV0aG9kLmtleS5uYW1lID09PSBcImFzeW5jXCIgJiYgdGhpcyQxLnR5cGUgIT09IHR5cGVzLnBhcmVuTCAmJlxuICAgICAgICAhdGhpcyQxLmNhbkluc2VydFNlbWljb2xvbigpKSB7XG4gICAgICBpc0FzeW5jID0gdHJ1ZTtcbiAgICAgIHRoaXMkMS5wYXJzZVByb3BlcnR5TmFtZShtZXRob2QpO1xuICAgIH1cbiAgICBtZXRob2Qua2luZCA9IFwibWV0aG9kXCI7XG4gICAgdmFyIGlzR2V0U2V0ID0gZmFsc2U7XG4gICAgaWYgKCFtZXRob2QuY29tcHV0ZWQpIHtcbiAgICAgIHZhciBrZXkgPSBtZXRob2Qua2V5O1xuICAgICAgaWYgKCFpc0dlbmVyYXRvciAmJiAhaXNBc3luYyAmJiBrZXkudHlwZSA9PT0gXCJJZGVudGlmaWVyXCIgJiYgdGhpcyQxLnR5cGUgIT09IHR5cGVzLnBhcmVuTCAmJiAoa2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwga2V5Lm5hbWUgPT09IFwic2V0XCIpKSB7XG4gICAgICAgIGlzR2V0U2V0ID0gdHJ1ZTtcbiAgICAgICAgbWV0aG9kLmtpbmQgPSBrZXkubmFtZTtcbiAgICAgICAga2V5ID0gdGhpcyQxLnBhcnNlUHJvcGVydHlOYW1lKG1ldGhvZCk7XG4gICAgICB9XG4gICAgICBpZiAoIW1ldGhvZC5zdGF0aWMgJiYgKGtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBrZXkubmFtZSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8XG4gICAgICAgICAga2V5LnR5cGUgPT09IFwiTGl0ZXJhbFwiICYmIGtleS52YWx1ZSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICBpZiAoaGFkQ29uc3RydWN0b3IpIHsgdGhpcyQxLnJhaXNlKGtleS5zdGFydCwgXCJEdXBsaWNhdGUgY29uc3RydWN0b3IgaW4gdGhlIHNhbWUgY2xhc3NcIik7IH1cbiAgICAgICAgaWYgKGlzR2V0U2V0KSB7IHRoaXMkMS5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgaGF2ZSBnZXQvc2V0IG1vZGlmaWVyXCIpOyB9XG4gICAgICAgIGlmIChpc0dlbmVyYXRvcikgeyB0aGlzJDEucmFpc2Uoa2V5LnN0YXJ0LCBcIkNvbnN0cnVjdG9yIGNhbid0IGJlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gICAgICAgIGlmIChpc0FzeW5jKSB7IHRoaXMkMS5yYWlzZShrZXkuc3RhcnQsIFwiQ29uc3RydWN0b3IgY2FuJ3QgYmUgYW4gYXN5bmMgbWV0aG9kXCIpOyB9XG4gICAgICAgIG1ldGhvZC5raW5kID0gXCJjb25zdHJ1Y3RvclwiO1xuICAgICAgICBoYWRDb25zdHJ1Y3RvciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMkMS5wYXJzZUNsYXNzTWV0aG9kKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gICAgaWYgKGlzR2V0U2V0KSB7XG4gICAgICB2YXIgcGFyYW1Db3VudCA9IG1ldGhvZC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgICBpZiAobWV0aG9kLnZhbHVlLnBhcmFtcy5sZW5ndGggIT09IHBhcmFtQ291bnQpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gbWV0aG9kLnZhbHVlLnN0YXJ0O1xuICAgICAgICBpZiAobWV0aG9kLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgICAgeyB0aGlzJDEucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJnZXR0ZXIgc2hvdWxkIGhhdmUgbm8gcGFyYW1zXCIpOyB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHRoaXMkMS5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcInNldHRlciBzaG91bGQgaGF2ZSBleGFjdGx5IG9uZSBwYXJhbVwiKTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG1ldGhvZC5raW5kID09PSBcInNldFwiICYmIG1ldGhvZC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICAgIHsgdGhpcyQxLnJhaXNlUmVjb3ZlcmFibGUobWV0aG9kLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBub2RlLmJvZHkgPSB0aGlzLmZpbmlzaE5vZGUoY2xhc3NCb2R5LCBcIkNsYXNzQm9keVwiKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBpc1N0YXRlbWVudCA/IFwiQ2xhc3NEZWNsYXJhdGlvblwiIDogXCJDbGFzc0V4cHJlc3Npb25cIilcbn07XG5cbnBwJDEucGFyc2VDbGFzc01ldGhvZCA9IGZ1bmN0aW9uKGNsYXNzQm9keSwgbWV0aG9kLCBpc0dlbmVyYXRvciwgaXNBc3luYykge1xuICBtZXRob2QudmFsdWUgPSB0aGlzLnBhcnNlTWV0aG9kKGlzR2VuZXJhdG9yLCBpc0FzeW5jKTtcbiAgY2xhc3NCb2R5LmJvZHkucHVzaCh0aGlzLmZpbmlzaE5vZGUobWV0aG9kLCBcIk1ldGhvZERlZmluaXRpb25cIikpO1xufTtcblxucHAkMS5wYXJzZUNsYXNzSWQgPSBmdW5jdGlvbihub2RlLCBpc1N0YXRlbWVudCkge1xuICBub2RlLmlkID0gdGhpcy50eXBlID09PSB0eXBlcy5uYW1lID8gdGhpcy5wYXJzZUlkZW50KCkgOiBpc1N0YXRlbWVudCA9PT0gdHJ1ZSA/IHRoaXMudW5leHBlY3RlZCgpIDogbnVsbDtcbn07XG5cbnBwJDEucGFyc2VDbGFzc1N1cGVyID0gZnVuY3Rpb24obm9kZSkge1xuICBub2RlLnN1cGVyQ2xhc3MgPSB0aGlzLmVhdCh0eXBlcy5fZXh0ZW5kcykgPyB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMoKSA6IG51bGw7XG59O1xuXG4vLyBQYXJzZXMgbW9kdWxlIGV4cG9ydCBkZWNsYXJhdGlvbi5cblxucHAkMS5wYXJzZUV4cG9ydCA9IGZ1bmN0aW9uKG5vZGUsIGV4cG9ydHMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0KCk7XG4gIC8vIGV4cG9ydCAqIGZyb20gJy4uLidcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnN0YXIpKSB7XG4gICAgdGhpcy5leHBlY3RDb250ZXh0dWFsKFwiZnJvbVwiKTtcbiAgICBub2RlLnNvdXJjZSA9IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiKVxuICB9XG4gIGlmICh0aGlzLmVhdCh0eXBlcy5fZGVmYXVsdCkpIHsgLy8gZXhwb3J0IGRlZmF1bHQgLi4uXG4gICAgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBcImRlZmF1bHRcIiwgdGhpcy5sYXN0VG9rU3RhcnQpO1xuICAgIHZhciBpc0FzeW5jO1xuICAgIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLl9mdW5jdGlvbiB8fCAoaXNBc3luYyA9IHRoaXMuaXNBc3luY0Z1bmN0aW9uKCkpKSB7XG4gICAgICB2YXIgZk5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICBpZiAoaXNBc3luYykgeyB0aGlzLm5leHQoKTsgfVxuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VGdW5jdGlvbihmTm9kZSwgXCJudWxsYWJsZUlEXCIsIGZhbHNlLCBpc0FzeW5jKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuX2NsYXNzKSB7XG4gICAgICB2YXIgY05vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgbm9kZS5kZWNsYXJhdGlvbiA9IHRoaXMucGFyc2VDbGFzcyhjTm9kZSwgXCJudWxsYWJsZUlEXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gICAgICB0aGlzLnNlbWljb2xvbigpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpXG4gIH1cbiAgLy8gZXhwb3J0IHZhcnxjb25zdHxsZXR8ZnVuY3Rpb258Y2xhc3MgLi4uXG4gIGlmICh0aGlzLnNob3VsZFBhcnNlRXhwb3J0U3RhdGVtZW50KCkpIHtcbiAgICBub2RlLmRlY2xhcmF0aW9uID0gdGhpcy5wYXJzZVN0YXRlbWVudCh0cnVlKTtcbiAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlID09PSBcIlZhcmlhYmxlRGVjbGFyYXRpb25cIilcbiAgICAgIHsgdGhpcy5jaGVja1ZhcmlhYmxlRXhwb3J0KGV4cG9ydHMsIG5vZGUuZGVjbGFyYXRpb24uZGVjbGFyYXRpb25zKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgdGhpcy5jaGVja0V4cG9ydChleHBvcnRzLCBub2RlLmRlY2xhcmF0aW9uLmlkLm5hbWUsIG5vZGUuZGVjbGFyYXRpb24uaWQuc3RhcnQpOyB9XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gW107XG4gICAgbm9kZS5zb3VyY2UgPSBudWxsO1xuICB9IGVsc2UgeyAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgICBub2RlLmRlY2xhcmF0aW9uID0gbnVsbDtcbiAgICBub2RlLnNwZWNpZmllcnMgPSB0aGlzLnBhcnNlRXhwb3J0U3BlY2lmaWVycyhleHBvcnRzKTtcbiAgICBpZiAodGhpcy5lYXRDb250ZXh0dWFsKFwiZnJvbVwiKSkge1xuICAgICAgbm9kZS5zb3VyY2UgPSB0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZyA/IHRoaXMucGFyc2VFeHByQXRvbSgpIDogdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNoZWNrIGZvciBrZXl3b3JkcyB1c2VkIGFzIGxvY2FsIG5hbWVzXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUuc3BlY2lmaWVyczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHNwZWMgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMkMS5jaGVja1VucmVzZXJ2ZWQoc3BlYy5sb2NhbCk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc291cmNlID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5zZW1pY29sb24oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiKVxufTtcblxucHAkMS5jaGVja0V4cG9ydCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIHBvcykge1xuICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgaWYgKGhhcyhleHBvcnRzLCBuYW1lKSlcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwb3MsIFwiRHVwbGljYXRlIGV4cG9ydCAnXCIgKyBuYW1lICsgXCInXCIpOyB9XG4gIGV4cG9ydHNbbmFtZV0gPSB0cnVlO1xufTtcblxucHAkMS5jaGVja1BhdHRlcm5FeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBwYXQpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHR5cGUgPSBwYXQudHlwZTtcbiAgaWYgKHR5cGUgPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgeyB0aGlzLmNoZWNrRXhwb3J0KGV4cG9ydHMsIHBhdC5uYW1lLCBwYXQuc3RhcnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gXCJPYmplY3RQYXR0ZXJuXCIpXG4gICAgeyBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhdC5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICAgIHtcbiAgICAgICAgdmFyIHByb3AgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMkMS5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcHJvcC52YWx1ZSk7XG4gICAgICB9IH1cbiAgZWxzZSBpZiAodHlwZSA9PSBcIkFycmF5UGF0dGVyblwiKVxuICAgIHsgZm9yICh2YXIgaSQxID0gMCwgbGlzdCQxID0gcGF0LmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgdmFyIGVsdCA9IGxpc3QkMVtpJDFdO1xuXG4gICAgICAgIGlmIChlbHQpIHsgdGhpcyQxLmNoZWNrUGF0dGVybkV4cG9ydChleHBvcnRzLCBlbHQpOyB9XG4gICAgfSB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gXCJBc3NpZ25tZW50UGF0dGVyblwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmxlZnQpOyB9XG4gIGVsc2UgaWYgKHR5cGUgPT0gXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICAgIHsgdGhpcy5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgcGF0LmV4cHJlc3Npb24pOyB9XG59O1xuXG5wcCQxLmNoZWNrVmFyaWFibGVFeHBvcnQgPSBmdW5jdGlvbihleHBvcnRzLCBkZWNscykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoIWV4cG9ydHMpIHsgcmV0dXJuIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBkZWNsczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBkZWNsID0gbGlzdFtpXTtcblxuICAgIHRoaXMkMS5jaGVja1BhdHRlcm5FeHBvcnQoZXhwb3J0cywgZGVjbC5pZCk7XG4gIH1cbn07XG5cbnBwJDEuc2hvdWxkUGFyc2VFeHBvcnRTdGF0ZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudHlwZS5rZXl3b3JkID09PSBcInZhclwiIHx8XG4gICAgdGhpcy50eXBlLmtleXdvcmQgPT09IFwiY29uc3RcIiB8fFxuICAgIHRoaXMudHlwZS5rZXl3b3JkID09PSBcImNsYXNzXCIgfHxcbiAgICB0aGlzLnR5cGUua2V5d29yZCA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgdGhpcy5pc0xldCgpIHx8XG4gICAgdGhpcy5pc0FzeW5jRnVuY3Rpb24oKVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGV4cG9ydHMuXG5cbnBwJDEucGFyc2VFeHBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oZXhwb3J0cykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZXMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICAvLyBleHBvcnQgeyB4LCB5IGFzIHogfSBbZnJvbSAnLi4uJ11cbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMkMS5zdGFydE5vZGUoKTtcbiAgICBub2RlLmxvY2FsID0gdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgbm9kZS5leHBvcnRlZCA9IHRoaXMkMS5lYXRDb250ZXh0dWFsKFwiYXNcIikgPyB0aGlzJDEucGFyc2VJZGVudCh0cnVlKSA6IG5vZGUubG9jYWw7XG4gICAgdGhpcyQxLmNoZWNrRXhwb3J0KGV4cG9ydHMsIG5vZGUuZXhwb3J0ZWQubmFtZSwgbm9kZS5leHBvcnRlZC5zdGFydCk7XG4gICAgbm9kZXMucHVzaCh0aGlzJDEuZmluaXNoTm9kZShub2RlLCBcIkV4cG9ydFNwZWNpZmllclwiKSk7XG4gIH1cbiAgcmV0dXJuIG5vZGVzXG59O1xuXG4vLyBQYXJzZXMgaW1wb3J0IGRlY2xhcmF0aW9uLlxuXG5wcCQxLnBhcnNlSW1wb3J0ID0gZnVuY3Rpb24obm9kZSkge1xuICB0aGlzLm5leHQoKTtcbiAgLy8gaW1wb3J0ICcuLi4nXG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLnN0cmluZykge1xuICAgIG5vZGUuc3BlY2lmaWVycyA9IGVtcHR5O1xuICAgIG5vZGUuc291cmNlID0gdGhpcy5wYXJzZUV4cHJBdG9tKCk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zcGVjaWZpZXJzID0gdGhpcy5wYXJzZUltcG9ydFNwZWNpZmllcnMoKTtcbiAgICB0aGlzLmV4cGVjdENvbnRleHR1YWwoXCJmcm9tXCIpO1xuICAgIG5vZGUuc291cmNlID0gdGhpcy50eXBlID09PSB0eXBlcy5zdHJpbmcgPyB0aGlzLnBhcnNlRXhwckF0b20oKSA6IHRoaXMudW5leHBlY3RlZCgpO1xuICB9XG4gIHRoaXMuc2VtaWNvbG9uKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJJbXBvcnREZWNsYXJhdGlvblwiKVxufTtcblxuLy8gUGFyc2VzIGEgY29tbWEtc2VwYXJhdGVkIGxpc3Qgb2YgbW9kdWxlIGltcG9ydHMuXG5cbnBwJDEucGFyc2VJbXBvcnRTcGVjaWZpZXJzID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBub2RlcyA9IFtdLCBmaXJzdCA9IHRydWU7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAvLyBpbXBvcnQgZGVmYXVsdE9iaiwgeyB4LCB5IGFzIHogfSBmcm9tICcuLi4nXG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUubG9jYWwgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICB0aGlzLmNoZWNrTFZhbChub2RlLmxvY2FsLCBcImxldFwiKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkltcG9ydERlZmF1bHRTcGVjaWZpZXJcIikpO1xuICAgIGlmICghdGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IHJldHVybiBub2RlcyB9XG4gIH1cbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuc3Rhcikge1xuICAgIHZhciBub2RlJDEgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHRoaXMuZXhwZWN0Q29udGV4dHVhbChcImFzXCIpO1xuICAgIG5vZGUkMS5sb2NhbCA9IHRoaXMucGFyc2VJZGVudCgpO1xuICAgIHRoaXMuY2hlY2tMVmFsKG5vZGUkMS5sb2NhbCwgXCJsZXRcIik7XG4gICAgbm9kZXMucHVzaCh0aGlzLmZpbmlzaE5vZGUobm9kZSQxLCBcIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwiKSk7XG4gICAgcmV0dXJuIG5vZGVzXG4gIH1cbiAgdGhpcy5leHBlY3QodHlwZXMuYnJhY2VMKTtcbiAgd2hpbGUgKCF0aGlzLmVhdCh0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKCFmaXJzdCkge1xuICAgICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAodGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYSh0eXBlcy5icmFjZVIpKSB7IGJyZWFrIH1cbiAgICB9IGVsc2UgeyBmaXJzdCA9IGZhbHNlOyB9XG5cbiAgICB2YXIgbm9kZSQyID0gdGhpcyQxLnN0YXJ0Tm9kZSgpO1xuICAgIG5vZGUkMi5pbXBvcnRlZCA9IHRoaXMkMS5wYXJzZUlkZW50KHRydWUpO1xuICAgIGlmICh0aGlzJDEuZWF0Q29udGV4dHVhbChcImFzXCIpKSB7XG4gICAgICBub2RlJDIubG9jYWwgPSB0aGlzJDEucGFyc2VJZGVudCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzJDEuY2hlY2tVbnJlc2VydmVkKG5vZGUkMi5pbXBvcnRlZCk7XG4gICAgICBub2RlJDIubG9jYWwgPSBub2RlJDIuaW1wb3J0ZWQ7XG4gICAgfVxuICAgIHRoaXMkMS5jaGVja0xWYWwobm9kZSQyLmxvY2FsLCBcImxldFwiKTtcbiAgICBub2Rlcy5wdXNoKHRoaXMkMS5maW5pc2hOb2RlKG5vZGUkMiwgXCJJbXBvcnRTcGVjaWZpZXJcIikpO1xuICB9XG4gIHJldHVybiBub2Rlc1xufTtcblxuLy8gU2V0IGBFeHByZXNzaW9uU3RhdGVtZW50I2RpcmVjdGl2ZWAgcHJvcGVydHkgZm9yIGRpcmVjdGl2ZSBwcm9sb2d1ZXMuXG5wcCQxLmFkYXB0RGlyZWN0aXZlUHJvbG9ndWUgPSBmdW5jdGlvbihzdGF0ZW1lbnRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGggJiYgdGhpcy5pc0RpcmVjdGl2ZUNhbmRpZGF0ZShzdGF0ZW1lbnRzW2ldKTsgKytpKSB7XG4gICAgc3RhdGVtZW50c1tpXS5kaXJlY3RpdmUgPSBzdGF0ZW1lbnRzW2ldLmV4cHJlc3Npb24ucmF3LnNsaWNlKDEsIC0xKTtcbiAgfVxufTtcbnBwJDEuaXNEaXJlY3RpdmVDYW5kaWRhdGUgPSBmdW5jdGlvbihzdGF0ZW1lbnQpIHtcbiAgcmV0dXJuIChcbiAgICBzdGF0ZW1lbnQudHlwZSA9PT0gXCJFeHByZXNzaW9uU3RhdGVtZW50XCIgJiZcbiAgICBzdGF0ZW1lbnQuZXhwcmVzc2lvbi50eXBlID09PSBcIkxpdGVyYWxcIiAmJlxuICAgIHR5cGVvZiBzdGF0ZW1lbnQuZXhwcmVzc2lvbi52YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgIC8vIFJlamVjdCBwYXJlbnRoZXNpemVkIHN0cmluZ3MuXG4gICAgKHRoaXMuaW5wdXRbc3RhdGVtZW50LnN0YXJ0XSA9PT0gXCJcXFwiXCIgfHwgdGhpcy5pbnB1dFtzdGF0ZW1lbnQuc3RhcnRdID09PSBcIidcIilcbiAgKVxufTtcblxudmFyIHBwJDIgPSBQYXJzZXIkMS5wcm90b3R5cGU7XG5cbi8vIENvbnZlcnQgZXhpc3RpbmcgZXhwcmVzc2lvbiBhdG9tIHRvIGFzc2lnbmFibGUgcGF0dGVyblxuLy8gaWYgcG9zc2libGUuXG5cbnBwJDIudG9Bc3NpZ25hYmxlID0gZnVuY3Rpb24obm9kZSwgaXNCaW5kaW5nKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBub2RlKSB7XG4gICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgICAgaWYgKHRoaXMuaW5Bc3luYyAmJiBub2RlLm5hbWUgPT09IFwiYXdhaXRcIilcbiAgICAgICAgeyB0aGlzLnJhaXNlKG5vZGUuc3RhcnQsIFwiQ2FuIG5vdCB1c2UgJ2F3YWl0JyBhcyBpZGVudGlmaWVyIGluc2lkZSBhbiBhc3luYyBmdW5jdGlvblwiKTsgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgY2FzZSBcIkFycmF5UGF0dGVyblwiOlxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJPYmplY3RFeHByZXNzaW9uXCI6XG4gICAgICBub2RlLnR5cGUgPSBcIk9iamVjdFBhdHRlcm5cIjtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaXN0ID0gbm9kZS5wcm9wZXJ0aWVzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcHJvcCA9IGxpc3RbaV07XG5cbiAgICAgIGlmIChwcm9wLmtpbmQgIT09IFwiaW5pdFwiKSB7IHRoaXMkMS5yYWlzZShwcm9wLmtleS5zdGFydCwgXCJPYmplY3QgcGF0dGVybiBjYW4ndCBjb250YWluIGdldHRlciBvciBzZXR0ZXJcIik7IH1cbiAgICAgICAgdGhpcyQxLnRvQXNzaWduYWJsZShwcm9wLnZhbHVlLCBpc0JpbmRpbmcpO1xuICAgICAgfVxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJBcnJheUV4cHJlc3Npb25cIjpcbiAgICAgIG5vZGUudHlwZSA9IFwiQXJyYXlQYXR0ZXJuXCI7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZUxpc3Qobm9kZS5lbGVtZW50cywgaXNCaW5kaW5nKTtcbiAgICAgIGJyZWFrXG5cbiAgICBjYXNlIFwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpcbiAgICAgIGlmIChub2RlLm9wZXJhdG9yID09PSBcIj1cIikge1xuICAgICAgICBub2RlLnR5cGUgPSBcIkFzc2lnbm1lbnRQYXR0ZXJuXCI7XG4gICAgICAgIGRlbGV0ZSBub2RlLm9wZXJhdG9yO1xuICAgICAgICB0aGlzLnRvQXNzaWduYWJsZShub2RlLmxlZnQsIGlzQmluZGluZyk7XG4gICAgICAgIC8vIGZhbGxzIHRocm91Z2ggdG8gQXNzaWdubWVudFBhdHRlcm5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmFpc2Uobm9kZS5sZWZ0LmVuZCwgXCJPbmx5ICc9JyBvcGVyYXRvciBjYW4gYmUgdXNlZCBmb3Igc3BlY2lmeWluZyBkZWZhdWx0IHZhbHVlLlwiKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgIGNhc2UgXCJBc3NpZ25tZW50UGF0dGVyblwiOlxuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOlxuICAgICAgdGhpcy50b0Fzc2lnbmFibGUobm9kZS5leHByZXNzaW9uLCBpc0JpbmRpbmcpO1xuICAgICAgYnJlYWtcblxuICAgIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgICBpZiAoIWlzQmluZGluZykgeyBicmVhayB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy5yYWlzZShub2RlLnN0YXJ0LCBcIkFzc2lnbmluZyB0byBydmFsdWVcIik7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBDb252ZXJ0IGxpc3Qgb2YgZXhwcmVzc2lvbiBhdG9tcyB0byBiaW5kaW5nIGxpc3QuXG5cbnBwJDIudG9Bc3NpZ25hYmxlTGlzdCA9IGZ1bmN0aW9uKGV4cHJMaXN0LCBpc0JpbmRpbmcpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVuZCA9IGV4cHJMaXN0Lmxlbmd0aDtcbiAgaWYgKGVuZCkge1xuICAgIHZhciBsYXN0ID0gZXhwckxpc3RbZW5kIC0gMV07XG4gICAgaWYgKGxhc3QgJiYgbGFzdC50eXBlID09IFwiUmVzdEVsZW1lbnRcIikge1xuICAgICAgLS1lbmQ7XG4gICAgfSBlbHNlIGlmIChsYXN0ICYmIGxhc3QudHlwZSA9PSBcIlNwcmVhZEVsZW1lbnRcIikge1xuICAgICAgbGFzdC50eXBlID0gXCJSZXN0RWxlbWVudFwiO1xuICAgICAgdmFyIGFyZyA9IGxhc3QuYXJndW1lbnQ7XG4gICAgICB0aGlzLnRvQXNzaWduYWJsZShhcmcsIGlzQmluZGluZyk7XG4gICAgICAtLWVuZDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID09PSA2ICYmIGlzQmluZGluZyAmJiBsYXN0ICYmIGxhc3QudHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiICYmIGxhc3QuYXJndW1lbnQudHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpXG4gICAgICB7IHRoaXMudW5leHBlY3RlZChsYXN0LmFyZ3VtZW50LnN0YXJ0KTsgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZW5kOyBpKyspIHtcbiAgICB2YXIgZWx0ID0gZXhwckxpc3RbaV07XG4gICAgaWYgKGVsdCkgeyB0aGlzJDEudG9Bc3NpZ25hYmxlKGVsdCwgaXNCaW5kaW5nKTsgfVxuICB9XG4gIHJldHVybiBleHByTGlzdFxufTtcblxuLy8gUGFyc2VzIHNwcmVhZCBlbGVtZW50LlxuXG5wcCQyLnBhcnNlU3ByZWFkID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuICBub2RlLmFyZ3VtZW50ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIlNwcmVhZEVsZW1lbnRcIilcbn07XG5cbnBwJDIucGFyc2VSZXN0QmluZGluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHRoaXMubmV4dCgpO1xuXG4gIC8vIFJlc3RFbGVtZW50IGluc2lkZSBvZiBhIGZ1bmN0aW9uIHBhcmFtZXRlciBtdXN0IGJlIGFuIGlkZW50aWZpZXJcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA9PT0gNiAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLm5hbWUpXG4gICAgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuXG4gIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcblxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiUmVzdEVsZW1lbnRcIilcbn07XG5cbi8vIFBhcnNlcyBsdmFsdWUgKGFzc2lnbmFibGUpIGF0b20uXG5cbnBwJDIucGFyc2VCaW5kaW5nQXRvbSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgICB0aGlzLm5leHQoKTtcbiAgICAgIG5vZGUuZWxlbWVudHMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMuYnJhY2tldFIsIHRydWUsIHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5UGF0dGVyblwiKVxuXG4gICAgY2FzZSB0eXBlcy5icmFjZUw6XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZU9iaih0cnVlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5wYXJzZUlkZW50KClcbn07XG5cbnBwJDIucGFyc2VCaW5kaW5nTGlzdCA9IGZ1bmN0aW9uKGNsb3NlLCBhbGxvd0VtcHR5LCBhbGxvd1RyYWlsaW5nQ29tbWEpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVsdHMgPSBbXSwgZmlyc3QgPSB0cnVlO1xuICB3aGlsZSAoIXRoaXMuZWF0KGNsb3NlKSkge1xuICAgIGlmIChmaXJzdCkgeyBmaXJzdCA9IGZhbHNlOyB9XG4gICAgZWxzZSB7IHRoaXMkMS5leHBlY3QodHlwZXMuY29tbWEpOyB9XG4gICAgaWYgKGFsbG93RW1wdHkgJiYgdGhpcyQxLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgICBlbHRzLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHtcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgIHZhciByZXN0ID0gdGhpcyQxLnBhcnNlUmVzdEJpbmRpbmcoKTtcbiAgICAgIHRoaXMkMS5wYXJzZUJpbmRpbmdMaXN0SXRlbShyZXN0KTtcbiAgICAgIGVsdHMucHVzaChyZXN0KTtcbiAgICAgIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuY29tbWEpIHsgdGhpcyQxLnJhaXNlKHRoaXMkMS5zdGFydCwgXCJDb21tYSBpcyBub3QgcGVybWl0dGVkIGFmdGVyIHRoZSByZXN0IGVsZW1lbnRcIik7IH1cbiAgICAgIHRoaXMkMS5leHBlY3QoY2xvc2UpO1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVsZW0gPSB0aGlzJDEucGFyc2VNYXliZURlZmF1bHQodGhpcyQxLnN0YXJ0LCB0aGlzJDEuc3RhcnRMb2MpO1xuICAgICAgdGhpcyQxLnBhcnNlQmluZGluZ0xpc3RJdGVtKGVsZW0pO1xuICAgICAgZWx0cy5wdXNoKGVsZW0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWx0c1xufTtcblxucHAkMi5wYXJzZUJpbmRpbmdMaXN0SXRlbSA9IGZ1bmN0aW9uKHBhcmFtKSB7XG4gIHJldHVybiBwYXJhbVxufTtcblxuLy8gUGFyc2VzIGFzc2lnbm1lbnQgcGF0dGVybiBhcm91bmQgZ2l2ZW4gYXRvbSBpZiBwb3NzaWJsZS5cblxucHAkMi5wYXJzZU1heWJlRGVmYXVsdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCkge1xuICBsZWZ0ID0gbGVmdCB8fCB0aGlzLnBhcnNlQmluZGluZ0F0b20oKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYgfHwgIXRoaXMuZWF0KHR5cGVzLmVxKSkgeyByZXR1cm4gbGVmdCB9XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50UGF0dGVyblwiKVxufTtcblxuLy8gVmVyaWZ5IHRoYXQgYSBub2RlIGlzIGFuIGx2YWwg4oCUIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBhc3NpZ25lZFxuLy8gdG8uXG4vLyBiaW5kaW5nVHlwZSBjYW4gYmUgZWl0aGVyOlxuLy8gJ3ZhcicgaW5kaWNhdGluZyB0aGF0IHRoZSBsdmFsIGNyZWF0ZXMgYSAndmFyJyBiaW5kaW5nXG4vLyAnbGV0JyBpbmRpY2F0aW5nIHRoYXQgdGhlIGx2YWwgY3JlYXRlcyBhIGxleGljYWwgKCdsZXQnIG9yICdjb25zdCcpIGJpbmRpbmdcbi8vICdub25lJyBpbmRpY2F0aW5nIHRoYXQgdGhlIGJpbmRpbmcgc2hvdWxkIGJlIGNoZWNrZWQgZm9yIGlsbGVnYWwgaWRlbnRpZmllcnMsIGJ1dCBub3QgZm9yIGR1cGxpY2F0ZSByZWZlcmVuY2VzXG5cbnBwJDIuY2hlY2tMVmFsID0gZnVuY3Rpb24oZXhwciwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBzd2l0Y2ggKGV4cHIudHlwZSkge1xuICBjYXNlIFwiSWRlbnRpZmllclwiOlxuICAgIGlmICh0aGlzLnN0cmljdCAmJiB0aGlzLnJlc2VydmVkV29yZHNTdHJpY3RCaW5kLnRlc3QoZXhwci5uYW1lKSlcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZyBcIiA6IFwiQXNzaWduaW5nIHRvIFwiKSArIGV4cHIubmFtZSArIFwiIGluIHN0cmljdCBtb2RlXCIpOyB9XG4gICAgaWYgKGNoZWNrQ2xhc2hlcykge1xuICAgICAgaWYgKGhhcyhjaGVja0NsYXNoZXMsIGV4cHIubmFtZSkpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKGV4cHIuc3RhcnQsIFwiQXJndW1lbnQgbmFtZSBjbGFzaFwiKTsgfVxuICAgICAgY2hlY2tDbGFzaGVzW2V4cHIubmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoYmluZGluZ1R5cGUgJiYgYmluZGluZ1R5cGUgIT09IFwibm9uZVwiKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGJpbmRpbmdUeXBlID09PSBcInZhclwiICYmICF0aGlzLmNhbkRlY2xhcmVWYXJOYW1lKGV4cHIubmFtZSkgfHxcbiAgICAgICAgYmluZGluZ1R5cGUgIT09IFwidmFyXCIgJiYgIXRoaXMuY2FuRGVjbGFyZUxleGljYWxOYW1lKGV4cHIubmFtZSlcbiAgICAgICkge1xuICAgICAgICB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoZXhwci5zdGFydCwgKFwiSWRlbnRpZmllciAnXCIgKyAoZXhwci5uYW1lKSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kaW5nVHlwZSA9PT0gXCJ2YXJcIikge1xuICAgICAgICB0aGlzLmRlY2xhcmVWYXJOYW1lKGV4cHIubmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRlY2xhcmVMZXhpY2FsTmFtZShleHByLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJNZW1iZXJFeHByZXNzaW9uXCI6XG4gICAgaWYgKGJpbmRpbmdUeXBlKSB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShleHByLnN0YXJ0LCAoYmluZGluZ1R5cGUgPyBcIkJpbmRpbmdcIiA6IFwiQXNzaWduaW5nIHRvXCIpICsgXCIgbWVtYmVyIGV4cHJlc3Npb25cIik7IH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJPYmplY3RQYXR0ZXJuXCI6XG4gICAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBleHByLnByb3BlcnRpZXM7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAxKVxuICAgICAge1xuICAgIHZhciBwcm9wID0gbGlzdFtpXTtcblxuICAgIHRoaXMkMS5jaGVja0xWYWwocHJvcC52YWx1ZSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gIH1cbiAgICBicmVha1xuXG4gIGNhc2UgXCJBcnJheVBhdHRlcm5cIjpcbiAgICBmb3IgKHZhciBpJDEgPSAwLCBsaXN0JDEgPSBleHByLmVsZW1lbnRzOyBpJDEgPCBsaXN0JDEubGVuZ3RoOyBpJDEgKz0gMSkge1xuICAgICAgdmFyIGVsZW0gPSBsaXN0JDFbaSQxXTtcblxuICAgIGlmIChlbGVtKSB7IHRoaXMkMS5jaGVja0xWYWwoZWxlbSwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7IH1cbiAgICB9XG4gICAgYnJlYWtcblxuICBjYXNlIFwiQXNzaWdubWVudFBhdHRlcm5cIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmxlZnQsIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgY2FzZSBcIlJlc3RFbGVtZW50XCI6XG4gICAgdGhpcy5jaGVja0xWYWwoZXhwci5hcmd1bWVudCwgYmluZGluZ1R5cGUsIGNoZWNrQ2xhc2hlcyk7XG4gICAgYnJlYWtcblxuICBjYXNlIFwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpcbiAgICB0aGlzLmNoZWNrTFZhbChleHByLmV4cHJlc3Npb24sIGJpbmRpbmdUeXBlLCBjaGVja0NsYXNoZXMpO1xuICAgIGJyZWFrXG5cbiAgZGVmYXVsdDpcbiAgICB0aGlzLnJhaXNlKGV4cHIuc3RhcnQsIChiaW5kaW5nVHlwZSA/IFwiQmluZGluZ1wiIDogXCJBc3NpZ25pbmcgdG9cIikgKyBcIiBydmFsdWVcIik7XG4gIH1cbn07XG5cbi8vIEEgcmVjdXJzaXZlIGRlc2NlbnQgcGFyc2VyIG9wZXJhdGVzIGJ5IGRlZmluaW5nIGZ1bmN0aW9ucyBmb3IgYWxsXG4vLyBzeW50YWN0aWMgZWxlbWVudHMsIGFuZCByZWN1cnNpdmVseSBjYWxsaW5nIHRob3NlLCBlYWNoIGZ1bmN0aW9uXG4vLyBhZHZhbmNpbmcgdGhlIGlucHV0IHN0cmVhbSBhbmQgcmV0dXJuaW5nIGFuIEFTVCBub2RlLiBQcmVjZWRlbmNlXG4vLyBvZiBjb25zdHJ1Y3RzIChmb3IgZXhhbXBsZSwgdGhlIGZhY3QgdGhhdCBgIXhbMV1gIG1lYW5zIGAhKHhbMV0pYFxuLy8gaW5zdGVhZCBvZiBgKCF4KVsxXWAgaXMgaGFuZGxlZCBieSB0aGUgZmFjdCB0aGF0IHRoZSBwYXJzZXJcbi8vIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIHVuYXJ5IHByZWZpeCBvcGVyYXRvcnMgaXMgY2FsbGVkIGZpcnN0LCBhbmRcbi8vIGluIHR1cm4gY2FsbHMgdGhlIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGBbXWAgc3Vic2NyaXB0cyDigJQgdGhhdFxuLy8gd2F5LCBpdCdsbCByZWNlaXZlIHRoZSBub2RlIGZvciBgeFsxXWAgYWxyZWFkeSBwYXJzZWQsIGFuZCB3cmFwc1xuLy8gKnRoYXQqIGluIHRoZSB1bmFyeSBvcGVyYXRvciBub2RlLlxuLy9cbi8vIEFjb3JuIHVzZXMgYW4gW29wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2VyXVtvcHBdIHRvIGhhbmRsZSBiaW5hcnlcbi8vIG9wZXJhdG9yIHByZWNlZGVuY2UsIGJlY2F1c2UgaXQgaXMgbXVjaCBtb3JlIGNvbXBhY3QgdGhhbiB1c2luZ1xuLy8gdGhlIHRlY2huaXF1ZSBvdXRsaW5lZCBhYm92ZSwgd2hpY2ggdXNlcyBkaWZmZXJlbnQsIG5lc3Rpbmdcbi8vIGZ1bmN0aW9ucyB0byBzcGVjaWZ5IHByZWNlZGVuY2UsIGZvciBhbGwgb2YgdGhlIHRlbiBiaW5hcnlcbi8vIHByZWNlZGVuY2UgbGV2ZWxzIHRoYXQgSmF2YVNjcmlwdCBkZWZpbmVzLlxuLy9cbi8vIFtvcHBdOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdG9yLXByZWNlZGVuY2VfcGFyc2VyXG5cbnZhciBwcCQzID0gUGFyc2VyJDEucHJvdG90eXBlO1xuXG4vLyBDaGVjayBpZiBwcm9wZXJ0eSBuYW1lIGNsYXNoZXMgd2l0aCBhbHJlYWR5IGFkZGVkLlxuLy8gT2JqZWN0L2NsYXNzIGdldHRlcnMgYW5kIHNldHRlcnMgYXJlIG5vdCBhbGxvd2VkIHRvIGNsYXNoIOKAlFxuLy8gZWl0aGVyIHdpdGggZWFjaCBvdGhlciBvciB3aXRoIGFuIGluaXQgcHJvcGVydHkg4oCUIGFuZCBpblxuLy8gc3RyaWN0IG1vZGUsIGluaXQgcHJvcGVydGllcyBhcmUgYWxzbyBub3QgYWxsb3dlZCB0byBiZSByZXBlYXRlZC5cblxucHAkMy5jaGVja1Byb3BDbGFzaCA9IGZ1bmN0aW9uKHByb3AsIHByb3BIYXNoKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAocHJvcC5jb21wdXRlZCB8fCBwcm9wLm1ldGhvZCB8fCBwcm9wLnNob3J0aGFuZCkpXG4gICAgeyByZXR1cm4gfVxuICB2YXIga2V5ID0gcHJvcC5rZXk7XG4gIHZhciBuYW1lO1xuICBzd2l0Y2ggKGtleS50eXBlKSB7XG4gIGNhc2UgXCJJZGVudGlmaWVyXCI6IG5hbWUgPSBrZXkubmFtZTsgYnJlYWtcbiAgY2FzZSBcIkxpdGVyYWxcIjogbmFtZSA9IFN0cmluZyhrZXkudmFsdWUpOyBicmVha1xuICBkZWZhdWx0OiByZXR1cm5cbiAgfVxuICB2YXIga2luZCA9IHByb3Aua2luZDtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKG5hbWUgPT09IFwiX19wcm90b19fXCIgJiYga2luZCA9PT0gXCJpbml0XCIpIHtcbiAgICAgIGlmIChwcm9wSGFzaC5wcm90bykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoa2V5LnN0YXJ0LCBcIlJlZGVmaW5pdGlvbiBvZiBfX3Byb3RvX18gcHJvcGVydHlcIik7IH1cbiAgICAgIHByb3BIYXNoLnByb3RvID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cbiAgbmFtZSA9IFwiJFwiICsgbmFtZTtcbiAgdmFyIG90aGVyID0gcHJvcEhhc2hbbmFtZV07XG4gIGlmIChvdGhlcikge1xuICAgIHZhciByZWRlZmluaXRpb247XG4gICAgaWYgKGtpbmQgPT09IFwiaW5pdFwiKSB7XG4gICAgICByZWRlZmluaXRpb24gPSB0aGlzLnN0cmljdCAmJiBvdGhlci5pbml0IHx8IG90aGVyLmdldCB8fCBvdGhlci5zZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZGVmaW5pdGlvbiA9IG90aGVyLmluaXQgfHwgb3RoZXJba2luZF07XG4gICAgfVxuICAgIGlmIChyZWRlZmluaXRpb24pXG4gICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShrZXkuc3RhcnQsIFwiUmVkZWZpbml0aW9uIG9mIHByb3BlcnR5XCIpOyB9XG4gIH0gZWxzZSB7XG4gICAgb3RoZXIgPSBwcm9wSGFzaFtuYW1lXSA9IHtcbiAgICAgIGluaXQ6IGZhbHNlLFxuICAgICAgZ2V0OiBmYWxzZSxcbiAgICAgIHNldDogZmFsc2VcbiAgICB9O1xuICB9XG4gIG90aGVyW2tpbmRdID0gdHJ1ZTtcbn07XG5cbi8vICMjIyBFeHByZXNzaW9uIHBhcnNpbmdcblxuLy8gVGhlc2UgbmVzdCwgZnJvbSB0aGUgbW9zdCBnZW5lcmFsIGV4cHJlc3Npb24gdHlwZSBhdCB0aGUgdG9wIHRvXG4vLyAnYXRvbWljJywgbm9uZGl2aXNpYmxlIGV4cHJlc3Npb24gdHlwZXMgYXQgdGhlIGJvdHRvbS4gTW9zdCBvZlxuLy8gdGhlIGZ1bmN0aW9ucyB3aWxsIHNpbXBseSBsZXQgdGhlIGZ1bmN0aW9uKHMpIGJlbG93IHRoZW0gcGFyc2UsXG4vLyBhbmQsICppZiogdGhlIHN5bnRhY3RpYyBjb25zdHJ1Y3QgdGhleSBoYW5kbGUgaXMgcHJlc2VudCwgd3JhcFxuLy8gdGhlIEFTVCBub2RlIHRoYXQgdGhlIGlubmVyIHBhcnNlciBnYXZlIHRoZW0gaW4gYW5vdGhlciBub2RlLlxuXG4vLyBQYXJzZSBhIGZ1bGwgZXhwcmVzc2lvbi4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBhcmUgdXNlZCB0b1xuLy8gZm9yYmlkIHRoZSBgaW5gIG9wZXJhdG9yIChpbiBmb3IgbG9vcHMgaW5pdGFsaXphdGlvbiBleHByZXNzaW9ucylcbi8vIGFuZCBwcm92aWRlIHJlZmVyZW5jZSBmb3Igc3RvcmluZyAnPScgb3BlcmF0b3IgaW5zaWRlIHNob3J0aGFuZFxuLy8gcHJvcGVydHkgYXNzaWdubWVudCBpbiBjb250ZXh0cyB3aGVyZSBib3RoIG9iamVjdCBleHByZXNzaW9uXG4vLyBhbmQgb2JqZWN0IHBhdHRlcm4gbWlnaHQgYXBwZWFyIChzbyBpdCdzIHBvc3NpYmxlIHRvIHJhaXNlXG4vLyBkZWxheWVkIHN5bnRheCBlcnJvciBhdCBjb3JyZWN0IHBvc2l0aW9uKS5cblxucHAkMy5wYXJzZUV4cHJlc3Npb24gPSBmdW5jdGlvbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIGlmICh0aGlzLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS5leHByZXNzaW9ucyA9IFtleHByXTtcbiAgICB3aGlsZSAodGhpcy5lYXQodHlwZXMuY29tbWEpKSB7IG5vZGUuZXhwcmVzc2lvbnMucHVzaCh0aGlzJDEucGFyc2VNYXliZUFzc2lnbihub0luLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpXG4gIH1cbiAgcmV0dXJuIGV4cHJcbn07XG5cbi8vIFBhcnNlIGFuIGFzc2lnbm1lbnQgZXhwcmVzc2lvbi4gVGhpcyBpbmNsdWRlcyBhcHBsaWNhdGlvbnMgb2Zcbi8vIG9wZXJhdG9ycyBsaWtlIGArPWAuXG5cbnBwJDMucGFyc2VNYXliZUFzc2lnbiA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGFmdGVyTGVmdFBhcnNlKSB7XG4gIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIHRoaXMuaXNDb250ZXh0dWFsKFwieWllbGRcIikpIHsgcmV0dXJuIHRoaXMucGFyc2VZaWVsZCgpIH1cblxuICB2YXIgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IGZhbHNlLCBvbGRQYXJlbkFzc2lnbiA9IC0xLCBvbGRUcmFpbGluZ0NvbW1hID0gLTE7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgb2xkUGFyZW5Bc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ247XG4gICAgb2xkVHJhaWxpbmdDb21tYSA9IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYTtcbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSAtMTtcbiAgfSBlbHNlIHtcbiAgICByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnM7XG4gICAgb3duRGVzdHJ1Y3R1cmluZ0Vycm9ycyA9IHRydWU7XG4gIH1cblxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIGlmICh0aGlzLnR5cGUgPT0gdHlwZXMucGFyZW5MIHx8IHRoaXMudHlwZSA9PSB0eXBlcy5uYW1lKVxuICAgIHsgdGhpcy5wb3RlbnRpYWxBcnJvd0F0ID0gdGhpcy5zdGFydDsgfVxuICB2YXIgbGVmdCA9IHRoaXMucGFyc2VNYXliZUNvbmRpdGlvbmFsKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAoYWZ0ZXJMZWZ0UGFyc2UpIHsgbGVmdCA9IGFmdGVyTGVmdFBhcnNlLmNhbGwodGhpcywgbGVmdCwgc3RhcnRQb3MsIHN0YXJ0TG9jKTsgfVxuICBpZiAodGhpcy50eXBlLmlzQXNzaWduKSB7XG4gICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgdHJ1ZSk7XG4gICAgaWYgKCFvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IERlc3RydWN0dXJpbmdFcnJvcnMuY2FsbChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTsgfVxuICAgIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgIG5vZGUub3BlcmF0b3IgPSB0aGlzLnZhbHVlO1xuICAgIG5vZGUubGVmdCA9IHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgPyB0aGlzLnRvQXNzaWduYWJsZShsZWZ0KSA6IGxlZnQ7XG4gICAgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5zaG9ydGhhbmRBc3NpZ24gPSAtMTsgLy8gcmVzZXQgYmVjYXVzZSBzaG9ydGhhbmQgZGVmYXVsdCB3YXMgdXNlZCBjb3JyZWN0bHlcbiAgICB0aGlzLmNoZWNrTFZhbChsZWZ0KTtcbiAgICB0aGlzLm5leHQoKTtcbiAgICBub2RlLnJpZ2h0ID0gdGhpcy5wYXJzZU1heWJlQXNzaWduKG5vSW4pO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIGlmIChvd25EZXN0cnVjdHVyaW5nRXJyb3JzKSB7IHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpOyB9XG4gIH1cbiAgaWYgKG9sZFBhcmVuQXNzaWduID4gLTEpIHsgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduID0gb2xkUGFyZW5Bc3NpZ247IH1cbiAgaWYgKG9sZFRyYWlsaW5nQ29tbWEgPiAtMSkgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPSBvbGRUcmFpbGluZ0NvbW1hOyB9XG4gIHJldHVybiBsZWZ0XG59O1xuXG4vLyBQYXJzZSBhIHRlcm5hcnkgY29uZGl0aW9uYWwgKGA/OmApIG9wZXJhdG9yLlxuXG5wcCQzLnBhcnNlTWF5YmVDb25kaXRpb25hbCA9IGZ1bmN0aW9uKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgdmFyIHN0YXJ0UG9zID0gdGhpcy5zdGFydCwgc3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB2YXIgZXhwciA9IHRoaXMucGFyc2VFeHByT3BzKG5vSW4sIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICBpZiAodGhpcy5lYXQodHlwZXMucXVlc3Rpb24pKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gICAgbm9kZS50ZXN0ID0gZXhwcjtcbiAgICBub2RlLmNvbnNlcXVlbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICB0aGlzLmV4cGVjdCh0eXBlcy5jb2xvbik7XG4gICAgbm9kZS5hbHRlcm5hdGUgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24obm9Jbik7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKVxuICB9XG4gIHJldHVybiBleHByXG59O1xuXG4vLyBTdGFydCB0aGUgcHJlY2VkZW5jZSBwYXJzZXIuXG5cbnBwJDMucGFyc2VFeHByT3BzID0gZnVuY3Rpb24obm9JbiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gIHZhciBleHByID0gdGhpcy5wYXJzZU1heWJlVW5hcnkocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICBpZiAodGhpcy5jaGVja0V4cHJlc3Npb25FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykpIHsgcmV0dXJuIGV4cHIgfVxuICByZXR1cm4gZXhwci5zdGFydCA9PSBzdGFydFBvcyAmJiBleHByLnR5cGUgPT09IFwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiA/IGV4cHIgOiB0aGlzLnBhcnNlRXhwck9wKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYywgLTEsIG5vSW4pXG59O1xuXG4vLyBQYXJzZSBiaW5hcnkgb3BlcmF0b3JzIHdpdGggdGhlIG9wZXJhdG9yIHByZWNlZGVuY2UgcGFyc2luZ1xuLy8gYWxnb3JpdGhtLiBgbGVmdGAgaXMgdGhlIGxlZnQtaGFuZCBzaWRlIG9mIHRoZSBvcGVyYXRvci5cbi8vIGBtaW5QcmVjYCBwcm92aWRlcyBjb250ZXh0IHRoYXQgYWxsb3dzIHRoZSBmdW5jdGlvbiB0byBzdG9wIGFuZFxuLy8gZGVmZXIgZnVydGhlciBwYXJzZXIgdG8gb25lIG9mIGl0cyBjYWxsZXJzIHdoZW4gaXQgZW5jb3VudGVycyBhblxuLy8gb3BlcmF0b3IgdGhhdCBoYXMgYSBsb3dlciBwcmVjZWRlbmNlIHRoYW4gdGhlIHNldCBpdCBpcyBwYXJzaW5nLlxuXG5wcCQzLnBhcnNlRXhwck9wID0gZnVuY3Rpb24obGVmdCwgbGVmdFN0YXJ0UG9zLCBsZWZ0U3RhcnRMb2MsIG1pblByZWMsIG5vSW4pIHtcbiAgdmFyIHByZWMgPSB0aGlzLnR5cGUuYmlub3A7XG4gIGlmIChwcmVjICE9IG51bGwgJiYgKCFub0luIHx8IHRoaXMudHlwZSAhPT0gdHlwZXMuX2luKSkge1xuICAgIGlmIChwcmVjID4gbWluUHJlYykge1xuICAgICAgdmFyIGxvZ2ljYWwgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxPUiB8fCB0aGlzLnR5cGUgPT09IHR5cGVzLmxvZ2ljYWxBTkQ7XG4gICAgICB2YXIgb3AgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy5uZXh0KCk7XG4gICAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgICB2YXIgcmlnaHQgPSB0aGlzLnBhcnNlRXhwck9wKHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIGZhbHNlKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBwcmVjLCBub0luKTtcbiAgICAgIHZhciBub2RlID0gdGhpcy5idWlsZEJpbmFyeShsZWZ0U3RhcnRQb3MsIGxlZnRTdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKTtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwck9wKG5vZGUsIGxlZnRTdGFydFBvcywgbGVmdFN0YXJ0TG9jLCBtaW5QcmVjLCBub0luKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGVmdFxufTtcblxucHAkMy5idWlsZEJpbmFyeSA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgbGVmdCwgcmlnaHQsIG9wLCBsb2dpY2FsKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICBub2RlLmxlZnQgPSBsZWZ0O1xuICBub2RlLm9wZXJhdG9yID0gb3A7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBsb2dpY2FsID8gXCJMb2dpY2FsRXhwcmVzc2lvblwiIDogXCJCaW5hcnlFeHByZXNzaW9uXCIpXG59O1xuXG4vLyBQYXJzZSB1bmFyeSBvcGVyYXRvcnMsIGJvdGggcHJlZml4IGFuZCBwb3N0Zml4LlxuXG5wcCQzLnBhcnNlTWF5YmVVbmFyeSA9IGZ1bmN0aW9uKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHNhd1VuYXJ5KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYywgZXhwcjtcbiAgaWYgKHRoaXMuaW5Bc3luYyAmJiB0aGlzLmlzQ29udGV4dHVhbChcImF3YWl0XCIpKSB7XG4gICAgZXhwciA9IHRoaXMucGFyc2VBd2FpdCgpO1xuICAgIHNhd1VuYXJ5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUucHJlZml4KSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpLCB1cGRhdGUgPSB0aGlzLnR5cGUgPT09IHR5cGVzLmluY0RlYztcbiAgICBub2RlLm9wZXJhdG9yID0gdGhpcy52YWx1ZTtcbiAgICBub2RlLnByZWZpeCA9IHRydWU7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICAgIHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRydWUpO1xuICAgIGlmICh1cGRhdGUpIHsgdGhpcy5jaGVja0xWYWwobm9kZS5hcmd1bWVudCk7IH1cbiAgICBlbHNlIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLm9wZXJhdG9yID09PSBcImRlbGV0ZVwiICYmXG4gICAgICAgICAgICAgbm9kZS5hcmd1bWVudC50eXBlID09PSBcIklkZW50aWZpZXJcIilcbiAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKG5vZGUuc3RhcnQsIFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIik7IH1cbiAgICBlbHNlIHsgc2F3VW5hcnkgPSB0cnVlOyB9XG4gICAgZXhwciA9IHRoaXMuZmluaXNoTm9kZShub2RlLCB1cGRhdGUgPyBcIlVwZGF0ZUV4cHJlc3Npb25cIiA6IFwiVW5hcnlFeHByZXNzaW9uXCIpO1xuICB9IGVsc2Uge1xuICAgIGV4cHIgPSB0aGlzLnBhcnNlRXhwclN1YnNjcmlwdHMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgaWYgKHRoaXMuY2hlY2tFeHByZXNzaW9uRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpKSB7IHJldHVybiBleHByIH1cbiAgICB3aGlsZSAodGhpcy50eXBlLnBvc3RmaXggJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5vcGVyYXRvciA9IHRoaXMkMS52YWx1ZTtcbiAgICAgIG5vZGUkMS5wcmVmaXggPSBmYWxzZTtcbiAgICAgIG5vZGUkMS5hcmd1bWVudCA9IGV4cHI7XG4gICAgICB0aGlzJDEuY2hlY2tMVmFsKGV4cHIpO1xuICAgICAgdGhpcyQxLm5leHQoKTtcbiAgICAgIGV4cHIgPSB0aGlzJDEuZmluaXNoTm9kZShub2RlJDEsIFwiVXBkYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIXNhd1VuYXJ5ICYmIHRoaXMuZWF0KHR5cGVzLnN0YXJzdGFyKSlcbiAgICB7IHJldHVybiB0aGlzLmJ1aWxkQmluYXJ5KHN0YXJ0UG9zLCBzdGFydExvYywgZXhwciwgdGhpcy5wYXJzZU1heWJlVW5hcnkobnVsbCwgZmFsc2UpLCBcIioqXCIsIGZhbHNlKSB9XG4gIGVsc2VcbiAgICB7IHJldHVybiBleHByIH1cbn07XG5cbi8vIFBhcnNlIGNhbGwsIGRvdCwgYW5kIGBbXWAtc3Vic2NyaXB0IGV4cHJlc3Npb25zLlxuXG5wcCQzLnBhcnNlRXhwclN1YnNjcmlwdHMgPSBmdW5jdGlvbihyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgdmFyIGV4cHIgPSB0aGlzLnBhcnNlRXhwckF0b20ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHZhciBza2lwQXJyb3dTdWJzY3JpcHRzID0gZXhwci50eXBlID09PSBcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCIgJiYgdGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tTdGFydCwgdGhpcy5sYXN0VG9rRW5kKSAhPT0gXCIpXCI7XG4gIGlmICh0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB8fCBza2lwQXJyb3dTdWJzY3JpcHRzKSB7IHJldHVybiBleHByIH1cbiAgdmFyIHJlc3VsdCA9IHRoaXMucGFyc2VTdWJzY3JpcHRzKGV4cHIsIHN0YXJ0UG9zLCBzdGFydExvYyk7XG4gIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHJlc3VsdC50eXBlID09PSBcIk1lbWJlckV4cHJlc3Npb25cIikge1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEFzc2lnbiA9IC0xOyB9XG4gICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPj0gcmVzdWx0LnN0YXJ0KSB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSAtMTsgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5cbnBwJDMucGFyc2VTdWJzY3JpcHRzID0gZnVuY3Rpb24oYmFzZSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCBub0NhbGxzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBtYXliZUFzeW5jQXJyb3cgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiBiYXNlLnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmIGJhc2UubmFtZSA9PT0gXCJhc3luY1wiICYmXG4gICAgICB0aGlzLmxhc3RUb2tFbmQgPT0gYmFzZS5lbmQgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCk7XG4gIGZvciAodmFyIGNvbXB1dGVkID0gKHZvaWQgMCk7Oykge1xuICAgIGlmICgoY29tcHV0ZWQgPSB0aGlzJDEuZWF0KHR5cGVzLmJyYWNrZXRMKSkgfHwgdGhpcyQxLmVhdCh0eXBlcy5kb3QpKSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMkMS5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpO1xuICAgICAgbm9kZS5vYmplY3QgPSBiYXNlO1xuICAgICAgbm9kZS5wcm9wZXJ0eSA9IGNvbXB1dGVkID8gdGhpcyQxLnBhcnNlRXhwcmVzc2lvbigpIDogdGhpcyQxLnBhcnNlSWRlbnQodHJ1ZSk7XG4gICAgICBub2RlLmNvbXB1dGVkID0gISFjb21wdXRlZDtcbiAgICAgIGlmIChjb21wdXRlZCkgeyB0aGlzJDEuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTsgfVxuICAgICAgYmFzZSA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUsIFwiTWVtYmVyRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKCFub0NhbGxzICYmIHRoaXMkMS5lYXQodHlwZXMucGFyZW5MKSkge1xuICAgICAgdmFyIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMgPSBuZXcgRGVzdHJ1Y3R1cmluZ0Vycm9ycywgb2xkWWllbGRQb3MgPSB0aGlzJDEueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcyQxLmF3YWl0UG9zO1xuICAgICAgdGhpcyQxLnlpZWxkUG9zID0gMDtcbiAgICAgIHRoaXMkMS5hd2FpdFBvcyA9IDA7XG4gICAgICB2YXIgZXhwckxpc3QgPSB0aGlzJDEucGFyc2VFeHByTGlzdCh0eXBlcy5wYXJlblIsIHRoaXMkMS5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgsIGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChtYXliZUFzeW5jQXJyb3cgJiYgIXRoaXMkMS5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzJDEuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgICB0aGlzJDEuY2hlY2tQYXR0ZXJuRXJyb3JzKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIGZhbHNlKTtcbiAgICAgICAgdGhpcyQxLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICAgICAgICB0aGlzJDEueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgICAgdGhpcyQxLmF3YWl0UG9zID0gb2xkQXdhaXRQb3M7XG4gICAgICAgIHJldHVybiB0aGlzJDEucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcyQxLnN0YXJ0Tm9kZUF0KHN0YXJ0UG9zLCBzdGFydExvYyksIGV4cHJMaXN0LCB0cnVlKVxuICAgICAgfVxuICAgICAgdGhpcyQxLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICAgIHRoaXMkMS55aWVsZFBvcyA9IG9sZFlpZWxkUG9zIHx8IHRoaXMkMS55aWVsZFBvcztcbiAgICAgIHRoaXMkMS5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zIHx8IHRoaXMkMS5hd2FpdFBvcztcbiAgICAgIHZhciBub2RlJDEgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMS5jYWxsZWUgPSBiYXNlO1xuICAgICAgbm9kZSQxLmFyZ3VtZW50cyA9IGV4cHJMaXN0O1xuICAgICAgYmFzZSA9IHRoaXMkMS5maW5pc2hOb2RlKG5vZGUkMSwgXCJDYWxsRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5iYWNrUXVvdGUpIHtcbiAgICAgIHZhciBub2RlJDIgPSB0aGlzJDEuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICAgIG5vZGUkMi50YWcgPSBiYXNlO1xuICAgICAgbm9kZSQyLnF1YXNpID0gdGhpcyQxLnBhcnNlVGVtcGxhdGUoe2lzVGFnZ2VkOiB0cnVlfSk7XG4gICAgICBiYXNlID0gdGhpcyQxLmZpbmlzaE5vZGUobm9kZSQyLCBcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJhc2VcbiAgICB9XG4gIH1cbn07XG5cbi8vIFBhcnNlIGFuIGF0b21pYyBleHByZXNzaW9uIOKAlCBlaXRoZXIgYSBzaW5nbGUgdG9rZW4gdGhhdCBpcyBhblxuLy8gZXhwcmVzc2lvbiwgYW4gZXhwcmVzc2lvbiBzdGFydGVkIGJ5IGEga2V5d29yZCBsaWtlIGBmdW5jdGlvbmAgb3Jcbi8vIGBuZXdgLCBvciBhbiBleHByZXNzaW9uIHdyYXBwZWQgaW4gcHVuY3R1YXRpb24gbGlrZSBgKClgLCBgW11gLFxuLy8gb3IgYHt9YC5cblxucHAkMy5wYXJzZUV4cHJBdG9tID0gZnVuY3Rpb24ocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgbm9kZSwgY2FuQmVBcnJvdyA9IHRoaXMucG90ZW50aWFsQXJyb3dBdCA9PSB0aGlzLnN0YXJ0O1xuICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICBjYXNlIHR5cGVzLl9zdXBlcjpcbiAgICBpZiAoIXRoaXMuaW5GdW5jdGlvbilcbiAgICAgIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0LCBcIidzdXBlcicgb3V0c2lkZSBvZiBmdW5jdGlvbiBvciBjbGFzc1wiKTsgfVxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIC8vIFRoZSBgc3VwZXJgIGtleXdvcmQgY2FuIGFwcGVhciBhdCBiZWxvdzpcbiAgICAvLyBTdXBlclByb3BlcnR5OlxuICAgIC8vICAgICBzdXBlciBbIEV4cHJlc3Npb24gXVxuICAgIC8vICAgICBzdXBlciAuIElkZW50aWZpZXJOYW1lXG4gICAgLy8gU3VwZXJDYWxsOlxuICAgIC8vICAgICBzdXBlciBBcmd1bWVudHNcbiAgICBpZiAodGhpcy50eXBlICE9PSB0eXBlcy5kb3QgJiYgdGhpcy50eXBlICE9PSB0eXBlcy5icmFja2V0TCAmJiB0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuTClcbiAgICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiU3VwZXJcIilcblxuICBjYXNlIHR5cGVzLl90aGlzOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUaGlzRXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMubmFtZTpcbiAgICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdmFyIGlkID0gdGhpcy5wYXJzZUlkZW50KHRoaXMudHlwZSAhPT0gdHlwZXMubmFtZSk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiAhdGhpcy5jYW5JbnNlcnRTZW1pY29sb24oKSAmJiB0aGlzLmVhdCh0eXBlcy5fZnVuY3Rpb24pKVxuICAgICAgeyByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgZmFsc2UsIGZhbHNlLCB0cnVlKSB9XG4gICAgaWYgKGNhbkJlQXJyb3cgJiYgIXRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkpIHtcbiAgICAgIGlmICh0aGlzLmVhdCh0eXBlcy5hcnJvdykpXG4gICAgICAgIHsgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBbaWRdLCBmYWxzZSkgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA4ICYmIGlkLm5hbWUgPT09IFwiYXN5bmNcIiAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLm5hbWUpIHtcbiAgICAgICAgaWQgPSB0aGlzLnBhcnNlSWRlbnQoKTtcbiAgICAgICAgaWYgKHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgIXRoaXMuZWF0KHR5cGVzLmFycm93KSlcbiAgICAgICAgICB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyb3dFeHByZXNzaW9uKHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKSwgW2lkXSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkXG5cbiAgY2FzZSB0eXBlcy5yZWdleHA6XG4gICAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICBub2RlID0gdGhpcy5wYXJzZUxpdGVyYWwodmFsdWUudmFsdWUpO1xuICAgIG5vZGUucmVnZXggPSB7cGF0dGVybjogdmFsdWUucGF0dGVybiwgZmxhZ3M6IHZhbHVlLmZsYWdzfTtcbiAgICByZXR1cm4gbm9kZVxuXG4gIGNhc2UgdHlwZXMubnVtOiBjYXNlIHR5cGVzLnN0cmluZzpcbiAgICByZXR1cm4gdGhpcy5wYXJzZUxpdGVyYWwodGhpcy52YWx1ZSlcblxuICBjYXNlIHR5cGVzLl9udWxsOiBjYXNlIHR5cGVzLl90cnVlOiBjYXNlIHR5cGVzLl9mYWxzZTpcbiAgICBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgICBub2RlLnZhbHVlID0gdGhpcy50eXBlID09PSB0eXBlcy5fbnVsbCA/IG51bGwgOiB0aGlzLnR5cGUgPT09IHR5cGVzLl90cnVlO1xuICAgIG5vZGUucmF3ID0gdGhpcy50eXBlLmtleXdvcmQ7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkxpdGVyYWxcIilcblxuICBjYXNlIHR5cGVzLnBhcmVuTDpcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LCBleHByID0gdGhpcy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uKGNhbkJlQXJyb3cpO1xuICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gICAgICBpZiAocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycy5wYXJlbnRoZXNpemVkQXNzaWduIDwgMCAmJiAhdGhpcy5pc1NpbXBsZUFzc2lnblRhcmdldChleHByKSlcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnBhcmVudGhlc2l6ZWRBc3NpZ24gPSBzdGFydDsgfVxuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMucGFyZW50aGVzaXplZEJpbmQgPSBzdGFydDsgfVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuXG4gIGNhc2UgdHlwZXMuYnJhY2tldEw6XG4gICAgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gICAgdGhpcy5uZXh0KCk7XG4gICAgbm9kZS5lbGVtZW50cyA9IHRoaXMucGFyc2VFeHByTGlzdCh0eXBlcy5icmFja2V0UiwgdHJ1ZSwgdHJ1ZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIkFycmF5RXhwcmVzc2lvblwiKVxuXG4gIGNhc2UgdHlwZXMuYnJhY2VMOlxuICAgIHJldHVybiB0aGlzLnBhcnNlT2JqKGZhbHNlLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKVxuXG4gIGNhc2UgdHlwZXMuX2Z1bmN0aW9uOlxuICAgIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24obm9kZSwgZmFsc2UpXG5cbiAgY2FzZSB0eXBlcy5fY2xhc3M6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VDbGFzcyh0aGlzLnN0YXJ0Tm9kZSgpLCBmYWxzZSlcblxuICBjYXNlIHR5cGVzLl9uZXc6XG4gICAgcmV0dXJuIHRoaXMucGFyc2VOZXcoKVxuXG4gIGNhc2UgdHlwZXMuYmFja1F1b3RlOlxuICAgIHJldHVybiB0aGlzLnBhcnNlVGVtcGxhdGUoKVxuXG4gIGRlZmF1bHQ6XG4gICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gIH1cbn07XG5cbnBwJDMucGFyc2VMaXRlcmFsID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICBub2RlLnZhbHVlID0gdmFsdWU7XG4gIG5vZGUucmF3ID0gdGhpcy5pbnB1dC5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLmVuZCk7XG4gIHRoaXMubmV4dCgpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiTGl0ZXJhbFwiKVxufTtcblxucHAkMy5wYXJzZVBhcmVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV4cGVjdCh0eXBlcy5wYXJlbkwpO1xuICB2YXIgdmFsID0gdGhpcy5wYXJzZUV4cHJlc3Npb24oKTtcbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcbiAgcmV0dXJuIHZhbFxufTtcblxucHAkMy5wYXJzZVBhcmVuQW5kRGlzdGluZ3Vpc2hFeHByZXNzaW9uID0gZnVuY3Rpb24oY2FuQmVBcnJvdykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBzdGFydExvYyA9IHRoaXMuc3RhcnRMb2MsIHZhbCwgYWxsb3dUcmFpbGluZ0NvbW1hID0gdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDg7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHRoaXMubmV4dCgpO1xuXG4gICAgdmFyIGlubmVyU3RhcnRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lclN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB2YXIgZXhwckxpc3QgPSBbXSwgZmlyc3QgPSB0cnVlLCBsYXN0SXNDb21tYSA9IGZhbHNlO1xuICAgIHZhciByZWZEZXN0cnVjdHVyaW5nRXJyb3JzID0gbmV3IERlc3RydWN0dXJpbmdFcnJvcnMsIG9sZFlpZWxkUG9zID0gdGhpcy55aWVsZFBvcywgb2xkQXdhaXRQb3MgPSB0aGlzLmF3YWl0UG9zLCBzcHJlYWRTdGFydCwgaW5uZXJQYXJlblN0YXJ0O1xuICAgIHRoaXMueWllbGRQb3MgPSAwO1xuICAgIHRoaXMuYXdhaXRQb3MgPSAwO1xuICAgIHdoaWxlICh0aGlzLnR5cGUgIT09IHR5cGVzLnBhcmVuUikge1xuICAgICAgZmlyc3QgPyBmaXJzdCA9IGZhbHNlIDogdGhpcyQxLmV4cGVjdCh0eXBlcy5jb21tYSk7XG4gICAgICBpZiAoYWxsb3dUcmFpbGluZ0NvbW1hICYmIHRoaXMkMS5hZnRlclRyYWlsaW5nQ29tbWEodHlwZXMucGFyZW5SLCB0cnVlKSkge1xuICAgICAgICBsYXN0SXNDb21tYSA9IHRydWU7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKHRoaXMkMS50eXBlID09PSB0eXBlcy5lbGxpcHNpcykge1xuICAgICAgICBzcHJlYWRTdGFydCA9IHRoaXMkMS5zdGFydDtcbiAgICAgICAgZXhwckxpc3QucHVzaCh0aGlzJDEucGFyc2VQYXJlbkl0ZW0odGhpcyQxLnBhcnNlUmVzdEJpbmRpbmcoKSkpO1xuICAgICAgICBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLmNvbW1hKSB7IHRoaXMkMS5yYWlzZSh0aGlzJDEuc3RhcnQsIFwiQ29tbWEgaXMgbm90IHBlcm1pdHRlZCBhZnRlciB0aGUgcmVzdCBlbGVtZW50XCIpOyB9XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLnBhcmVuTCAmJiAhaW5uZXJQYXJlblN0YXJ0KSB7XG4gICAgICAgICAgaW5uZXJQYXJlblN0YXJ0ID0gdGhpcyQxLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGV4cHJMaXN0LnB1c2godGhpcyQxLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMsIHRoaXMkMS5wYXJzZVBhcmVuSXRlbSkpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaW5uZXJFbmRQb3MgPSB0aGlzLnN0YXJ0LCBpbm5lckVuZExvYyA9IHRoaXMuc3RhcnRMb2M7XG4gICAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5SKTtcblxuICAgIGlmIChjYW5CZUFycm93ICYmICF0aGlzLmNhbkluc2VydFNlbWljb2xvbigpICYmIHRoaXMuZWF0KHR5cGVzLmFycm93KSkge1xuICAgICAgdGhpcy5jaGVja1BhdHRlcm5FcnJvcnMocmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycywgZmFsc2UpO1xuICAgICAgdGhpcy5jaGVja1lpZWxkQXdhaXRJbkRlZmF1bHRQYXJhbXMoKTtcbiAgICAgIGlmIChpbm5lclBhcmVuU3RhcnQpIHsgdGhpcy51bmV4cGVjdGVkKGlubmVyUGFyZW5TdGFydCk7IH1cbiAgICAgIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgICAgIHRoaXMuYXdhaXRQb3MgPSBvbGRBd2FpdFBvcztcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGFyZW5BcnJvd0xpc3Qoc3RhcnRQb3MsIHN0YXJ0TG9jLCBleHByTGlzdClcbiAgICB9XG5cbiAgICBpZiAoIWV4cHJMaXN0Lmxlbmd0aCB8fCBsYXN0SXNDb21tYSkgeyB0aGlzLnVuZXhwZWN0ZWQodGhpcy5sYXN0VG9rU3RhcnQpOyB9XG4gICAgaWYgKHNwcmVhZFN0YXJ0KSB7IHRoaXMudW5leHBlY3RlZChzcHJlYWRTdGFydCk7IH1cbiAgICB0aGlzLmNoZWNrRXhwcmVzc2lvbkVycm9ycyhyZWZEZXN0cnVjdHVyaW5nRXJyb3JzLCB0cnVlKTtcbiAgICB0aGlzLnlpZWxkUG9zID0gb2xkWWllbGRQb3MgfHwgdGhpcy55aWVsZFBvcztcbiAgICB0aGlzLmF3YWl0UG9zID0gb2xkQXdhaXRQb3MgfHwgdGhpcy5hd2FpdFBvcztcblxuICAgIGlmIChleHByTGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB2YWwgPSB0aGlzLnN0YXJ0Tm9kZUF0KGlubmVyU3RhcnRQb3MsIGlubmVyU3RhcnRMb2MpO1xuICAgICAgdmFsLmV4cHJlc3Npb25zID0gZXhwckxpc3Q7XG4gICAgICB0aGlzLmZpbmlzaE5vZGVBdCh2YWwsIFwiU2VxdWVuY2VFeHByZXNzaW9uXCIsIGlubmVyRW5kUG9zLCBpbm5lckVuZExvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IGV4cHJMaXN0WzBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWwgPSB0aGlzLnBhcnNlUGFyZW5FeHByZXNzaW9uKCk7XG4gIH1cblxuICBpZiAodGhpcy5vcHRpb25zLnByZXNlcnZlUGFyZW5zKSB7XG4gICAgdmFyIHBhciA9IHRoaXMuc3RhcnROb2RlQXQoc3RhcnRQb3MsIHN0YXJ0TG9jKTtcbiAgICBwYXIuZXhwcmVzc2lvbiA9IHZhbDtcbiAgICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKHBhciwgXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufTtcblxucHAkMy5wYXJzZVBhcmVuSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW1cbn07XG5cbnBwJDMucGFyc2VQYXJlbkFycm93TGlzdCA9IGZ1bmN0aW9uKHN0YXJ0UG9zLCBzdGFydExvYywgZXhwckxpc3QpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VBcnJvd0V4cHJlc3Npb24odGhpcy5zdGFydE5vZGVBdChzdGFydFBvcywgc3RhcnRMb2MpLCBleHByTGlzdClcbn07XG5cbi8vIE5ldydzIHByZWNlZGVuY2UgaXMgc2xpZ2h0bHkgdHJpY2t5LiBJdCBtdXN0IGFsbG93IGl0cyBhcmd1bWVudCB0b1xuLy8gYmUgYSBgW11gIG9yIGRvdCBzdWJzY3JpcHQgZXhwcmVzc2lvbiwgYnV0IG5vdCBhIGNhbGwg4oCUIGF0IGxlYXN0LFxuLy8gbm90IHdpdGhvdXQgd3JhcHBpbmcgaXQgaW4gcGFyZW50aGVzZXMuIFRodXMsIGl0IHVzZXMgdGhlIG5vQ2FsbHNcbi8vIGFyZ3VtZW50IHRvIHBhcnNlU3Vic2NyaXB0cyB0byBwcmV2ZW50IGl0IGZyb20gY29uc3VtaW5nIHRoZVxuLy8gYXJndW1lbnQgbGlzdC5cblxudmFyIGVtcHR5JDEgPSBbXTtcblxucHAkMy5wYXJzZU5ldyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCk7XG4gIHZhciBtZXRhID0gdGhpcy5wYXJzZUlkZW50KHRydWUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYgJiYgdGhpcy5lYXQodHlwZXMuZG90KSkge1xuICAgIG5vZGUubWV0YSA9IG1ldGE7XG4gICAgbm9kZS5wcm9wZXJ0eSA9IHRoaXMucGFyc2VJZGVudCh0cnVlKTtcbiAgICBpZiAobm9kZS5wcm9wZXJ0eS5uYW1lICE9PSBcInRhcmdldFwiKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5wcm9wZXJ0eS5zdGFydCwgXCJUaGUgb25seSB2YWxpZCBtZXRhIHByb3BlcnR5IGZvciBuZXcgaXMgbmV3LnRhcmdldFwiKTsgfVxuICAgIGlmICghdGhpcy5pbkZ1bmN0aW9uKVxuICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJuZXcudGFyZ2V0IGNhbiBvbmx5IGJlIHVzZWQgaW4gZnVuY3Rpb25zXCIpOyB9XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk1ldGFQcm9wZXJ0eVwiKVxuICB9XG4gIHZhciBzdGFydFBvcyA9IHRoaXMuc3RhcnQsIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgbm9kZS5jYWxsZWUgPSB0aGlzLnBhcnNlU3Vic2NyaXB0cyh0aGlzLnBhcnNlRXhwckF0b20oKSwgc3RhcnRQb3MsIHN0YXJ0TG9jLCB0cnVlKTtcbiAgaWYgKHRoaXMuZWF0KHR5cGVzLnBhcmVuTCkpIHsgbm9kZS5hcmd1bWVudHMgPSB0aGlzLnBhcnNlRXhwckxpc3QodHlwZXMucGFyZW5SLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCwgZmFsc2UpOyB9XG4gIGVsc2UgeyBub2RlLmFyZ3VtZW50cyA9IGVtcHR5JDE7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoTm9kZShub2RlLCBcIk5ld0V4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIHRlbXBsYXRlIGV4cHJlc3Npb24uXG5cbnBwJDMucGFyc2VUZW1wbGF0ZUVsZW1lbnQgPSBmdW5jdGlvbihyZWYpIHtcbiAgdmFyIGlzVGFnZ2VkID0gcmVmLmlzVGFnZ2VkO1xuXG4gIHZhciBlbGVtID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuaW52YWxpZFRlbXBsYXRlKSB7XG4gICAgaWYgKCFpc1RhZ2dlZCkge1xuICAgICAgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHRoaXMuc3RhcnQsIFwiQmFkIGVzY2FwZSBzZXF1ZW5jZSBpbiB1bnRhZ2dlZCB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgIH1cbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLnZhbHVlLFxuICAgICAgY29va2VkOiBudWxsXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBlbGVtLnZhbHVlID0ge1xuICAgICAgcmF3OiB0aGlzLmlucHV0LnNsaWNlKHRoaXMuc3RhcnQsIHRoaXMuZW5kKS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpLFxuICAgICAgY29va2VkOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgZWxlbS50YWlsID0gdGhpcy50eXBlID09PSB0eXBlcy5iYWNrUXVvdGU7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUoZWxlbSwgXCJUZW1wbGF0ZUVsZW1lbnRcIilcbn07XG5cbnBwJDMucGFyc2VUZW1wbGF0ZSA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgdGhpcyQxID0gdGhpcztcbiAgaWYgKCByZWYgPT09IHZvaWQgMCApIHJlZiA9IHt9O1xuICB2YXIgaXNUYWdnZWQgPSByZWYuaXNUYWdnZWQ7IGlmICggaXNUYWdnZWQgPT09IHZvaWQgMCApIGlzVGFnZ2VkID0gZmFsc2U7XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5leHByZXNzaW9ucyA9IFtdO1xuICB2YXIgY3VyRWx0ID0gdGhpcy5wYXJzZVRlbXBsYXRlRWxlbWVudCh7aXNUYWdnZWQ6IGlzVGFnZ2VkfSk7XG4gIG5vZGUucXVhc2lzID0gW2N1ckVsdF07XG4gIHdoaWxlICghY3VyRWx0LnRhaWwpIHtcbiAgICB0aGlzJDEuZXhwZWN0KHR5cGVzLmRvbGxhckJyYWNlTCk7XG4gICAgbm9kZS5leHByZXNzaW9ucy5wdXNoKHRoaXMkMS5wYXJzZUV4cHJlc3Npb24oKSk7XG4gICAgdGhpcyQxLmV4cGVjdCh0eXBlcy5icmFjZVIpO1xuICAgIG5vZGUucXVhc2lzLnB1c2goY3VyRWx0ID0gdGhpcyQxLnBhcnNlVGVtcGxhdGVFbGVtZW50KHtpc1RhZ2dlZDogaXNUYWdnZWR9KSk7XG4gIH1cbiAgdGhpcy5uZXh0KCk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJUZW1wbGF0ZUxpdGVyYWxcIilcbn07XG5cbnBwJDMuaXNBc3luY1Byb3AgPSBmdW5jdGlvbihwcm9wKSB7XG4gIHJldHVybiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIiAmJiBwcm9wLmtleS5uYW1lID09PSBcImFzeW5jXCIgJiZcbiAgICAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuYnJhY2tldEwgfHwgdGhpcy50eXBlLmtleXdvcmQpICYmXG4gICAgIWxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnN0YXJ0KSlcbn07XG5cbi8vIFBhcnNlIGFuIG9iamVjdCBsaXRlcmFsIG9yIGJpbmRpbmcgcGF0dGVybi5cblxucHAkMy5wYXJzZU9iaiA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZSA9IHRoaXMuc3RhcnROb2RlKCksIGZpcnN0ID0gdHJ1ZSwgcHJvcEhhc2ggPSB7fTtcbiAgbm9kZS5wcm9wZXJ0aWVzID0gW107XG4gIHRoaXMubmV4dCgpO1xuICB3aGlsZSAoIXRoaXMuZWF0KHR5cGVzLmJyYWNlUikpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzJDEuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmICh0aGlzJDEuYWZ0ZXJUcmFpbGluZ0NvbW1hKHR5cGVzLmJyYWNlUikpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBwcm9wID0gdGhpcyQxLnBhcnNlUHJvcGVydHkoaXNQYXR0ZXJuLCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICB0aGlzJDEuY2hlY2tQcm9wQ2xhc2gocHJvcCwgcHJvcEhhc2gpO1xuICAgIG5vZGUucHJvcGVydGllcy5wdXNoKHByb3ApO1xuICB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgaXNQYXR0ZXJuID8gXCJPYmplY3RQYXR0ZXJuXCIgOiBcIk9iamVjdEV4cHJlc3Npb25cIilcbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eSA9IGZ1bmN0aW9uKGlzUGF0dGVybiwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICB2YXIgcHJvcCA9IHRoaXMuc3RhcnROb2RlKCksIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2M7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIHByb3AubWV0aG9kID0gZmFsc2U7XG4gICAgcHJvcC5zaG9ydGhhbmQgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuIHx8IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgIHN0YXJ0UG9zID0gdGhpcy5zdGFydDtcbiAgICAgIHN0YXJ0TG9jID0gdGhpcy5zdGFydExvYztcbiAgICB9XG4gICAgaWYgKCFpc1BhdHRlcm4pXG4gICAgICB7IGlzR2VuZXJhdG9yID0gdGhpcy5lYXQodHlwZXMuc3Rhcik7IH1cbiAgfVxuICB0aGlzLnBhcnNlUHJvcGVydHlOYW1lKHByb3ApO1xuICBpZiAoIWlzUGF0dGVybiAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOCAmJiAhaXNHZW5lcmF0b3IgJiYgdGhpcy5pc0FzeW5jUHJvcChwcm9wKSkge1xuICAgIGlzQXN5bmMgPSB0cnVlO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIH0gZWxzZSB7XG4gICAgaXNBc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMucGFyc2VQcm9wZXJ0eVZhbHVlKHByb3AsIGlzUGF0dGVybiwgaXNHZW5lcmF0b3IsIGlzQXN5bmMsIHN0YXJ0UG9zLCBzdGFydExvYywgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUocHJvcCwgXCJQcm9wZXJ0eVwiKVxufTtcblxucHAkMy5wYXJzZVByb3BlcnR5VmFsdWUgPSBmdW5jdGlvbihwcm9wLCBpc1BhdHRlcm4sIGlzR2VuZXJhdG9yLCBpc0FzeW5jLCBzdGFydFBvcywgc3RhcnRMb2MsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgaWYgKChpc0dlbmVyYXRvciB8fCBpc0FzeW5jKSAmJiB0aGlzLnR5cGUgPT09IHR5cGVzLmNvbG9uKVxuICAgIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cblxuICBpZiAodGhpcy5lYXQodHlwZXMuY29sb24pKSB7XG4gICAgcHJvcC52YWx1ZSA9IGlzUGF0dGVybiA/IHRoaXMucGFyc2VNYXliZURlZmF1bHQodGhpcy5zdGFydCwgdGhpcy5zdGFydExvYykgOiB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oZmFsc2UsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2ICYmIHRoaXMudHlwZSA9PT0gdHlwZXMucGFyZW5MKSB7XG4gICAgaWYgKGlzUGF0dGVybikgeyB0aGlzLnVuZXhwZWN0ZWQoKTsgfVxuICAgIHByb3Aua2luZCA9IFwiaW5pdFwiO1xuICAgIHByb3AubWV0aG9kID0gdHJ1ZTtcbiAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1ldGhvZChpc0dlbmVyYXRvciwgaXNBc3luYyk7XG4gIH0gZWxzZSBpZiAoIWlzUGF0dGVybiAmJlxuICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA1ICYmICFwcm9wLmNvbXB1dGVkICYmIHByb3Aua2V5LnR5cGUgPT09IFwiSWRlbnRpZmllclwiICYmXG4gICAgICAgICAgICAgKHByb3Aua2V5Lm5hbWUgPT09IFwiZ2V0XCIgfHwgcHJvcC5rZXkubmFtZSA9PT0gXCJzZXRcIikgJiZcbiAgICAgICAgICAgICAodGhpcy50eXBlICE9IHR5cGVzLmNvbW1hICYmIHRoaXMudHlwZSAhPSB0eXBlcy5icmFjZVIpKSB7XG4gICAgaWYgKGlzR2VuZXJhdG9yIHx8IGlzQXN5bmMpIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbiAgICBwcm9wLmtpbmQgPSBwcm9wLmtleS5uYW1lO1xuICAgIHRoaXMucGFyc2VQcm9wZXJ0eU5hbWUocHJvcCk7XG4gICAgcHJvcC52YWx1ZSA9IHRoaXMucGFyc2VNZXRob2QoZmFsc2UpO1xuICAgIHZhciBwYXJhbUNvdW50ID0gcHJvcC5raW5kID09PSBcImdldFwiID8gMCA6IDE7XG4gICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCAhPT0gcGFyYW1Db3VudCkge1xuICAgICAgdmFyIHN0YXJ0ID0gcHJvcC52YWx1ZS5zdGFydDtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwiZ2V0XCIpXG4gICAgICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcImdldHRlciBzaG91bGQgaGF2ZSBubyBwYXJhbXNcIik7IH1cbiAgICAgIGVsc2VcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIFwic2V0dGVyIHNob3VsZCBoYXZlIGV4YWN0bHkgb25lIHBhcmFtXCIpOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wLmtpbmQgPT09IFwic2V0XCIgJiYgcHJvcC52YWx1ZS5wYXJhbXNbMF0udHlwZSA9PT0gXCJSZXN0RWxlbWVudFwiKVxuICAgICAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShwcm9wLnZhbHVlLnBhcmFtc1swXS5zdGFydCwgXCJTZXR0ZXIgY2Fubm90IHVzZSByZXN0IHBhcmFtc1wiKTsgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiAhcHJvcC5jb21wdXRlZCAmJiBwcm9wLmtleS50eXBlID09PSBcIklkZW50aWZpZXJcIikge1xuICAgIHRoaXMuY2hlY2tVbnJlc2VydmVkKHByb3Aua2V5KTtcbiAgICBwcm9wLmtpbmQgPSBcImluaXRcIjtcbiAgICBpZiAoaXNQYXR0ZXJuKSB7XG4gICAgICBwcm9wLnZhbHVlID0gdGhpcy5wYXJzZU1heWJlRGVmYXVsdChzdGFydFBvcywgc3RhcnRMb2MsIHByb3Aua2V5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gdHlwZXMuZXEgJiYgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycykge1xuICAgICAgaWYgKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMuc2hvcnRoYW5kQXNzaWduIDwgMClcbiAgICAgICAgeyByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnNob3J0aGFuZEFzc2lnbiA9IHRoaXMuc3RhcnQ7IH1cbiAgICAgIHByb3AudmFsdWUgPSB0aGlzLnBhcnNlTWF5YmVEZWZhdWx0KHN0YXJ0UG9zLCBzdGFydExvYywgcHJvcC5rZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLnZhbHVlID0gcHJvcC5rZXk7XG4gICAgfVxuICAgIHByb3Auc2hvcnRoYW5kID0gdHJ1ZTtcbiAgfSBlbHNlIHsgdGhpcy51bmV4cGVjdGVkKCk7IH1cbn07XG5cbnBwJDMucGFyc2VQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbihwcm9wKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikge1xuICAgIGlmICh0aGlzLmVhdCh0eXBlcy5icmFja2V0TCkpIHtcbiAgICAgIHByb3AuY29tcHV0ZWQgPSB0cnVlO1xuICAgICAgcHJvcC5rZXkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICAgIHRoaXMuZXhwZWN0KHR5cGVzLmJyYWNrZXRSKTtcbiAgICAgIHJldHVybiBwcm9wLmtleVxuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmNvbXB1dGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcm9wLmtleSA9IHRoaXMudHlwZSA9PT0gdHlwZXMubnVtIHx8IHRoaXMudHlwZSA9PT0gdHlwZXMuc3RyaW5nID8gdGhpcy5wYXJzZUV4cHJBdG9tKCkgOiB0aGlzLnBhcnNlSWRlbnQodHJ1ZSlcbn07XG5cbi8vIEluaXRpYWxpemUgZW1wdHkgZnVuY3Rpb24gbm9kZS5cblxucHAkMy5pbml0RnVuY3Rpb24gPSBmdW5jdGlvbihub2RlKSB7XG4gIG5vZGUuaWQgPSBudWxsO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICBub2RlLmdlbmVyYXRvciA9IGZhbHNlO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOClcbiAgICB7IG5vZGUuYXN5bmMgPSBmYWxzZTsgfVxufTtcblxuLy8gUGFyc2Ugb2JqZWN0IG9yIGNsYXNzIG1ldGhvZC5cblxucHAkMy5wYXJzZU1ldGhvZCA9IGZ1bmN0aW9uKGlzR2VuZXJhdG9yLCBpc0FzeW5jKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKSwgb2xkSW5HZW4gPSB0aGlzLmluR2VuZXJhdG9yLCBvbGRJbkFzeW5jID0gdGhpcy5pbkFzeW5jLFxuICAgICAgb2xkWWllbGRQb3MgPSB0aGlzLnlpZWxkUG9zLCBvbGRBd2FpdFBvcyA9IHRoaXMuYXdhaXRQb3MsIG9sZEluRnVuYyA9IHRoaXMuaW5GdW5jdGlvbjtcblxuICB0aGlzLmluaXRGdW5jdGlvbihub2RlKTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KVxuICAgIHsgbm9kZS5nZW5lcmF0b3IgPSBpc0dlbmVyYXRvcjsgfVxuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy5pbkdlbmVyYXRvciA9IG5vZGUuZ2VuZXJhdG9yO1xuICB0aGlzLmluQXN5bmMgPSBub2RlLmFzeW5jO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuaW5GdW5jdGlvbiA9IHRydWU7XG4gIHRoaXMuZW50ZXJGdW5jdGlvblNjb3BlKCk7XG5cbiAgdGhpcy5leHBlY3QodHlwZXMucGFyZW5MKTtcbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnBhcnNlQmluZGluZ0xpc3QodHlwZXMucGFyZW5SLCBmYWxzZSwgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpO1xuICB0aGlzLmNoZWNrWWllbGRBd2FpdEluRGVmYXVsdFBhcmFtcygpO1xuICB0aGlzLnBhcnNlRnVuY3Rpb25Cb2R5KG5vZGUsIGZhbHNlKTtcblxuICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gIHRoaXMuaW5Bc3luYyA9IG9sZEluQXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJGdW5jdGlvbkV4cHJlc3Npb25cIilcbn07XG5cbi8vIFBhcnNlIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gd2l0aCBnaXZlbiBwYXJhbWV0ZXJzLlxuXG5wcCQzLnBhcnNlQXJyb3dFeHByZXNzaW9uID0gZnVuY3Rpb24obm9kZSwgcGFyYW1zLCBpc0FzeW5jKSB7XG4gIHZhciBvbGRJbkdlbiA9IHRoaXMuaW5HZW5lcmF0b3IsIG9sZEluQXN5bmMgPSB0aGlzLmluQXN5bmMsXG4gICAgICBvbGRZaWVsZFBvcyA9IHRoaXMueWllbGRQb3MsIG9sZEF3YWl0UG9zID0gdGhpcy5hd2FpdFBvcywgb2xkSW5GdW5jID0gdGhpcy5pbkZ1bmN0aW9uO1xuXG4gIHRoaXMuZW50ZXJGdW5jdGlvblNjb3BlKCk7XG4gIHRoaXMuaW5pdEZ1bmN0aW9uKG5vZGUpO1xuICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDgpXG4gICAgeyBub2RlLmFzeW5jID0gISFpc0FzeW5jOyB9XG5cbiAgdGhpcy5pbkdlbmVyYXRvciA9IGZhbHNlO1xuICB0aGlzLmluQXN5bmMgPSBub2RlLmFzeW5jO1xuICB0aGlzLnlpZWxkUG9zID0gMDtcbiAgdGhpcy5hd2FpdFBvcyA9IDA7XG4gIHRoaXMuaW5GdW5jdGlvbiA9IHRydWU7XG5cbiAgbm9kZS5wYXJhbXMgPSB0aGlzLnRvQXNzaWduYWJsZUxpc3QocGFyYW1zLCB0cnVlKTtcbiAgdGhpcy5wYXJzZUZ1bmN0aW9uQm9keShub2RlLCB0cnVlKTtcblxuICB0aGlzLmluR2VuZXJhdG9yID0gb2xkSW5HZW47XG4gIHRoaXMuaW5Bc3luYyA9IG9sZEluQXN5bmM7XG4gIHRoaXMueWllbGRQb3MgPSBvbGRZaWVsZFBvcztcbiAgdGhpcy5hd2FpdFBvcyA9IG9sZEF3YWl0UG9zO1xuICB0aGlzLmluRnVuY3Rpb24gPSBvbGRJbkZ1bmM7XG4gIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgXCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiKVxufTtcblxuLy8gUGFyc2UgZnVuY3Rpb24gYm9keSBhbmQgY2hlY2sgcGFyYW1ldGVycy5cblxucHAkMy5wYXJzZUZ1bmN0aW9uQm9keSA9IGZ1bmN0aW9uKG5vZGUsIGlzQXJyb3dGdW5jdGlvbikge1xuICB2YXIgaXNFeHByZXNzaW9uID0gaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMudHlwZSAhPT0gdHlwZXMuYnJhY2VMO1xuICB2YXIgb2xkU3RyaWN0ID0gdGhpcy5zdHJpY3QsIHVzZVN0cmljdCA9IGZhbHNlO1xuXG4gIGlmIChpc0V4cHJlc3Npb24pIHtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgICBub2RlLmV4cHJlc3Npb24gPSB0cnVlO1xuICAgIHRoaXMuY2hlY2tQYXJhbXMobm9kZSwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub25TaW1wbGUgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNyAmJiAhdGhpcy5pc1NpbXBsZVBhcmFtTGlzdChub2RlLnBhcmFtcyk7XG4gICAgaWYgKCFvbGRTdHJpY3QgfHwgbm9uU2ltcGxlKSB7XG4gICAgICB1c2VTdHJpY3QgPSB0aGlzLnN0cmljdERpcmVjdGl2ZSh0aGlzLmVuZCk7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgc3RyaWN0IG1vZGUgZnVuY3Rpb24sIHZlcmlmeSB0aGF0IGFyZ3VtZW50IG5hbWVzXG4gICAgICAvLyBhcmUgbm90IHJlcGVhdGVkLCBhbmQgaXQgZG9lcyBub3QgdHJ5IHRvIGJpbmQgdGhlIHdvcmRzIGBldmFsYFxuICAgICAgLy8gb3IgYGFyZ3VtZW50c2AuXG4gICAgICBpZiAodXNlU3RyaWN0ICYmIG5vblNpbXBsZSlcbiAgICAgICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUobm9kZS5zdGFydCwgXCJJbGxlZ2FsICd1c2Ugc3RyaWN0JyBkaXJlY3RpdmUgaW4gZnVuY3Rpb24gd2l0aCBub24tc2ltcGxlIHBhcmFtZXRlciBsaXN0XCIpOyB9XG4gICAgfVxuICAgIC8vIFN0YXJ0IGEgbmV3IHNjb3BlIHdpdGggcmVnYXJkIHRvIGxhYmVscyBhbmQgdGhlIGBpbkZ1bmN0aW9uYFxuICAgIC8vIGZsYWcgKHJlc3RvcmUgdGhlbSB0byB0aGVpciBvbGQgdmFsdWUgYWZ0ZXJ3YXJkcykuXG4gICAgdmFyIG9sZExhYmVscyA9IHRoaXMubGFiZWxzO1xuICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgaWYgKHVzZVN0cmljdCkgeyB0aGlzLnN0cmljdCA9IHRydWU7IH1cblxuICAgIC8vIEFkZCB0aGUgcGFyYW1zIHRvIHZhckRlY2xhcmVkTmFtZXMgdG8gZW5zdXJlIHRoYXQgYW4gZXJyb3IgaXMgdGhyb3duXG4gICAgLy8gaWYgYSBsZXQvY29uc3QgZGVjbGFyYXRpb24gaW4gdGhlIGZ1bmN0aW9uIGNsYXNoZXMgd2l0aCBvbmUgb2YgdGhlIHBhcmFtcy5cbiAgICB0aGlzLmNoZWNrUGFyYW1zKG5vZGUsICFvbGRTdHJpY3QgJiYgIXVzZVN0cmljdCAmJiAhaXNBcnJvd0Z1bmN0aW9uICYmIHRoaXMuaXNTaW1wbGVQYXJhbUxpc3Qobm9kZS5wYXJhbXMpKTtcbiAgICBub2RlLmJvZHkgPSB0aGlzLnBhcnNlQmxvY2soZmFsc2UpO1xuICAgIG5vZGUuZXhwcmVzc2lvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHREaXJlY3RpdmVQcm9sb2d1ZShub2RlLmJvZHkuYm9keSk7XG4gICAgdGhpcy5sYWJlbHMgPSBvbGRMYWJlbHM7XG4gIH1cbiAgdGhpcy5leGl0RnVuY3Rpb25TY29wZSgpO1xuXG4gIGlmICh0aGlzLnN0cmljdCAmJiBub2RlLmlkKSB7XG4gICAgLy8gRW5zdXJlIHRoZSBmdW5jdGlvbiBuYW1lIGlzbid0IGEgZm9yYmlkZGVuIGlkZW50aWZpZXIgaW4gc3RyaWN0IG1vZGUsIGUuZy4gJ2V2YWwnXG4gICAgdGhpcy5jaGVja0xWYWwobm9kZS5pZCwgXCJub25lXCIpO1xuICB9XG4gIHRoaXMuc3RyaWN0ID0gb2xkU3RyaWN0O1xufTtcblxucHAkMy5pc1NpbXBsZVBhcmFtTGlzdCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IHBhcmFtczsgaSA8IGxpc3QubGVuZ3RoOyBpICs9IDEpXG4gICAge1xuICAgIHZhciBwYXJhbSA9IGxpc3RbaV07XG5cbiAgICBpZiAocGFyYW0udHlwZSAhPT0gXCJJZGVudGlmaWVyXCIpIHsgcmV0dXJuIGZhbHNlXG4gIH0gfVxuICByZXR1cm4gdHJ1ZVxufTtcblxuLy8gQ2hlY2tzIGZ1bmN0aW9uIHBhcmFtcyBmb3IgdmFyaW91cyBkaXNhbGxvd2VkIHBhdHRlcm5zIHN1Y2ggYXMgdXNpbmcgXCJldmFsXCJcbi8vIG9yIFwiYXJndW1lbnRzXCIgYW5kIGR1cGxpY2F0ZSBwYXJhbWV0ZXJzLlxuXG5wcCQzLmNoZWNrUGFyYW1zID0gZnVuY3Rpb24obm9kZSwgYWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBuYW1lSGFzaCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbGlzdCA9IG5vZGUucGFyYW1zOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSlcbiAgICB7XG4gICAgdmFyIHBhcmFtID0gbGlzdFtpXTtcblxuICAgIHRoaXMkMS5jaGVja0xWYWwocGFyYW0sIFwidmFyXCIsIGFsbG93RHVwbGljYXRlcyA/IG51bGwgOiBuYW1lSGFzaCk7XG4gIH1cbn07XG5cbi8vIFBhcnNlcyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGV4cHJlc3Npb25zLCBhbmQgcmV0dXJucyB0aGVtIGFzXG4vLyBhbiBhcnJheS4gYGNsb3NlYCBpcyB0aGUgdG9rZW4gdHlwZSB0aGF0IGVuZHMgdGhlIGxpc3QsIGFuZFxuLy8gYGFsbG93RW1wdHlgIGNhbiBiZSB0dXJuZWQgb24gdG8gYWxsb3cgc3Vic2VxdWVudCBjb21tYXMgd2l0aFxuLy8gbm90aGluZyBpbiBiZXR3ZWVuIHRoZW0gdG8gYmUgcGFyc2VkIGFzIGBudWxsYCAod2hpY2ggaXMgbmVlZGVkXG4vLyBmb3IgYXJyYXkgbGl0ZXJhbHMpLlxuXG5wcCQzLnBhcnNlRXhwckxpc3QgPSBmdW5jdGlvbihjbG9zZSwgYWxsb3dUcmFpbGluZ0NvbW1hLCBhbGxvd0VtcHR5LCByZWZEZXN0cnVjdHVyaW5nRXJyb3JzKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlbHRzID0gW10sIGZpcnN0ID0gdHJ1ZTtcbiAgd2hpbGUgKCF0aGlzLmVhdChjbG9zZSkpIHtcbiAgICBpZiAoIWZpcnN0KSB7XG4gICAgICB0aGlzJDEuZXhwZWN0KHR5cGVzLmNvbW1hKTtcbiAgICAgIGlmIChhbGxvd1RyYWlsaW5nQ29tbWEgJiYgdGhpcyQxLmFmdGVyVHJhaWxpbmdDb21tYShjbG9zZSkpIHsgYnJlYWsgfVxuICAgIH0gZWxzZSB7IGZpcnN0ID0gZmFsc2U7IH1cblxuICAgIHZhciBlbHQgPSAodm9pZCAwKTtcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiB0aGlzJDEudHlwZSA9PT0gdHlwZXMuY29tbWEpXG4gICAgICB7IGVsdCA9IG51bGw7IH1cbiAgICBlbHNlIGlmICh0aGlzJDEudHlwZSA9PT0gdHlwZXMuZWxsaXBzaXMpIHtcbiAgICAgIGVsdCA9IHRoaXMkMS5wYXJzZVNwcmVhZChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzKTtcbiAgICAgIGlmIChyZWZEZXN0cnVjdHVyaW5nRXJyb3JzICYmIHRoaXMkMS50eXBlID09PSB0eXBlcy5jb21tYSAmJiByZWZEZXN0cnVjdHVyaW5nRXJyb3JzLnRyYWlsaW5nQ29tbWEgPCAwKVxuICAgICAgICB7IHJlZkRlc3RydWN0dXJpbmdFcnJvcnMudHJhaWxpbmdDb21tYSA9IHRoaXMkMS5zdGFydDsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbHQgPSB0aGlzJDEucGFyc2VNYXliZUFzc2lnbihmYWxzZSwgcmVmRGVzdHJ1Y3R1cmluZ0Vycm9ycyk7XG4gICAgfVxuICAgIGVsdHMucHVzaChlbHQpO1xuICB9XG4gIHJldHVybiBlbHRzXG59O1xuXG5wcCQzLmNoZWNrVW5yZXNlcnZlZCA9IGZ1bmN0aW9uKHJlZikge1xuICB2YXIgc3RhcnQgPSByZWYuc3RhcnQ7XG4gIHZhciBlbmQgPSByZWYuZW5kO1xuICB2YXIgbmFtZSA9IHJlZi5uYW1lO1xuXG4gIGlmICh0aGlzLmluR2VuZXJhdG9yICYmIG5hbWUgPT09IFwieWllbGRcIilcbiAgICB7IHRoaXMucmFpc2VSZWNvdmVyYWJsZShzdGFydCwgXCJDYW4gbm90IHVzZSAneWllbGQnIGFzIGlkZW50aWZpZXIgaW5zaWRlIGEgZ2VuZXJhdG9yXCIpOyB9XG4gIGlmICh0aGlzLmluQXN5bmMgJiYgbmFtZSA9PT0gXCJhd2FpdFwiKVxuICAgIHsgdGhpcy5yYWlzZVJlY292ZXJhYmxlKHN0YXJ0LCBcIkNhbiBub3QgdXNlICdhd2FpdCcgYXMgaWRlbnRpZmllciBpbnNpZGUgYW4gYXN5bmMgZnVuY3Rpb25cIik7IH1cbiAgaWYgKHRoaXMuaXNLZXl3b3JkKG5hbWUpKVxuICAgIHsgdGhpcy5yYWlzZShzdGFydCwgKFwiVW5leHBlY3RlZCBrZXl3b3JkICdcIiArIG5hbWUgKyBcIidcIikpOyB9XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2ICYmXG4gICAgdGhpcy5pbnB1dC5zbGljZShzdGFydCwgZW5kKS5pbmRleE9mKFwiXFxcXFwiKSAhPSAtMSkgeyByZXR1cm4gfVxuICB2YXIgcmUgPSB0aGlzLnN0cmljdCA/IHRoaXMucmVzZXJ2ZWRXb3Jkc1N0cmljdCA6IHRoaXMucmVzZXJ2ZWRXb3JkcztcbiAgaWYgKHJlLnRlc3QobmFtZSkpXG4gICAgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUoc3RhcnQsIChcIlRoZSBrZXl3b3JkICdcIiArIG5hbWUgKyBcIicgaXMgcmVzZXJ2ZWRcIikpOyB9XG59O1xuXG4vLyBQYXJzZSB0aGUgbmV4dCB0b2tlbiBhcyBhbiBpZGVudGlmaWVyLiBJZiBgbGliZXJhbGAgaXMgdHJ1ZSAodXNlZFxuLy8gd2hlbiBwYXJzaW5nIHByb3BlcnRpZXMpLCBpdCB3aWxsIGFsc28gY29udmVydCBrZXl3b3JkcyBpbnRvXG4vLyBpZGVudGlmaWVycy5cblxucHAkMy5wYXJzZUlkZW50ID0gZnVuY3Rpb24obGliZXJhbCwgaXNCaW5kaW5nKSB7XG4gIHZhciBub2RlID0gdGhpcy5zdGFydE5vZGUoKTtcbiAgaWYgKGxpYmVyYWwgJiYgdGhpcy5vcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT0gXCJuZXZlclwiKSB7IGxpYmVyYWwgPSBmYWxzZTsgfVxuICBpZiAodGhpcy50eXBlID09PSB0eXBlcy5uYW1lKSB7XG4gICAgbm9kZS5uYW1lID0gdGhpcy52YWx1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnR5cGUua2V5d29yZCkge1xuICAgIG5vZGUubmFtZSA9IHRoaXMudHlwZS5rZXl3b3JkO1xuXG4gICAgLy8gVG8gZml4IGh0dHBzOi8vZ2l0aHViLmNvbS90ZXJuanMvYWNvcm4vaXNzdWVzLzU3NVxuICAgIC8vIGBjbGFzc2AgYW5kIGBmdW5jdGlvbmAga2V5d29yZHMgcHVzaCBuZXcgY29udGV4dCBpbnRvIHRoaXMuY29udGV4dC5cbiAgICAvLyBCdXQgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHBvcCB0aGUgY29udGV4dCBpZiB0aGUga2V5d29yZCBpcyBjb25zdW1lZCBhcyBhbiBpZGVudGlmaWVyIHN1Y2ggYXMgYSBwcm9wZXJ0eSBuYW1lLlxuICAgIC8vIElmIHRoZSBwcmV2aW91cyB0b2tlbiBpcyBhIGRvdCwgdGhpcyBkb2VzIG5vdCBhcHBseSBiZWNhdXNlIHRoZSBjb250ZXh0LW1hbmFnaW5nIGNvZGUgYWxyZWFkeSBpZ25vcmVkIHRoZSBrZXl3b3JkXG4gICAgaWYgKChub2RlLm5hbWUgPT09IFwiY2xhc3NcIiB8fCBub2RlLm5hbWUgPT09IFwiZnVuY3Rpb25cIikgJiZcbiAgICAgICAgKHRoaXMubGFzdFRva0VuZCAhPT0gdGhpcy5sYXN0VG9rU3RhcnQgKyAxIHx8IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLmxhc3RUb2tTdGFydCkgIT09IDQ2KSkge1xuICAgICAgdGhpcy5jb250ZXh0LnBvcCgpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnVuZXhwZWN0ZWQoKTtcbiAgfVxuICB0aGlzLm5leHQoKTtcbiAgdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiSWRlbnRpZmllclwiKTtcbiAgaWYgKCFsaWJlcmFsKSB7IHRoaXMuY2hlY2tVbnJlc2VydmVkKG5vZGUpOyB9XG4gIHJldHVybiBub2RlXG59O1xuXG4vLyBQYXJzZXMgeWllbGQgZXhwcmVzc2lvbiBpbnNpZGUgZ2VuZXJhdG9yLlxuXG5wcCQzLnBhcnNlWWllbGQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnlpZWxkUG9zKSB7IHRoaXMueWllbGRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgaWYgKHRoaXMudHlwZSA9PSB0eXBlcy5zZW1pIHx8IHRoaXMuY2FuSW5zZXJ0U2VtaWNvbG9uKCkgfHwgKHRoaXMudHlwZSAhPSB0eXBlcy5zdGFyICYmICF0aGlzLnR5cGUuc3RhcnRzRXhwcikpIHtcbiAgICBub2RlLmRlbGVnYXRlID0gZmFsc2U7XG4gICAgbm9kZS5hcmd1bWVudCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kZWxlZ2F0ZSA9IHRoaXMuZWF0KHR5cGVzLnN0YXIpO1xuICAgIG5vZGUuYXJndW1lbnQgPSB0aGlzLnBhcnNlTWF5YmVBc3NpZ24oKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiWWllbGRFeHByZXNzaW9uXCIpXG59O1xuXG5wcCQzLnBhcnNlQXdhaXQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmF3YWl0UG9zKSB7IHRoaXMuYXdhaXRQb3MgPSB0aGlzLnN0YXJ0OyB9XG5cbiAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICB0aGlzLm5leHQoKTtcbiAgbm9kZS5hcmd1bWVudCA9IHRoaXMucGFyc2VNYXliZVVuYXJ5KG51bGwsIHRydWUpO1xuICByZXR1cm4gdGhpcy5maW5pc2hOb2RlKG5vZGUsIFwiQXdhaXRFeHByZXNzaW9uXCIpXG59O1xuXG52YXIgcHAkNCA9IFBhcnNlciQxLnByb3RvdHlwZTtcblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMgb24gcGFyc2UgZXJyb3JzLiBJdFxuLy8gdGFrZXMgYW4gb2Zmc2V0IGludGVnZXIgKGludG8gdGhlIGN1cnJlbnQgYGlucHV0YCkgdG8gaW5kaWNhdGVcbi8vIHRoZSBsb2NhdGlvbiBvZiB0aGUgZXJyb3IsIGF0dGFjaGVzIHRoZSBwb3NpdGlvbiB0byB0aGUgZW5kXG4vLyBvZiB0aGUgZXJyb3IgbWVzc2FnZSwgYW5kIHRoZW4gcmFpc2VzIGEgYFN5bnRheEVycm9yYCB3aXRoIHRoYXRcbi8vIG1lc3NhZ2UuXG5cbnBwJDQucmFpc2UgPSBmdW5jdGlvbihwb3MsIG1lc3NhZ2UpIHtcbiAgdmFyIGxvYyA9IGdldExpbmVJbmZvKHRoaXMuaW5wdXQsIHBvcyk7XG4gIG1lc3NhZ2UgKz0gXCIgKFwiICsgbG9jLmxpbmUgKyBcIjpcIiArIGxvYy5jb2x1bW4gKyBcIilcIjtcbiAgdmFyIGVyciA9IG5ldyBTeW50YXhFcnJvcihtZXNzYWdlKTtcbiAgZXJyLnBvcyA9IHBvczsgZXJyLmxvYyA9IGxvYzsgZXJyLnJhaXNlZEF0ID0gdGhpcy5wb3M7XG4gIHRocm93IGVyclxufTtcblxucHAkNC5yYWlzZVJlY292ZXJhYmxlID0gcHAkNC5yYWlzZTtcblxucHAkNC5jdXJQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucykge1xuICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5jdXJMaW5lLCB0aGlzLnBvcyAtIHRoaXMubGluZVN0YXJ0KVxuICB9XG59O1xuXG52YXIgcHAkNSA9IFBhcnNlciQxLnByb3RvdHlwZTtcblxuLy8gT2JqZWN0LmFzc2lnbiBwb2x5ZmlsbFxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odGFyZ2V0KSB7XG4gIHZhciBzb3VyY2VzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAxO1xuICB3aGlsZSAoIGxlbi0tID4gMCApIHNvdXJjZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAxIF07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxpc3QgPSBzb3VyY2VzOyBpIDwgbGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBzb3VyY2UgPSBsaXN0W2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKGhhcyhzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldFxufTtcblxuLy8gVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSBrZWVwIHRyYWNrIG9mIGRlY2xhcmVkIHZhcmlhYmxlcyBpbiB0aGUgY3VycmVudCBzY29wZSBpbiBvcmRlciB0byBkZXRlY3QgZHVwbGljYXRlIHZhcmlhYmxlIG5hbWVzLlxuXG5wcCQ1LmVudGVyRnVuY3Rpb25TY29wZSA9IGZ1bmN0aW9uKCkge1xuICAvLyB2YXI6IGEgaGFzaCBvZiB2YXItZGVjbGFyZWQgbmFtZXMgaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZVxuICAvLyBsZXhpY2FsOiBhIGhhc2ggb2YgbGV4aWNhbGx5LWRlY2xhcmVkIG5hbWVzIGluIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGVcbiAgLy8gY2hpbGRWYXI6IGEgaGFzaCBvZiB2YXItZGVjbGFyZWQgbmFtZXMgaW4gYWxsIGNoaWxkIGxleGljYWwgc2NvcGVzIG9mIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGUgKHdpdGhpbiB0aGUgY3VycmVudCBmdW5jdGlvbiBzY29wZSlcbiAgLy8gcGFyZW50TGV4aWNhbDogYSBoYXNoIG9mIGxleGljYWxseS1kZWNsYXJlZCBuYW1lcyBpbiBhbGwgcGFyZW50IGxleGljYWwgc2NvcGVzIG9mIHRoZSBjdXJyZW50IGxleGljYWwgc2NvcGUgKHdpdGhpbiB0aGUgY3VycmVudCBmdW5jdGlvbiBzY29wZSlcbiAgdGhpcy5zY29wZVN0YWNrLnB1c2goe3Zhcjoge30sIGxleGljYWw6IHt9LCBjaGlsZFZhcjoge30sIHBhcmVudExleGljYWw6IHt9fSk7XG59O1xuXG5wcCQ1LmV4aXRGdW5jdGlvblNjb3BlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbn07XG5cbnBwJDUuZW50ZXJMZXhpY2FsU2NvcGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBhcmVudFNjb3BlID0gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcbiAgdmFyIGNoaWxkU2NvcGUgPSB7dmFyOiB7fSwgbGV4aWNhbDoge30sIGNoaWxkVmFyOiB7fSwgcGFyZW50TGV4aWNhbDoge319O1xuXG4gIHRoaXMuc2NvcGVTdGFjay5wdXNoKGNoaWxkU2NvcGUpO1xuICBhc3NpZ24oY2hpbGRTY29wZS5wYXJlbnRMZXhpY2FsLCBwYXJlbnRTY29wZS5sZXhpY2FsLCBwYXJlbnRTY29wZS5wYXJlbnRMZXhpY2FsKTtcbn07XG5cbnBwJDUuZXhpdExleGljYWxTY29wZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2hpbGRTY29wZSA9IHRoaXMuc2NvcGVTdGFjay5wb3AoKTtcbiAgdmFyIHBhcmVudFNjb3BlID0gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcblxuICBhc3NpZ24ocGFyZW50U2NvcGUuY2hpbGRWYXIsIGNoaWxkU2NvcGUudmFyLCBjaGlsZFNjb3BlLmNoaWxkVmFyKTtcbn07XG5cbi8qKlxuICogQSBuYW1lIGNhbiBiZSBkZWNsYXJlZCB3aXRoIGB2YXJgIGlmIHRoZXJlIGFyZSBubyB2YXJpYWJsZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGRlY2xhcmVkIHdpdGggYGxldGAvYGNvbnN0YFxuICogaW4gdGhlIGN1cnJlbnQgbGV4aWNhbCBzY29wZSBvciBhbnkgb2YgdGhlIHBhcmVudCBsZXhpY2FsIHNjb3BlcyBpbiB0aGlzIGZ1bmN0aW9uLlxuICovXG5wcCQ1LmNhbkRlY2xhcmVWYXJOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICB2YXIgY3VycmVudFNjb3BlID0gdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXTtcblxuICByZXR1cm4gIWhhcyhjdXJyZW50U2NvcGUubGV4aWNhbCwgbmFtZSkgJiYgIWhhcyhjdXJyZW50U2NvcGUucGFyZW50TGV4aWNhbCwgbmFtZSlcbn07XG5cbi8qKlxuICogQSBuYW1lIGNhbiBiZSBkZWNsYXJlZCB3aXRoIGBsZXRgL2Bjb25zdGAgaWYgdGhlcmUgYXJlIG5vIHZhcmlhYmxlcyB3aXRoIHRoZSBzYW1lIG5hbWUgZGVjbGFyZWQgd2l0aCBgbGV0YC9gY29uc3RgXG4gKiBpbiB0aGUgY3VycmVudCBzY29wZSwgYW5kIHRoZXJlIGFyZSBubyB2YXJpYWJsZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGRlY2xhcmVkIHdpdGggYHZhcmAgaW4gdGhlIGN1cnJlbnQgc2NvcGUgb3IgaW5cbiAqIGFueSBjaGlsZCBsZXhpY2FsIHNjb3BlcyBpbiB0aGlzIGZ1bmN0aW9uLlxuICovXG5wcCQ1LmNhbkRlY2xhcmVMZXhpY2FsTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdmFyIGN1cnJlbnRTY29wZSA9IHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV07XG5cbiAgcmV0dXJuICFoYXMoY3VycmVudFNjb3BlLmxleGljYWwsIG5hbWUpICYmICFoYXMoY3VycmVudFNjb3BlLnZhciwgbmFtZSkgJiYgIWhhcyhjdXJyZW50U2NvcGUuY2hpbGRWYXIsIG5hbWUpXG59O1xuXG5wcCQ1LmRlY2xhcmVWYXJOYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICB0aGlzLnNjb3BlU3RhY2tbdGhpcy5zY29wZVN0YWNrLmxlbmd0aCAtIDFdLnZhcltuYW1lXSA9IHRydWU7XG59O1xuXG5wcCQ1LmRlY2xhcmVMZXhpY2FsTmFtZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdGhpcy5zY29wZVN0YWNrW3RoaXMuc2NvcGVTdGFjay5sZW5ndGggLSAxXS5sZXhpY2FsW25hbWVdID0gdHJ1ZTtcbn07XG5cbnZhciBOb2RlID0gZnVuY3Rpb24gTm9kZShwYXJzZXIsIHBvcywgbG9jKSB7XG4gIHRoaXMudHlwZSA9IFwiXCI7XG4gIHRoaXMuc3RhcnQgPSBwb3M7XG4gIHRoaXMuZW5kID0gMDtcbiAgaWYgKHBhcnNlci5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IHRoaXMubG9jID0gbmV3IFNvdXJjZUxvY2F0aW9uKHBhcnNlciwgbG9jKTsgfVxuICBpZiAocGFyc2VyLm9wdGlvbnMuZGlyZWN0U291cmNlRmlsZSlcbiAgICB7IHRoaXMuc291cmNlRmlsZSA9IHBhcnNlci5vcHRpb25zLmRpcmVjdFNvdXJjZUZpbGU7IH1cbiAgaWYgKHBhcnNlci5vcHRpb25zLnJhbmdlcylcbiAgICB7IHRoaXMucmFuZ2UgPSBbcG9zLCAwXTsgfVxufTtcblxuLy8gU3RhcnQgYW4gQVNUIG5vZGUsIGF0dGFjaGluZyBhIHN0YXJ0IG9mZnNldC5cblxudmFyIHBwJDYgPSBQYXJzZXIkMS5wcm90b3R5cGU7XG5cbnBwJDYuc3RhcnROb2RlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0TG9jKVxufTtcblxucHAkNi5zdGFydE5vZGVBdCA9IGZ1bmN0aW9uKHBvcywgbG9jKSB7XG4gIHJldHVybiBuZXcgTm9kZSh0aGlzLCBwb3MsIGxvYylcbn07XG5cbi8vIEZpbmlzaCBhbiBBU1Qgbm9kZSwgYWRkaW5nIGB0eXBlYCBhbmQgYGVuZGAgcHJvcGVydGllcy5cblxuZnVuY3Rpb24gZmluaXNoTm9kZUF0KG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIG5vZGUudHlwZSA9IHR5cGU7XG4gIG5vZGUuZW5kID0gcG9zO1xuICBpZiAodGhpcy5vcHRpb25zLmxvY2F0aW9ucylcbiAgICB7IG5vZGUubG9jLmVuZCA9IGxvYzsgfVxuICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcylcbiAgICB7IG5vZGUucmFuZ2VbMV0gPSBwb3M7IH1cbiAgcmV0dXJuIG5vZGVcbn1cblxucHAkNi5maW5pc2hOb2RlID0gZnVuY3Rpb24obm9kZSwgdHlwZSkge1xuICByZXR1cm4gZmluaXNoTm9kZUF0LmNhbGwodGhpcywgbm9kZSwgdHlwZSwgdGhpcy5sYXN0VG9rRW5kLCB0aGlzLmxhc3RUb2tFbmRMb2MpXG59O1xuXG4vLyBGaW5pc2ggbm9kZSBhdCBnaXZlbiBwb3NpdGlvblxuXG5wcCQ2LmZpbmlzaE5vZGVBdCA9IGZ1bmN0aW9uKG5vZGUsIHR5cGUsIHBvcywgbG9jKSB7XG4gIHJldHVybiBmaW5pc2hOb2RlQXQuY2FsbCh0aGlzLCBub2RlLCB0eXBlLCBwb3MsIGxvYylcbn07XG5cbi8vIFRoZSBhbGdvcml0aG0gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHJlZ2V4cCBjYW4gYXBwZWFyIGF0IGFcbi8vIGdpdmVuIHBvaW50IGluIHRoZSBwcm9ncmFtIGlzIGxvb3NlbHkgYmFzZWQgb24gc3dlZXQuanMnIGFwcHJvYWNoLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3N3ZWV0LmpzL3dpa2kvZGVzaWduXG5cbnZhciBUb2tDb250ZXh0ID0gZnVuY3Rpb24gVG9rQ29udGV4dCh0b2tlbiwgaXNFeHByLCBwcmVzZXJ2ZVNwYWNlLCBvdmVycmlkZSwgZ2VuZXJhdG9yKSB7XG4gIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgdGhpcy5pc0V4cHIgPSAhIWlzRXhwcjtcbiAgdGhpcy5wcmVzZXJ2ZVNwYWNlID0gISFwcmVzZXJ2ZVNwYWNlO1xuICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gIHRoaXMuZ2VuZXJhdG9yID0gISFnZW5lcmF0b3I7XG59O1xuXG52YXIgdHlwZXMkMSA9IHtcbiAgYl9zdGF0OiBuZXcgVG9rQ29udGV4dChcIntcIiwgZmFsc2UpLFxuICBiX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwie1wiLCB0cnVlKSxcbiAgYl90bXBsOiBuZXcgVG9rQ29udGV4dChcIiR7XCIsIGZhbHNlKSxcbiAgcF9zdGF0OiBuZXcgVG9rQ29udGV4dChcIihcIiwgZmFsc2UpLFxuICBwX2V4cHI6IG5ldyBUb2tDb250ZXh0KFwiKFwiLCB0cnVlKSxcbiAgcV90bXBsOiBuZXcgVG9rQ29udGV4dChcImBcIiwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIHAudHJ5UmVhZFRlbXBsYXRlVG9rZW4oKTsgfSksXG4gIGZfc3RhdDogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCBmYWxzZSksXG4gIGZfZXhwcjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlKSxcbiAgZl9leHByX2dlbjogbmV3IFRva0NvbnRleHQoXCJmdW5jdGlvblwiLCB0cnVlLCBmYWxzZSwgbnVsbCwgdHJ1ZSksXG4gIGZfZ2VuOiBuZXcgVG9rQ29udGV4dChcImZ1bmN0aW9uXCIsIGZhbHNlLCBmYWxzZSwgbnVsbCwgdHJ1ZSlcbn07XG5cbnZhciBwcCQ3ID0gUGFyc2VyJDEucHJvdG90eXBlO1xuXG5wcCQ3LmluaXRpYWxDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBbdHlwZXMkMS5iX3N0YXRdXG59O1xuXG5wcCQ3LmJyYWNlSXNCbG9jayA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLmN1ckNvbnRleHQoKTtcbiAgaWYgKHBhcmVudCA9PT0gdHlwZXMkMS5mX2V4cHIgfHwgcGFyZW50ID09PSB0eXBlcyQxLmZfc3RhdClcbiAgICB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiAmJiAocGFyZW50ID09PSB0eXBlcyQxLmJfc3RhdCB8fCBwYXJlbnQgPT09IHR5cGVzJDEuYl9leHByKSlcbiAgICB7IHJldHVybiAhcGFyZW50LmlzRXhwciB9XG5cbiAgLy8gVGhlIGNoZWNrIGZvciBgdHQubmFtZSAmJiBleHByQWxsb3dlZGAgZGV0ZWN0cyB3aGV0aGVyIHdlIGFyZVxuICAvLyBhZnRlciBhIGB5aWVsZGAgb3IgYG9mYCBjb25zdHJ1Y3QuIFNlZSB0aGUgYHVwZGF0ZUNvbnRleHRgIGZvclxuICAvLyBgdHQubmFtZWAuXG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX3JldHVybiB8fCBwcmV2VHlwZSA9PSB0eXBlcy5uYW1lICYmIHRoaXMuZXhwckFsbG93ZWQpXG4gICAgeyByZXR1cm4gbGluZUJyZWFrLnRlc3QodGhpcy5pbnB1dC5zbGljZSh0aGlzLmxhc3RUb2tFbmQsIHRoaXMuc3RhcnQpKSB9XG4gIGlmIChwcmV2VHlwZSA9PT0gdHlwZXMuX2Vsc2UgfHwgcHJldlR5cGUgPT09IHR5cGVzLnNlbWkgfHwgcHJldlR5cGUgPT09IHR5cGVzLmVvZiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMucGFyZW5SIHx8IHByZXZUeXBlID09IHR5cGVzLmFycm93KVxuICAgIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocHJldlR5cGUgPT0gdHlwZXMuYnJhY2VMKVxuICAgIHsgcmV0dXJuIHBhcmVudCA9PT0gdHlwZXMkMS5iX3N0YXQgfVxuICBpZiAocHJldlR5cGUgPT0gdHlwZXMuX3ZhciB8fCBwcmV2VHlwZSA9PSB0eXBlcy5uYW1lKVxuICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuICF0aGlzLmV4cHJBbGxvd2VkXG59O1xuXG5wcCQ3LmluR2VuZXJhdG9yQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7IGkgPj0gMTsgaS0tKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzJDEuY29udGV4dFtpXTtcbiAgICBpZiAoY29udGV4dC50b2tlbiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgeyByZXR1cm4gY29udGV4dC5nZW5lcmF0b3IgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblxucHAkNy51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIHVwZGF0ZSwgdHlwZSA9IHRoaXMudHlwZTtcbiAgaWYgKHR5cGUua2V5d29yZCAmJiBwcmV2VHlwZSA9PSB0eXBlcy5kb3QpXG4gICAgeyB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7IH1cbiAgZWxzZSBpZiAodXBkYXRlID0gdHlwZS51cGRhdGVDb250ZXh0KVxuICAgIHsgdXBkYXRlLmNhbGwodGhpcywgcHJldlR5cGUpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuZXhwckFsbG93ZWQgPSB0eXBlLmJlZm9yZUV4cHI7IH1cbn07XG5cbi8vIFRva2VuLXNwZWNpZmljIGNvbnRleHQgdXBkYXRlIGNvZGVcblxudHlwZXMucGFyZW5SLnVwZGF0ZUNvbnRleHQgPSB0eXBlcy5icmFjZVIudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jb250ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgaWYgKG91dCA9PT0gdHlwZXMkMS5iX3N0YXQgJiYgdGhpcy5jdXJDb250ZXh0KCkudG9rZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIG91dCA9IHRoaXMuY29udGV4dC5wb3AoKTtcbiAgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gIW91dC5pc0V4cHI7XG59O1xuXG50eXBlcy5icmFjZUwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHRoaXMuYnJhY2VJc0Jsb2NrKHByZXZUeXBlKSA/IHR5cGVzJDEuYl9zdGF0IDogdHlwZXMkMS5iX2V4cHIpO1xuICB0aGlzLmV4cHJBbGxvd2VkID0gdHJ1ZTtcbn07XG5cbnR5cGVzLmRvbGxhckJyYWNlTC51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuYl90bXBsKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5wYXJlbkwudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKHByZXZUeXBlKSB7XG4gIHZhciBzdGF0ZW1lbnRQYXJlbnMgPSBwcmV2VHlwZSA9PT0gdHlwZXMuX2lmIHx8IHByZXZUeXBlID09PSB0eXBlcy5fZm9yIHx8IHByZXZUeXBlID09PSB0eXBlcy5fd2l0aCB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuX3doaWxlO1xuICB0aGlzLmNvbnRleHQucHVzaChzdGF0ZW1lbnRQYXJlbnMgPyB0eXBlcyQxLnBfc3RhdCA6IHR5cGVzJDEucF9leHByKTtcbiAgdGhpcy5leHByQWxsb3dlZCA9IHRydWU7XG59O1xuXG50eXBlcy5pbmNEZWMudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICAvLyB0b2tFeHByQWxsb3dlZCBzdGF5cyB1bmNoYW5nZWRcbn07XG5cbnR5cGVzLl9mdW5jdGlvbi51cGRhdGVDb250ZXh0ID0gdHlwZXMuX2NsYXNzLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUuYmVmb3JlRXhwciAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuc2VtaSAmJiBwcmV2VHlwZSAhPT0gdHlwZXMuX2Vsc2UgJiZcbiAgICAgICEoKHByZXZUeXBlID09PSB0eXBlcy5jb2xvbiB8fCBwcmV2VHlwZSA9PT0gdHlwZXMuYnJhY2VMKSAmJiB0aGlzLmN1ckNvbnRleHQoKSA9PT0gdHlwZXMkMS5iX3N0YXQpKVxuICAgIHsgdGhpcy5jb250ZXh0LnB1c2godHlwZXMkMS5mX2V4cHIpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEuZl9zdGF0KTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcy5iYWNrUXVvdGUudXBkYXRlQ29udGV4dCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5jdXJDb250ZXh0KCkgPT09IHR5cGVzJDEucV90bXBsKVxuICAgIHsgdGhpcy5jb250ZXh0LnBvcCgpOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuY29udGV4dC5wdXNoKHR5cGVzJDEucV90bXBsKTsgfVxuICB0aGlzLmV4cHJBbGxvd2VkID0gZmFsc2U7XG59O1xuXG50eXBlcy5zdGFyLnVwZGF0ZUNvbnRleHQgPSBmdW5jdGlvbihwcmV2VHlwZSkge1xuICBpZiAocHJldlR5cGUgPT0gdHlwZXMuX2Z1bmN0aW9uKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDE7XG4gICAgaWYgKHRoaXMuY29udGV4dFtpbmRleF0gPT09IHR5cGVzJDEuZl9leHByKVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2V4cHJfZ2VuOyB9XG4gICAgZWxzZVxuICAgICAgeyB0aGlzLmNvbnRleHRbaW5kZXhdID0gdHlwZXMkMS5mX2dlbjsgfVxuICB9XG4gIHRoaXMuZXhwckFsbG93ZWQgPSB0cnVlO1xufTtcblxudHlwZXMubmFtZS51cGRhdGVDb250ZXh0ID0gZnVuY3Rpb24ocHJldlR5cGUpIHtcbiAgdmFyIGFsbG93ZWQgPSBmYWxzZTtcbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA2KSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT0gXCJvZlwiICYmICF0aGlzLmV4cHJBbGxvd2VkIHx8XG4gICAgICAgIHRoaXMudmFsdWUgPT0gXCJ5aWVsZFwiICYmIHRoaXMuaW5HZW5lcmF0b3JDb250ZXh0KCkpXG4gICAgICB7IGFsbG93ZWQgPSB0cnVlOyB9XG4gIH1cbiAgdGhpcy5leHByQWxsb3dlZCA9IGFsbG93ZWQ7XG59O1xuXG4vLyBPYmplY3QgdHlwZSB1c2VkIHRvIHJlcHJlc2VudCB0b2tlbnMuIE5vdGUgdGhhdCBub3JtYWxseSwgdG9rZW5zXG4vLyBzaW1wbHkgZXhpc3QgYXMgcHJvcGVydGllcyBvbiB0aGUgcGFyc2VyIG9iamVjdC4gVGhpcyBpcyBvbmx5XG4vLyB1c2VkIGZvciB0aGUgb25Ub2tlbiBjYWxsYmFjayBhbmQgdGhlIGV4dGVybmFsIHRva2VuaXplci5cblxudmFyIFRva2VuID0gZnVuY3Rpb24gVG9rZW4ocCkge1xuICB0aGlzLnR5cGUgPSBwLnR5cGU7XG4gIHRoaXMudmFsdWUgPSBwLnZhbHVlO1xuICB0aGlzLnN0YXJ0ID0gcC5zdGFydDtcbiAgdGhpcy5lbmQgPSBwLmVuZDtcbiAgaWYgKHAub3B0aW9ucy5sb2NhdGlvbnMpXG4gICAgeyB0aGlzLmxvYyA9IG5ldyBTb3VyY2VMb2NhdGlvbihwLCBwLnN0YXJ0TG9jLCBwLmVuZExvYyk7IH1cbiAgaWYgKHAub3B0aW9ucy5yYW5nZXMpXG4gICAgeyB0aGlzLnJhbmdlID0gW3Auc3RhcnQsIHAuZW5kXTsgfVxufTtcblxuLy8gIyMgVG9rZW5pemVyXG5cbnZhciBwcCQ4ID0gUGFyc2VyJDEucHJvdG90eXBlO1xuXG4vLyBBcmUgd2UgcnVubmluZyB1bmRlciBSaGlubz9cbnZhciBpc1JoaW5vID0gdHlwZW9mIFBhY2thZ2VzID09IFwib2JqZWN0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFBhY2thZ2VzKSA9PSBcIltvYmplY3QgSmF2YVBhY2thZ2VdXCI7XG5cbi8vIE1vdmUgdG8gdGhlIG5leHQgdG9rZW5cblxucHAkOC5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMub25Ub2tlbilcbiAgICB7IHRoaXMub3B0aW9ucy5vblRva2VuKG5ldyBUb2tlbih0aGlzKSk7IH1cblxuICB0aGlzLmxhc3RUb2tFbmQgPSB0aGlzLmVuZDtcbiAgdGhpcy5sYXN0VG9rU3RhcnQgPSB0aGlzLnN0YXJ0O1xuICB0aGlzLmxhc3RUb2tFbmRMb2MgPSB0aGlzLmVuZExvYztcbiAgdGhpcy5sYXN0VG9rU3RhcnRMb2MgPSB0aGlzLnN0YXJ0TG9jO1xuICB0aGlzLm5leHRUb2tlbigpO1xufTtcblxucHAkOC5nZXRUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm5leHQoKTtcbiAgcmV0dXJuIG5ldyBUb2tlbih0aGlzKVxufTtcblxuLy8gSWYgd2UncmUgaW4gYW4gRVM2IGVudmlyb25tZW50LCBtYWtlIHBhcnNlcnMgaXRlcmFibGVcbmlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiKVxuICB7IHBwJDhbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuID0gdGhpcyQxLmdldFRva2VuKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogdG9rZW4udHlwZSA9PT0gdHlwZXMuZW9mLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9OyB9XG5cbi8vIFRvZ2dsZSBzdHJpY3QgbW9kZS4gUmUtcmVhZHMgdGhlIG5leHQgbnVtYmVyIG9yIHN0cmluZyB0byBwbGVhc2Vcbi8vIHBlZGFudGljIHRlc3RzIChgXCJ1c2Ugc3RyaWN0XCI7IDAxMDtgIHNob3VsZCBmYWlsKS5cblxucHAkOC5jdXJDb250ZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNvbnRleHRbdGhpcy5jb250ZXh0Lmxlbmd0aCAtIDFdXG59O1xuXG4vLyBSZWFkIGEgc2luZ2xlIHRva2VuLCB1cGRhdGluZyB0aGUgcGFyc2VyIG9iamVjdCdzIHRva2VuLXJlbGF0ZWRcbi8vIHByb3BlcnRpZXMuXG5cbnBwJDgubmV4dFRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjdXJDb250ZXh0ID0gdGhpcy5jdXJDb250ZXh0KCk7XG4gIGlmICghY3VyQ29udGV4dCB8fCAhY3VyQ29udGV4dC5wcmVzZXJ2ZVNwYWNlKSB7IHRoaXMuc2tpcFNwYWNlKCk7IH1cblxuICB0aGlzLnN0YXJ0ID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuc3RhcnRMb2MgPSB0aGlzLmN1clBvc2l0aW9uKCk7IH1cbiAgaWYgKHRoaXMucG9zID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmVvZikgfVxuXG4gIGlmIChjdXJDb250ZXh0Lm92ZXJyaWRlKSB7IHJldHVybiBjdXJDb250ZXh0Lm92ZXJyaWRlKHRoaXMpIH1cbiAgZWxzZSB7IHRoaXMucmVhZFRva2VuKHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSk7IH1cbn07XG5cbnBwJDgucmVhZFRva2VuID0gZnVuY3Rpb24oY29kZSkge1xuICAvLyBJZGVudGlmaWVyIG9yIGtleXdvcmQuICdcXHVYWFhYJyBzZXF1ZW5jZXMgYXJlIGFsbG93ZWQgaW5cbiAgLy8gaWRlbnRpZmllcnMsIHNvICdcXCcgYWxzbyBkaXNwYXRjaGVzIHRvIHRoYXQuXG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChjb2RlLCB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgfHwgY29kZSA9PT0gOTIgLyogJ1xcJyAqLylcbiAgICB7IHJldHVybiB0aGlzLnJlYWRXb3JkKCkgfVxuXG4gIHJldHVybiB0aGlzLmdldFRva2VuRnJvbUNvZGUoY29kZSlcbn07XG5cbnBwJDguZnVsbENoYXJDb2RlQXRQb3MgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvZGUgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpO1xuICBpZiAoY29kZSA8PSAweGQ3ZmYgfHwgY29kZSA+PSAweGUwMDApIHsgcmV0dXJuIGNvZGUgfVxuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICByZXR1cm4gKGNvZGUgPDwgMTApICsgbmV4dCAtIDB4MzVmZGMwMFxufTtcblxucHAkOC5za2lwQmxvY2tDb21tZW50ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBzdGFydExvYyA9IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQgJiYgdGhpcy5jdXJQb3NpdGlvbigpO1xuICB2YXIgc3RhcnQgPSB0aGlzLnBvcywgZW5kID0gdGhpcy5pbnB1dC5pbmRleE9mKFwiKi9cIiwgdGhpcy5wb3MgKz0gMik7XG4gIGlmIChlbmQgPT09IC0xKSB7IHRoaXMucmFpc2UodGhpcy5wb3MgLSAyLCBcIlVudGVybWluYXRlZCBjb21tZW50XCIpOyB9XG4gIHRoaXMucG9zID0gZW5kICsgMjtcbiAgaWYgKHRoaXMub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICBsaW5lQnJlYWtHLmxhc3RJbmRleCA9IHN0YXJ0O1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gbGluZUJyZWFrRy5leGVjKHRoaXMuaW5wdXQpKSAmJiBtYXRjaC5pbmRleCA8IHRoaXMucG9zKSB7XG4gICAgICArK3RoaXMkMS5jdXJMaW5lO1xuICAgICAgdGhpcyQxLmxpbmVTdGFydCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQodHJ1ZSwgdGhpcy5pbnB1dC5zbGljZShzdGFydCArIDIsIGVuZCksIHN0YXJ0LCB0aGlzLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TG9jLCB0aGlzLmN1clBvc2l0aW9uKCkpOyB9XG59O1xuXG5wcCQ4LnNraXBMaW5lQ29tbWVudCA9IGZ1bmN0aW9uKHN0YXJ0U2tpcCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnQgPSB0aGlzLnBvcztcbiAgdmFyIHN0YXJ0TG9jID0gdGhpcy5vcHRpb25zLm9uQ29tbWVudCAmJiB0aGlzLmN1clBvc2l0aW9uKCk7XG4gIHZhciBjaCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArPSBzdGFydFNraXApO1xuICB3aGlsZSAodGhpcy5wb3MgPCB0aGlzLmlucHV0Lmxlbmd0aCAmJiAhaXNOZXdMaW5lKGNoKSkge1xuICAgIGNoID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzJDEucG9zKTtcbiAgfVxuICBpZiAodGhpcy5vcHRpb25zLm9uQ29tbWVudClcbiAgICB7IHRoaXMub3B0aW9ucy5vbkNvbW1lbnQoZmFsc2UsIHRoaXMuaW5wdXQuc2xpY2Uoc3RhcnQgKyBzdGFydFNraXAsIHRoaXMucG9zKSwgc3RhcnQsIHRoaXMucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRMb2MsIHRoaXMuY3VyUG9zaXRpb24oKSk7IH1cbn07XG5cbi8vIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgdGhlIHBhcnNlIGFuZCBhZnRlciBldmVyeSB0b2tlbi4gU2tpcHNcbi8vIHdoaXRlc3BhY2UgYW5kIGNvbW1lbnRzLCBhbmQuXG5cbnBwJDguc2tpcFNwYWNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGxvb3A6IHdoaWxlICh0aGlzLnBvcyA8IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgdmFyIGNoID0gdGhpcyQxLmlucHV0LmNoYXJDb2RlQXQodGhpcyQxLnBvcyk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgMzI6IGNhc2UgMTYwOiAvLyAnICdcbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxMzpcbiAgICAgIGlmICh0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zICsgMSkgPT09IDEwKSB7XG4gICAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIH1cbiAgICBjYXNlIDEwOiBjYXNlIDgyMzI6IGNhc2UgODIzMzpcbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIGlmICh0aGlzJDEub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzJDEuY3VyTGluZTtcbiAgICAgICAgdGhpcyQxLmxpbmVTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgNDc6IC8vICcvJ1xuICAgICAgc3dpdGNoICh0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zICsgMSkpIHtcbiAgICAgIGNhc2UgNDI6IC8vICcqJ1xuICAgICAgICB0aGlzJDEuc2tpcEJsb2NrQ29tbWVudCgpO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSA0NzpcbiAgICAgICAgdGhpcyQxLnNraXBMaW5lQ29tbWVudCgyKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrIGxvb3BcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmIChjaCA+IDggJiYgY2ggPCAxNCB8fCBjaCA+PSA1NzYwICYmIG5vbkFTQ0lJd2hpdGVzcGFjZS50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKSkge1xuICAgICAgICArK3RoaXMkMS5wb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhayBsb29wXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vLyBDYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSB0b2tlbi4gU2V0cyBgZW5kYCwgYHZhbGAsIGFuZFxuLy8gbWFpbnRhaW5zIGBjb250ZXh0YCBhbmQgYGV4cHJBbGxvd2VkYCwgYW5kIHNraXBzIHRoZSBzcGFjZSBhZnRlclxuLy8gdGhlIHRva2VuLCBzbyB0aGF0IHRoZSBuZXh0IG9uZSdzIGBzdGFydGAgd2lsbCBwb2ludCBhdCB0aGVcbi8vIHJpZ2h0IHBvc2l0aW9uLlxuXG5wcCQ4LmZpbmlzaFRva2VuID0gZnVuY3Rpb24odHlwZSwgdmFsKSB7XG4gIHRoaXMuZW5kID0gdGhpcy5wb3M7XG4gIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMuZW5kTG9jID0gdGhpcy5jdXJQb3NpdGlvbigpOyB9XG4gIHZhciBwcmV2VHlwZSA9IHRoaXMudHlwZTtcbiAgdGhpcy50eXBlID0gdHlwZTtcbiAgdGhpcy52YWx1ZSA9IHZhbDtcblxuICB0aGlzLnVwZGF0ZUNvbnRleHQocHJldlR5cGUpO1xufTtcblxuLy8gIyMjIFRva2VuIHJlYWRpbmdcblxuLy8gVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgdG8gZmV0Y2ggdGhlIG5leHQgdG9rZW4uIEl0XG4vLyBpcyBzb21ld2hhdCBvYnNjdXJlLCBiZWNhdXNlIGl0IHdvcmtzIGluIGNoYXJhY3RlciBjb2RlcyByYXRoZXJcbi8vIHRoYW4gY2hhcmFjdGVycywgYW5kIGJlY2F1c2Ugb3BlcmF0b3IgcGFyc2luZyBoYXMgYmVlbiBpbmxpbmVkXG4vLyBpbnRvIGl0LlxuLy9cbi8vIEFsbCBpbiB0aGUgbmFtZSBvZiBzcGVlZC5cbi8vXG5wcCQ4LnJlYWRUb2tlbl9kb3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPj0gNDggJiYgbmV4dCA8PSA1NykgeyByZXR1cm4gdGhpcy5yZWFkTnVtYmVyKHRydWUpIH1cbiAgdmFyIG5leHQyID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMik7XG4gIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNiAmJiBuZXh0ID09PSA0NiAmJiBuZXh0MiA9PT0gNDYpIHsgLy8gNDYgPSBkb3QgJy4nXG4gICAgdGhpcy5wb3MgKz0gMztcbiAgICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5lbGxpcHNpcylcbiAgfSBlbHNlIHtcbiAgICArK3RoaXMucG9zO1xuICAgIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmRvdClcbiAgfVxufTtcblxucHAkOC5yZWFkVG9rZW5fc2xhc2ggPSBmdW5jdGlvbigpIHsgLy8gJy8nXG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gIGlmICh0aGlzLmV4cHJBbGxvd2VkKSB7ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLnJlYWRSZWdleHAoKSB9XG4gIGlmIChuZXh0ID09PSA2MSkgeyByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5hc3NpZ24sIDIpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuc2xhc2gsIDEpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9tdWx0X21vZHVsb19leHAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICclKidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgdmFyIHNpemUgPSAxO1xuICB2YXIgdG9rZW50eXBlID0gY29kZSA9PT0gNDIgPyB0eXBlcy5zdGFyIDogdHlwZXMubW9kdWxvO1xuXG4gIC8vIGV4cG9uZW50aWF0aW9uIG9wZXJhdG9yICoqIGFuZCAqKj1cbiAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA+PSA3ICYmIGNvZGUgPT0gNDIgJiYgbmV4dCA9PT0gNDIpIHtcbiAgICArK3NpemU7XG4gICAgdG9rZW50eXBlID0gdHlwZXMuc3RhcnN0YXI7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpO1xuICB9XG5cbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgc2l6ZSArIDEpIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodG9rZW50eXBlLCBzaXplKVxufTtcblxucHAkOC5yZWFkVG9rZW5fcGlwZV9hbXAgPSBmdW5jdGlvbihjb2RlKSB7IC8vICd8JidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gMTI0ID8gdHlwZXMubG9naWNhbE9SIDogdHlwZXMubG9naWNhbEFORCwgMikgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKGNvZGUgPT09IDEyNCA/IHR5cGVzLmJpdHdpc2VPUiA6IHR5cGVzLmJpdHdpc2VBTkQsIDEpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9jYXJldCA9IGZ1bmN0aW9uKCkgeyAvLyAnXidcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmFzc2lnbiwgMikgfVxuICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5iaXR3aXNlWE9SLCAxKVxufTtcblxucHAkOC5yZWFkVG9rZW5fcGx1c19taW4gPSBmdW5jdGlvbihjb2RlKSB7IC8vICcrLSdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IGNvZGUpIHtcbiAgICBpZiAobmV4dCA9PSA0NSAmJiAhdGhpcy5pbk1vZHVsZSAmJiB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PSA2MiAmJlxuICAgICAgICAodGhpcy5sYXN0VG9rRW5kID09PSAwIHx8IGxpbmVCcmVhay50ZXN0KHRoaXMuaW5wdXQuc2xpY2UodGhpcy5sYXN0VG9rRW5kLCB0aGlzLnBvcykpKSkge1xuICAgICAgLy8gQSBgLS0+YCBsaW5lIGNvbW1lbnRcbiAgICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDMpO1xuICAgICAgdGhpcy5za2lwU3BhY2UoKTtcbiAgICAgIHJldHVybiB0aGlzLm5leHRUb2tlbigpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmluY0RlYywgMilcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCAyKSB9XG4gIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLnBsdXNNaW4sIDEpXG59O1xuXG5wcCQ4LnJlYWRUb2tlbl9sdF9ndCA9IGZ1bmN0aW9uKGNvZGUpIHsgLy8gJzw+J1xuICB2YXIgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDEpO1xuICB2YXIgc2l6ZSA9IDE7XG4gIGlmIChuZXh0ID09PSBjb2RlKSB7XG4gICAgc2l6ZSA9IGNvZGUgPT09IDYyICYmIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDIpID09PSA2MiA/IDMgOiAyO1xuICAgIGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyBzaXplKSA9PT0gNjEpIHsgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMuYXNzaWduLCBzaXplICsgMSkgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmJpdFNoaWZ0LCBzaXplKVxuICB9XG4gIGlmIChuZXh0ID09IDMzICYmIGNvZGUgPT0gNjAgJiYgIXRoaXMuaW5Nb2R1bGUgJiYgdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMikgPT0gNDUgJiZcbiAgICAgIHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyArIDMpID09IDQ1KSB7XG4gICAgLy8gYDwhLS1gLCBhbiBYTUwtc3R5bGUgY29tbWVudCB0aGF0IHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBhIGxpbmUgY29tbWVudFxuICAgIHRoaXMuc2tpcExpbmVDb21tZW50KDQpO1xuICAgIHRoaXMuc2tpcFNwYWNlKCk7XG4gICAgcmV0dXJuIHRoaXMubmV4dFRva2VuKClcbiAgfVxuICBpZiAobmV4dCA9PT0gNjEpIHsgc2l6ZSA9IDI7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AodHlwZXMucmVsYXRpb25hbCwgc2l6ZSlcbn07XG5cbnBwJDgucmVhZFRva2VuX2VxX2V4Y2wgPSBmdW5jdGlvbihjb2RlKSB7IC8vICc9ISdcbiAgdmFyIG5leHQgPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAxKTtcbiAgaWYgKG5leHQgPT09IDYxKSB7IHJldHVybiB0aGlzLmZpbmlzaE9wKHR5cGVzLmVxdWFsaXR5LCB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MgKyAyKSA9PT0gNjEgPyAzIDogMikgfVxuICBpZiAoY29kZSA9PT0gNjEgJiYgbmV4dCA9PT0gNjIgJiYgdGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHsgLy8gJz0+J1xuICAgIHRoaXMucG9zICs9IDI7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYXJyb3cpXG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoT3AoY29kZSA9PT0gNjEgPyB0eXBlcy5lcSA6IHR5cGVzLnByZWZpeCwgMSlcbn07XG5cbnBwJDguZ2V0VG9rZW5Gcm9tQ29kZSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgLy8gVGhlIGludGVycHJldGF0aW9uIG9mIGEgZG90IGRlcGVuZHMgb24gd2hldGhlciBpdCBpcyBmb2xsb3dlZFxuICAgIC8vIGJ5IGEgZGlnaXQgb3IgYW5vdGhlciB0d28gZG90cy5cbiAgY2FzZSA0NjogLy8gJy4nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2RvdCgpXG5cbiAgICAvLyBQdW5jdHVhdGlvbiB0b2tlbnMuXG4gIGNhc2UgNDA6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLnBhcmVuTClcbiAgY2FzZSA0MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucGFyZW5SKVxuICBjYXNlIDU5OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zZW1pKVxuICBjYXNlIDQ0OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb21tYSlcbiAgY2FzZSA5MTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2tldEwpXG4gIGNhc2UgOTM6ICsrdGhpcy5wb3M7IHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGVzLmJyYWNrZXRSKVxuICBjYXNlIDEyMzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VMKVxuICBjYXNlIDEyNTogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYnJhY2VSKVxuICBjYXNlIDU4OiArK3RoaXMucG9zOyByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5jb2xvbilcbiAgY2FzZSA2MzogKyt0aGlzLnBvczsgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMucXVlc3Rpb24pXG5cbiAgY2FzZSA5NjogLy8gJ2AnXG4gICAgaWYgKHRoaXMub3B0aW9ucy5lY21hVmVyc2lvbiA8IDYpIHsgYnJlYWsgfVxuICAgICsrdGhpcy5wb3M7XG4gICAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuXG4gIGNhc2UgNDg6IC8vICcwJ1xuICAgIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zICsgMSk7XG4gICAgaWYgKG5leHQgPT09IDEyMCB8fCBuZXh0ID09PSA4OCkgeyByZXR1cm4gdGhpcy5yZWFkUmFkaXhOdW1iZXIoMTYpIH0gLy8gJzB4JywgJzBYJyAtIGhleCBudW1iZXJcbiAgICBpZiAodGhpcy5vcHRpb25zLmVjbWFWZXJzaW9uID49IDYpIHtcbiAgICAgIGlmIChuZXh0ID09PSAxMTEgfHwgbmV4dCA9PT0gNzkpIHsgcmV0dXJuIHRoaXMucmVhZFJhZGl4TnVtYmVyKDgpIH0gLy8gJzBvJywgJzBPJyAtIG9jdGFsIG51bWJlclxuICAgICAgaWYgKG5leHQgPT09IDk4IHx8IG5leHQgPT09IDY2KSB7IHJldHVybiB0aGlzLnJlYWRSYWRpeE51bWJlcigyKSB9IC8vICcwYicsICcwQicgLSBiaW5hcnkgbnVtYmVyXG4gICAgfVxuICAgIC8vIEFueXRoaW5nIGVsc2UgYmVnaW5uaW5nIHdpdGggYSBkaWdpdCBpcyBhbiBpbnRlZ2VyLCBvY3RhbFxuICAgIC8vIG51bWJlciwgb3IgZmxvYXQuXG4gIGNhc2UgNDk6IGNhc2UgNTA6IGNhc2UgNTE6IGNhc2UgNTI6IGNhc2UgNTM6IGNhc2UgNTQ6IGNhc2UgNTU6IGNhc2UgNTY6IGNhc2UgNTc6IC8vIDEtOVxuICAgIHJldHVybiB0aGlzLnJlYWROdW1iZXIoZmFsc2UpXG5cbiAgICAvLyBRdW90ZXMgcHJvZHVjZSBzdHJpbmdzLlxuICBjYXNlIDM0OiBjYXNlIDM5OiAvLyAnXCInLCBcIidcIlxuICAgIHJldHVybiB0aGlzLnJlYWRTdHJpbmcoY29kZSlcblxuICAgIC8vIE9wZXJhdG9ycyBhcmUgcGFyc2VkIGlubGluZSBpbiB0aW55IHN0YXRlIG1hY2hpbmVzLiAnPScgKDYxKSBpc1xuICAgIC8vIG9mdGVuIHJlZmVycmVkIHRvLiBgZmluaXNoT3BgIHNpbXBseSBza2lwcyB0aGUgYW1vdW50IG9mXG4gICAgLy8gY2hhcmFjdGVycyBpdCBpcyBnaXZlbiBhcyBzZWNvbmQgYXJndW1lbnQsIGFuZCByZXR1cm5zIGEgdG9rZW5cbiAgICAvLyBvZiB0aGUgdHlwZSBnaXZlbiBieSBpdHMgZmlyc3QgYXJndW1lbnQuXG5cbiAgY2FzZSA0NzogLy8gJy8nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3NsYXNoKClcblxuICBjYXNlIDM3OiBjYXNlIDQyOiAvLyAnJSonXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX211bHRfbW9kdWxvX2V4cChjb2RlKVxuXG4gIGNhc2UgMTI0OiBjYXNlIDM4OiAvLyAnfCYnXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BpcGVfYW1wKGNvZGUpXG5cbiAgY2FzZSA5NDogLy8gJ14nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX2NhcmV0KClcblxuICBjYXNlIDQzOiBjYXNlIDQ1OiAvLyAnKy0nXG4gICAgcmV0dXJuIHRoaXMucmVhZFRva2VuX3BsdXNfbWluKGNvZGUpXG5cbiAgY2FzZSA2MDogY2FzZSA2MjogLy8gJzw+J1xuICAgIHJldHVybiB0aGlzLnJlYWRUb2tlbl9sdF9ndChjb2RlKVxuXG4gIGNhc2UgNjE6IGNhc2UgMzM6IC8vICc9ISdcbiAgICByZXR1cm4gdGhpcy5yZWFkVG9rZW5fZXFfZXhjbChjb2RlKVxuXG4gIGNhc2UgMTI2OiAvLyAnfidcbiAgICByZXR1cm4gdGhpcy5maW5pc2hPcCh0eXBlcy5wcmVmaXgsIDEpXG4gIH1cblxuICB0aGlzLnJhaXNlKHRoaXMucG9zLCBcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIiArIGNvZGVQb2ludFRvU3RyaW5nKGNvZGUpICsgXCInXCIpO1xufTtcblxucHAkOC5maW5pc2hPcCA9IGZ1bmN0aW9uKHR5cGUsIHNpemUpIHtcbiAgdmFyIHN0ciA9IHRoaXMuaW5wdXQuc2xpY2UodGhpcy5wb3MsIHRoaXMucG9zICsgc2l6ZSk7XG4gIHRoaXMucG9zICs9IHNpemU7XG4gIHJldHVybiB0aGlzLmZpbmlzaFRva2VuKHR5cGUsIHN0cilcbn07XG5cbi8vIFBhcnNlIGEgcmVndWxhciBleHByZXNzaW9uLiBTb21lIGNvbnRleHQtYXdhcmVuZXNzIGlzIG5lY2Vzc2FyeSxcbi8vIHNpbmNlIGEgJy8nIGluc2lkZSBhICdbXScgc2V0IGRvZXMgbm90IGVuZCB0aGUgZXhwcmVzc2lvbi5cblxuZnVuY3Rpb24gdHJ5Q3JlYXRlUmVnZXhwKHNyYywgZmxhZ3MsIHRocm93RXJyb3JBdCwgcGFyc2VyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc3JjLCBmbGFncylcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aHJvd0Vycm9yQXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikgeyBwYXJzZXIucmFpc2UodGhyb3dFcnJvckF0LCBcIkVycm9yIHBhcnNpbmcgcmVndWxhciBleHByZXNzaW9uOiBcIiArIGUubWVzc2FnZSk7IH1cbiAgICAgIHRocm93IGVcbiAgICB9XG4gIH1cbn1cblxudmFyIHJlZ2V4cFVuaWNvZGVTdXBwb3J0ID0gISF0cnlDcmVhdGVSZWdleHAoXCJcXHVmZmZmXCIsIFwidVwiKTtcblxucHAkOC5yZWFkUmVnZXhwID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBlc2NhcGVkLCBpbkNsYXNzLCBzdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMkMS5wb3MgPj0gdGhpcyQxLmlucHV0Lmxlbmd0aCkgeyB0aGlzJDEucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQXQodGhpcyQxLnBvcyk7XG4gICAgaWYgKGxpbmVCcmVhay50ZXN0KGNoKSkgeyB0aGlzJDEucmFpc2Uoc3RhcnQsIFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTsgfVxuICAgIGlmICghZXNjYXBlZCkge1xuICAgICAgaWYgKGNoID09PSBcIltcIikgeyBpbkNsYXNzID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoY2ggPT09IFwiXVwiICYmIGluQ2xhc3MpIHsgaW5DbGFzcyA9IGZhbHNlOyB9XG4gICAgICBlbHNlIGlmIChjaCA9PT0gXCIvXCIgJiYgIWluQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgZXNjYXBlZCA9IGNoID09PSBcIlxcXFxcIjtcbiAgICB9IGVsc2UgeyBlc2NhcGVkID0gZmFsc2U7IH1cbiAgICArK3RoaXMkMS5wb3M7XG4gIH1cbiAgdmFyIGNvbnRlbnQgPSB0aGlzLmlucHV0LnNsaWNlKHN0YXJ0LCB0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIC8vIE5lZWQgdG8gdXNlIGByZWFkV29yZDFgIGJlY2F1c2UgJ1xcdVhYWFgnIHNlcXVlbmNlcyBhcmUgYWxsb3dlZFxuICAvLyBoZXJlIChkb24ndCBhc2spLlxuICB2YXIgbW9kcyA9IHRoaXMucmVhZFdvcmQxKCk7XG4gIHZhciB0bXAgPSBjb250ZW50LCB0bXBGbGFncyA9IFwiXCI7XG4gIGlmIChtb2RzKSB7XG4gICAgdmFyIHZhbGlkRmxhZ3MgPSAvXltnaW1dKiQvO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNikgeyB2YWxpZEZsYWdzID0gL15bZ2ltdXldKiQvOyB9XG4gICAgaWYgKCF2YWxpZEZsYWdzLnRlc3QobW9kcykpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbiBmbGFnXCIpOyB9XG4gICAgaWYgKG1vZHMuaW5kZXhPZihcInVcIikgPj0gMCkge1xuICAgICAgaWYgKHJlZ2V4cFVuaWNvZGVTdXBwb3J0KSB7XG4gICAgICAgIHRtcEZsYWdzID0gXCJ1XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXBsYWNlIGVhY2ggYXN0cmFsIHN5bWJvbCBhbmQgZXZlcnkgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UgdGhhdFxuICAgICAgICAvLyBwb3NzaWJseSByZXByZXNlbnRzIGFuIGFzdHJhbCBzeW1ib2wgb3IgYSBwYWlyZWQgc3Vycm9nYXRlIHdpdGggYVxuICAgICAgICAvLyBzaW5nbGUgQVNDSUkgc3ltYm9sIHRvIGF2b2lkIHRocm93aW5nIG9uIHJlZ3VsYXIgZXhwcmVzc2lvbnMgdGhhdFxuICAgICAgICAvLyBhcmUgb25seSB2YWxpZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBgL3VgIGZsYWcuXG4gICAgICAgIC8vIE5vdGU6IHJlcGxhY2luZyB3aXRoIHRoZSBBU0NJSSBzeW1ib2wgYHhgIG1pZ2h0IGNhdXNlIGZhbHNlXG4gICAgICAgIC8vIG5lZ2F0aXZlcyBpbiB1bmxpa2VseSBzY2VuYXJpb3MuIEZvciBleGFtcGxlLCBgW1xcdXs2MX0tYl1gIGlzIGFcbiAgICAgICAgLy8gcGVyZmVjdGx5IHZhbGlkIHBhdHRlcm4gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGBbYS1iXWAsIGJ1dCBpdCB3b3VsZFxuICAgICAgICAvLyBiZSByZXBsYWNlZCBieSBgW3gtYl1gIHdoaWNoIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgdG1wID0gdG1wLnJlcGxhY2UoL1xcXFx1XFx7KFswLTlhLWZBLUZdKylcXH0vZywgZnVuY3Rpb24gKF9tYXRjaCwgY29kZSwgb2Zmc2V0KSB7XG4gICAgICAgICAgY29kZSA9IE51bWJlcihcIjB4XCIgKyBjb2RlKTtcbiAgICAgICAgICBpZiAoY29kZSA+IDB4MTBGRkZGKSB7IHRoaXMkMS5yYWlzZShzdGFydCArIG9mZnNldCArIDMsIFwiQ29kZSBwb2ludCBvdXQgb2YgYm91bmRzXCIpOyB9XG4gICAgICAgICAgcmV0dXJuIFwieFwiXG4gICAgICAgIH0pO1xuICAgICAgICB0bXAgPSB0bXAucmVwbGFjZSgvXFxcXHUoW2EtZkEtRjAtOV17NH0pfFtcXHVEODAwLVxcdURCRkZdW1xcdURDMDAtXFx1REZGRl0vZywgXCJ4XCIpO1xuICAgICAgICB0bXBGbGFncyA9IHRtcEZsYWdzLnJlcGxhY2UoXCJ1XCIsIFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEZXRlY3QgaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICB2YXIgdmFsdWUgPSBudWxsO1xuICAvLyBSaGlubydzIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXJzZXIgaXMgZmxha3kgYW5kIHRocm93cyB1bmNhdGNoYWJsZSBleGNlcHRpb25zLFxuICAvLyBzbyBkb24ndCBkbyBkZXRlY3Rpb24gaWYgd2UgYXJlIHJ1bm5pbmcgdW5kZXIgUmhpbm9cbiAgaWYgKCFpc1JoaW5vKSB7XG4gICAgdHJ5Q3JlYXRlUmVnZXhwKHRtcCwgdG1wRmxhZ3MsIHN0YXJ0LCB0aGlzKTtcbiAgICAvLyBHZXQgYSByZWd1bGFyIGV4cHJlc3Npb24gb2JqZWN0IGZvciB0aGlzIHBhdHRlcm4tZmxhZyBwYWlyLCBvciBgbnVsbGAgaW5cbiAgICAvLyBjYXNlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZmxhZ3MgaXQgdXNlcy5cbiAgICB2YWx1ZSA9IHRyeUNyZWF0ZVJlZ2V4cChjb250ZW50LCBtb2RzKTtcbiAgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5yZWdleHAsIHtwYXR0ZXJuOiBjb250ZW50LCBmbGFnczogbW9kcywgdmFsdWU6IHZhbHVlfSlcbn07XG5cbi8vIFJlYWQgYW4gaW50ZWdlciBpbiB0aGUgZ2l2ZW4gcmFkaXguIFJldHVybiBudWxsIGlmIHplcm8gZGlnaXRzXG4vLyB3ZXJlIHJlYWQsIHRoZSBpbnRlZ2VyIHZhbHVlIG90aGVyd2lzZS4gV2hlbiBgbGVuYCBpcyBnaXZlbiwgdGhpc1xuLy8gd2lsbCByZXR1cm4gYG51bGxgIHVubGVzcyB0aGUgaW50ZWdlciBoYXMgZXhhY3RseSBgbGVuYCBkaWdpdHMuXG5cbnBwJDgucmVhZEludCA9IGZ1bmN0aW9uKHJhZGl4LCBsZW4pIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHN0YXJ0ID0gdGhpcy5wb3MsIHRvdGFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIGUgPSBsZW4gPT0gbnVsbCA/IEluZmluaXR5IDogbGVuOyBpIDwgZTsgKytpKSB7XG4gICAgdmFyIGNvZGUgPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKSwgdmFsID0gKHZvaWQgMCk7XG4gICAgaWYgKGNvZGUgPj0gOTcpIHsgdmFsID0gY29kZSAtIDk3ICsgMTA7IH0gLy8gYVxuICAgIGVsc2UgaWYgKGNvZGUgPj0gNjUpIHsgdmFsID0gY29kZSAtIDY1ICsgMTA7IH0gLy8gQVxuICAgIGVsc2UgaWYgKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgeyB2YWwgPSBjb2RlIC0gNDg7IH0gLy8gMC05XG4gICAgZWxzZSB7IHZhbCA9IEluZmluaXR5OyB9XG4gICAgaWYgKHZhbCA+PSByYWRpeCkgeyBicmVhayB9XG4gICAgKyt0aGlzJDEucG9zO1xuICAgIHRvdGFsID0gdG90YWwgKiByYWRpeCArIHZhbDtcbiAgfVxuICBpZiAodGhpcy5wb3MgPT09IHN0YXJ0IHx8IGxlbiAhPSBudWxsICYmIHRoaXMucG9zIC0gc3RhcnQgIT09IGxlbikgeyByZXR1cm4gbnVsbCB9XG5cbiAgcmV0dXJuIHRvdGFsXG59O1xuXG5wcCQ4LnJlYWRSYWRpeE51bWJlciA9IGZ1bmN0aW9uKHJhZGl4KSB7XG4gIHRoaXMucG9zICs9IDI7IC8vIDB4XG4gIHZhciB2YWwgPSB0aGlzLnJlYWRJbnQocmFkaXgpO1xuICBpZiAodmFsID09IG51bGwpIHsgdGhpcy5yYWlzZSh0aGlzLnN0YXJ0ICsgMiwgXCJFeHBlY3RlZCBudW1iZXIgaW4gcmFkaXggXCIgKyByYWRpeCk7IH1cbiAgaWYgKGlzSWRlbnRpZmllclN0YXJ0KHRoaXMuZnVsbENoYXJDb2RlQXRQb3MoKSkpIHsgdGhpcy5yYWlzZSh0aGlzLnBvcywgXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKTsgfVxuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5udW0sIHZhbClcbn07XG5cbi8vIFJlYWQgYW4gaW50ZWdlciwgb2N0YWwgaW50ZWdlciwgb3IgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxuXG5wcCQ4LnJlYWROdW1iZXIgPSBmdW5jdGlvbihzdGFydHNXaXRoRG90KSB7XG4gIHZhciBzdGFydCA9IHRoaXMucG9zLCBpc0Zsb2F0ID0gZmFsc2UsIG9jdGFsID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKSA9PT0gNDg7XG4gIGlmICghc3RhcnRzV2l0aERvdCAmJiB0aGlzLnJlYWRJbnQoMTApID09PSBudWxsKSB7IHRoaXMucmFpc2Uoc3RhcnQsIFwiSW52YWxpZCBudW1iZXJcIik7IH1cbiAgaWYgKG9jdGFsICYmIHRoaXMucG9zID09IHN0YXJ0ICsgMSkgeyBvY3RhbCA9IGZhbHNlOyB9XG4gIHZhciBuZXh0ID0gdGhpcy5pbnB1dC5jaGFyQ29kZUF0KHRoaXMucG9zKTtcbiAgaWYgKG5leHQgPT09IDQ2ICYmICFvY3RhbCkgeyAvLyAnLidcbiAgICArK3RoaXMucG9zO1xuICAgIHRoaXMucmVhZEludCgxMCk7XG4gICAgaXNGbG9hdCA9IHRydWU7XG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gIH1cbiAgaWYgKChuZXh0ID09PSA2OSB8fCBuZXh0ID09PSAxMDEpICYmICFvY3RhbCkgeyAvLyAnZUUnXG4gICAgbmV4dCA9IHRoaXMuaW5wdXQuY2hhckNvZGVBdCgrK3RoaXMucG9zKTtcbiAgICBpZiAobmV4dCA9PT0gNDMgfHwgbmV4dCA9PT0gNDUpIHsgKyt0aGlzLnBvczsgfSAvLyAnKy0nXG4gICAgaWYgKHRoaXMucmVhZEludCgxMCkgPT09IG51bGwpIHsgdGhpcy5yYWlzZShzdGFydCwgXCJJbnZhbGlkIG51bWJlclwiKTsgfVxuICAgIGlzRmxvYXQgPSB0cnVlO1xuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydCh0aGlzLmZ1bGxDaGFyQ29kZUF0UG9zKCkpKSB7IHRoaXMucmFpc2UodGhpcy5wb3MsIFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7IH1cblxuICB2YXIgc3RyID0gdGhpcy5pbnB1dC5zbGljZShzdGFydCwgdGhpcy5wb3MpLCB2YWw7XG4gIGlmIChpc0Zsb2F0KSB7IHZhbCA9IHBhcnNlRmxvYXQoc3RyKTsgfVxuICBlbHNlIGlmICghb2N0YWwgfHwgc3RyLmxlbmd0aCA9PT0gMSkgeyB2YWwgPSBwYXJzZUludChzdHIsIDEwKTsgfVxuICBlbHNlIGlmICh0aGlzLnN0cmljdCkgeyB0aGlzLnJhaXNlKHN0YXJ0LCBcIkludmFsaWQgbnVtYmVyXCIpOyB9XG4gIGVsc2UgaWYgKC9bODldLy50ZXN0KHN0cikpIHsgdmFsID0gcGFyc2VJbnQoc3RyLCAxMCk7IH1cbiAgZWxzZSB7IHZhbCA9IHBhcnNlSW50KHN0ciwgOCk7IH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZXMubnVtLCB2YWwpXG59O1xuXG4vLyBSZWFkIGEgc3RyaW5nIHZhbHVlLCBpbnRlcnByZXRpbmcgYmFja3NsYXNoLWVzY2FwZXMuXG5cbnBwJDgucmVhZENvZGVQb2ludCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpLCBjb2RlO1xuXG4gIGlmIChjaCA9PT0gMTIzKSB7IC8vICd7J1xuICAgIGlmICh0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPCA2KSB7IHRoaXMudW5leHBlY3RlZCgpOyB9XG4gICAgdmFyIGNvZGVQb3MgPSArK3RoaXMucG9zO1xuICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKHRoaXMuaW5wdXQuaW5kZXhPZihcIn1cIiwgdGhpcy5wb3MpIC0gdGhpcy5wb3MpO1xuICAgICsrdGhpcy5wb3M7XG4gICAgaWYgKGNvZGUgPiAweDEwRkZGRikgeyB0aGlzLmludmFsaWRTdHJpbmdUb2tlbihjb2RlUG9zLCBcIkNvZGUgcG9pbnQgb3V0IG9mIGJvdW5kc1wiKTsgfVxuICB9IGVsc2Uge1xuICAgIGNvZGUgPSB0aGlzLnJlYWRIZXhDaGFyKDQpO1xuICB9XG4gIHJldHVybiBjb2RlXG59O1xuXG5mdW5jdGlvbiBjb2RlUG9pbnRUb1N0cmluZyhjb2RlKSB7XG4gIC8vIFVURi0xNiBEZWNvZGluZ1xuICBpZiAoY29kZSA8PSAweEZGRkYpIHsgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSkgfVxuICBjb2RlIC09IDB4MTAwMDA7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKChjb2RlID4+IDEwKSArIDB4RDgwMCwgKGNvZGUgJiAxMDIzKSArIDB4REMwMClcbn1cblxucHAkOC5yZWFkU3RyaW5nID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG91dCA9IFwiXCIsIGNodW5rU3RhcnQgPSArK3RoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMkMS5wb3MgPj0gdGhpcyQxLmlucHV0Lmxlbmd0aCkgeyB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIlVudGVybWluYXRlZCBzdHJpbmcgY29uc3RhbnRcIik7IH1cbiAgICB2YXIgY2ggPSB0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKTtcbiAgICBpZiAoY2ggPT09IHF1b3RlKSB7IGJyZWFrIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgIG91dCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcyQxLnJlYWRFc2NhcGVkQ2hhcihmYWxzZSk7XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzTmV3TGluZShjaCkpIHsgdGhpcyQxLnJhaXNlKHRoaXMkMS5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpOyB9XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgfVxuICB9XG4gIG91dCArPSB0aGlzLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMucG9zKyspO1xuICByZXR1cm4gdGhpcy5maW5pc2hUb2tlbih0eXBlcy5zdHJpbmcsIG91dClcbn07XG5cbi8vIFJlYWRzIHRlbXBsYXRlIHN0cmluZyB0b2tlbnMuXG5cbnZhciBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUiA9IHt9O1xuXG5wcCQ4LnRyeVJlYWRUZW1wbGF0ZVRva2VuID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaW5UZW1wbGF0ZUVsZW1lbnQgPSB0cnVlO1xuICB0cnkge1xuICAgIHRoaXMucmVhZFRtcGxUb2tlbigpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyID09PSBJTlZBTElEX1RFTVBMQVRFX0VTQ0FQRV9FUlJPUikge1xuICAgICAgdGhpcy5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuICB9XG5cbiAgdGhpcy5pblRlbXBsYXRlRWxlbWVudCA9IGZhbHNlO1xufTtcblxucHAkOC5pbnZhbGlkU3RyaW5nVG9rZW4gPSBmdW5jdGlvbihwb3NpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAodGhpcy5pblRlbXBsYXRlRWxlbWVudCAmJiB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gOSkge1xuICAgIHRocm93IElOVkFMSURfVEVNUExBVEVfRVNDQVBFX0VSUk9SXG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yYWlzZShwb3NpdGlvbiwgbWVzc2FnZSk7XG4gIH1cbn07XG5cbnBwJDgucmVhZFRtcGxUb2tlbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb3V0ID0gXCJcIiwgY2h1bmtTdGFydCA9IHRoaXMucG9zO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKHRoaXMkMS5wb3MgPj0gdGhpcyQxLmlucHV0Lmxlbmd0aCkgeyB0aGlzJDEucmFpc2UodGhpcyQxLnN0YXJ0LCBcIlVudGVybWluYXRlZCB0ZW1wbGF0ZVwiKTsgfVxuICAgIHZhciBjaCA9IHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MpO1xuICAgIGlmIChjaCA9PT0gOTYgfHwgY2ggPT09IDM2ICYmIHRoaXMkMS5pbnB1dC5jaGFyQ29kZUF0KHRoaXMkMS5wb3MgKyAxKSA9PT0gMTIzKSB7IC8vICdgJywgJyR7J1xuICAgICAgaWYgKHRoaXMkMS5wb3MgPT09IHRoaXMkMS5zdGFydCAmJiAodGhpcyQxLnR5cGUgPT09IHR5cGVzLnRlbXBsYXRlIHx8IHRoaXMkMS50eXBlID09PSB0eXBlcy5pbnZhbGlkVGVtcGxhdGUpKSB7XG4gICAgICAgIGlmIChjaCA9PT0gMzYpIHtcbiAgICAgICAgICB0aGlzJDEucG9zICs9IDI7XG4gICAgICAgICAgcmV0dXJuIHRoaXMkMS5maW5pc2hUb2tlbih0eXBlcy5kb2xsYXJCcmFjZUwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKyt0aGlzJDEucG9zO1xuICAgICAgICAgIHJldHVybiB0aGlzJDEuZmluaXNoVG9rZW4odHlwZXMuYmFja1F1b3RlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvdXQgKz0gdGhpcyQxLmlucHV0LnNsaWNlKGNodW5rU3RhcnQsIHRoaXMkMS5wb3MpO1xuICAgICAgcmV0dXJuIHRoaXMkMS5maW5pc2hUb2tlbih0eXBlcy50ZW1wbGF0ZSwgb3V0KVxuICAgIH1cbiAgICBpZiAoY2ggPT09IDkyKSB7IC8vICdcXCdcbiAgICAgIG91dCArPSB0aGlzJDEuaW5wdXQuc2xpY2UoY2h1bmtTdGFydCwgdGhpcyQxLnBvcyk7XG4gICAgICBvdXQgKz0gdGhpcyQxLnJlYWRFc2NhcGVkQ2hhcih0cnVlKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgIH0gZWxzZSBpZiAoaXNOZXdMaW5lKGNoKSkge1xuICAgICAgb3V0ICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIGlmICh0aGlzJDEuaW5wdXQuY2hhckNvZGVBdCh0aGlzJDEucG9zKSA9PT0gMTApIHsgKyt0aGlzJDEucG9zOyB9XG4gICAgICBjYXNlIDEwOlxuICAgICAgICBvdXQgKz0gXCJcXG5cIjtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzJDEub3B0aW9ucy5sb2NhdGlvbnMpIHtcbiAgICAgICAgKyt0aGlzJDEuY3VyTGluZTtcbiAgICAgICAgdGhpcyQxLmxpbmVTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgICB9XG4gICAgICBjaHVua1N0YXJ0ID0gdGhpcyQxLnBvcztcbiAgICB9IGVsc2Uge1xuICAgICAgKyt0aGlzJDEucG9zO1xuICAgIH1cbiAgfVxufTtcblxuLy8gUmVhZHMgYSB0ZW1wbGF0ZSB0b2tlbiB0byBzZWFyY2ggZm9yIHRoZSBlbmQsIHdpdGhvdXQgdmFsaWRhdGluZyBhbnkgZXNjYXBlIHNlcXVlbmNlc1xucHAkOC5yZWFkSW52YWxpZFRlbXBsYXRlVG9rZW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICg7IHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGg7IHRoaXMucG9zKyspIHtcbiAgICBzd2l0Y2ggKHRoaXMkMS5pbnB1dFt0aGlzJDEucG9zXSkge1xuICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICArK3RoaXMkMS5wb3M7XG4gICAgICBicmVha1xuXG4gICAgY2FzZSBcIiRcIjpcbiAgICAgIGlmICh0aGlzJDEuaW5wdXRbdGhpcyQxLnBvcyArIDFdICE9PSBcIntcIikge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIC8vIGZhbGxzIHRocm91Z2hcblxuICAgIGNhc2UgXCJgXCI6XG4gICAgICByZXR1cm4gdGhpcyQxLmZpbmlzaFRva2VuKHR5cGVzLmludmFsaWRUZW1wbGF0ZSwgdGhpcyQxLmlucHV0LnNsaWNlKHRoaXMkMS5zdGFydCwgdGhpcyQxLnBvcykpXG5cbiAgICAvLyBubyBkZWZhdWx0XG4gICAgfVxuICB9XG4gIHRoaXMucmFpc2UodGhpcy5zdGFydCwgXCJVbnRlcm1pbmF0ZWQgdGVtcGxhdGVcIik7XG59O1xuXG4vLyBVc2VkIHRvIHJlYWQgZXNjYXBlZCBjaGFyYWN0ZXJzXG5cbnBwJDgucmVhZEVzY2FwZWRDaGFyID0gZnVuY3Rpb24oaW5UZW1wbGF0ZSkge1xuICB2YXIgY2ggPSB0aGlzLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzLnBvcyk7XG4gICsrdGhpcy5wb3M7XG4gIHN3aXRjaCAoY2gpIHtcbiAgY2FzZSAxMTA6IHJldHVybiBcIlxcblwiIC8vICduJyAtPiAnXFxuJ1xuICBjYXNlIDExNDogcmV0dXJuIFwiXFxyXCIgLy8gJ3InIC0+ICdcXHInXG4gIGNhc2UgMTIwOiByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRIZXhDaGFyKDIpKSAvLyAneCdcbiAgY2FzZSAxMTc6IHJldHVybiBjb2RlUG9pbnRUb1N0cmluZyh0aGlzLnJlYWRDb2RlUG9pbnQoKSkgLy8gJ3UnXG4gIGNhc2UgMTE2OiByZXR1cm4gXCJcXHRcIiAvLyAndCcgLT4gJ1xcdCdcbiAgY2FzZSA5ODogcmV0dXJuIFwiXFxiXCIgLy8gJ2InIC0+ICdcXGInXG4gIGNhc2UgMTE4OiByZXR1cm4gXCJcXHUwMDBiXCIgLy8gJ3YnIC0+ICdcXHUwMDBiJ1xuICBjYXNlIDEwMjogcmV0dXJuIFwiXFxmXCIgLy8gJ2YnIC0+ICdcXGYnXG4gIGNhc2UgMTM6IGlmICh0aGlzLmlucHV0LmNoYXJDb2RlQXQodGhpcy5wb3MpID09PSAxMCkgeyArK3RoaXMucG9zOyB9IC8vICdcXHJcXG4nXG4gIGNhc2UgMTA6IC8vICcgXFxuJ1xuICAgIGlmICh0aGlzLm9wdGlvbnMubG9jYXRpb25zKSB7IHRoaXMubGluZVN0YXJ0ID0gdGhpcy5wb3M7ICsrdGhpcy5jdXJMaW5lOyB9XG4gICAgcmV0dXJuIFwiXCJcbiAgZGVmYXVsdDpcbiAgICBpZiAoY2ggPj0gNDggJiYgY2ggPD0gNTUpIHtcbiAgICAgIHZhciBvY3RhbFN0ciA9IHRoaXMuaW5wdXQuc3Vic3RyKHRoaXMucG9zIC0gMSwgMykubWF0Y2goL15bMC03XSsvKVswXTtcbiAgICAgIHZhciBvY3RhbCA9IHBhcnNlSW50KG9jdGFsU3RyLCA4KTtcbiAgICAgIGlmIChvY3RhbCA+IDI1NSkge1xuICAgICAgICBvY3RhbFN0ciA9IG9jdGFsU3RyLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgb2N0YWwgPSBwYXJzZUludChvY3RhbFN0ciwgOCk7XG4gICAgICB9XG4gICAgICBpZiAob2N0YWxTdHIgIT09IFwiMFwiICYmICh0aGlzLnN0cmljdCB8fCBpblRlbXBsYXRlKSkge1xuICAgICAgICB0aGlzLmludmFsaWRTdHJpbmdUb2tlbih0aGlzLnBvcyAtIDIsIFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucG9zICs9IG9jdGFsU3RyLmxlbmd0aCAtIDE7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvY3RhbClcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpXG4gIH1cbn07XG5cbi8vIFVzZWQgdG8gcmVhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlcyAoJ1xceCcsICdcXHUnLCAnXFxVJykuXG5cbnBwJDgucmVhZEhleENoYXIgPSBmdW5jdGlvbihsZW4pIHtcbiAgdmFyIGNvZGVQb3MgPSB0aGlzLnBvcztcbiAgdmFyIG4gPSB0aGlzLnJlYWRJbnQoMTYsIGxlbik7XG4gIGlmIChuID09PSBudWxsKSB7IHRoaXMuaW52YWxpZFN0cmluZ1Rva2VuKGNvZGVQb3MsIFwiQmFkIGNoYXJhY3RlciBlc2NhcGUgc2VxdWVuY2VcIik7IH1cbiAgcmV0dXJuIG5cbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciwgYW5kIHJldHVybiBpdCBhcyBhIHN0cmluZy4gU2V0cyBgdGhpcy5jb250YWluc0VzY2Bcbi8vIHRvIHdoZXRoZXIgdGhlIHdvcmQgY29udGFpbmVkIGEgJ1xcdScgZXNjYXBlLlxuLy9cbi8vIEluY3JlbWVudGFsbHkgYWRkcyBvbmx5IGVzY2FwZWQgY2hhcnMsIGFkZGluZyBvdGhlciBjaHVua3MgYXMtaXNcbi8vIGFzIGEgbWljcm8tb3B0aW1pemF0aW9uLlxuXG5wcCQ4LnJlYWRXb3JkMSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmNvbnRhaW5zRXNjID0gZmFsc2U7XG4gIHZhciB3b3JkID0gXCJcIiwgZmlyc3QgPSB0cnVlLCBjaHVua1N0YXJ0ID0gdGhpcy5wb3M7XG4gIHZhciBhc3RyYWwgPSB0aGlzLm9wdGlvbnMuZWNtYVZlcnNpb24gPj0gNjtcbiAgd2hpbGUgKHRoaXMucG9zIDwgdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICB2YXIgY2ggPSB0aGlzJDEuZnVsbENoYXJDb2RlQXRQb3MoKTtcbiAgICBpZiAoaXNJZGVudGlmaWVyQ2hhcihjaCwgYXN0cmFsKSkge1xuICAgICAgdGhpcyQxLnBvcyArPSBjaCA8PSAweGZmZmYgPyAxIDogMjtcbiAgICB9IGVsc2UgaWYgKGNoID09PSA5MikgeyAvLyBcIlxcXCJcbiAgICAgIHRoaXMkMS5jb250YWluc0VzYyA9IHRydWU7XG4gICAgICB3b3JkICs9IHRoaXMkMS5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzJDEucG9zKTtcbiAgICAgIHZhciBlc2NTdGFydCA9IHRoaXMkMS5wb3M7XG4gICAgICBpZiAodGhpcyQxLmlucHV0LmNoYXJDb2RlQXQoKyt0aGlzJDEucG9zKSAhPSAxMTcpIC8vIFwidVwiXG4gICAgICAgIHsgdGhpcyQxLmludmFsaWRTdHJpbmdUb2tlbih0aGlzJDEucG9zLCBcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIik7IH1cbiAgICAgICsrdGhpcyQxLnBvcztcbiAgICAgIHZhciBlc2MgPSB0aGlzJDEucmVhZENvZGVQb2ludCgpO1xuICAgICAgaWYgKCEoZmlyc3QgPyBpc0lkZW50aWZpZXJTdGFydCA6IGlzSWRlbnRpZmllckNoYXIpKGVzYywgYXN0cmFsKSlcbiAgICAgICAgeyB0aGlzJDEuaW52YWxpZFN0cmluZ1Rva2VuKGVzY1N0YXJ0LCBcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIik7IH1cbiAgICAgIHdvcmQgKz0gY29kZVBvaW50VG9TdHJpbmcoZXNjKTtcbiAgICAgIGNodW5rU3RhcnQgPSB0aGlzJDEucG9zO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBmaXJzdCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB3b3JkICsgdGhpcy5pbnB1dC5zbGljZShjaHVua1N0YXJ0LCB0aGlzLnBvcylcbn07XG5cbi8vIFJlYWQgYW4gaWRlbnRpZmllciBvciBrZXl3b3JkIHRva2VuLiBXaWxsIGNoZWNrIGZvciByZXNlcnZlZFxuLy8gd29yZHMgd2hlbiBuZWNlc3NhcnkuXG5cbnBwJDgucmVhZFdvcmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdvcmQgPSB0aGlzLnJlYWRXb3JkMSgpO1xuICB2YXIgdHlwZSA9IHR5cGVzLm5hbWU7XG4gIGlmICh0aGlzLmtleXdvcmRzLnRlc3Qod29yZCkpIHtcbiAgICBpZiAodGhpcy5jb250YWluc0VzYykgeyB0aGlzLnJhaXNlUmVjb3ZlcmFibGUodGhpcy5zdGFydCwgXCJFc2NhcGUgc2VxdWVuY2UgaW4ga2V5d29yZCBcIiArIHdvcmQpOyB9XG4gICAgdHlwZSA9IGtleXdvcmRzJDFbd29yZF07XG4gIH1cbiAgcmV0dXJuIHRoaXMuZmluaXNoVG9rZW4odHlwZSwgd29yZClcbn07XG5cbi8vIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQuXG4vL1xuLy8gQWNvcm4gd2FzIHdyaXR0ZW4gYnkgTWFyaWpuIEhhdmVyYmVrZSwgSW5ndmFyIFN0ZXBhbnlhbiwgYW5kXG4vLyB2YXJpb3VzIGNvbnRyaWJ1dG9ycyBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4vL1xuLy8gR2l0IHJlcG9zaXRvcmllcyBmb3IgQWNvcm4gYXJlIGF2YWlsYWJsZSBhdFxuLy9cbi8vICAgICBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2dpdC9hY29yblxuLy8gICAgIGh0dHBzOi8vZ2l0aHViLmNvbS90ZXJuanMvYWNvcm4uZ2l0XG4vL1xuLy8gUGxlYXNlIHVzZSB0aGUgW2dpdGh1YiBidWcgdHJhY2tlcl1bZ2hidF0gdG8gcmVwb3J0IGlzc3Vlcy5cbi8vXG4vLyBbZ2hidF06IGh0dHBzOi8vZ2l0aHViLmNvbS90ZXJuanMvYWNvcm4vaXNzdWVzXG4vL1xuLy8gVGhpcyBmaWxlIGRlZmluZXMgdGhlIG1haW4gcGFyc2VyIGludGVyZmFjZS4gVGhlIGxpYnJhcnkgYWxzbyBjb21lc1xuLy8gd2l0aCBhIFtlcnJvci10b2xlcmFudCBwYXJzZXJdW2RhbW1pdF0gYW5kIGFuXG4vLyBbYWJzdHJhY3Qgc3ludGF4IHRyZWUgd2Fsa2VyXVt3YWxrXSwgZGVmaW5lZCBpbiBvdGhlciBmaWxlcy5cbi8vXG4vLyBbZGFtbWl0XTogYWNvcm5fbG9vc2UuanNcbi8vIFt3YWxrXTogdXRpbC93YWxrLmpzXG5cbnZhciB2ZXJzaW9uJDEgPSBcIjUuMi4xXCI7XG5cbi8vIFRoZSBtYWluIGV4cG9ydGVkIGludGVyZmFjZSAodW5kZXIgYHNlbGYuYWNvcm5gIHdoZW4gaW4gdGhlXG4vLyBicm93c2VyKSBpcyBhIGBwYXJzZWAgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGNvZGUgc3RyaW5nIGFuZFxuLy8gcmV0dXJucyBhbiBhYnN0cmFjdCBzeW50YXggdHJlZSBhcyBzcGVjaWZpZWQgYnkgW01vemlsbGEgcGFyc2VyXG4vLyBBUEldW2FwaV0uXG4vL1xuLy8gW2FwaV06IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvU3BpZGVyTW9ua2V5L1BhcnNlcl9BUElcblxuZnVuY3Rpb24gcGFyc2UkMShpbnB1dCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBhcnNlciQxKG9wdGlvbnMsIGlucHV0KS5wYXJzZSgpXG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gdHJpZXMgdG8gcGFyc2UgYSBzaW5nbGUgZXhwcmVzc2lvbiBhdCBhIGdpdmVuXG4vLyBvZmZzZXQgaW4gYSBzdHJpbmcuIFVzZWZ1bCBmb3IgcGFyc2luZyBtaXhlZC1sYW5ndWFnZSBmb3JtYXRzXG4vLyB0aGF0IGVtYmVkIEphdmFTY3JpcHQgZXhwcmVzc2lvbnMuXG5cbmZ1bmN0aW9uIHBhcnNlRXhwcmVzc2lvbkF0KGlucHV0LCBwb3MsIG9wdGlvbnMpIHtcbiAgdmFyIHAgPSBuZXcgUGFyc2VyJDEob3B0aW9ucywgaW5wdXQsIHBvcyk7XG4gIHAubmV4dFRva2VuKCk7XG4gIHJldHVybiBwLnBhcnNlRXhwcmVzc2lvbigpXG59XG5cbi8vIEFjb3JuIGlzIG9yZ2FuaXplZCBhcyBhIHRva2VuaXplciBhbmQgYSByZWN1cnNpdmUtZGVzY2VudCBwYXJzZXIuXG4vLyBUaGUgYHRva2VuaXplcmAgZXhwb3J0IHByb3ZpZGVzIGFuIGludGVyZmFjZSB0byB0aGUgdG9rZW5pemVyLlxuXG5mdW5jdGlvbiB0b2tlbml6ZXIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQYXJzZXIkMShvcHRpb25zLCBpbnB1dClcbn1cblxuLy8gVGhpcyBpcyBhIHRlcnJpYmxlIGtsdWRnZSB0byBzdXBwb3J0IHRoZSBleGlzdGluZywgcHJlLUVTNlxuLy8gaW50ZXJmYWNlIHdoZXJlIHRoZSBsb29zZSBwYXJzZXIgbW9kdWxlIHJldHJvYWN0aXZlbHkgYWRkcyBleHBvcnRzXG4vLyB0byB0aGlzIG1vZHVsZS5cbnZhciBwYXJzZV9kYW1taXQ7XG52YXIgTG9vc2VQYXJzZXI7XG52YXIgcGx1Z2luc0xvb3NlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuZnVuY3Rpb24gYWRkTG9vc2VFeHBvcnRzKHBhcnNlLCBQYXJzZXIkJDEsIHBsdWdpbnMkJDEpIHtcbiAgcGFyc2VfZGFtbWl0ID0gcGFyc2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gIExvb3NlUGFyc2VyID0gUGFyc2VyJCQxO1xuICBwbHVnaW5zTG9vc2UgPSBwbHVnaW5zJCQxO1xufVxuXG5cblxuXG52YXIgYWNvcm4gPSBPYmplY3QuZnJlZXplKHtcblx0dmVyc2lvbjogdmVyc2lvbiQxLFxuXHRwYXJzZTogcGFyc2UkMSxcblx0cGFyc2VFeHByZXNzaW9uQXQ6IHBhcnNlRXhwcmVzc2lvbkF0LFxuXHR0b2tlbml6ZXI6IHRva2VuaXplcixcblx0Z2V0IHBhcnNlX2RhbW1pdCAoKSB7IHJldHVybiBwYXJzZV9kYW1taXQ7IH0sXG5cdGdldCBMb29zZVBhcnNlciAoKSB7IHJldHVybiBMb29zZVBhcnNlcjsgfSxcblx0Z2V0IHBsdWdpbnNMb29zZSAoKSB7IHJldHVybiBwbHVnaW5zTG9vc2U7IH0sXG5cdGFkZExvb3NlRXhwb3J0czogYWRkTG9vc2VFeHBvcnRzLFxuXHRQYXJzZXI6IFBhcnNlciQxLFxuXHRwbHVnaW5zOiBwbHVnaW5zLFxuXHRkZWZhdWx0T3B0aW9uczogZGVmYXVsdE9wdGlvbnMsXG5cdFBvc2l0aW9uOiBQb3NpdGlvbixcblx0U291cmNlTG9jYXRpb246IFNvdXJjZUxvY2F0aW9uLFxuXHRnZXRMaW5lSW5mbzogZ2V0TGluZUluZm8sXG5cdE5vZGU6IE5vZGUsXG5cdFRva2VuVHlwZTogVG9rZW5UeXBlLFxuXHR0b2tUeXBlczogdHlwZXMsXG5cdGtleXdvcmRUeXBlczoga2V5d29yZHMkMSxcblx0VG9rQ29udGV4dDogVG9rQ29udGV4dCxcblx0dG9rQ29udGV4dHM6IHR5cGVzJDEsXG5cdGlzSWRlbnRpZmllckNoYXI6IGlzSWRlbnRpZmllckNoYXIsXG5cdGlzSWRlbnRpZmllclN0YXJ0OiBpc0lkZW50aWZpZXJTdGFydCxcblx0VG9rZW46IFRva2VuLFxuXHRpc05ld0xpbmU6IGlzTmV3TGluZSxcblx0bGluZUJyZWFrOiBsaW5lQnJlYWssXG5cdGxpbmVCcmVha0c6IGxpbmVCcmVha0csXG5cdG5vbkFTQ0lJd2hpdGVzcGFjZTogbm9uQVNDSUl3aGl0ZXNwYWNlXG59KTtcblxudmFyIGxpdGVyYWxzID0gbmV3IE1hcChbWyd0cnVlJywgdHJ1ZV0sIFsnZmFsc2UnLCBmYWxzZV0sIFsnbnVsbCcsIG51bGxdXSk7XG5mdW5jdGlvbiByZWFkRXhwcmVzc2lvbihwYXJzZXIpIHtcbiAgICB2YXIgc3RhcnQgPSBwYXJzZXIuaW5kZXg7XG4gICAgdmFyIG5hbWUgPSBwYXJzZXIucmVhZFVudGlsKC9cXHMqfX0vKTtcbiAgICBpZiAobmFtZSAmJiAvXlthLXpdKyQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgbmFtZS5sZW5ndGg7XG4gICAgICAgIGlmIChsaXRlcmFscy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0xpdGVyYWwnLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGl0ZXJhbHMuZ2V0KG5hbWUpLFxuICAgICAgICAgICAgICAgIHJhdzogbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0lkZW50aWZpZXInLFxuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydCArIG5hbWUubGVuZ3RoLFxuICAgICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZXIuaW5kZXggPSBzdGFydDtcbiAgICB0cnkge1xuICAgICAgICB2YXIgbm9kZSA9IHBhcnNlRXhwcmVzc2lvbkF0KHBhcnNlci50ZW1wbGF0ZSwgcGFyc2VyLmluZGV4LCB7XG4gICAgICAgICAgICBwcmVzZXJ2ZVBhcmVuczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcGFyc2VyLmluZGV4ID0gbm9kZS5lbmQ7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHBhcnNlci5hY29ybkVycm9yKGVycik7XG4gICAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xuXG5mdW5jdGlvbiBpbmplY3REeW5hbWljSW1wb3J0KGFjb3JuKSB7XG4gIGNvbnN0IHR0ID0gYWNvcm4udG9rVHlwZXM7XG5cbiAgLy8gTk9URTogVGhpcyBhbGxvd3MgYHlpZWxkIGltcG9ydCgpYCB0byBwYXJzZSBjb3JyZWN0bHkuXG4gIHR0Ll9pbXBvcnQuc3RhcnRzRXhwciA9IHRydWU7XG5cbiAgZnVuY3Rpb24gcGFyc2VEeW5hbWljSW1wb3J0KCkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgIHRoaXMubmV4dCgpO1xuICAgIGlmICh0aGlzLnR5cGUgIT09IHR0LnBhcmVuTCkge1xuICAgICAgdGhpcy51bmV4cGVjdGVkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZpbmlzaE5vZGUobm9kZSwgJ0ltcG9ydCcpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVla05leHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRbdGhpcy5wb3NdO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGFjb3JuLnBsdWdpbnMuZHluYW1pY0ltcG9ydCA9IGZ1bmN0aW9uIGR5bmFtaWNJbXBvcnRQbHVnaW4oaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5leHRlbmQoJ3BhcnNlU3RhdGVtZW50JywgbmV4dE1ldGhvZCA9PiAoXG4gICAgICBmdW5jdGlvbiBwYXJzZVN0YXRlbWVudCguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSgpO1xuICAgICAgICBpZiAodGhpcy50eXBlID09PSB0dC5faW1wb3J0KSB7XG4gICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gcGVla05leHQuY2FsbCh0aGlzKTtcbiAgICAgICAgICBpZiAobmV4dFRva2VuID09PSB0dC5wYXJlbkwubGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cHIgPSB0aGlzLnBhcnNlRXhwcmVzc2lvbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFeHByZXNzaW9uU3RhdGVtZW50KG5vZGUsIGV4cHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXh0TWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgICkpO1xuXG4gICAgaW5zdGFuY2UuZXh0ZW5kKCdwYXJzZUV4cHJBdG9tJywgbmV4dE1ldGhvZCA9PiAoXG4gICAgICBmdW5jdGlvbiBwYXJzZUV4cHJBdG9tKHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gdHQuX2ltcG9ydCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZUR5bmFtaWNJbXBvcnQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dE1ldGhvZC5jYWxsKHRoaXMsIHJlZkRlc3RydWN0dXJpbmdFcnJvcnMpO1xuICAgICAgfVxuICAgICkpO1xuICB9O1xuXG4gIHJldHVybiBhY29ybjtcbn1cblxuZnVuY3Rpb24gcmVwZWF0KHN0ciwgaSkge1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICByZXN1bHQgKz0gc3RyO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbnZhciBzY3JpcHRDbG9zaW5nVGFnID0gJzwvc2NyaXB0Pic7XG5pbmplY3REeW5hbWljSW1wb3J0KGFjb3JuKTtcbmZ1bmN0aW9uIHJlYWRTY3JpcHQocGFyc2VyLCBzdGFydCwgYXR0cmlidXRlcykge1xuICAgIHZhciBzY3JpcHRTdGFydCA9IHBhcnNlci5pbmRleDtcbiAgICB2YXIgc2NyaXB0RW5kID0gcGFyc2VyLnRlbXBsYXRlLmluZGV4T2Yoc2NyaXB0Q2xvc2luZ1RhZywgc2NyaXB0U3RhcnQpO1xuICAgIGlmIChzY3JpcHRFbmQgPT09IC0xKVxuICAgICAgICBwYXJzZXIuZXJyb3IoXCI8c2NyaXB0PiBtdXN0IGhhdmUgYSBjbG9zaW5nIHRhZ1wiKTtcbiAgICB2YXIgc291cmNlID0gcmVwZWF0KCcgJywgc2NyaXB0U3RhcnQpICsgcGFyc2VyLnRlbXBsYXRlLnNsaWNlKHNjcmlwdFN0YXJ0LCBzY3JpcHRFbmQpO1xuICAgIHBhcnNlci5pbmRleCA9IHNjcmlwdEVuZCArIHNjcmlwdENsb3NpbmdUYWcubGVuZ3RoO1xuICAgIHZhciBhc3Q7XG4gICAgdHJ5IHtcbiAgICAgICAgYXN0ID0gcGFyc2UkMShzb3VyY2UsIHtcbiAgICAgICAgICAgIGVjbWFWZXJzaW9uOiA4LFxuICAgICAgICAgICAgc291cmNlVHlwZTogJ21vZHVsZScsXG4gICAgICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0ltcG9ydDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBwYXJzZXIuYWNvcm5FcnJvcihlcnIpO1xuICAgIH1cbiAgICBpZiAoIWFzdC5ib2R5Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgYXN0LnN0YXJ0ID0gc2NyaXB0U3RhcnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IHBhcnNlci5pbmRleCxcbiAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgY29udGVudDogYXN0XG4gICAgfTtcbn1cblxudmFyIE1BWF9MSU5FX0xFTkdUSCA9IDEwMDtcbnZhciBPRkZTRVRfQ09SUkVDVElPTiA9IDYwO1xudmFyIFRBQl9SRVBMQUNFTUVOVCA9ICcgICAgJztcblxuZnVuY3Rpb24gc291cmNlRnJhZ21lbnQoZXJyb3IsIGV4dHJhTGluZXMpIHtcbiAgICBmdW5jdGlvbiBwcm9jZXNzTGluZXMoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsIGlkeCkge1xuICAgICAgICAgICAgdmFyIG51bSA9IFN0cmluZyhzdGFydCArIGlkeCArIDEpO1xuXG4gICAgICAgICAgICB3aGlsZSAobnVtLmxlbmd0aCA8IG1heE51bUxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG51bSA9ICcgJyArIG51bTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG51bSArICcgfCcgKyBsaW5lO1xuICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICB2YXIgbGluZXMgPSBlcnJvci5zb3VyY2Uuc3BsaXQoL1xcbnxcXHJcXG4/fFxcZi8pO1xuICAgIHZhciBsaW5lID0gZXJyb3IubGluZTtcbiAgICB2YXIgY29sdW1uID0gZXJyb3IuY29sdW1uO1xuICAgIHZhciBzdGFydExpbmUgPSBNYXRoLm1heCgxLCBsaW5lIC0gZXh0cmFMaW5lcykgLSAxO1xuICAgIHZhciBlbmRMaW5lID0gTWF0aC5taW4obGluZSArIGV4dHJhTGluZXMsIGxpbmVzLmxlbmd0aCArIDEpO1xuICAgIHZhciBtYXhOdW1MZW5ndGggPSBNYXRoLm1heCg0LCBTdHJpbmcoZW5kTGluZSkubGVuZ3RoKSArIDE7XG4gICAgdmFyIGN1dExlZnQgPSAwO1xuXG4gICAgLy8gY29ycmVjdCBjb2x1bW4gYWNjb3JkaW5nIHRvIHJlcGxhY2VkIHRhYiBiZWZvcmUgY29sdW1uXG4gICAgY29sdW1uICs9IChUQUJfUkVQTEFDRU1FTlQubGVuZ3RoIC0gMSkgKiAobGluZXNbbGluZSAtIDFdLnN1YnN0cigwLCBjb2x1bW4gLSAxKS5tYXRjaCgvXFx0L2cpIHx8IFtdKS5sZW5ndGg7XG5cbiAgICBpZiAoY29sdW1uID4gTUFYX0xJTkVfTEVOR1RIKSB7XG4gICAgICAgIGN1dExlZnQgPSBjb2x1bW4gLSBPRkZTRVRfQ09SUkVDVElPTiArIDM7XG4gICAgICAgIGNvbHVtbiA9IE9GRlNFVF9DT1JSRUNUSU9OIC0gMjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gc3RhcnRMaW5lOyBpIDw9IGVuZExpbmU7IGkrKykge1xuICAgICAgICBpZiAoaSA+PSAwICYmIGkgPCBsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmVzW2ldID0gbGluZXNbaV0ucmVwbGFjZSgvXFx0L2csIFRBQl9SRVBMQUNFTUVOVCk7XG4gICAgICAgICAgICBsaW5lc1tpXSA9XG4gICAgICAgICAgICAgICAgKGN1dExlZnQgPiAwICYmIGxpbmVzW2ldLmxlbmd0aCA+IGN1dExlZnQgPyAnXFx1MjAyNicgOiAnJykgK1xuICAgICAgICAgICAgICAgIGxpbmVzW2ldLnN1YnN0cihjdXRMZWZ0LCBNQVhfTElORV9MRU5HVEggLSAyKSArXG4gICAgICAgICAgICAgICAgKGxpbmVzW2ldLmxlbmd0aCA+IGN1dExlZnQgKyBNQVhfTElORV9MRU5HVEggLSAxID8gJ1xcdTIwMjYnIDogJycpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgcHJvY2Vzc0xpbmVzKHN0YXJ0TGluZSwgbGluZSksXG4gICAgICAgIG5ldyBBcnJheShjb2x1bW4gKyBtYXhOdW1MZW5ndGggKyAyKS5qb2luKCctJykgKyAnXicsXG4gICAgICAgIHByb2Nlc3NMaW5lcyhsaW5lLCBlbmRMaW5lKVxuICAgIF0uam9pbignXFxuJyk7XG59XG5cbnZhciBDc3NTeW50YXhFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHNvdXJjZSwgb2Zmc2V0LCBsaW5lLCBjb2x1bW4pIHtcbiAgICAvLyBzb21lIFZNcyBwcmV2ZW50IHNldHRpbmcgbGluZS9jb2x1bW4gb3RoZXJ3aXNlIChpT1MgU2FmYXJpIDEwIGV2ZW4gdGhyb3cgYW4gZXhjZXB0aW9uKVxuICAgIHZhciBlcnJvciA9IE9iamVjdC5jcmVhdGUoU3ludGF4RXJyb3IucHJvdG90eXBlKTtcblxuICAgIGVycm9yLm5hbWUgPSAnQ3NzU3ludGF4RXJyb3InO1xuICAgIGVycm9yLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIGVycm9yLnN0YWNrID0gKG5ldyBFcnJvcigpLnN0YWNrIHx8ICcnKS5yZXBsYWNlKC9eLitcXG4vLCBlcnJvci5uYW1lICsgJzogJyArIGVycm9yLm1lc3NhZ2UgKyAnXFxuJyk7XG4gICAgZXJyb3Iuc291cmNlID0gc291cmNlO1xuICAgIGVycm9yLm9mZnNldCA9IG9mZnNldDtcbiAgICBlcnJvci5saW5lID0gbGluZTtcbiAgICBlcnJvci5jb2x1bW4gPSBjb2x1bW47XG5cbiAgICBlcnJvci5zb3VyY2VGcmFnbWVudCA9IGZ1bmN0aW9uKGV4dHJhTGluZXMpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZUZyYWdtZW50KGVycm9yLCBpc05hTihleHRyYUxpbmVzKSA/IDAgOiBleHRyYUxpbmVzKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ2Zvcm1hdHRlZE1lc3NhZ2UnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICdQYXJzZSBlcnJvcjogJyArIGVycm9yLm1lc3NhZ2UgKyAnXFxuJyArXG4gICAgICAgICAgICAgICAgc291cmNlRnJhZ21lbnQoZXJyb3IsIDIpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmb3IgYmFja3dhcmQgY2FwYWJpbGl0eVxuICAgIGVycm9yLnBhcnNlRXJyb3IgPSB7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBsaW5lOiBsaW5lLFxuICAgICAgICBjb2x1bW46IGNvbHVtblxuICAgIH07XG5cbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG52YXIgZXJyb3IgPSBDc3NTeW50YXhFcnJvcjtcblxuLy8gdG9rZW4gdHlwZXMgKG5vdGU6IHZhbHVlIHNob3VsZG4ndCBpbnRlcnNlY3Qgd2l0aCB1c2VkIGNoYXIgY29kZXMpXG52YXIgV0hJVEVTUEFDRSQxID0gMTtcbnZhciBJREVOVElGSUVSJDEgPSAyO1xudmFyIE5VTUJFUiQxID0gMztcbnZhciBTVFJJTkckMSA9IDQ7XG52YXIgQ09NTUVOVCQxID0gNTtcbnZhciBQVU5DVFVBVE9SJDEgPSA2O1xudmFyIENETyQxID0gNztcbnZhciBDREMkMSA9IDg7XG52YXIgQVRSVUxFJDEgPSAxNDtcbnZhciBGVU5DVElPTiQxID0gMTU7XG52YXIgVVJMJDEgPSAxNjtcbnZhciBSQVckMSA9IDE3O1xuXG52YXIgVEFCID0gOTtcbnZhciBOJDEgPSAxMDtcbnZhciBGJDEgPSAxMjtcbnZhciBSJDEgPSAxMztcbnZhciBTUEFDRSA9IDMyO1xuXG52YXIgVFlQRSQxID0ge1xuICAgIFdoaXRlU3BhY2U6ICAgV0hJVEVTUEFDRSQxLFxuICAgIElkZW50aWZpZXI6ICAgSURFTlRJRklFUiQxLFxuICAgIE51bWJlcjogICAgICAgICAgIE5VTUJFUiQxLFxuICAgIFN0cmluZzogICAgICAgICAgIFNUUklORyQxLFxuICAgIENvbW1lbnQ6ICAgICAgICAgQ09NTUVOVCQxLFxuICAgIFB1bmN0dWF0b3I6ICAgUFVOQ1RVQVRPUiQxLFxuICAgIENETzogICAgICAgICAgICAgICAgIENETyQxLFxuICAgIENEQzogICAgICAgICAgICAgICAgIENEQyQxLFxuICAgIEF0cnVsZTogICAgICAgICAgIEFUUlVMRSQxLFxuICAgIEZ1bmN0aW9uOiAgICAgICBGVU5DVElPTiQxLFxuICAgIFVybDogICAgICAgICAgICAgICAgIFVSTCQxLFxuICAgIFJhdzogICAgICAgICAgICAgICAgIFJBVyQxLFxuXG4gICAgRXhjbGFtYXRpb25NYXJrOiAgICAgIDMzLCAgLy8gIVxuICAgIFF1b3RhdGlvbk1hcms6ICAgICAgICAzNCwgIC8vIFwiXG4gICAgTnVtYmVyU2lnbjogICAgICAgICAgIDM1LCAgLy8gI1xuICAgIERvbGxhclNpZ246ICAgICAgICAgICAzNiwgIC8vICRcbiAgICBQZXJjZW50U2lnbjogICAgICAgICAgMzcsICAvLyAlXG4gICAgQW1wZXJzYW5kOiAgICAgICAgICAgIDM4LCAgLy8gJlxuICAgIEFwb3N0cm9waGU6ICAgICAgICAgICAzOSwgIC8vICdcbiAgICBMZWZ0UGFyZW50aGVzaXM6ICAgICAgNDAsICAvLyAoXG4gICAgUmlnaHRQYXJlbnRoZXNpczogICAgIDQxLCAgLy8gKVxuICAgIEFzdGVyaXNrOiAgICAgICAgICAgICA0MiwgIC8vICpcbiAgICBQbHVzU2lnbjogICAgICAgICAgICAgNDMsICAvLyArXG4gICAgQ29tbWE6ICAgICAgICAgICAgICAgIDQ0LCAgLy8gLFxuICAgIEh5cGhlbk1pbnVzOiAgICAgICAgICA0NSwgIC8vIC1cbiAgICBGdWxsU3RvcDogICAgICAgICAgICAgNDYsICAvLyAuXG4gICAgU29saWR1czogICAgICAgICAgICAgIDQ3LCAgLy8gL1xuICAgIENvbG9uOiAgICAgICAgICAgICAgICA1OCwgIC8vIDpcbiAgICBTZW1pY29sb246ICAgICAgICAgICAgNTksICAvLyA7XG4gICAgTGVzc1RoYW5TaWduOiAgICAgICAgIDYwLCAgLy8gPFxuICAgIEVxdWFsc1NpZ246ICAgICAgICAgICA2MSwgIC8vID1cbiAgICBHcmVhdGVyVGhhblNpZ246ICAgICAgNjIsICAvLyA+XG4gICAgUXVlc3Rpb25NYXJrOiAgICAgICAgIDYzLCAgLy8gP1xuICAgIENvbW1lcmNpYWxBdDogICAgICAgICA2NCwgIC8vIEBcbiAgICBMZWZ0U3F1YXJlQnJhY2tldDogICAgOTEsICAvLyBbXG4gICAgQmFja3NsYXNoOiAgICAgICAgICAgIDkyLCAgLy8gXFxcbiAgICBSaWdodFNxdWFyZUJyYWNrZXQ6ICAgOTMsICAvLyBdXG4gICAgQ2lyY3VtZmxleEFjY2VudDogICAgIDk0LCAgLy8gXlxuICAgIExvd0xpbmU6ICAgICAgICAgICAgICA5NSwgIC8vIF9cbiAgICBHcmF2ZUFjY2VudDogICAgICAgICAgOTYsICAvLyBgXG4gICAgTGVmdEN1cmx5QnJhY2tldDogICAgMTIzLCAgLy8ge1xuICAgIFZlcnRpY2FsTGluZTogICAgICAgIDEyNCwgIC8vIHxcbiAgICBSaWdodEN1cmx5QnJhY2tldDogICAxMjUsICAvLyB9XG4gICAgVGlsZGU6ICAgICAgICAgICAgICAgMTI2ICAgLy8gflxufTtcblxudmFyIE5BTUUkMSA9IE9iamVjdC5rZXlzKFRZUEUkMSkucmVkdWNlKGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgcmVzdWx0W1RZUEUkMVtrZXldXSA9IGtleTtcbiAgICByZXR1cm4gcmVzdWx0O1xufSwge30pO1xuXG4vLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXN5bnRheC8jdG9rZW5pemVyLWRlZmluaXRpb25zXG4vLyA+IG5vbi1BU0NJSSBjb2RlIHBvaW50XG4vLyA+ICAgQSBjb2RlIHBvaW50IHdpdGggYSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVSswMDgwIDxjb250cm9sPlxuLy8gPiBuYW1lLXN0YXJ0IGNvZGUgcG9pbnRcbi8vID4gICBBIGxldHRlciwgYSBub24tQVNDSUkgY29kZSBwb2ludCwgb3IgVSswMDVGIExPVyBMSU5FIChfKS5cbi8vID4gbmFtZSBjb2RlIHBvaW50XG4vLyA+ICAgQSBuYW1lLXN0YXJ0IGNvZGUgcG9pbnQsIGEgZGlnaXQsIG9yIFUrMDAyRCBIWVBIRU4tTUlOVVMgKC0pXG4vLyBUaGF0IG1lYW5zIG9ubHkgQVNDSUkgY29kZSBwb2ludHMgaGFzIGEgc3BlY2lhbCBtZWFuaW5nIGFuZCB3ZSBhIG1hcHMgZm9yIDAuLjEyNyBjb2RlcyBvbmx5XG52YXIgU2FmZVVpbnQzMkFycmF5JDEgPSB0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDMyQXJyYXkgOiBBcnJheTsgLy8gZmFsbGJhY2sgb24gQXJyYXkgd2hlbiBUeXBlZEFycmF5IGlzIG5vdCBzdXBwb3J0ZWRcbnZhciBTWU1CT0xfVFlQRSQxID0gbmV3IFNhZmVVaW50MzJBcnJheSQxKDB4ODApO1xudmFyIFBVTkNUVUFUSU9OID0gbmV3IFNhZmVVaW50MzJBcnJheSQxKDB4ODApO1xudmFyIFNUT1BfVVJMX1JBVyA9IG5ldyBTYWZlVWludDMyQXJyYXkkMSgweDgwKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBTWU1CT0xfVFlQRSQxLmxlbmd0aDsgaSsrKSB7XG4gICAgU1lNQk9MX1RZUEUkMVtpXSA9IElERU5USUZJRVIkMTtcbn1cblxuLy8gZmlsbCBjYXRlZ29yaWVzXG5bXG4gICAgVFlQRSQxLkV4Y2xhbWF0aW9uTWFyaywgICAgLy8gIVxuICAgIFRZUEUkMS5RdW90YXRpb25NYXJrLCAgICAgIC8vIFwiXG4gICAgVFlQRSQxLk51bWJlclNpZ24sICAgICAgICAgLy8gI1xuICAgIFRZUEUkMS5Eb2xsYXJTaWduLCAgICAgICAgIC8vICRcbiAgICBUWVBFJDEuUGVyY2VudFNpZ24sICAgICAgICAvLyAlXG4gICAgVFlQRSQxLkFtcGVyc2FuZCwgICAgICAgICAgLy8gJlxuICAgIFRZUEUkMS5BcG9zdHJvcGhlLCAgICAgICAgIC8vICdcbiAgICBUWVBFJDEuTGVmdFBhcmVudGhlc2lzLCAgICAvLyAoXG4gICAgVFlQRSQxLlJpZ2h0UGFyZW50aGVzaXMsICAgLy8gKVxuICAgIFRZUEUkMS5Bc3RlcmlzaywgICAgICAgICAgIC8vICpcbiAgICBUWVBFJDEuUGx1c1NpZ24sICAgICAgICAgICAvLyArXG4gICAgVFlQRSQxLkNvbW1hLCAgICAgICAgICAgICAgLy8gLFxuICAgIFRZUEUkMS5IeXBoZW5NaW51cywgICAgICAgIC8vIC1cbiAgICBUWVBFJDEuRnVsbFN0b3AsICAgICAgICAgICAvLyAuXG4gICAgVFlQRSQxLlNvbGlkdXMsICAgICAgICAgICAgLy8gL1xuICAgIFRZUEUkMS5Db2xvbiwgICAgICAgICAgICAgIC8vIDpcbiAgICBUWVBFJDEuU2VtaWNvbG9uLCAgICAgICAgICAvLyA7XG4gICAgVFlQRSQxLkxlc3NUaGFuU2lnbiwgICAgICAgLy8gPFxuICAgIFRZUEUkMS5FcXVhbHNTaWduLCAgICAgICAgIC8vID1cbiAgICBUWVBFJDEuR3JlYXRlclRoYW5TaWduLCAgICAvLyA+XG4gICAgVFlQRSQxLlF1ZXN0aW9uTWFyaywgICAgICAgLy8gP1xuICAgIFRZUEUkMS5Db21tZXJjaWFsQXQsICAgICAgIC8vIEBcbiAgICBUWVBFJDEuTGVmdFNxdWFyZUJyYWNrZXQsICAvLyBbXG4gICAgLy8gVFlQRS5CYWNrc2xhc2gsICAgICAgICAgIC8vIFxcXG4gICAgVFlQRSQxLlJpZ2h0U3F1YXJlQnJhY2tldCwgLy8gXVxuICAgIFRZUEUkMS5DaXJjdW1mbGV4QWNjZW50LCAgIC8vIF5cbiAgICAvLyBUWVBFLkxvd0xpbmUsICAgICAgICAgICAgLy8gX1xuICAgIFRZUEUkMS5HcmF2ZUFjY2VudCwgICAgICAgIC8vIGBcbiAgICBUWVBFJDEuTGVmdEN1cmx5QnJhY2tldCwgICAvLyB7XG4gICAgVFlQRSQxLlZlcnRpY2FsTGluZSwgICAgICAgLy8gfFxuICAgIFRZUEUkMS5SaWdodEN1cmx5QnJhY2tldCwgIC8vIH1cbiAgICBUWVBFJDEuVGlsZGUgICAgICAgICAgICAgICAvLyB+XG5dLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgU1lNQk9MX1RZUEUkMVtOdW1iZXIoa2V5KV0gPSBQVU5DVFVBVE9SJDE7XG4gICAgUFVOQ1RVQVRJT05bTnVtYmVyKGtleSldID0gUFVOQ1RVQVRPUiQxO1xufSk7XG5cbmZvciAodmFyIGkgPSA0ODsgaSA8PSA1NzsgaSsrKSB7XG4gICAgU1lNQk9MX1RZUEUkMVtpXSA9IE5VTUJFUiQxO1xufVxuXG5TWU1CT0xfVFlQRSQxW1NQQUNFXSA9IFdISVRFU1BBQ0UkMTtcblNZTUJPTF9UWVBFJDFbVEFCXSA9IFdISVRFU1BBQ0UkMTtcblNZTUJPTF9UWVBFJDFbTiQxXSA9IFdISVRFU1BBQ0UkMTtcblNZTUJPTF9UWVBFJDFbUiQxXSA9IFdISVRFU1BBQ0UkMTtcblNZTUJPTF9UWVBFJDFbRiQxXSA9IFdISVRFU1BBQ0UkMTtcblxuU1lNQk9MX1RZUEUkMVtUWVBFJDEuQXBvc3Ryb3BoZV0gPSBTVFJJTkckMTtcblNZTUJPTF9UWVBFJDFbVFlQRSQxLlF1b3RhdGlvbk1hcmtdID0gU1RSSU5HJDE7XG5cblNUT1BfVVJMX1JBV1tTUEFDRV0gPSAxO1xuU1RPUF9VUkxfUkFXW1RBQl0gPSAxO1xuU1RPUF9VUkxfUkFXW04kMV0gPSAxO1xuU1RPUF9VUkxfUkFXW1IkMV0gPSAxO1xuU1RPUF9VUkxfUkFXW0YkMV0gPSAxO1xuU1RPUF9VUkxfUkFXW1RZUEUkMS5BcG9zdHJvcGhlXSA9IDE7XG5TVE9QX1VSTF9SQVdbVFlQRSQxLlF1b3RhdGlvbk1hcmtdID0gMTtcblNUT1BfVVJMX1JBV1tUWVBFJDEuTGVmdFBhcmVudGhlc2lzXSA9IDE7XG5TVE9QX1VSTF9SQVdbVFlQRSQxLlJpZ2h0UGFyZW50aGVzaXNdID0gMTtcblxuLy8gd2hpdGVzcGFjZSBpcyBwdW5jdHVhdGlvbiAuLi5cblBVTkNUVUFUSU9OW1NQQUNFXSA9IFBVTkNUVUFUT1IkMTtcblBVTkNUVUFUSU9OW1RBQl0gPSBQVU5DVFVBVE9SJDE7XG5QVU5DVFVBVElPTltOJDFdID0gUFVOQ1RVQVRPUiQxO1xuUFVOQ1RVQVRJT05bUiQxXSA9IFBVTkNUVUFUT1IkMTtcblBVTkNUVUFUSU9OW0YkMV0gPSBQVU5DVFVBVE9SJDE7XG4vLyAuLi4gaHlwZXIgbWludXMgaXMgbm90XG5QVU5DVFVBVElPTltUWVBFJDEuSHlwaGVuTWludXNdID0gMDtcblxudmFyIF9jb25zdCA9IHtcbiAgICBUWVBFOiBUWVBFJDEsXG4gICAgTkFNRTogTkFNRSQxLFxuXG4gICAgU1lNQk9MX1RZUEU6IFNZTUJPTF9UWVBFJDEsXG4gICAgUFVOQ1RVQVRJT046IFBVTkNUVUFUSU9OLFxuICAgIFNUT1BfVVJMX1JBVzogU1RPUF9VUkxfUkFXXG59O1xuXG52YXIgUFVOQ1RVQVRJT04kMSA9IF9jb25zdC5QVU5DVFVBVElPTjtcbnZhciBTVE9QX1VSTF9SQVckMSA9IF9jb25zdC5TVE9QX1VSTF9SQVc7XG52YXIgVFlQRSQyID0gX2NvbnN0LlRZUEU7XG52YXIgRlVMTFNUT1AkMSA9IFRZUEUkMi5GdWxsU3RvcDtcbnZhciBQTFVTU0lHTiQxID0gVFlQRSQyLlBsdXNTaWduO1xudmFyIEhZUEhFTk1JTlVTJDEgPSBUWVBFJDIuSHlwaGVuTWludXM7XG52YXIgUFVOQ1RVQVRPUiQyID0gVFlQRSQyLlB1bmN0dWF0b3I7XG52YXIgVEFCJDEgPSA5O1xudmFyIE4kMiA9IDEwO1xudmFyIEYkMiA9IDEyO1xudmFyIFIkMiA9IDEzO1xudmFyIFNQQUNFJDEgPSAzMjtcbnZhciBCQUNLX1NMQVNIID0gOTI7XG52YXIgRSA9IDEwMTsgLy8gJ2UnLmNoYXJDb2RlQXQoMClcblxuZnVuY3Rpb24gZmlyc3RDaGFyT2Zmc2V0JDEoc291cmNlKSB7XG4gICAgLy8gZGV0ZWN0IEJPTSAoaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnl0ZV9vcmRlcl9tYXJrKVxuICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGIHx8ICAvLyBVVEYtMTZCRVxuICAgICAgICBzb3VyY2UuY2hhckNvZGVBdCgwKSA9PT0gMHhGRkZFKSB7ICAvLyBVVEYtMTZMRVxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaXNIZXgoY29kZSkge1xuICAgIHJldHVybiAoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fCAvLyAwIC4uIDlcbiAgICAgICAgICAgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgfHwgLy8gQSAuLiBGXG4gICAgICAgICAgIChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKTsgIC8vIGEgLi4gZlxufVxuXG5mdW5jdGlvbiBpc051bWJlciQxKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3O1xufVxuXG5mdW5jdGlvbiBpc05ld2xpbmUoc291cmNlLCBvZmZzZXQsIGNvZGUpIHtcbiAgICBpZiAoY29kZSA9PT0gTiQyIHx8IGNvZGUgPT09IEYkMiB8fCBjb2RlID09PSBSJDIpIHtcbiAgICAgICAgaWYgKGNvZGUgPT09IFIkMiAmJiBvZmZzZXQgKyAxIDwgc291cmNlLmxlbmd0aCAmJiBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQgKyAxKSA9PT0gTiQyKSB7XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xufVxuXG5mdW5jdGlvbiBjbXBDaGFyKHRlc3RTdHIsIG9mZnNldCwgcmVmZXJlbmNlQ29kZSkge1xuICAgIHZhciBjb2RlID0gdGVzdFN0ci5jaGFyQ29kZUF0KG9mZnNldCk7XG5cbiAgICAvLyBjb2RlLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDkwKSB7XG4gICAgICAgIGNvZGUgPSBjb2RlIHwgMzI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvZGUgPT09IHJlZmVyZW5jZUNvZGU7XG59XG5cbmZ1bmN0aW9uIGNtcFN0ciQxKHRlc3RTdHIsIHN0YXJ0LCBlbmQsIHJlZmVyZW5jZVN0cikge1xuICAgIGlmIChlbmQgLSBzdGFydCAhPT0gcmVmZXJlbmNlU3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0ZXN0U3RyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgdmFyIHRlc3RDb2RlID0gdGVzdFN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB2YXIgcmVmQ29kZSA9IHJlZmVyZW5jZVN0ci5jaGFyQ29kZUF0KGkgLSBzdGFydCk7XG5cbiAgICAgICAgLy8gdGVzdFN0cltpXS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlmICh0ZXN0Q29kZSA+PSA2NSAmJiB0ZXN0Q29kZSA8PSA5MCkge1xuICAgICAgICAgICAgdGVzdENvZGUgPSB0ZXN0Q29kZSB8IDMyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRlc3RDb2RlICE9PSByZWZDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZW5kc1dpdGgodGVzdFN0ciwgcmVmZXJlbmNlU3RyKSB7XG4gICAgcmV0dXJuIGNtcFN0ciQxKHRlc3RTdHIsIHRlc3RTdHIubGVuZ3RoIC0gcmVmZXJlbmNlU3RyLmxlbmd0aCwgdGVzdFN0ci5sZW5ndGgsIHJlZmVyZW5jZVN0cik7XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXN0Tm9uU3BhY2VMb2NhdGlvbiQxKHNjYW5uZXIpIHtcbiAgICBmb3IgKHZhciBpID0gc2Nhbm5lci5zb3VyY2UubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjb2RlICE9PSBTUEFDRSQxICYmIGNvZGUgIT09IFRBQiQxICYmIGNvZGUgIT09IFIkMiAmJiBjb2RlICE9PSBOJDIgJiYgY29kZSAhPT0gRiQyKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY2FubmVyLmdldExvY2F0aW9uKGkgKyAxKTtcbn1cblxuZnVuY3Rpb24gZmluZFdoaXRlU3BhY2VFbmQkMShzb3VyY2UsIG9mZnNldCkge1xuICAgIGZvciAoOyBvZmZzZXQgPCBzb3VyY2UubGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgICB2YXIgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCk7XG5cbiAgICAgICAgaWYgKGNvZGUgIT09IFNQQUNFJDEgJiYgY29kZSAhPT0gVEFCJDEgJiYgY29kZSAhPT0gUiQyICYmIGNvZGUgIT09IE4kMiAmJiBjb2RlICE9PSBGJDIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZmluZENvbW1lbnRFbmQkMShzb3VyY2UsIG9mZnNldCkge1xuICAgIHZhciBjb21tZW50RW5kID0gc291cmNlLmluZGV4T2YoJyovJywgb2Zmc2V0KTtcblxuICAgIGlmIChjb21tZW50RW5kID09PSAtMSkge1xuICAgICAgICByZXR1cm4gc291cmNlLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tbWVudEVuZCArIDI7XG59XG5cbmZ1bmN0aW9uIGZpbmRTdHJpbmdFbmQkMShzb3VyY2UsIG9mZnNldCwgcXVvdGUpIHtcbiAgICBmb3IgKDsgb2Zmc2V0IDwgc291cmNlLmxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpO1xuXG4gICAgICAgIC8vIFRPRE86IGJhZCBzdHJpbmdcbiAgICAgICAgaWYgKGNvZGUgPT09IEJBQ0tfU0xBU0gpIHtcbiAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IHF1b3RlKSB7XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZmluZERlY2ltYWxOdW1iZXJFbmQoc291cmNlLCBvZmZzZXQpIHtcbiAgICBmb3IgKDsgb2Zmc2V0IDwgc291cmNlLmxlbmd0aDsgb2Zmc2V0KyspIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpO1xuXG4gICAgICAgIGlmIChjb2RlIDwgNDggfHwgY29kZSA+IDU3KSB7ICAvLyBub3QgYSAwIC4uIDlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZmluZE51bWJlckVuZCQxKHNvdXJjZSwgb2Zmc2V0LCBhbGxvd0ZyYWN0aW9uKSB7XG4gICAgdmFyIGNvZGU7XG5cbiAgICBvZmZzZXQgPSBmaW5kRGVjaW1hbE51bWJlckVuZChzb3VyY2UsIG9mZnNldCk7XG5cbiAgICAvLyBmcmFjdGlvbjogLlxcZCtcbiAgICBpZiAoYWxsb3dGcmFjdGlvbiAmJiBvZmZzZXQgKyAxIDwgc291cmNlLmxlbmd0aCAmJiBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpID09PSBGVUxMU1RPUCQxKSB7XG4gICAgICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQgKyAxKTtcblxuICAgICAgICBpZiAoaXNOdW1iZXIkMShjb2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZmluZERlY2ltYWxOdW1iZXJFbmQoc291cmNlLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4cG9uZW50OiBlWystXVxcZCtcbiAgICBpZiAob2Zmc2V0ICsgMSA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgaWYgKChzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQpIHwgMzIpID09PSBFKSB7IC8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2sgZm9yIGBlYFxuICAgICAgICAgICAgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCArIDEpO1xuXG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gUExVU1NJR04kMSB8fCBjb2RlID09PSBIWVBIRU5NSU5VUyQxKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDIgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChvZmZzZXQgKyAyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlciQxKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZmluZERlY2ltYWxOdW1iZXJFbmQoc291cmNlLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbi8vIHNraXAgZXNjYXBlZCB1bmljb2RlIHNlcXVlbmNlIHRoYXQgY2FuIGVuZHMgd2l0aCBzcGFjZVxuLy8gWzAtOWEtZl17MSw2fShcXHJcXG58WyBcXG5cXHJcXHRcXGZdKT9cbmZ1bmN0aW9uIGZpbmRFc2Nhc2VFbmQoc291cmNlLCBvZmZzZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDcgJiYgb2Zmc2V0ICsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCArIGkpO1xuXG4gICAgICAgIGlmIChpICE9PSA2ICYmIGlzSGV4KGNvZGUpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGkgLSAxICsgaXNOZXdsaW5lKHNvdXJjZSwgb2Zmc2V0ICsgaSwgY29kZSk7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gU1BBQ0UkMSB8fCBjb2RlID09PSBUQUIkMSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZmluZElkZW50aWZpZXJFbmQkMShzb3VyY2UsIG9mZnNldCkge1xuICAgIGZvciAoOyBvZmZzZXQgPCBzb3VyY2UubGVuZ3RoOyBvZmZzZXQrKykge1xuICAgICAgICB2YXIgY29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCk7XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IEJBQ0tfU0xBU0gpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGZpbmRFc2Nhc2VFbmQoc291cmNlLCBvZmZzZXQgKyAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHg4MCAmJiBQVU5DVFVBVElPTiQxW2NvZGVdID09PSBQVU5DVFVBVE9SJDIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldDtcbn1cblxuZnVuY3Rpb24gZmluZFVybFJhd0VuZCQxKHNvdXJjZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7IG9mZnNldCA8IHNvdXJjZS5sZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcblxuICAgICAgICBpZiAoY29kZSA9PT0gQkFDS19TTEFTSCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZmluZEVzY2FzZUVuZChzb3VyY2UsIG9mZnNldCArIDEpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwICYmIFNUT1BfVVJMX1JBVyQxW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbnZhciB1dGlscyA9IHtcbiAgICBmaXJzdENoYXJPZmZzZXQ6IGZpcnN0Q2hhck9mZnNldCQxLFxuXG4gICAgaXNIZXg6IGlzSGV4LFxuICAgIGlzTnVtYmVyOiBpc051bWJlciQxLFxuICAgIGlzTmV3bGluZTogaXNOZXdsaW5lLFxuXG4gICAgY21wQ2hhcjogY21wQ2hhcixcbiAgICBjbXBTdHI6IGNtcFN0ciQxLFxuICAgIGVuZHNXaXRoOiBlbmRzV2l0aCxcblxuICAgIGZpbmRMYXN0Tm9uU3BhY2VMb2NhdGlvbjogZmluZExhc3ROb25TcGFjZUxvY2F0aW9uJDEsXG4gICAgZmluZFdoaXRlU3BhY2VFbmQ6IGZpbmRXaGl0ZVNwYWNlRW5kJDEsXG4gICAgZmluZENvbW1lbnRFbmQ6IGZpbmRDb21tZW50RW5kJDEsXG4gICAgZmluZFN0cmluZ0VuZDogZmluZFN0cmluZ0VuZCQxLFxuICAgIGZpbmREZWNpbWFsTnVtYmVyRW5kOiBmaW5kRGVjaW1hbE51bWJlckVuZCxcbiAgICBmaW5kTnVtYmVyRW5kOiBmaW5kTnVtYmVyRW5kJDEsXG4gICAgZmluZEVzY2FzZUVuZDogZmluZEVzY2FzZUVuZCxcbiAgICBmaW5kSWRlbnRpZmllckVuZDogZmluZElkZW50aWZpZXJFbmQkMSxcbiAgICBmaW5kVXJsUmF3RW5kOiBmaW5kVXJsUmF3RW5kJDFcbn07XG5cbnZhciBUWVBFID0gX2NvbnN0LlRZUEU7XG52YXIgTkFNRSA9IF9jb25zdC5OQU1FO1xudmFyIFNZTUJPTF9UWVBFID0gX2NvbnN0LlNZTUJPTF9UWVBFO1xuXG5cbnZhciBmaXJzdENoYXJPZmZzZXQgPSB1dGlscy5maXJzdENoYXJPZmZzZXQ7XG52YXIgY21wU3RyID0gdXRpbHMuY21wU3RyO1xudmFyIGlzTnVtYmVyID0gdXRpbHMuaXNOdW1iZXI7XG52YXIgZmluZExhc3ROb25TcGFjZUxvY2F0aW9uID0gdXRpbHMuZmluZExhc3ROb25TcGFjZUxvY2F0aW9uO1xudmFyIGZpbmRXaGl0ZVNwYWNlRW5kID0gdXRpbHMuZmluZFdoaXRlU3BhY2VFbmQ7XG52YXIgZmluZENvbW1lbnRFbmQgPSB1dGlscy5maW5kQ29tbWVudEVuZDtcbnZhciBmaW5kU3RyaW5nRW5kID0gdXRpbHMuZmluZFN0cmluZ0VuZDtcbnZhciBmaW5kTnVtYmVyRW5kID0gdXRpbHMuZmluZE51bWJlckVuZDtcbnZhciBmaW5kSWRlbnRpZmllckVuZCA9IHV0aWxzLmZpbmRJZGVudGlmaWVyRW5kO1xudmFyIGZpbmRVcmxSYXdFbmQgPSB1dGlscy5maW5kVXJsUmF3RW5kO1xuXG52YXIgTlVMTCA9IDA7XG52YXIgV0hJVEVTUEFDRSA9IFRZUEUuV2hpdGVTcGFjZTtcbnZhciBJREVOVElGSUVSID0gVFlQRS5JZGVudGlmaWVyO1xudmFyIE5VTUJFUiA9IFRZUEUuTnVtYmVyO1xudmFyIFNUUklORyA9IFRZUEUuU3RyaW5nO1xudmFyIENPTU1FTlQgPSBUWVBFLkNvbW1lbnQ7XG52YXIgUFVOQ1RVQVRPUiA9IFRZUEUuUHVuY3R1YXRvcjtcbnZhciBDRE8gPSBUWVBFLkNETztcbnZhciBDREMgPSBUWVBFLkNEQztcbnZhciBBVFJVTEUgPSBUWVBFLkF0cnVsZTtcbnZhciBGVU5DVElPTiA9IFRZUEUuRnVuY3Rpb247XG52YXIgVVJMID0gVFlQRS5Vcmw7XG52YXIgUkFXID0gVFlQRS5SYXc7XG5cbnZhciBOID0gMTA7XG52YXIgRiA9IDEyO1xudmFyIFIgPSAxMztcbnZhciBTVEFSID0gVFlQRS5Bc3RlcmlzaztcbnZhciBTTEFTSCA9IFRZUEUuU29saWR1cztcbnZhciBGVUxMU1RPUCA9IFRZUEUuRnVsbFN0b3A7XG52YXIgUExVU1NJR04gPSBUWVBFLlBsdXNTaWduO1xudmFyIEhZUEhFTk1JTlVTID0gVFlQRS5IeXBoZW5NaW51cztcbnZhciBHUkVBVEVSVEhBTlNJR04gPSBUWVBFLkdyZWF0ZXJUaGFuU2lnbjtcbnZhciBMRVNTVEhBTlNJR04gPSBUWVBFLkxlc3NUaGFuU2lnbjtcbnZhciBFWENMQU1BVElPTk1BUksgPSBUWVBFLkV4Y2xhbWF0aW9uTWFyaztcbnZhciBDT01NRVJDSUFMQVQgPSBUWVBFLkNvbW1lcmNpYWxBdDtcbnZhciBRVU9UQVRJT05NQVJLID0gVFlQRS5RdW90YXRpb25NYXJrO1xudmFyIEFQT1NUUk9QSEUgPSBUWVBFLkFwb3N0cm9waGU7XG52YXIgTEVGVFBBUkVOVEhFU0lTID0gVFlQRS5MZWZ0UGFyZW50aGVzaXM7XG52YXIgUklHSFRQQVJFTlRIRVNJUyA9IFRZUEUuUmlnaHRQYXJlbnRoZXNpcztcbnZhciBMRUZUQ1VSTFlCUkFDS0VUID0gVFlQRS5MZWZ0Q3VybHlCcmFja2V0O1xudmFyIFJJR0hUQ1VSTFlCUkFDS0VUID0gVFlQRS5SaWdodEN1cmx5QnJhY2tldDtcbnZhciBMRUZUU1FVQVJFQlJBQ0tFVCA9IFRZUEUuTGVmdFNxdWFyZUJyYWNrZXQ7XG52YXIgUklHSFRTUVVBUkVCUkFDS0VUID0gVFlQRS5SaWdodFNxdWFyZUJyYWNrZXQ7XG5cbnZhciBNSU5fQlVGRkVSX1NJWkUgPSAxNiAqIDEwMjQ7XG52YXIgT0ZGU0VUX01BU0sgPSAweDAwRkZGRkZGO1xudmFyIFRZUEVfU0hJRlQgPSAyNDtcbnZhciBTYWZlVWludDMyQXJyYXkgPSB0eXBlb2YgVWludDMyQXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDMyQXJyYXkgOiBBcnJheTsgLy8gZmFsbGJhY2sgb24gQXJyYXkgd2hlbiBUeXBlZEFycmF5IGlzIG5vdCBzdXBwb3J0ZWRcblxuZnVuY3Rpb24gY29tcHV0ZUxpbmVzQW5kQ29sdW1ucyh0b2tlbml6ZXIsIHNvdXJjZSkge1xuICAgIHZhciBzb3VyY2VMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHZhciBzdGFydCA9IGZpcnN0Q2hhck9mZnNldChzb3VyY2UpO1xuICAgIHZhciBsaW5lcyA9IHRva2VuaXplci5saW5lcztcbiAgICB2YXIgbGluZSA9IHRva2VuaXplci5zdGFydExpbmU7XG4gICAgdmFyIGNvbHVtbnMgPSB0b2tlbml6ZXIuY29sdW1ucztcbiAgICB2YXIgY29sdW1uID0gdG9rZW5pemVyLnN0YXJ0Q29sdW1uO1xuXG4gICAgaWYgKGxpbmVzID09PSBudWxsIHx8IGxpbmVzLmxlbmd0aCA8IHNvdXJjZUxlbmd0aCArIDEpIHtcbiAgICAgICAgbGluZXMgPSBuZXcgU2FmZVVpbnQzMkFycmF5KE1hdGgubWF4KHNvdXJjZUxlbmd0aCArIDEwMjQsIE1JTl9CVUZGRVJfU0laRSkpO1xuICAgICAgICBjb2x1bW5zID0gbmV3IFNhZmVVaW50MzJBcnJheShsaW5lcy5sZW5ndGgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IHNvdXJjZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAgICAgbGluZXNbaV0gPSBsaW5lO1xuICAgICAgICBjb2x1bW5zW2ldID0gY29sdW1uKys7XG5cbiAgICAgICAgaWYgKGNvZGUgPT09IE4gfHwgY29kZSA9PT0gUiB8fCBjb2RlID09PSBGKSB7XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gUiAmJiBpICsgMSA8IHNvdXJjZUxlbmd0aCAmJiBzb3VyY2UuY2hhckNvZGVBdChpICsgMSkgPT09IE4pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgbGluZXNbaV0gPSBsaW5lO1xuICAgICAgICAgICAgICAgIGNvbHVtbnNbaV0gPSBjb2x1bW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxpbmUrKztcbiAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsaW5lc1tpXSA9IGxpbmU7XG4gICAgY29sdW1uc1tpXSA9IGNvbHVtbjtcblxuICAgIHRva2VuaXplci5saW5lc0Fuc0NvbHVtbnNDb21wdXRlZCA9IHRydWU7XG4gICAgdG9rZW5pemVyLmxpbmVzID0gbGluZXM7XG4gICAgdG9rZW5pemVyLmNvbHVtbnMgPSBjb2x1bW5zO1xufVxuXG5mdW5jdGlvbiB0b2tlbkxheW91dCh0b2tlbml6ZXIsIHNvdXJjZSwgc3RhcnRQb3MpIHtcbiAgICB2YXIgc291cmNlTGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0QW5kVHlwZSA9IHRva2VuaXplci5vZmZzZXRBbmRUeXBlO1xuICAgIHZhciBiYWxhbmNlID0gdG9rZW5pemVyLmJhbGFuY2U7XG4gICAgdmFyIHRva2VuQ291bnQgPSAwO1xuICAgIHZhciBwcmV2VHlwZSA9IDA7XG4gICAgdmFyIG9mZnNldCA9IHN0YXJ0UG9zO1xuICAgIHZhciBhbmNob3IgPSAwO1xuICAgIHZhciBiYWxhbmNlQ2xvc2VDb2RlID0gMDtcbiAgICB2YXIgYmFsYW5jZVN0YXJ0ID0gMDtcbiAgICB2YXIgYmFsYW5jZVByZXYgPSAwO1xuXG4gICAgaWYgKG9mZnNldEFuZFR5cGUgPT09IG51bGwgfHwgb2Zmc2V0QW5kVHlwZS5sZW5ndGggPCBzb3VyY2VMZW5ndGggKyAxKSB7XG4gICAgICAgIG9mZnNldEFuZFR5cGUgPSBuZXcgU2FmZVVpbnQzMkFycmF5KHNvdXJjZUxlbmd0aCArIDEwMjQpO1xuICAgICAgICBiYWxhbmNlID0gbmV3IFNhZmVVaW50MzJBcnJheShzb3VyY2VMZW5ndGggKyAxMDI0KTtcbiAgICB9XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgc291cmNlTGVuZ3RoKSB7XG4gICAgICAgIHZhciBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgdmFyIHR5cGUgPSBjb2RlIDwgMHg4MCA/IFNZTUJPTF9UWVBFW2NvZGVdIDogSURFTlRJRklFUjtcblxuICAgICAgICBiYWxhbmNlW3Rva2VuQ291bnRdID0gc291cmNlTGVuZ3RoO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBXSElURVNQQUNFOlxuICAgICAgICAgICAgICAgIG9mZnNldCA9IGZpbmRXaGl0ZVNwYWNlRW5kKHNvdXJjZSwgb2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgUFVOQ1RVQVRPUjpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBiYWxhbmNlQ2xvc2VDb2RlOlxuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVByZXYgPSBiYWxhbmNlU3RhcnQgJiBPRkZTRVRfTUFTSztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2VTdGFydCA9IGJhbGFuY2VbYmFsYW5jZVByZXZdO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZUNsb3NlQ29kZSA9IGJhbGFuY2VTdGFydCA+PiBUWVBFX1NISUZUO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVt0b2tlbkNvdW50XSA9IGJhbGFuY2VQcmV2O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVtiYWxhbmNlUHJldisrXSA9IHRva2VuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKDsgYmFsYW5jZVByZXYgPCB0b2tlbkNvdW50OyBiYWxhbmNlUHJldisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJhbGFuY2VbYmFsYW5jZVByZXZdID09PSBzb3VyY2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVtiYWxhbmNlUHJldl0gPSB0b2tlbkNvdW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEVGVFNRVUFSRUJSQUNLRVQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlW3Rva2VuQ291bnRdID0gYmFsYW5jZVN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYmFsYW5jZUNsb3NlQ29kZSA9IFJJR0hUU1FVQVJFQlJBQ0tFVDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2VTdGFydCA9IChiYWxhbmNlQ2xvc2VDb2RlIDw8IFRZUEVfU0hJRlQpIHwgdG9rZW5Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTEVGVENVUkxZQlJBQ0tFVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbdG9rZW5Db3VudF0gPSBiYWxhbmNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlQ2xvc2VDb2RlID0gUklHSFRDVVJMWUJSQUNLRVQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlU3RhcnQgPSAoYmFsYW5jZUNsb3NlQ29kZSA8PCBUWVBFX1NISUZUKSB8IHRva2VuQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIExFRlRQQVJFTlRIRVNJUzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbdG9rZW5Db3VudF0gPSBiYWxhbmNlU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlQ2xvc2VDb2RlID0gUklHSFRQQVJFTlRIRVNJUztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2VTdGFydCA9IChiYWxhbmNlQ2xvc2VDb2RlIDw8IFRZUEVfU0hJRlQpIHwgdG9rZW5Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIC8qXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IFNUQVIgJiYgcHJldlR5cGUgPT09IFNMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBDT01NRU5UO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBmaW5kQ29tbWVudEVuZChzb3VyY2UsIG9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkNvdW50LS07IC8vIHJld3JpdGUgcHJldiB0b2tlblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBlZGdlIGNhc2UgZm9yIC0uMTIzIGFuZCArLjEyM1xuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBGVUxMU1RPUCAmJiAocHJldlR5cGUgPT09IFBMVVNTSUdOIHx8IHByZXZUeXBlID09PSBIWVBIRU5NSU5VUykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDEgPCBzb3VyY2VMZW5ndGggJiYgaXNOdW1iZXIoc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gTlVNQkVSO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZmluZE51bWJlckVuZChzb3VyY2UsIG9mZnNldCArIDIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuQ291bnQtLTsgLy8gcmV3cml0ZSBwcmV2IHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIDwhLS1cbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gRVhDTEFNQVRJT05NQVJLICYmIHByZXZUeXBlID09PSBMRVNTVEhBTlNJR04pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDIgPCBzb3VyY2VMZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZS5jaGFyQ29kZUF0KG9mZnNldCArIDEpID09PSBIWVBIRU5NSU5VUyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPT09IEhZUEhFTk1JTlVTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gQ0RPO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuQ291bnQtLTsgLy8gcmV3cml0ZSBwcmV2IHRva2VuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIC0tPlxuICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBIWVBIRU5NSU5VUyAmJiBwcmV2VHlwZSA9PT0gSFlQSEVOTUlOVVMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIDEgPCBzb3VyY2VMZW5ndGggJiYgc291cmNlLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPT09IEdSRUFURVJUSEFOU0lHTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IENEQztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCArIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbkNvdW50LS07IC8vIHJld3JpdGUgcHJldiB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZGVudChcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gTEVGVFBBUkVOVEhFU0lTICYmIHByZXZUeXBlID09PSBJREVOVElGSUVSKSB7XG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuQ291bnQtLTsgLy8gcmV3cml0ZSBwcmV2IHRva2VuXG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2VbdG9rZW5Db3VudF0gPSBiYWxhbmNlW3Rva2VuQ291bnQgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgYmFsYW5jZVN0YXJ0LS07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gNCBjaGFyIGxlbmd0aCBpZGVudGlmaWVyIGFuZCBlcXVhbCB0byBgdXJsKGAgKGNhc2UgaW5zZW5zaXRpdmUpXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZzZXQgLSBhbmNob3IgPT09IDQgJiYgY21wU3RyKHNvdXJjZSwgYW5jaG9yLCBvZmZzZXQsICd1cmwoJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSBmb3IgdXJsKCkgYmVjYXVzZSBpdCBjYW4gY29udGFpbiBhbnkgc3ltYm9scyBzZXF1ZW5jZSB3aXRoIGZldyBleGNlcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBmaW5kV2hpdGVTcGFjZUVuZChzb3VyY2UsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlID0gc291cmNlLmNoYXJDb2RlQXQoYW5jaG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlICE9PSBMRUZUUEFSRU5USEVTSVMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlICE9PSBSSUdIVFBBUkVOVEhFU0lTICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZSAhPT0gUVVPVEFUSU9OTUFSSyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUgIT09IEFQT1NUUk9QSEUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cmwoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0QW5kVHlwZVt0b2tlbkNvdW50KytdID0gKFVSTCA8PCBUWVBFX1NISUZUKSB8IG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlW3Rva2VuQ291bnRdID0gc291cmNlTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd3MqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuY2hvciAhPT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldEFuZFR5cGVbdG9rZW5Db3VudCsrXSA9IChXSElURVNQQUNFIDw8IFRZUEVfU0hJRlQpIHwgYW5jaG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlW3Rva2VuQ291bnRdID0gc291cmNlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJhd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBSQVc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZmluZFVybFJhd0VuZChzb3VyY2UsIGFuY2hvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBVUkw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gRlVOQ1RJT047XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdHlwZSA9IGNvZGU7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgMTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBOVU1CRVI6XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gZmluZE51bWJlckVuZChzb3VyY2UsIG9mZnNldCArIDEsIHByZXZUeXBlICE9PSBGVUxMU1RPUCk7XG5cbiAgICAgICAgICAgICAgICAvLyBtZXJnZSBudW1iZXIgd2l0aCBhIHByZWNlZGluZyBkb3QsIGRhc2ggb3IgcGx1c1xuICAgICAgICAgICAgICAgIGlmIChwcmV2VHlwZSA9PT0gRlVMTFNUT1AgfHxcbiAgICAgICAgICAgICAgICAgICAgcHJldlR5cGUgPT09IEhZUEhFTk1JTlVTIHx8XG4gICAgICAgICAgICAgICAgICAgIHByZXZUeXBlID09PSBQTFVTU0lHTikge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbkNvdW50LS07IC8vIHJld3JpdGUgcHJldiB0b2tlblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFNUUklORzpcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBmaW5kU3RyaW5nRW5kKHNvdXJjZSwgb2Zmc2V0ICsgMSwgY29kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYW5jaG9yID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGZpbmRJZGVudGlmaWVyRW5kKHNvdXJjZSwgb2Zmc2V0KTtcblxuICAgICAgICAgICAgICAgIC8vIG1lcmdlIGlkZW50aWZpZXIgd2l0aCBhIHByZWNlZGluZyBkYXNoXG4gICAgICAgICAgICAgICAgaWYgKHByZXZUeXBlID09PSBIWVBIRU5NSU5VUykge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXdyaXRlIHByZXYgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5Db3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHByZXYgcHJldiB0b2tlbiB0eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciBjYXNlIEAtcHJlZml4LWlkZW50XG4gICAgICAgICAgICAgICAgICAgIHByZXZUeXBlID0gdG9rZW5Db3VudCA9PT0gMCA/IDAgOiBvZmZzZXRBbmRUeXBlW3Rva2VuQ291bnQgLSAxXSA+PiBUWVBFX1NISUZUO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChwcmV2VHlwZSA9PT0gQ09NTUVSQ0lBTEFUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJld3JpdGUgcHJldiB0b2tlbiBhbmQgY2hhbmdlIHR5cGUgdG8gPGF0LWtleXdvcmQtdG9rZW4+XG4gICAgICAgICAgICAgICAgICAgIHRva2VuQ291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IEFUUlVMRTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvZmZzZXRBbmRUeXBlW3Rva2VuQ291bnQrK10gPSAodHlwZSA8PCBUWVBFX1NISUZUKSB8IG9mZnNldDtcbiAgICAgICAgcHJldlR5cGUgPSB0eXBlO1xuICAgIH1cblxuICAgIC8vIGZpbmFsaXplIGFycmF5c1xuICAgIG9mZnNldEFuZFR5cGVbdG9rZW5Db3VudF0gPSBvZmZzZXQ7XG4gICAgYmFsYW5jZVt0b2tlbkNvdW50XSA9IHNvdXJjZUxlbmd0aDtcbiAgICB3aGlsZSAoYmFsYW5jZVN0YXJ0ICE9PSAwKSB7XG4gICAgICAgIGJhbGFuY2VQcmV2ID0gYmFsYW5jZVN0YXJ0ICYgT0ZGU0VUX01BU0s7XG4gICAgICAgIGJhbGFuY2VTdGFydCA9IGJhbGFuY2VbYmFsYW5jZVByZXZdO1xuICAgICAgICBiYWxhbmNlW2JhbGFuY2VQcmV2XSA9IHNvdXJjZUxlbmd0aDtcbiAgICB9XG5cbiAgICB0b2tlbml6ZXIub2Zmc2V0QW5kVHlwZSA9IG9mZnNldEFuZFR5cGU7XG4gICAgdG9rZW5pemVyLnRva2VuQ291bnQgPSB0b2tlbkNvdW50O1xuICAgIHRva2VuaXplci5iYWxhbmNlID0gYmFsYW5jZTtcbn1cblxuLy9cbi8vIHRva2VuaXplclxuLy9cblxudmFyIFRva2VuaXplciA9IGZ1bmN0aW9uKHNvdXJjZSwgc3RhcnRPZmZzZXQsIHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4pIHtcbiAgICB0aGlzLm9mZnNldEFuZFR5cGUgPSBudWxsO1xuICAgIHRoaXMuYmFsYW5jZSA9IG51bGw7XG4gICAgdGhpcy5saW5lcyA9IG51bGw7XG4gICAgdGhpcy5jb2x1bW5zID0gbnVsbDtcblxuICAgIHRoaXMuc2V0U291cmNlKHNvdXJjZSwgc3RhcnRPZmZzZXQsIHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4pO1xufTtcblxuVG9rZW5pemVyLnByb3RvdHlwZSA9IHtcbiAgICBzZXRTb3VyY2U6IGZ1bmN0aW9uKHNvdXJjZSwgc3RhcnRPZmZzZXQsIHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgdmFyIHNhZmVTb3VyY2UgPSBTdHJpbmcoc291cmNlIHx8ICcnKTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZmlyc3RDaGFyT2Zmc2V0KHNhZmVTb3VyY2UpO1xuXG4gICAgICAgIHRoaXMuc291cmNlID0gc2FmZVNvdXJjZTtcbiAgICAgICAgdGhpcy5maXJzdENoYXJPZmZzZXQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5zdGFydE9mZnNldCA9IHR5cGVvZiBzdGFydE9mZnNldCA9PT0gJ3VuZGVmaW5lZCcgPyAwIDogc3RhcnRPZmZzZXQ7XG4gICAgICAgIHRoaXMuc3RhcnRMaW5lID0gdHlwZW9mIHN0YXJ0TGluZSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogc3RhcnRMaW5lO1xuICAgICAgICB0aGlzLnN0YXJ0Q29sdW1uID0gdHlwZW9mIHN0YXJ0Q29sdW1uID09PSAndW5kZWZpbmVkJyA/IDEgOiBzdGFydENvbHVtbjtcbiAgICAgICAgdGhpcy5saW5lc0Fuc0NvbHVtbnNDb21wdXRlZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuZW9mID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3VycmVudFRva2VuID0gLTE7XG4gICAgICAgIHRoaXMudG9rZW5UeXBlID0gMDtcbiAgICAgICAgdGhpcy50b2tlblN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudG9rZW5FbmQgPSBzdGFydDtcblxuICAgICAgICB0b2tlbkxheW91dCh0aGlzLCBzYWZlU291cmNlLCBzdGFydCk7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgIH0sXG5cbiAgICBsb29rdXBUeXBlOiBmdW5jdGlvbihvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ICs9IHRoaXMuY3VycmVudFRva2VuO1xuXG4gICAgICAgIGlmIChvZmZzZXQgPCB0aGlzLnRva2VuQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZnNldEFuZFR5cGVbb2Zmc2V0XSA+PiBUWVBFX1NISUZUO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIE5VTEw7XG4gICAgfSxcbiAgICBsb29rdXBOb25XU1R5cGU6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgKz0gdGhpcy5jdXJyZW50VG9rZW47XG5cbiAgICAgICAgZm9yICh2YXIgdHlwZTsgb2Zmc2V0IDwgdGhpcy50b2tlbkNvdW50OyBvZmZzZXQrKykge1xuICAgICAgICAgICAgdHlwZSA9IHRoaXMub2Zmc2V0QW5kVHlwZVtvZmZzZXRdID4+IFRZUEVfU0hJRlQ7XG5cbiAgICAgICAgICAgIGlmICh0eXBlICE9PSBXSElURVNQQUNFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTlVMTDtcbiAgICB9LFxuICAgIGxvb2t1cFZhbHVlOiBmdW5jdGlvbihvZmZzZXQsIHJlZmVyZW5jZVN0cikge1xuICAgICAgICBvZmZzZXQgKz0gdGhpcy5jdXJyZW50VG9rZW47XG5cbiAgICAgICAgaWYgKG9mZnNldCA8IHRoaXMudG9rZW5Db3VudCkge1xuICAgICAgICAgICAgcmV0dXJuIGNtcFN0cihcbiAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEFuZFR5cGVbb2Zmc2V0IC0gMV0gJiBPRkZTRVRfTUFTSyxcbiAgICAgICAgICAgICAgICB0aGlzLm9mZnNldEFuZFR5cGVbb2Zmc2V0XSAmIE9GRlNFVF9NQVNLLFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZVN0clxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGdldFRva2VuU3RhcnQ6IGZ1bmN0aW9uKHRva2VuTnVtKSB7XG4gICAgICAgIGlmICh0b2tlbk51bSA9PT0gdGhpcy5jdXJyZW50VG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuU3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9rZW5OdW0gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5OdW0gPCB0aGlzLnRva2VuQ291bnRcbiAgICAgICAgICAgICAgICA/IHRoaXMub2Zmc2V0QW5kVHlwZVt0b2tlbk51bSAtIDFdICYgT0ZGU0VUX01BU0tcbiAgICAgICAgICAgICAgICA6IHRoaXMub2Zmc2V0QW5kVHlwZVt0aGlzLnRva2VuQ291bnRdICYgT0ZGU0VUX01BU0s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5maXJzdENoYXJPZmZzZXQ7XG4gICAgfSxcbiAgICBnZXRPZmZzZXRFeGNsdWRlV1M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VG9rZW4gPiAwKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMub2Zmc2V0QW5kVHlwZVt0aGlzLmN1cnJlbnRUb2tlbiAtIDFdID4+IFRZUEVfU0hJRlQpID09PSBXSElURVNQQUNFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRva2VuID4gMVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMub2Zmc2V0QW5kVHlwZVt0aGlzLmN1cnJlbnRUb2tlbiAtIDJdICYgT0ZGU0VUX01BU0tcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmZpcnN0Q2hhck9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b2tlblN0YXJ0O1xuICAgIH0sXG4gICAgZ2V0UmF3TGVuZ3RoOiBmdW5jdGlvbihzdGFydFRva2VuLCBlbmRUb2tlblR5cGUxLCBlbmRUb2tlblR5cGUyLCBpbmNsdWRlVG9rZW5UeXBlMikge1xuICAgICAgICB2YXIgY3Vyc29yID0gc3RhcnRUb2tlbjtcbiAgICAgICAgdmFyIGJhbGFuY2VFbmQ7XG5cbiAgICAgICAgbG9vcDpcbiAgICAgICAgZm9yICg7IGN1cnNvciA8IHRoaXMudG9rZW5Db3VudDsgY3Vyc29yKyspIHtcbiAgICAgICAgICAgIGJhbGFuY2VFbmQgPSB0aGlzLmJhbGFuY2VbY3Vyc29yXTtcblxuICAgICAgICAgICAgLy8gYmVsYW5jZSBlbmQgcG9pbnRzIHRvIG9mZnNldCBiZWZvcmUgc3RhcnRcbiAgICAgICAgICAgIGlmIChiYWxhbmNlRW5kIDwgc3RhcnRUb2tlbikge1xuICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIHRva2VuIGlzIHN0b3AgdHlwZVxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLm9mZnNldEFuZFR5cGVbY3Vyc29yXSA+PiBUWVBFX1NISUZUKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBlbmRUb2tlblR5cGUxOlxuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBlbmRUb2tlblR5cGUyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5jbHVkZVRva2VuVHlwZTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGxvb3A7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAvLyBmYXN0IGZvcndhcmQgdG8gdGhlIGVuZCBvZiBiYWxhbmNlZCBibG9ja1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5iYWxhbmNlW2JhbGFuY2VFbmRdID09PSBjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGJhbGFuY2VFbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN1cnNvciAtIHRoaXMuY3VycmVudFRva2VuO1xuICAgIH0sXG5cbiAgICBnZXRUb2tlblZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnN0cmluZyh0aGlzLnRva2VuU3RhcnQsIHRoaXMudG9rZW5FbmQpO1xuICAgIH0sXG4gICAgc3Vic3RyVG9DdXJzb3I6IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5zdWJzdHJpbmcoc3RhcnQsIHRoaXMudG9rZW5TdGFydCk7XG4gICAgfSxcblxuICAgIHNraXBXUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB0aGlzLmN1cnJlbnRUb2tlbiwgc2tpcFRva2VuQ291bnQgPSAwOyBpIDwgdGhpcy50b2tlbkNvdW50OyBpKyssIHNraXBUb2tlbkNvdW50KyspIHtcbiAgICAgICAgICAgIGlmICgodGhpcy5vZmZzZXRBbmRUeXBlW2ldID4+IFRZUEVfU0hJRlQpICE9PSBXSElURVNQQUNFKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2tpcFRva2VuQ291bnQgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNraXAoc2tpcFRva2VuQ291bnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBza2lwU0M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB3aGlsZSAodGhpcy50b2tlblR5cGUgPT09IFdISVRFU1BBQ0UgfHwgdGhpcy50b2tlblR5cGUgPT09IENPTU1FTlQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBza2lwOiBmdW5jdGlvbih0b2tlbkNvdW50KSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5jdXJyZW50VG9rZW4gKyB0b2tlbkNvdW50O1xuXG4gICAgICAgIGlmIChuZXh0IDwgdGhpcy50b2tlbkNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLnRva2VuU3RhcnQgPSB0aGlzLm9mZnNldEFuZFR5cGVbbmV4dCAtIDFdICYgT0ZGU0VUX01BU0s7XG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5vZmZzZXRBbmRUeXBlW25leHRdO1xuICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgPSBuZXh0ID4+IFRZUEVfU0hJRlQ7XG4gICAgICAgICAgICB0aGlzLnRva2VuRW5kID0gbmV4dCAmIE9GRlNFVF9NQVNLO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VG9rZW4gPSB0aGlzLnRva2VuQ291bnQ7XG4gICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5jdXJyZW50VG9rZW4gKyAxO1xuXG4gICAgICAgIGlmIChuZXh0IDwgdGhpcy50b2tlbkNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUb2tlbiA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLnRva2VuU3RhcnQgPSB0aGlzLnRva2VuRW5kO1xuICAgICAgICAgICAgbmV4dCA9IHRoaXMub2Zmc2V0QW5kVHlwZVtuZXh0XTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5UeXBlID0gbmV4dCA+PiBUWVBFX1NISUZUO1xuICAgICAgICAgICAgdGhpcy50b2tlbkVuZCA9IG5leHQgJiBPRkZTRVRfTUFTSztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRva2VuID0gdGhpcy50b2tlbkNvdW50O1xuICAgICAgICAgICAgdGhpcy5lb2YgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy50b2tlblR5cGUgPSBOVUxMO1xuICAgICAgICAgICAgdGhpcy50b2tlblN0YXJ0ID0gdGhpcy50b2tlbkVuZCA9IHRoaXMuc291cmNlLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBlYXQ6IGZ1bmN0aW9uKHRva2VuVHlwZSkge1xuICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgIT09IHRva2VuVHlwZSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudG9rZW5TdGFydDtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gTkFNRVt0b2tlblR5cGVdICsgJyBpcyBleHBlY3RlZCc7XG5cbiAgICAgICAgICAgIC8vIHR3ZWFrIG1lc3NhZ2UgYW5kIG9mZnNldFxuICAgICAgICAgICAgaWYgKHRva2VuVHlwZSA9PT0gSURFTlRJRklFUikge1xuICAgICAgICAgICAgICAgIC8vIHdoZW4gaWRlbnRpZmllciBpcyBleHBlY3RlZCBidXQgdGhlcmUgaXMgYSBmdW5jdGlvbiBvciB1cmxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgPT09IEZVTkNUSU9OIHx8IHRoaXMudG9rZW5UeXBlID09PSBVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy50b2tlbkVuZCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gJyBidXQgZnVuY3Rpb24gZm91bmQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiB0ZXN0IHR5cGUgaXMgcGFydCBvZiBhbm90aGVyIHRva2VuIHNob3cgZXJyb3IgZm9yIGN1cnJlbnQgcG9zaXRpb24gKyAxXG4gICAgICAgICAgICAgICAgLy8gZS5nLiBlYXQoSFlQSEVOTUlOVVMpIHdpbGwgZmFpbCBvbiBcIi1mb29cIiwgYnV0IHBvaW50aW5nIG9uIFwiLVwiIGlzIG9kZFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMudG9rZW5TdGFydCkgPT09IHRva2VuVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lcnJvcihtZXNzYWdlLCBvZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSxcbiAgICBlYXROb25XUzogZnVuY3Rpb24odG9rZW5UeXBlKSB7XG4gICAgICAgIHRoaXMuc2tpcFdTKCk7XG4gICAgICAgIHRoaXMuZWF0KHRva2VuVHlwZSk7XG4gICAgfSxcblxuICAgIGNvbnN1bWU6IGZ1bmN0aW9uKHRva2VuVHlwZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFRva2VuVmFsdWUoKTtcblxuICAgICAgICB0aGlzLmVhdCh0b2tlblR5cGUpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGNvbnN1bWVGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXMuc291cmNlLnN1YnN0cmluZyh0aGlzLnRva2VuU3RhcnQsIHRoaXMudG9rZW5FbmQgLSAxKTtcblxuICAgICAgICB0aGlzLmVhdChGVU5DVElPTik7XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSxcbiAgICBjb25zdW1lTm9uV1M6IGZ1bmN0aW9uKHRva2VuVHlwZSkge1xuICAgICAgICB0aGlzLnNraXBXUygpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWUodG9rZW5UeXBlKTtcbiAgICB9LFxuXG4gICAgZXhwZWN0SWRlbnRpZmllcjogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAodGhpcy50b2tlblR5cGUgIT09IElERU5USUZJRVIgfHwgY21wU3RyKHRoaXMuc291cmNlLCB0aGlzLnRva2VuU3RhcnQsIHRoaXMudG9rZW5FbmQsIG5hbWUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcignSWRlbnRpZmllciBgJyArIG5hbWUgKyAnYCBpcyBleHBlY3RlZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfSxcblxuICAgIGdldExvY2F0aW9uOiBmdW5jdGlvbihvZmZzZXQsIGZpbGVuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5saW5lc0Fuc0NvbHVtbnNDb21wdXRlZCkge1xuICAgICAgICAgICAgY29tcHV0ZUxpbmVzQW5kQ29sdW1ucyh0aGlzLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc291cmNlOiBmaWxlbmFtZSxcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5zdGFydE9mZnNldCArIG9mZnNldCxcbiAgICAgICAgICAgIGxpbmU6IHRoaXMubGluZXNbb2Zmc2V0XSxcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW5zW29mZnNldF1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0TG9jYXRpb25SYW5nZTogZnVuY3Rpb24oc3RhcnQsIGVuZCwgZmlsZW5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmxpbmVzQW5zQ29sdW1uc0NvbXB1dGVkKSB7XG4gICAgICAgICAgICBjb21wdXRlTGluZXNBbmRDb2x1bW5zKHRoaXMsIHRoaXMuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2U6IGZpbGVuYW1lLFxuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuc3RhcnRPZmZzZXQgKyBzdGFydCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmVzW3N0YXJ0XSxcbiAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uc1tzdGFydF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuc3RhcnRPZmZzZXQgKyBlbmQsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy5saW5lc1tlbmRdLFxuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW5zW2VuZF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgZXJyb3I6IGZ1bmN0aW9uKG1lc3NhZ2UsIG9mZnNldCkge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygb2Zmc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvZmZzZXQgPCB0aGlzLnNvdXJjZS5sZW5ndGhcbiAgICAgICAgICAgID8gdGhpcy5nZXRMb2NhdGlvbihvZmZzZXQpXG4gICAgICAgICAgICA6IHRoaXMuZW9mXG4gICAgICAgICAgICAgICAgPyBmaW5kTGFzdE5vblNwYWNlTG9jYXRpb24odGhpcylcbiAgICAgICAgICAgICAgICA6IHRoaXMuZ2V0TG9jYXRpb24odGhpcy50b2tlblN0YXJ0KTtcblxuICAgICAgICB0aHJvdyBuZXcgZXJyb3IoXG4gICAgICAgICAgICBtZXNzYWdlIHx8ICdVbmV4cGVjdGVkIGlucHV0JyxcbiAgICAgICAgICAgIHRoaXMuc291cmNlLFxuICAgICAgICAgICAgbG9jYXRpb24ub2Zmc2V0LFxuICAgICAgICAgICAgbG9jYXRpb24ubGluZSxcbiAgICAgICAgICAgIGxvY2F0aW9uLmNvbHVtblxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICBkdW1wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMub2Zmc2V0QW5kVHlwZSwgMCwgdGhpcy50b2tlbkNvdW50KS5tYXAoZnVuY3Rpb24oaXRlbSwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gICAgICAgICAgICB2YXIgZW5kID0gaXRlbSAmIE9GRlNFVF9NQVNLO1xuXG4gICAgICAgICAgICBvZmZzZXQgPSBlbmQ7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWR4OiBpZHgsXG4gICAgICAgICAgICAgICAgdHlwZTogTkFNRVtpdGVtID4+IFRZUEVfU0hJRlRdLFxuICAgICAgICAgICAgICAgIGNodW5rOiB0aGlzLnNvdXJjZS5zdWJzdHJpbmcoc3RhcnQsIGVuZCksXG4gICAgICAgICAgICAgICAgYmFsYW5jZTogdGhpcy5iYWxhbmNlW2lkeF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cbn07XG5cbi8vIGV4dGVuZCB3aXRoIGVycm9yIGNsYXNzXG5Ub2tlbml6ZXIuQ3NzU3ludGF4RXJyb3IgPSBlcnJvcjtcblxuLy8gZXh0ZW5kIHRva2VuaXplciB3aXRoIGNvbnN0YW50c1xuT2JqZWN0LmtleXMoX2NvbnN0KS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIFRva2VuaXplcltrZXldID0gX2NvbnN0W2tleV07XG59KTtcblxuLy8gZXh0ZW5kIHRva2VuaXplciB3aXRoIHN0YXRpYyBtZXRob2RzIGZyb20gdXRpbHNcbk9iamVjdC5rZXlzKHV0aWxzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIFRva2VuaXplcltrZXldID0gdXRpbHNba2V5XTtcbn0pO1xuXG4vLyB3YXJtIHVwIHRva2VuaXplciB0byBlbGltaXRhdGUgY29kZSBicmFuY2hlcyB0aGF0IG5ldmVyIGV4ZWN1dGVcbi8vIGZpeCBzb2Z0IGRlb3B0aW1pemF0aW9ucyAoaW5zdWZmaWNpZW50IHR5cGUgZmVlZGJhY2spXG5uZXcgVG9rZW5pemVyKCdcXG5cXHJcXHJcXG5cXGY8IS0tLS0+Ly9cIlwiXFwnXFwnLypcXHJcXG5cXGYqLzFhOy5cXFxcMzFcXHRcXCsye3VybChhKTtmdW5jKCk7KzEuMmUzIC0uNGUtNSAuNmUrN30nKS5nZXRMb2NhdGlvbigpO1xuXG52YXIgVG9rZW5pemVyXzEgPSBUb2tlbml6ZXI7XG5cbnZhciB0b2tlbml6ZXIkMSA9IFRva2VuaXplcl8xO1xuXG4vL1xuLy8gICAgICAgICAgICBpdGVtICAgICAgICBpdGVtICAgICAgICBpdGVtICAgICAgICBpdGVtXG4vLyAgICAgICAgICAvLS0tLS0tXFwgICAgLy0tLS0tLVxcICAgIC8tLS0tLS1cXCAgICAvLS0tLS0tXFxcbi8vICAgICAgICAgIHwgZGF0YSB8ICAgIHwgZGF0YSB8ICAgIHwgZGF0YSB8ICAgIHwgZGF0YSB8XG4vLyAgbnVsbCA8LS0rLXByZXYgfDwtLS0rLXByZXYgfDwtLS0rLXByZXYgfDwtLS0rLXByZXYgfFxuLy8gICAgICAgICAgfCBuZXh0LSstLS0+fCBuZXh0LSstLS0+fCBuZXh0LSstLS0+fCBuZXh0LSstLT4gbnVsbFxuLy8gICAgICAgICAgXFwtLS0tLS0vICAgIFxcLS0tLS0tLyAgICBcXC0tLS0tLS8gICAgXFwtLS0tLS0vXG4vLyAgICAgICAgICAgICBeICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXlxuLy8gICAgICAgICAgICAgfCAgICAgICAgICAgICAgICBsaXN0ICAgICAgICAgICAgICAgIHxcbi8vICAgICAgICAgICAgIHwgICAgICAgICAgICAgIC8tLS0tLS1cXCAgICAgICAgICAgICAgfFxuLy8gICAgICAgICAgICAgXFwtLS0tLS0tLS0tLS0tLSstaGVhZCB8ICAgICAgICAgICAgICB8XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IHRhaWwtKy0tLS0tLS0tLS0tLS0tL1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgXFwtLS0tLS0vXG4vL1xuXG5mdW5jdGlvbiBjcmVhdGVJdGVtKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmV2OiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgfTtcbn1cblxudmFyIGN1cnNvcnMgPSBudWxsO1xudmFyIExpc3QgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xufTtcblxuTGlzdC5jcmVhdGVJdGVtID0gY3JlYXRlSXRlbTtcbkxpc3QucHJvdG90eXBlLmNyZWF0ZUl0ZW0gPSBjcmVhdGVJdGVtO1xuXG5MaXN0LnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmhlYWQ7XG5cbiAgICB3aGlsZSAoY3Vyc29yKSB7XG4gICAgICAgIHNpemUrKztcbiAgICAgICAgY3Vyc29yID0gY3Vyc29yLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNpemU7XG59O1xuXG5MaXN0LnByb3RvdHlwZS5mcm9tQXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBjdXJzb3IgPSBudWxsO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSBjcmVhdGVJdGVtKGFycmF5W2ldKTtcblxuICAgICAgICBpZiAoY3Vyc29yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCA9IGl0ZW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBpdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5wcmV2ID0gY3Vyc29yO1xuICAgICAgICBjdXJzb3IgPSBpdGVtO1xuICAgIH1cblxuICAgIHRoaXMudGFpbCA9IGN1cnNvcjtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKGN1cnNvcikge1xuICAgICAgICByZXN1bHQucHVzaChjdXJzb3IuZGF0YSk7XG4gICAgICAgIGN1cnNvciA9IGN1cnNvci5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5MaXN0LnByb3RvdHlwZS50b0pTT04gPSBMaXN0LnByb3RvdHlwZS50b0FycmF5O1xuXG5MaXN0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZCA9PT0gbnVsbDtcbn07XG5cbkxpc3QucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZCAmJiB0aGlzLmhlYWQuZGF0YTtcbn07XG5cbkxpc3QucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsICYmIHRoaXMudGFpbC5kYXRhO1xufTtcblxuZnVuY3Rpb24gYWxsb2NhdGVDdXJzb3Iobm9kZSwgcHJldiwgbmV4dCkge1xuICAgIHZhciBjdXJzb3I7XG5cbiAgICBpZiAoY3Vyc29ycyAhPT0gbnVsbCkge1xuICAgICAgICBjdXJzb3IgPSBjdXJzb3JzO1xuICAgICAgICBjdXJzb3JzID0gY3Vyc29ycy5jdXJzb3I7XG4gICAgICAgIGN1cnNvci5wcmV2ID0gcHJldjtcbiAgICAgICAgY3Vyc29yLm5leHQgPSBuZXh0O1xuICAgICAgICBjdXJzb3IuY3Vyc29yID0gbm9kZS5jdXJzb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgcHJldjogcHJldixcbiAgICAgICAgICAgIG5leHQ6IG5leHQsXG4gICAgICAgICAgICBjdXJzb3I6IG5vZGUuY3Vyc29yXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgbm9kZS5jdXJzb3IgPSBjdXJzb3I7XG5cbiAgICByZXR1cm4gY3Vyc29yO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlQ3Vyc29yKG5vZGUpIHtcbiAgICB2YXIgY3Vyc29yID0gbm9kZS5jdXJzb3I7XG5cbiAgICBub2RlLmN1cnNvciA9IGN1cnNvci5jdXJzb3I7XG4gICAgY3Vyc29yLnByZXYgPSBudWxsO1xuICAgIGN1cnNvci5uZXh0ID0gbnVsbDtcbiAgICBjdXJzb3IuY3Vyc29yID0gY3Vyc29ycztcbiAgICBjdXJzb3JzID0gY3Vyc29yO1xufVxuXG5MaXN0LnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICB2YXIgaXRlbTtcblxuICAgIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgfVxuXG4gICAgLy8gcHVzaCBjdXJzb3JcbiAgICB2YXIgY3Vyc29yID0gYWxsb2NhdGVDdXJzb3IodGhpcywgbnVsbCwgdGhpcy5oZWFkKTtcblxuICAgIHdoaWxlIChjdXJzb3IubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtID0gY3Vyc29yLm5leHQ7XG4gICAgICAgIGN1cnNvci5uZXh0ID0gaXRlbS5uZXh0O1xuXG4gICAgICAgIGZuLmNhbGwoY29udGV4dCwgaXRlbS5kYXRhLCBpdGVtLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvLyBwb3AgY3Vyc29yXG4gICAgcmVsZWFzZUN1cnNvcih0aGlzKTtcbn07XG5cbkxpc3QucHJvdG90eXBlLmVhY2hSaWdodCA9IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XG4gICAgdmFyIGl0ZW07XG5cbiAgICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIH1cblxuICAgIC8vIHB1c2ggY3Vyc29yXG4gICAgdmFyIGN1cnNvciA9IGFsbG9jYXRlQ3Vyc29yKHRoaXMsIHRoaXMudGFpbCwgbnVsbCk7XG5cbiAgICB3aGlsZSAoY3Vyc29yLnByZXYgIT09IG51bGwpIHtcbiAgICAgICAgaXRlbSA9IGN1cnNvci5wcmV2O1xuICAgICAgICBjdXJzb3IucHJldiA9IGl0ZW0ucHJldjtcblxuICAgICAgICBmbi5jYWxsKGNvbnRleHQsIGl0ZW0uZGF0YSwgaXRlbSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gcG9wIGN1cnNvclxuICAgIHJlbGVhc2VDdXJzb3IodGhpcyk7XG59O1xuXG5MaXN0LnByb3RvdHlwZS5uZXh0VW50aWwgPSBmdW5jdGlvbihzdGFydCwgZm4sIGNvbnRleHQpIHtcbiAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpdGVtO1xuXG4gICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250ZXh0ID0gdGhpcztcbiAgICB9XG5cbiAgICAvLyBwdXNoIGN1cnNvclxuICAgIHZhciBjdXJzb3IgPSBhbGxvY2F0ZUN1cnNvcih0aGlzLCBudWxsLCBzdGFydCk7XG5cbiAgICB3aGlsZSAoY3Vyc29yLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgaXRlbSA9IGN1cnNvci5uZXh0O1xuICAgICAgICBjdXJzb3IubmV4dCA9IGl0ZW0ubmV4dDtcblxuICAgICAgICBpZiAoZm4uY2FsbChjb250ZXh0LCBpdGVtLmRhdGEsIGl0ZW0sIHRoaXMpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBvcCBjdXJzb3JcbiAgICByZWxlYXNlQ3Vyc29yKHRoaXMpO1xufTtcblxuTGlzdC5wcm90b3R5cGUucHJldlVudGlsID0gZnVuY3Rpb24oc3RhcnQsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXRlbTtcblxuICAgIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgfVxuXG4gICAgLy8gcHVzaCBjdXJzb3JcbiAgICB2YXIgY3Vyc29yID0gYWxsb2NhdGVDdXJzb3IodGhpcywgc3RhcnQsIG51bGwpO1xuXG4gICAgd2hpbGUgKGN1cnNvci5wcmV2ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZW0gPSBjdXJzb3IucHJldjtcbiAgICAgICAgY3Vyc29yLnByZXYgPSBpdGVtLnByZXY7XG5cbiAgICAgICAgaWYgKGZuLmNhbGwoY29udGV4dCwgaXRlbS5kYXRhLCBpdGVtLCB0aGlzKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwb3AgY3Vyc29yXG4gICAgcmVsZWFzZUN1cnNvcih0aGlzKTtcbn07XG5cbkxpc3QucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbihmbiwgY29udGV4dCkge1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmhlYWQ7XG5cbiAgICBpZiAoY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgIH1cblxuICAgIHdoaWxlIChjdXJzb3IgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGZuLmNhbGwoY29udGV4dCwgY3Vyc29yLmRhdGEsIGN1cnNvciwgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3Vyc29yID0gY3Vyc29yLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuTGlzdC5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGN1cnNvciA9IHRoaXMuaGVhZDtcblxuICAgIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgfVxuXG4gICAgd2hpbGUgKGN1cnNvciAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucHVzaChmbi5jYWxsKGNvbnRleHQsIGN1cnNvci5kYXRhLCBjdXJzb3IsIHRoaXMpKTtcbiAgICAgICAgY3Vyc29yID0gY3Vyc29yLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xufTtcblxuTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSBuZXcgTGlzdCgpO1xuICAgIHZhciBjdXJzb3IgPSB0aGlzLmhlYWQ7XG5cbiAgICB3aGlsZSAoY3Vyc29yICE9PSBudWxsKSB7XG4gICAgICAgIHJlc3VsdC5pbnNlcnQoY3JlYXRlSXRlbShjdXJzb3IuZGF0YSkpO1xuICAgICAgICBjdXJzb3IgPSBjdXJzb3IubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuTGlzdC5wcm90b3R5cGUudXBkYXRlQ3Vyc29ycyA9IGZ1bmN0aW9uKHByZXZPbGQsIHByZXZOZXcsIG5leHRPbGQsIG5leHROZXcpIHtcbiAgICB2YXIgY3Vyc29yID0gdGhpcy5jdXJzb3I7XG5cbiAgICB3aGlsZSAoY3Vyc29yICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChjdXJzb3IucHJldiA9PT0gcHJldk9sZCkge1xuICAgICAgICAgICAgY3Vyc29yLnByZXYgPSBwcmV2TmV3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnNvci5uZXh0ID09PSBuZXh0T2xkKSB7XG4gICAgICAgICAgICBjdXJzb3IubmV4dCA9IG5leHROZXc7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJzb3IgPSBjdXJzb3IuY3Vyc29yO1xuICAgIH1cbn07XG5cbkxpc3QucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgLy8gICAgICBoZWFkXG4gICAgLy8gICAgXlxuICAgIC8vIGl0ZW1cbiAgICB0aGlzLnVwZGF0ZUN1cnNvcnMobnVsbCwgaXRlbSwgdGhpcy5oZWFkLCBpdGVtKTtcblxuICAgIC8vIGluc2VydCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG4gICAgaWYgKHRoaXMuaGVhZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBuZXcgaXRlbSA8LSBmaXJzdCBpdGVtXG4gICAgICAgIHRoaXMuaGVhZC5wcmV2ID0gaXRlbTtcblxuICAgICAgICAvLyBuZXcgaXRlbSAtPiBmaXJzdCBpdGVtXG4gICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuaGVhZDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBsaXN0IGhhcyBubyBoZWFkLCB0aGVuIGl0IGFsc28gaGFzIG5vIHRhaWxcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIHRhaWwgcG9pbnRzIHRvIHRoZSBuZXcgaXRlbVxuICAgICAgICB0aGlzLnRhaWwgPSBpdGVtO1xuICAgIH1cblxuICAgIC8vIGhlYWQgYWx3YXlzIHBvaW50cyB0byBuZXcgaXRlbVxuICAgIHRoaXMuaGVhZCA9IGl0ZW07XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkxpc3QucHJvdG90eXBlLnByZXBlbmREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnByZXBlbmQoY3JlYXRlSXRlbShkYXRhKSk7XG59O1xuXG5MaXN0LnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgLy8gdGFpbFxuICAgIC8vICAgICAgXlxuICAgIC8vICAgICAgaXRlbVxuICAgIHRoaXMudXBkYXRlQ3Vyc29ycyh0aGlzLnRhaWwsIGl0ZW0sIG51bGwsIGl0ZW0pO1xuXG4gICAgLy8gaW5zZXJ0IHRvIHRoZSBlbmRpbmcgb2YgdGhlIGxpc3RcbiAgICBpZiAodGhpcy50YWlsICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGxhc3QgaXRlbSAtPiBuZXcgaXRlbVxuICAgICAgICB0aGlzLnRhaWwubmV4dCA9IGl0ZW07XG5cbiAgICAgICAgLy8gbGFzdCBpdGVtIDwtIG5ldyBpdGVtXG4gICAgICAgIGl0ZW0ucHJldiA9IHRoaXMudGFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBsaXN0IGhhcyBubyB0YWlsLCB0aGVuIGl0IGFsc28gaGFzIG5vIGhlYWRcbiAgICAgICAgLy8gaW4gdGhpcyBjYXNlIGhlYWQgcG9pbnRzIHRvIG5ldyBpdGVtXG4gICAgICAgIHRoaXMuaGVhZCA9IGl0ZW07XG4gICAgfVxuXG4gICAgLy8gdGFpbCBhbHdheXMgcG9pbnRzIHRvIG5ldyBpdGVtXG4gICAgdGhpcy50YWlsID0gaXRlbTtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuTGlzdC5wcm90b3R5cGUuYXBwZW5kRGF0YSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5hcHBlbmQoY3JlYXRlSXRlbShkYXRhKSk7XG59O1xuXG5MaXN0LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbihpdGVtLCBiZWZvcmUpIHtcbiAgICBpZiAoYmVmb3JlICE9PSB1bmRlZmluZWQgJiYgYmVmb3JlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIHByZXYgICBiZWZvcmVcbiAgICAgICAgLy8gICAgICBeXG4gICAgICAgIC8vICAgICBpdGVtXG4gICAgICAgIHRoaXMudXBkYXRlQ3Vyc29ycyhiZWZvcmUucHJldiwgaXRlbSwgYmVmb3JlLCBpdGVtKTtcblxuICAgICAgICBpZiAoYmVmb3JlLnByZXYgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGluc2VydCB0byB0aGUgYmVnaW5uaW5nIG9mIGxpc3RcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQgIT09IGJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmVmb3JlIGRvZXNuXFwndCBiZWxvbmcgdG8gbGlzdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzaW5jZSBoZWFkIHBvaW50cyB0byBiZWZvcmUgdGhlcmVmb3JlIGxpc3QgZG9lc24ndCBlbXB0eVxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBjaGVjayB0YWlsXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBpdGVtO1xuICAgICAgICAgICAgYmVmb3JlLnByZXYgPSBpdGVtO1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gYmVmb3JlO1xuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUN1cnNvcnMobnVsbCwgaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGluc2VydCBiZXR3ZWVuIHR3byBpdGVtc1xuICAgICAgICAgICAgYmVmb3JlLnByZXYubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICBpdGVtLnByZXYgPSBiZWZvcmUucHJldjtcblxuICAgICAgICAgICAgYmVmb3JlLnByZXYgPSBpdGVtO1xuICAgICAgICAgICAgaXRlbS5uZXh0ID0gYmVmb3JlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBlbmQoaXRlbSk7XG4gICAgfVxufTtcblxuTGlzdC5wcm90b3R5cGUuaW5zZXJ0RGF0YSA9IGZ1bmN0aW9uKGRhdGEsIGJlZm9yZSkge1xuICAgIHRoaXMuaW5zZXJ0KGNyZWF0ZUl0ZW0oZGF0YSksIGJlZm9yZSk7XG59O1xuXG5MaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgLy8gICAgICBpdGVtXG4gICAgLy8gICAgICAgXlxuICAgIC8vIHByZXYgICAgIG5leHRcbiAgICB0aGlzLnVwZGF0ZUN1cnNvcnMoaXRlbSwgaXRlbS5wcmV2LCBpdGVtLCBpdGVtLm5leHQpO1xuXG4gICAgaWYgKGl0ZW0ucHJldiAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtLnByZXYubmV4dCA9IGl0ZW0ubmV4dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5oZWFkICE9PSBpdGVtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZW0gZG9lc25cXCd0IGJlbG9uZyB0byBsaXN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmhlYWQgPSBpdGVtLm5leHQ7XG4gICAgfVxuXG4gICAgaWYgKGl0ZW0ubmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtLm5leHQucHJldiA9IGl0ZW0ucHJldjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy50YWlsICE9PSBpdGVtKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2l0ZW0gZG9lc25cXCd0IGJlbG9uZyB0byBsaXN0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRhaWwgPSBpdGVtLnByZXY7XG4gICAgfVxuXG4gICAgaXRlbS5wcmV2ID0gbnVsbDtcbiAgICBpdGVtLm5leHQgPSBudWxsO1xuXG4gICAgcmV0dXJuIGl0ZW07XG59O1xuXG5MaXN0LnByb3RvdHlwZS5hcHBlbmRMaXN0ID0gZnVuY3Rpb24obGlzdCkge1xuICAgIC8vIGlnbm9yZSBlbXB0eSBsaXN0c1xuICAgIGlmIChsaXN0LmhlYWQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQ3Vyc29ycyh0aGlzLnRhaWwsIGxpc3QudGFpbCwgbnVsbCwgbGlzdC5oZWFkKTtcblxuICAgIC8vIGluc2VydCB0byBlbmQgb2YgdGhlIGxpc3RcbiAgICBpZiAodGhpcy50YWlsICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGlmIGRlc3RpbmF0aW9uIGxpc3QgaGFzIGEgdGFpbCwgdGhlbiBpdCBhbHNvIGhhcyBhIGhlYWQsXG4gICAgICAgIC8vIGJ1dCBoZWFkIGRvZXNuJ3QgY2hhbmdlXG5cbiAgICAgICAgLy8gZGVzdCB0YWlsIC0+IHNvdXJjZSBoZWFkXG4gICAgICAgIHRoaXMudGFpbC5uZXh0ID0gbGlzdC5oZWFkO1xuXG4gICAgICAgIC8vIGRlc3QgdGFpbCA8LSBzb3VyY2UgaGVhZFxuICAgICAgICBsaXN0LmhlYWQucHJldiA9IHRoaXMudGFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBsaXN0IGhhcyBubyBhIHRhaWwsIHRoZW4gaXQgYWxzbyBoYXMgbm8gYSBoZWFkXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSBwb2ludHMgaGVhZCB0byBuZXcgaXRlbVxuICAgICAgICB0aGlzLmhlYWQgPSBsaXN0LmhlYWQ7XG4gICAgfVxuXG4gICAgLy8gdGFpbCBhbHdheXMgc3RhcnQgcG9pbnQgdG8gbmV3IGl0ZW1cbiAgICB0aGlzLnRhaWwgPSBsaXN0LnRhaWw7XG5cbiAgICBsaXN0LmhlYWQgPSBudWxsO1xuICAgIGxpc3QudGFpbCA9IG51bGw7XG59O1xuXG5MaXN0LnByb3RvdHlwZS5pbnNlcnRMaXN0ID0gZnVuY3Rpb24obGlzdCwgYmVmb3JlKSB7XG4gICAgaWYgKGJlZm9yZSAhPT0gdW5kZWZpbmVkICYmIGJlZm9yZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBpZ25vcmUgZW1wdHkgbGlzdHNcbiAgICAgICAgaWYgKGxpc3QuaGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVDdXJzb3JzKGJlZm9yZS5wcmV2LCBsaXN0LnRhaWwsIGJlZm9yZSwgbGlzdC5oZWFkKTtcblxuICAgICAgICAvLyBpbnNlcnQgaW4gdGhlIG1pZGRsZSBvZiBkaXN0IGxpc3RcbiAgICAgICAgaWYgKGJlZm9yZS5wcmV2ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBiZWZvcmUucHJldiA8LT4gbGlzdC5oZWFkXG4gICAgICAgICAgICBiZWZvcmUucHJldi5uZXh0ID0gbGlzdC5oZWFkO1xuICAgICAgICAgICAgbGlzdC5oZWFkLnByZXYgPSBiZWZvcmUucHJldjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IGxpc3QuaGVhZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJlZm9yZS5wcmV2ID0gbGlzdC50YWlsO1xuICAgICAgICBsaXN0LnRhaWwubmV4dCA9IGJlZm9yZTtcblxuICAgICAgICBsaXN0LmhlYWQgPSBudWxsO1xuICAgICAgICBsaXN0LnRhaWwgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXBwZW5kTGlzdChsaXN0KTtcbiAgICB9XG59O1xuXG5MaXN0LnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24ob2xkSXRlbSwgbmV3SXRlbU9yTGlzdCkge1xuICAgIGlmICgnaGVhZCcgaW4gbmV3SXRlbU9yTGlzdCkge1xuICAgICAgICB0aGlzLmluc2VydExpc3QobmV3SXRlbU9yTGlzdCwgb2xkSXRlbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnNlcnQobmV3SXRlbU9yTGlzdCwgb2xkSXRlbSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKG9sZEl0ZW0pO1xufTtcblxudmFyIGxpc3QgPSBMaXN0O1xuXG52YXIgVFlQRSQzID0gdG9rZW5pemVyJDEuVFlQRTtcbnZhciBXSElURVNQQUNFJDIgPSBUWVBFJDMuV2hpdGVTcGFjZTtcbnZhciBDT01NRU5UJDIgPSBUWVBFJDMuQ29tbWVudDtcblxudmFyIHNlcXVlbmNlID0gZnVuY3Rpb24gcmVhZFNlcXVlbmNlKHJlY29nbml6ZXIpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBuZXcgbGlzdCgpO1xuICAgIHZhciBjaGlsZCA9IG51bGw7XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgIHJlY29nbml6ZXI6IHJlY29nbml6ZXIsXG4gICAgICAgIHNwYWNlOiBudWxsLFxuICAgICAgICBpZ25vcmVXUzogZmFsc2UsXG4gICAgICAgIGlnbm9yZVdTQWZ0ZXI6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZikge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2Nhbm5lci50b2tlblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ09NTUVOVCQyOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIGNhc2UgV0hJVEVTUEFDRSQyOlxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0Lmlnbm9yZVdTKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5zcGFjZSA9IHRoaXMuV2hpdGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gcmVjb2duaXplci5nZXROb2RlLmNhbGwodGhpcywgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQuc3BhY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEoY29udGV4dC5zcGFjZSk7XG4gICAgICAgICAgICBjb250ZXh0LnNwYWNlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEoY2hpbGQpO1xuXG4gICAgICAgIGlmIChjb250ZXh0Lmlnbm9yZVdTQWZ0ZXIpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaWdub3JlV1NBZnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGV4dC5pZ25vcmVXUyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0Lmlnbm9yZVdTID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGRyZW47XG59O1xuXG52YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlQ29udGV4dChuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tuYW1lXSgpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDb25maWcoY29uZmlnKSB7XG4gICAgdmFyIHBhcnNlckNvbmZpZyA9IHtcbiAgICAgICAgY29udGV4dDoge30sXG4gICAgICAgIHNjb3BlOiB7fSxcbiAgICAgICAgYXRydWxlOiB7fSxcbiAgICAgICAgcHNldWRvOiB7fVxuICAgIH07XG5cbiAgICBpZiAoY29uZmlnLnBhcnNlQ29udGV4dCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGNvbmZpZy5wYXJzZUNvbnRleHQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZW9mIGNvbmZpZy5wYXJzZUNvbnRleHRbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlckNvbmZpZy5jb250ZXh0W25hbWVdID0gY29uZmlnLnBhcnNlQ29udGV4dFtuYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZXJDb25maWcuY29udGV4dFtuYW1lXSA9IGNyZWF0ZVBhcnNlQ29udGV4dChjb25maWcucGFyc2VDb250ZXh0W25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLnNjb3BlKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnLnNjb3BlKSB7XG4gICAgICAgICAgICBwYXJzZXJDb25maWcuc2NvcGVbbmFtZV0gPSBjb25maWcuc2NvcGVbbmFtZV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmF0cnVsZSkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGNvbmZpZy5hdHJ1bGUpIHtcbiAgICAgICAgICAgIHZhciBhdHJ1bGUgPSBjb25maWcuYXRydWxlW25hbWVdO1xuXG4gICAgICAgICAgICBpZiAoYXRydWxlLnBhcnNlKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyQ29uZmlnLmF0cnVsZVtuYW1lXSA9IGF0cnVsZS5wYXJzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25maWcucHNldWRvKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnLnBzZXVkbykge1xuICAgICAgICAgICAgdmFyIHBzZXVkbyA9IGNvbmZpZy5wc2V1ZG9bbmFtZV07XG5cbiAgICAgICAgICAgIGlmIChwc2V1ZG8ucGFyc2UpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXJDb25maWcucHNldWRvW25hbWVdID0gcHNldWRvLnBhcnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5ub2RlKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnLm5vZGUpIHtcbiAgICAgICAgICAgIHBhcnNlckNvbmZpZ1tuYW1lXSA9IGNvbmZpZy5ub2RlW25hbWVdLnBhcnNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlckNvbmZpZztcbn1cblxudmFyIGNyZWF0ZSQxID0gZnVuY3Rpb24gY3JlYXRlUGFyc2VyKGNvbmZpZykge1xuICAgIHZhciBwYXJzZXIgPSB7XG4gICAgICAgIHNjYW5uZXI6IG5ldyB0b2tlbml6ZXIkMSgpLFxuICAgICAgICBmaWxlbmFtZTogJzx1bmtub3duPicsXG4gICAgICAgIG5lZWRQb3NpdGlvbnM6IGZhbHNlLFxuICAgICAgICB0b2xlcmFudDogZmFsc2UsXG4gICAgICAgIG9uUGFyc2VFcnJvcjogbm9vcCxcbiAgICAgICAgcGFyc2VBdHJ1bGVFeHByZXNzaW9uOiB0cnVlLFxuICAgICAgICBwYXJzZVNlbGVjdG9yOiB0cnVlLFxuICAgICAgICBwYXJzZVZhbHVlOiB0cnVlLFxuICAgICAgICBwYXJzZUN1c3RvbVByb3BlcnR5OiBmYWxzZSxcblxuICAgICAgICByZWFkU2VxdWVuY2U6IHNlcXVlbmNlLFxuXG4gICAgICAgIHRvbGVyYW50UGFyc2U6IGZ1bmN0aW9uKGNvbnN1bWVyLCBmYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMudG9sZXJhbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIuY3VycmVudFRva2VuO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUGFyc2VFcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrLmNhbGwodGhpcywgc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN1bWVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TG9jYXRpb246IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FubmVyLmdldExvY2F0aW9uUmFuZ2UoXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZW5hbWVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TG9jYXRpb25Gcm9tTGlzdDogZnVuY3Rpb24obGlzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmVlZFBvc2l0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNjYW5uZXIuZ2V0TG9jYXRpb25SYW5nZShcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5oZWFkICE9PSBudWxsID8gbGlzdC5maXJzdCgpLmxvYy5zdGFydC5vZmZzZXQgLSB0aGlzLnNjYW5uZXIuc3RhcnRPZmZzZXQgOiB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5oZWFkICE9PSBudWxsID8gbGlzdC5sYXN0KCkubG9jLmVuZC5vZmZzZXQgLSB0aGlzLnNjYW5uZXIuc3RhcnRPZmZzZXQgOiB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlbmFtZVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGNvbmZpZyA9IHByb2Nlc3NDb25maWcoY29uZmlnIHx8IHt9KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gY29uZmlnKSB7XG4gICAgICAgIHBhcnNlcltrZXldID0gY29uZmlnW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHNvdXJjZSwgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgICB2YXIgY29udGV4dCA9IG9wdGlvbnMuY29udGV4dCB8fCAnZGVmYXVsdCc7XG4gICAgICAgIHZhciBhc3Q7XG5cbiAgICAgICAgcGFyc2VyLnNjYW5uZXIuc2V0U291cmNlKHNvdXJjZSwgb3B0aW9ucy5vZmZzZXQsIG9wdGlvbnMubGluZSwgb3B0aW9ucy5jb2x1bW4pO1xuICAgICAgICBwYXJzZXIuZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lIHx8ICc8dW5rbm93bj4nO1xuICAgICAgICBwYXJzZXIubmVlZFBvc2l0aW9ucyA9IEJvb2xlYW4ob3B0aW9ucy5wb3NpdGlvbnMpO1xuICAgICAgICBwYXJzZXIudG9sZXJhbnQgPSBCb29sZWFuKG9wdGlvbnMudG9sZXJhbnQpO1xuICAgICAgICBwYXJzZXIub25QYXJzZUVycm9yID0gdHlwZW9mIG9wdGlvbnMub25QYXJzZUVycm9yID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5vblBhcnNlRXJyb3IgOiBub29wO1xuICAgICAgICBwYXJzZXIucGFyc2VBdHJ1bGVFeHByZXNzaW9uID0gJ3BhcnNlQXRydWxlRXhwcmVzc2lvbicgaW4gb3B0aW9ucyA/IEJvb2xlYW4ob3B0aW9ucy5wYXJzZUF0cnVsZUV4cHJlc3Npb24pIDogdHJ1ZTtcbiAgICAgICAgcGFyc2VyLnBhcnNlU2VsZWN0b3IgPSAncGFyc2VTZWxlY3RvcicgaW4gb3B0aW9ucyA/IEJvb2xlYW4ob3B0aW9ucy5wYXJzZVNlbGVjdG9yKSA6IHRydWU7XG4gICAgICAgIHBhcnNlci5wYXJzZVZhbHVlID0gJ3BhcnNlVmFsdWUnIGluIG9wdGlvbnMgPyBCb29sZWFuKG9wdGlvbnMucGFyc2VWYWx1ZSkgOiB0cnVlO1xuICAgICAgICBwYXJzZXIucGFyc2VDdXN0b21Qcm9wZXJ0eSA9ICdwYXJzZUN1c3RvbVByb3BlcnR5JyBpbiBvcHRpb25zID8gQm9vbGVhbihvcHRpb25zLnBhcnNlQ3VzdG9tUHJvcGVydHkpIDogZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwYXJzZXIuY29udGV4dC5oYXNPd25Qcm9wZXJ0eShjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGNvbnRleHQgYCcgKyBjb250ZXh0ICsgJ2AnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFzdCA9IHBhcnNlci5jb250ZXh0W2NvbnRleHRdLmNhbGwocGFyc2VyLCBvcHRpb25zKTtcblxuICAgICAgICBpZiAoIXBhcnNlci5zY2FubmVyLmVvZikge1xuICAgICAgICAgICAgcGFyc2VyLnNjYW5uZXIuZXJyb3IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGFzdCwgbnVsbCwgNCkpO1xuICAgICAgICByZXR1cm4gYXN0O1xuICAgIH07XG59O1xuXG52YXIgY21wQ2hhciQxID0gdG9rZW5pemVyJDEuY21wQ2hhcjtcbnZhciBUWVBFJDQgPSB0b2tlbml6ZXIkMS5UWVBFO1xuXG52YXIgSURFTlRJRklFUiQyID0gVFlQRSQ0LklkZW50aWZpZXI7XG52YXIgU1RSSU5HJDIgPSBUWVBFJDQuU3RyaW5nO1xudmFyIE5VTUJFUiQyID0gVFlQRSQ0Lk51bWJlcjtcbnZhciBGVU5DVElPTiQyID0gVFlQRSQ0LkZ1bmN0aW9uO1xudmFyIFVSTCQyID0gVFlQRSQ0LlVybDtcbnZhciBOVU1CRVJTSUdOID0gVFlQRSQ0Lk51bWJlclNpZ247XG52YXIgTEVGVFBBUkVOVEhFU0lTJDEgPSBUWVBFJDQuTGVmdFBhcmVudGhlc2lzO1xudmFyIExFRlRTUVVBUkVCUkFDS0VUJDEgPSBUWVBFJDQuTGVmdFNxdWFyZUJyYWNrZXQ7XG52YXIgUExVU1NJR04kMiA9IFRZUEUkNC5QbHVzU2lnbjtcbnZhciBIWVBIRU5NSU5VUyQyID0gVFlQRSQ0Lkh5cGhlbk1pbnVzO1xudmFyIENPTU1BID0gVFlQRSQ0LkNvbW1hO1xudmFyIFNPTElEVVMgPSBUWVBFJDQuU29saWR1cztcbnZhciBBU1RFUklTSyA9IFRZUEUkNC5Bc3RlcmlzaztcbnZhciBQRVJDRU5UU0lHTiA9IFRZUEUkNC5QZXJjZW50U2lnbjtcbnZhciBCQUNLU0xBU0ggPSBUWVBFJDQuQmFja3NsYXNoO1xudmFyIFUgPSAxMTc7IC8vICd1Jy5jaGFyQ29kZUF0KDApXG5cbnZhciBfZGVmYXVsdCA9IGZ1bmN0aW9uIGRlZmF1bHRSZWNvZ25pemVyKGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc2Nhbm5lci50b2tlblR5cGUpIHtcbiAgICAgICAgY2FzZSBOVU1CRVJTSUdOOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuSGV4Q29sb3IoKTtcblxuICAgICAgICBjYXNlIENPTU1BOlxuICAgICAgICAgICAgY29udGV4dC5zcGFjZSA9IG51bGw7XG4gICAgICAgICAgICBjb250ZXh0Lmlnbm9yZVdTQWZ0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuT3BlcmF0b3IoKTtcblxuICAgICAgICBjYXNlIFNPTElEVVM6XG4gICAgICAgIGNhc2UgQVNURVJJU0s6XG4gICAgICAgIGNhc2UgUExVU1NJR04kMjpcbiAgICAgICAgY2FzZSBIWVBIRU5NSU5VUyQyOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuT3BlcmF0b3IoKTtcblxuICAgICAgICBjYXNlIExFRlRQQVJFTlRIRVNJUyQxOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuUGFyZW50aGVzZXModGhpcy5yZWFkU2VxdWVuY2UsIGNvbnRleHQucmVjb2duaXplcik7XG5cbiAgICAgICAgY2FzZSBMRUZUU1FVQVJFQlJBQ0tFVCQxOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQnJhY2tldHModGhpcy5yZWFkU2VxdWVuY2UsIGNvbnRleHQucmVjb2duaXplcik7XG5cbiAgICAgICAgY2FzZSBTVFJJTkckMjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlN0cmluZygpO1xuXG4gICAgICAgIGNhc2UgTlVNQkVSJDI6XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2Nhbm5lci5sb29rdXBUeXBlKDEpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBQRVJDRU5UU0lHTjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuUGVyY2VudGFnZSgpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBJREVOVElGSUVSJDI6XG4gICAgICAgICAgICAgICAgICAgIC8vIGVkZ2UgY2FzZTogbnVtYmVyIHdpdGggZm9sb3dpbmcgXFwwIGFuZCBcXDkgaGFjayBzaG91bGRuJ3QgdG8gYmUgYSBEaW1lbnNpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtcENoYXIkMSh0aGlzLnNjYW5uZXIuc291cmNlLCB0aGlzLnNjYW5uZXIudG9rZW5FbmQsIEJBQ0tTTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk51bWJlcigpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLk51bWJlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgRlVOQ1RJT04kMjpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkZ1bmN0aW9uKHRoaXMucmVhZFNlcXVlbmNlLCBjb250ZXh0LnJlY29nbml6ZXIpO1xuXG4gICAgICAgIGNhc2UgVVJMJDI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5VcmwoKTtcblxuICAgICAgICBjYXNlIElERU5USUZJRVIkMjpcbiAgICAgICAgICAgIC8vIGNoZWNrIGZvciB1bmljb2RlIHJhbmdlLCBpdCBzaG91bGQgc3RhcnQgd2l0aCB1KyBvciBVK1xuICAgICAgICAgICAgaWYgKGNtcENoYXIkMSh0aGlzLnNjYW5uZXIuc291cmNlLCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCwgVSkgJiZcbiAgICAgICAgICAgICAgICBjbXBDaGFyJDEodGhpcy5zY2FubmVyLnNvdXJjZSwgdGhpcy5zY2FubmVyLnRva2VuU3RhcnQgKyAxLCBQTFVTU0lHTiQyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlVuaWNvZGVSYW5nZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGF0cnVsZUV4cHJlc3Npb24gPSB7XG4gICAgZ2V0Tm9kZTogX2RlZmF1bHRcbn07XG5cbnZhciBUWVBFJDUgPSB0b2tlbml6ZXIkMS5UWVBFO1xuXG52YXIgSURFTlRJRklFUiQzID0gVFlQRSQ1LklkZW50aWZpZXI7XG52YXIgTlVNQkVSJDMgPSBUWVBFJDUuTnVtYmVyO1xudmFyIE5VTUJFUlNJR04kMSA9IFRZUEUkNS5OdW1iZXJTaWduO1xudmFyIExFRlRTUVVBUkVCUkFDS0VUJDIgPSBUWVBFJDUuTGVmdFNxdWFyZUJyYWNrZXQ7XG52YXIgUExVU1NJR04kMyA9IFRZUEUkNS5QbHVzU2lnbjtcbnZhciBTT0xJRFVTJDEgPSBUWVBFJDUuU29saWR1cztcbnZhciBBU1RFUklTSyQxID0gVFlQRSQ1LkFzdGVyaXNrO1xudmFyIEZVTExTVE9QJDIgPSBUWVBFJDUuRnVsbFN0b3A7XG52YXIgQ09MT04gPSBUWVBFJDUuQ29sb247XG52YXIgR1JFQVRFUlRIQU5TSUdOJDEgPSBUWVBFJDUuR3JlYXRlclRoYW5TaWduO1xudmFyIFZFUlRJQ0FMTElORSA9IFRZUEUkNS5WZXJ0aWNhbExpbmU7XG52YXIgVElMREUgPSBUWVBFJDUuVGlsZGU7XG5cbmZ1bmN0aW9uIGdldE5vZGUoY29udGV4dCkge1xuICAgIHN3aXRjaCAodGhpcy5zY2FubmVyLnRva2VuVHlwZSkge1xuICAgICAgICBjYXNlIFBMVVNTSUdOJDM6XG4gICAgICAgIGNhc2UgR1JFQVRFUlRIQU5TSUdOJDE6XG4gICAgICAgIGNhc2UgVElMREU6XG4gICAgICAgICAgICBjb250ZXh0LnNwYWNlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnRleHQuaWdub3JlV1NBZnRlciA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5Db21iaW5hdG9yKCk7XG5cbiAgICAgICAgY2FzZSBTT0xJRFVTJDE6ICAvLyAvZGVlcC9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLkNvbWJpbmF0b3IoKTtcblxuICAgICAgICBjYXNlIEZVTExTVE9QJDI6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5DbGFzc1NlbGVjdG9yKCk7XG5cbiAgICAgICAgY2FzZSBMRUZUU1FVQVJFQlJBQ0tFVCQyOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQXR0cmlidXRlU2VsZWN0b3IoKTtcblxuICAgICAgICBjYXNlIE5VTUJFUlNJR04kMTpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLklkU2VsZWN0b3IoKTtcblxuICAgICAgICBjYXNlIENPTE9OOlxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5sb29rdXBUeXBlKDEpID09PSBDT0xPTikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLlBzZXVkb0VsZW1lbnRTZWxlY3RvcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5Qc2V1ZG9DbGFzc1NlbGVjdG9yKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBJREVOVElGSUVSJDM6XG4gICAgICAgIGNhc2UgQVNURVJJU0skMTpcbiAgICAgICAgY2FzZSBWRVJUSUNBTExJTkU6XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5UeXBlU2VsZWN0b3IoKTtcblxuICAgICAgICBjYXNlIE5VTUJFUiQzOlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuUGVyY2VudGFnZSgpO1xuICAgIH1cbn1cblxudmFyIHNlbGVjdG9yID0ge1xuICAgIGdldE5vZGU6IGdldE5vZGVcbn07XG5cbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtaW1hZ2VzLTQvI2VsZW1lbnQtbm90YXRpb25cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9lbGVtZW50XG52YXIgZWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgIHZhciBpZCA9IHRoaXMuSWRTZWxlY3RvcigpO1xuXG4gICAgdGhpcy5zY2FubmVyLnNraXBTQygpO1xuXG4gICAgcmV0dXJuIG5ldyBsaXN0KCkuYXBwZW5kRGF0YShcbiAgICAgICAgaWRcbiAgICApO1xufTtcblxuLy8gbGVnYWN5IElFIGZ1bmN0aW9uXG4vLyBleHByZXNzaW9uICcoJyByYXcgJyknXG52YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgbGlzdCgpLmFwcGVuZERhdGEoXG4gICAgICAgIHRoaXMuUmF3KHRoaXMuc2Nhbm5lci5jdXJyZW50VG9rZW4sIDAsIDAsIGZhbHNlLCBmYWxzZSlcbiAgICApO1xufTtcblxudmFyIFRZUEUkNiA9IHRva2VuaXplciQxLlRZUEU7XG5cbnZhciBJREVOVElGSUVSJDQgPSBUWVBFJDYuSWRlbnRpZmllcjtcbnZhciBDT01NQSQxID0gVFlQRSQ2LkNvbW1hO1xudmFyIFNFTUlDT0xPTiA9IFRZUEUkNi5TZW1pY29sb247XG52YXIgSFlQSEVOTUlOVVMkMyA9IFRZUEUkNi5IeXBoZW5NaW51cztcbnZhciBFWENMQU1BVElPTk1BUkskMSA9IFRZUEUkNi5FeGNsYW1hdGlvbk1hcms7XG5cbi8vIHZhciAnKCcgaWRlbnQgKCcsJyA8dmFsdWU+PyApPyAnKSdcbnZhciBfdmFyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbmV3IGxpc3QoKTtcblxuICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgIHZhciBpZGVudFN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG5cbiAgICB0aGlzLnNjYW5uZXIuZWF0KEhZUEhFTk1JTlVTJDMpO1xuICAgIGlmICh0aGlzLnNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQodGhpcy5zY2FubmVyLnRva2VuU3RhcnQpICE9PSBIWVBIRU5NSU5VUyQzKSB7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5lcnJvcignSHlwaGVuTWludXMgaXMgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgdGhpcy5zY2FubmVyLmVhdChJREVOVElGSUVSJDQpO1xuXG4gICAgY2hpbGRyZW4uYXBwZW5kRGF0YSh7XG4gICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKGlkZW50U3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgbmFtZTogdGhpcy5zY2FubmVyLnN1YnN0clRvQ3Vyc29yKGlkZW50U3RhcnQpXG4gICAgfSk7XG5cbiAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG5cbiAgICBpZiAodGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gQ09NTUEkMSkge1xuICAgICAgICBjaGlsZHJlbi5hcHBlbmREYXRhKHRoaXMuT3BlcmF0b3IoKSk7XG4gICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEodGhpcy5wYXJzZUN1c3RvbVByb3BlcnR5XG4gICAgICAgICAgICA/IHRoaXMuVmFsdWUobnVsbClcbiAgICAgICAgICAgIDogdGhpcy5SYXcodGhpcy5zY2FubmVyLmN1cnJlbnRUb2tlbiwgRVhDTEFNQVRJT05NQVJLJDEsIFNFTUlDT0xPTiwgZmFsc2UsIGZhbHNlKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjaGlsZHJlbjtcbn07XG5cbnZhciB2YWx1ZSA9IHtcbiAgICBnZXROb2RlOiBfZGVmYXVsdCxcbiAgICAnLW1vei1lbGVtZW50JzogZWxlbWVudCxcbiAgICAnZWxlbWVudCc6IGVsZW1lbnQsXG4gICAgJ2V4cHJlc3Npb24nOiBleHByZXNzaW9uLFxuICAgICd2YXInOiBfdmFyXG59O1xuXG52YXIgc2NvcGUgPSB7XG4gICAgQXRydWxlRXhwcmVzc2lvbjogYXRydWxlRXhwcmVzc2lvbixcbiAgICBTZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgVmFsdWU6IHZhbHVlXG59O1xuXG52YXIgZm9udEZhY2UgPSB7XG4gICAgcGFyc2U6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogbnVsbCxcbiAgICAgICAgYmxvY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQmxvY2sodGhpcy5EZWNsYXJhdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgVFlQRSQ3ID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIFNUUklORyQzID0gVFlQRSQ3LlN0cmluZztcbnZhciBJREVOVElGSUVSJDUgPSBUWVBFJDcuSWRlbnRpZmllcjtcbnZhciBVUkwkMyA9IFRZUEUkNy5Vcmw7XG52YXIgTEVGVFBBUkVOVEhFU0lTJDIgPSBUWVBFJDcuTGVmdFBhcmVudGhlc2lzO1xuXG52YXIgX2ltcG9ydCA9IHtcbiAgICBwYXJzZToge1xuICAgICAgICBleHByZXNzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IG5ldyBsaXN0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBTVFJJTkckMzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uYXBwZW5kRGF0YSh0aGlzLlN0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFVSTCQzOlxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5hcHBlbmREYXRhKHRoaXMuVXJsKCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5lcnJvcignU3RyaW5nIG9yIHVybCgpIGlzIGV4cGVjdGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIubG9va3VwTm9uV1NUeXBlKDApID09PSBJREVOVElGSUVSJDUgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubG9va3VwTm9uV1NUeXBlKDApID09PSBMRUZUUEFSRU5USEVTSVMkMikge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEodGhpcy5XaGl0ZVNwYWNlKCkpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEodGhpcy5NZWRpYVF1ZXJ5TGlzdCgpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBibG9jazogbnVsbFxuICAgIH1cbn07XG5cbnZhciBtZWRpYSA9IHtcbiAgICBwYXJzZToge1xuICAgICAgICBleHByZXNzaW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgbGlzdCgpLmFwcGVuZERhdGEoXG4gICAgICAgICAgICAgICAgdGhpcy5NZWRpYVF1ZXJ5TGlzdCgpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBibG9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5CbG9jayh0aGlzLlJ1bGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIFRZUEUkOCA9IHRva2VuaXplciQxLlRZUEU7XG52YXIgTEVGVENVUkxZQlJBQ0tFVCQxID0gVFlQRSQ4LkxlZnRDdXJseUJyYWNrZXQ7XG5cbnZhciBwYWdlID0ge1xuICAgIHBhcnNlOiB7XG4gICAgICAgIGV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5sb29rdXBOb25XU1R5cGUoMCkgPT09IExFRlRDVVJMWUJSQUNLRVQkMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IGxpc3QoKS5hcHBlbmREYXRhKFxuICAgICAgICAgICAgICAgIHRoaXMuU2VsZWN0b3JMaXN0KClcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG4gICAgICAgIGJsb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkJsb2NrKHRoaXMuRGVjbGFyYXRpb24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIFRZUEUkOSA9IHRva2VuaXplciQxLlRZUEU7XG5cbnZhciBXSElURVNQQUNFJDMgPSBUWVBFJDkuV2hpdGVTcGFjZTtcbnZhciBDT01NRU5UJDMgPSBUWVBFJDkuQ29tbWVudDtcbnZhciBJREVOVElGSUVSJDYgPSBUWVBFJDkuSWRlbnRpZmllcjtcbnZhciBGVU5DVElPTiQzID0gVFlQRSQ5LkZ1bmN0aW9uO1xudmFyIExFRlRQQVJFTlRIRVNJUyQzID0gVFlQRSQ5LkxlZnRQYXJlbnRoZXNpcztcbnZhciBIWVBIRU5NSU5VUyQ0ID0gVFlQRSQ5Lkh5cGhlbk1pbnVzO1xudmFyIENPTE9OJDEgPSBUWVBFJDkuQ29sb247XG5cbmZ1bmN0aW9uIGNvbnN1bWVSYXcoKSB7XG4gICAgcmV0dXJuIG5ldyBsaXN0KCkuYXBwZW5kRGF0YShcbiAgICAgICAgdGhpcy5SYXcodGhpcy5zY2FubmVyLmN1cnJlbnRUb2tlbiwgMCwgMCwgZmFsc2UsIGZhbHNlKVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudGhlc2VzKCkge1xuICAgIHZhciBpbmRleCA9IDA7XG5cbiAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG5cbiAgICAvLyBUT0RPOiBtYWtlIGl0IHNpbXBsaWVyXG4gICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgPT09IElERU5USUZJRVIkNikge1xuICAgICAgICBpbmRleCA9IDE7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlID09PSBIWVBIRU5NSU5VUyQ0ICYmXG4gICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubG9va3VwVHlwZSgxKSA9PT0gSURFTlRJRklFUiQ2KSB7XG4gICAgICAgIGluZGV4ID0gMjtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggIT09IDAgJiYgdGhpcy5zY2FubmVyLmxvb2t1cE5vbldTVHlwZShpbmRleCkgPT09IENPTE9OJDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBsaXN0KCkuYXBwZW5kRGF0YShcbiAgICAgICAgICAgIHRoaXMuRGVjbGFyYXRpb24oKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiByZWFkU2VxdWVuY2UkMS5jYWxsKHRoaXMpO1xufVxuXG5mdW5jdGlvbiByZWFkU2VxdWVuY2UkMSgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBuZXcgbGlzdCgpO1xuICAgIHZhciBzcGFjZSA9IG51bGw7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgdGhpcy5zY2FubmVyLnNraXBTQygpO1xuXG4gICAgc2NhbjpcbiAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFdISVRFU1BBQ0UkMzpcbiAgICAgICAgICAgICAgICBzcGFjZSA9IHRoaXMuV2hpdGVTcGFjZSgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjYXNlIENPTU1FTlQkMzpcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBjYXNlIEZVTkNUSU9OJDM6XG4gICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLkZ1bmN0aW9uKGNvbnN1bWVSYXcsIHRoaXMuc2NvcGUuQXRydWxlRXhwcmVzc2lvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgSURFTlRJRklFUiQ2OlxuICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5JZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgTEVGVFBBUkVOVEhFU0lTJDM6XG4gICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLlBhcmVudGhlc2VzKHBhcmVudGhlc2VzLCB0aGlzLnNjb3BlLkF0cnVsZUV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3BhY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEoc3BhY2UpO1xuICAgICAgICAgICAgc3BhY2UgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY2hpbGRyZW4uYXBwZW5kRGF0YShjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgc3VwcG9ydHMgPSB7XG4gICAgcGFyc2U6IHtcbiAgICAgICAgZXhwcmVzc2lvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSByZWFkU2VxdWVuY2UkMS5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVycm9yKCdDb25kaXRpb24gaXMgZXhwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgICAgICB9LFxuICAgICAgICBibG9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5CbG9jayh0aGlzLlJ1bGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxudmFyIGF0cnVsZSA9IHtcbiAgICAnZm9udC1mYWNlJzogZm9udEZhY2UsXG4gICAgJ2ltcG9ydCc6IF9pbXBvcnQsXG4gICAgJ21lZGlhJzogbWVkaWEsXG4gICAgJ3BhZ2UnOiBwYWdlLFxuICAgICdzdXBwb3J0cyc6IHN1cHBvcnRzXG59O1xuXG52YXIgZGlyID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBsaXN0KCkuYXBwZW5kRGF0YShcbiAgICAgICAgICAgIHRoaXMuSWRlbnRpZmllcigpXG4gICAgICAgICk7XG4gICAgfVxufTtcblxudmFyIGhhcyQxID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBsaXN0KCkuYXBwZW5kRGF0YShcbiAgICAgICAgICAgIHRoaXMuU2VsZWN0b3JMaXN0KClcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG52YXIgbGFuZyA9IHtcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgbGlzdCgpLmFwcGVuZERhdGEoXG4gICAgICAgICAgICB0aGlzLklkZW50aWZpZXIoKVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbnZhciBzZWxlY3Rvckxpc3QgPSB7XG4gICAgcGFyc2U6IGZ1bmN0aW9uIHNlbGVjdG9yTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBsaXN0KCkuYXBwZW5kRGF0YShcbiAgICAgICAgICAgIHRoaXMuU2VsZWN0b3JMaXN0KClcbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG52YXIgbWF0Y2hlcyA9IHNlbGVjdG9yTGlzdDtcblxudmFyIG5vdCA9IHNlbGVjdG9yTGlzdDtcblxudmFyIEFMTE9XX09GX0NMQVVTRSA9IHRydWU7XG5cbnZhciBudGhXaXRoT2ZDbGF1c2UgPSB7XG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IGxpc3QoKS5hcHBlbmREYXRhKFxuICAgICAgICAgICAgdGhpcy5OdGgoQUxMT1dfT0ZfQ0xBVVNFKVxuICAgICAgICApO1xuICAgIH1cbn07XG5cbnZhciBudGhDaGlsZCA9IG50aFdpdGhPZkNsYXVzZTtcblxudmFyIG50aExhc3RDaGlsZCA9IG50aFdpdGhPZkNsYXVzZTtcblxudmFyIERJU0FMTE9XX09GX0NMQVVTRSA9IGZhbHNlO1xuXG52YXIgbnRoID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiBudGgoKSB7XG4gICAgICAgIHJldHVybiBuZXcgbGlzdCgpLmFwcGVuZERhdGEoXG4gICAgICAgICAgICB0aGlzLk50aChESVNBTExPV19PRl9DTEFVU0UpXG4gICAgICAgICk7XG4gICAgfVxufTtcblxudmFyIG50aExhc3RPZlR5cGUgPSBudGg7XG5cbnZhciBudGhPZlR5cGUgPSBudGg7XG5cbnZhciBzbG90dGVkID0ge1xuICAgIHBhcnNlOiBmdW5jdGlvbiBjb21wb3VuZFNlbGVjdG9yKCkge1xuICAgICAgICByZXR1cm4gbmV3IGxpc3QoKS5hcHBlbmREYXRhKFxuICAgICAgICAgICAgdGhpcy5TZWxlY3RvcigpXG4gICAgICAgICk7XG4gICAgfVxufTtcblxudmFyIHBzZXVkbyA9IHtcbiAgICAnZGlyJzogZGlyLFxuICAgICdoYXMnOiBoYXMkMSxcbiAgICAnbGFuZyc6IGxhbmcsXG4gICAgJ21hdGNoZXMnOiBtYXRjaGVzLFxuICAgICdub3QnOiBub3QsXG4gICAgJ250aC1jaGlsZCc6IG50aENoaWxkLFxuICAgICdudGgtbGFzdC1jaGlsZCc6IG50aExhc3RDaGlsZCxcbiAgICAnbnRoLWxhc3Qtb2YtdHlwZSc6IG50aExhc3RPZlR5cGUsXG4gICAgJ250aC1vZi10eXBlJzogbnRoT2ZUeXBlLFxuICAgICdzbG90dGVkJzogc2xvdHRlZFxufTtcblxudmFyIGNtcENoYXIkMiA9IHRva2VuaXplciQxLmNtcENoYXI7XG52YXIgaXNOdW1iZXIkMiA9IHRva2VuaXplciQxLmlzTnVtYmVyO1xudmFyIFRZUEUkMTAgPSB0b2tlbml6ZXIkMS5UWVBFO1xuXG52YXIgSURFTlRJRklFUiQ3ID0gVFlQRSQxMC5JZGVudGlmaWVyO1xudmFyIE5VTUJFUiQ0ID0gVFlQRSQxMC5OdW1iZXI7XG52YXIgUExVU1NJR04kNCA9IFRZUEUkMTAuUGx1c1NpZ247XG52YXIgSFlQSEVOTUlOVVMkNSA9IFRZUEUkMTAuSHlwaGVuTWludXM7XG52YXIgTiQzID0gMTEwOyAvLyAnbicuY2hhckNvZGVBdCgwKVxudmFyIERJU0FMTE9XX1NJR04gPSB0cnVlO1xudmFyIEFMTE9XX1NJR04gPSBmYWxzZTtcblxuZnVuY3Rpb24gY2hlY2tUb2tlbklzSW50ZWdlcihzY2FubmVyLCBkaXNhbGxvd1NpZ24pIHtcbiAgICB2YXIgcG9zID0gc2Nhbm5lci50b2tlblN0YXJ0O1xuXG4gICAgaWYgKHNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQocG9zKSA9PT0gUExVU1NJR04kNCB8fFxuICAgICAgICBzY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHBvcykgPT09IEhZUEhFTk1JTlVTJDUpIHtcbiAgICAgICAgaWYgKGRpc2FsbG93U2lnbikge1xuICAgICAgICAgICAgc2Nhbm5lci5lcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHBvcysrO1xuICAgIH1cblxuICAgIGZvciAoOyBwb3MgPCBzY2FubmVyLnRva2VuRW5kOyBwb3MrKykge1xuICAgICAgICBpZiAoIWlzTnVtYmVyJDIoc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdChwb3MpKSkge1xuICAgICAgICAgICAgc2Nhbm5lci5lcnJvcignVW5leHBlY3RlZCBpbnB1dCcsIHBvcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIEFuK0IgbWljcm9zeW50YXggaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy1zeW50YXgtMy8jYW5iXG52YXIgQW5QbHVzQiA9IHtcbiAgICBuYW1lOiAnQW5QbHVzQicsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIGE6IFtTdHJpbmcsIG51bGxdLFxuICAgICAgICBiOiBbU3RyaW5nLCBudWxsXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIudG9rZW5TdGFydDtcbiAgICAgICAgdmFyIGVuZCA9IHN0YXJ0O1xuICAgICAgICB2YXIgcHJlZml4ID0gJyc7XG4gICAgICAgIHZhciBhID0gbnVsbDtcbiAgICAgICAgdmFyIGIgPSBudWxsO1xuXG4gICAgICAgIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlID09PSBOVU1CRVIkNCB8fFxuICAgICAgICAgICAgdGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gUExVU1NJR04kNCkge1xuICAgICAgICAgICAgY2hlY2tUb2tlbklzSW50ZWdlcih0aGlzLnNjYW5uZXIsIEFMTE9XX1NJR04pO1xuICAgICAgICAgICAgcHJlZml4ID0gdGhpcy5zY2FubmVyLmdldFRva2VuVmFsdWUoKTtcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNjYW5uZXIudG9rZW5TdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlID09PSBJREVOVElGSUVSJDcpIHtcbiAgICAgICAgICAgIHZhciBiU3RhcnQgPSB0aGlzLnNjYW5uZXIudG9rZW5TdGFydDtcblxuICAgICAgICAgICAgaWYgKGNtcENoYXIkMih0aGlzLnNjYW5uZXIuc291cmNlLCBiU3RhcnQsIEhZUEhFTk1JTlVTJDUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByZWZpeCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlZml4ID0gJy0nO1xuICAgICAgICAgICAgICAgICAgICBiU3RhcnQrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgaHlwaGVuIG1pbnVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWNtcENoYXIkMih0aGlzLnNjYW5uZXIuc291cmNlLCBiU3RhcnQsIE4kMykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYSA9IHByZWZpeCA9PT0gJycgID8gJzEnICA6XG4gICAgICAgICAgICAgICAgcHJlZml4ID09PSAnKycgPyAnKzEnIDpcbiAgICAgICAgICAgICAgICBwcmVmaXggPT09ICctJyA/ICctMScgOlxuICAgICAgICAgICAgICAgIHByZWZpeDtcblxuICAgICAgICAgICAgdmFyIGxlbiA9IHRoaXMuc2Nhbm5lci50b2tlbkVuZCAtIGJTdGFydDtcbiAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgLy8gLi5uLS4uXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdChiU3RhcnQgKyAxKSAhPT0gSFlQSEVOTUlOVVMkNSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQnLCBiU3RhcnQgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAobGVuID4gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyAuLm4te251bWJlcn0uLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCA9IGJTdGFydCArIDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi5uLSB7bnVtYmVyfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2hlY2tUb2tlbklzSW50ZWdlcih0aGlzLnNjYW5uZXIsIERJU0FMTE9XX1NJR04pO1xuICAgICAgICAgICAgICAgIGIgPSAnLScgKyB0aGlzLnNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZWZpeCA9ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgZW5kID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNraXBTQygpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgPT09IEhZUEhFTk1JTlVTJDUgfHxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gUExVU1NJR04kNCkge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXggPSB0aGlzLnNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgPT09IE5VTUJFUiQ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrVG9rZW5Jc0ludGVnZXIodGhpcy5zY2FubmVyLCBwcmVmaXggIT09ICcnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTnVtYmVyJDIodGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckF0KHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZml4ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGFuIG9wZXJhdG9yIGJlZm9yZSBudW1iZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5lcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwbHVzIGlzIHVzaW5nIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZpeCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYiA9IHByZWZpeCArIHRoaXMuc2Nhbm5lci5nZXRUb2tlblZhbHVlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVhdChOVU1CRVIkNCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09PSAnJyB8fCBwcmVmaXggPT09ICcrJykgeyAvLyBubyBudW1iZXJcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICdOdW1iZXIgb3IgaWRlbnRpZmllciBpcyBleHBlY3RlZCcsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0ICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gUExVU1NJR04kNCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gSFlQSEVOTUlOVVMkNVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYiA9IHByZWZpeDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnQW5QbHVzQicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIGVuZCksXG4gICAgICAgICAgICBhOiBhLFxuICAgICAgICAgICAgYjogYlxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICB2YXIgYSA9IG5vZGUuYSAhPT0gbnVsbCAmJiBub2RlLmEgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGIgPSBub2RlLmIgIT09IG51bGwgJiYgbm9kZS5iICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuayhcbiAgICAgICAgICAgICAgICBub2RlLmEgPT09ICcrMScgPyAnK24nIDpcbiAgICAgICAgICAgICAgICBub2RlLmEgPT09ICAnMScgPyAgJ24nIDpcbiAgICAgICAgICAgICAgICBub2RlLmEgPT09ICctMScgPyAnLW4nIDpcbiAgICAgICAgICAgICAgICBub2RlLmEgKyAnbidcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICAgICAgYiA9IFN0cmluZyhub2RlLmIpO1xuICAgICAgICAgICAgICAgIGlmIChiLmNoYXJBdCgwKSA9PT0gJy0nIHx8IGIuY2hhckF0KDApID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NodW5rKGIuY2hhckF0KDApKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NodW5rKGIuc3Vic3RyKDEpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzQ2h1bmsoJysnKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0NodW5rKGIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuayhTdHJpbmcobm9kZS5iKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgVFlQRSQxMSA9IHRva2VuaXplciQxLlRZUEU7XG5cbnZhciBBVFJVTEUkMiA9IFRZUEUkMTEuQXRydWxlO1xudmFyIFNFTUlDT0xPTiQxID0gVFlQRSQxMS5TZW1pY29sb247XG52YXIgTEVGVENVUkxZQlJBQ0tFVCQyID0gVFlQRSQxMS5MZWZ0Q3VybHlCcmFja2V0O1xudmFyIFJJR0hUQ1VSTFlCUkFDS0VUJDEgPSBUWVBFJDExLlJpZ2h0Q3VybHlCcmFja2V0O1xuXG5mdW5jdGlvbiBpc0Jsb2NrQXRydWxlKCkge1xuICAgIGZvciAodmFyIG9mZnNldCA9IDEsIHR5cGU7IHR5cGUgPSB0aGlzLnNjYW5uZXIubG9va3VwVHlwZShvZmZzZXQpOyBvZmZzZXQrKykge1xuICAgICAgICBpZiAodHlwZSA9PT0gUklHSFRDVVJMWUJSQUNLRVQkMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gTEVGVENVUkxZQlJBQ0tFVCQyIHx8XG4gICAgICAgICAgICB0eXBlID09PSBBVFJVTEUkMikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zY2FubmVyLnNraXAob2Zmc2V0KTtcbiAgICB0aGlzLnNjYW5uZXIuZWF0KFJJR0hUQ1VSTFlCUkFDS0VUJDEpO1xufVxuXG52YXIgQXRydWxlID0ge1xuICAgIG5hbWU6ICdBdHJ1bGUnLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICBuYW1lOiBTdHJpbmcsXG4gICAgICAgIGV4cHJlc3Npb246IFsnQXRydWxlRXhwcmVzc2lvbicsIG51bGxdLFxuICAgICAgICBibG9jazogWydCbG9jaycsIG51bGxdXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgdmFyIG5hbWVMb3dlckNhc2U7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gbnVsbDtcbiAgICAgICAgdmFyIGJsb2NrID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNjYW5uZXIuZWF0KEFUUlVMRSQyKTtcblxuICAgICAgICBuYW1lID0gdGhpcy5zY2FubmVyLnN1YnN0clRvQ3Vyc29yKHN0YXJ0ICsgMSk7XG4gICAgICAgIG5hbWVMb3dlckNhc2UgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgICAgICBleHByZXNzaW9uID0gdGhpcy5BdHJ1bGVFeHByZXNzaW9uKG5hbWUpO1xuXG4gICAgICAgIC8vIHR1cm4gZW1wdHkgQXRydWxlRXhwcmVzc2lvbiBpbnRvIG51bGxcbiAgICAgICAgaWYgKGV4cHJlc3Npb24uY2hpbGRyZW4uaGVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZXhwcmVzc2lvbiA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuYXRydWxlLmhhc093blByb3BlcnR5KG5hbWVMb3dlckNhc2UpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuYXRydWxlW25hbWVMb3dlckNhc2VdLmJsb2NrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgIT09IExFRlRDVVJMWUJSQUNLRVQkMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogbWFrZSB0b2xlcmFudFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ0N1cmx5IGJyYWNrZXQgaXMgZXhwZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBibG9jayA9IHRoaXMuYXRydWxlW25hbWVMb3dlckNhc2VdLmJsb2NrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50b2xlcmFudCB8fCAhdGhpcy5zY2FubmVyLmVvZikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuZWF0KFNFTUlDT0xPTiQxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2Nhbm5lci50b2tlblR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFNFTUlDT0xPTiQxOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgTEVGVENVUkxZQlJBQ0tFVCQyOlxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBzaG91bGQgY29uc3VtZSBibG9jayBjb250ZW50IGFzIFJhdz9cbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSB0aGlzLkJsb2NrKGlzQmxvY2tBdHJ1bGUuY2FsbCh0aGlzKSA/IHRoaXMuRGVjbGFyYXRpb24gOiB0aGlzLlJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy50b2xlcmFudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVycm9yKCdTZW1pY29sb24gb3IgYmxvY2sgaXMgZXhwZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBdHJ1bGUnLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgIGJsb2NrOiBibG9ja1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJ0AnKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUubmFtZSk7XG5cbiAgICAgICAgaWYgKG5vZGUuZXhwcmVzc2lvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc0NodW5rKCcgJyk7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlKHByb2Nlc3NDaHVuaywgbm9kZS5leHByZXNzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChub2RlLmJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRlKHByb2Nlc3NDaHVuaywgbm9kZS5ibG9jayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmsoJzsnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2Fsa0NvbnRleHQ6ICdhdHJ1bGUnXG59O1xuXG52YXIgVFlQRSQxMiA9IHRva2VuaXplciQxLlRZUEU7XG52YXIgU0VNSUNPTE9OJDIgPSBUWVBFJDEyLlNlbWljb2xvbjtcbnZhciBMRUZUQ1VSTFlCUkFDS0VUJDMgPSBUWVBFJDEyLkxlZnRDdXJseUJyYWNrZXQ7XG5cbmZ1bmN0aW9uIGNvbnN1bWVSYXckMShzdGFydFRva2VuKSB7XG4gICAgcmV0dXJuIG5ldyBsaXN0KCkuYXBwZW5kRGF0YShcbiAgICAgICAgdGhpcy5SYXcoc3RhcnRUb2tlbiwgU0VNSUNPTE9OJDIsIExFRlRDVVJMWUJSQUNLRVQkMywgZmFsc2UsIHRydWUpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gY29uc3VtZURlZmF1bHRTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkU2VxdWVuY2UodGhpcy5zY29wZS5BdHJ1bGVFeHByZXNzaW9uKTtcbn1cblxudmFyIEF0cnVsZUV4cHJlc3Npb24gPSB7XG4gICAgbmFtZTogJ0F0cnVsZUV4cHJlc3Npb24nLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICBjaGlsZHJlbjogW1tdXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0VG9rZW4gPSB0aGlzLnNjYW5uZXIuY3VycmVudFRva2VuO1xuXG4gICAgICAgIGlmIChuYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucGFyc2VBdHJ1bGVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAvLyBjdXN0b20gY29uc3VtZXJcbiAgICAgICAgICAgIGlmICh0aGlzLmF0cnVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5hdHJ1bGVbbmFtZV0uZXhwcmVzc2lvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMudG9sZXJhbnRQYXJzZSh0aGlzLmF0cnVsZVtuYW1lXS5leHByZXNzaW9uLCBjb25zdW1lUmF3JDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBjb25zdW1lclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbiA9IHRoaXMudG9sZXJhbnRQYXJzZShjb25zdW1lRGVmYXVsdFNlcXVlbmNlLCBjb25zdW1lUmF3JDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy50b2xlcmFudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIuZW9mIHx8ICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlICE9PSBTRU1JQ09MT04kMiAmJiB0aGlzLnNjYW5uZXIudG9rZW5UeXBlICE9PSBMRUZUQ1VSTFlCUkFDS0VUJDMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gY29uc3VtZVJhdyQxLmNhbGwodGhpcywgc3RhcnRUb2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBjb25zdW1lUmF3JDEuY2FsbCh0aGlzLCBzdGFydFRva2VuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY2hpbGRyZW4gPSBuZXcgbGlzdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBdHJ1bGVFeHByZXNzaW9uJyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbkZyb21MaXN0KGNoaWxkcmVuKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICB0aGlzLmVhY2gocHJvY2Vzc0NodW5rLCBub2RlKTtcbiAgICB9LFxuICAgIHdhbGtDb250ZXh0OiAnYXRydWxlRXhwcmVzc2lvbidcbn07XG5cbnZhciBUWVBFJDEzID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIElERU5USUZJRVIkOCA9IFRZUEUkMTMuSWRlbnRpZmllcjtcbnZhciBTVFJJTkckNCA9IFRZUEUkMTMuU3RyaW5nO1xudmFyIERPTExBUlNJR04gPSBUWVBFJDEzLkRvbGxhclNpZ247XG52YXIgQVNURVJJU0skMiA9IFRZUEUkMTMuQXN0ZXJpc2s7XG52YXIgQ09MT04kMiA9IFRZUEUkMTMuQ29sb247XG52YXIgRVFVQUxTU0lHTiA9IFRZUEUkMTMuRXF1YWxzU2lnbjtcbnZhciBMRUZUU1FVQVJFQlJBQ0tFVCQzID0gVFlQRSQxMy5MZWZ0U3F1YXJlQnJhY2tldDtcbnZhciBSSUdIVFNRVUFSRUJSQUNLRVQkMSA9IFRZUEUkMTMuUmlnaHRTcXVhcmVCcmFja2V0O1xudmFyIENJUkNVTUZMRVhBQ0NFTlQgPSBUWVBFJDEzLkNpcmN1bWZsZXhBY2NlbnQ7XG52YXIgVkVSVElDQUxMSU5FJDEgPSBUWVBFJDEzLlZlcnRpY2FsTGluZTtcbnZhciBUSUxERSQxID0gVFlQRSQxMy5UaWxkZTtcblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlTmFtZSgpIHtcbiAgICBpZiAodGhpcy5zY2FubmVyLmVvZikge1xuICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgdmFyIGV4cGVjdElkZW50aWZpZXIgPSBmYWxzZTtcbiAgICB2YXIgY2hlY2tDb2xvbiA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gQVNURVJJU0skMikge1xuICAgICAgICBleHBlY3RJZGVudGlmaWVyID0gdHJ1ZTtcbiAgICAgICAgY2hlY2tDb2xvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zY2FubmVyLnRva2VuVHlwZSAhPT0gVkVSVElDQUxMSU5FJDEpIHtcbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdChJREVOVElGSUVSJDgpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlID09PSBWRVJUSUNBTExJTkUkMSkge1xuICAgICAgICBpZiAodGhpcy5zY2FubmVyLmxvb2t1cFR5cGUoMSkgIT09IEVRVUFMU1NJR04pIHtcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZXIuZWF0KElERU5USUZJRVIkOCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXhwZWN0SWRlbnRpZmllcikge1xuICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVycm9yKCdJZGVudGlmaWVyIGlzIGV4cGVjdGVkJywgdGhpcy5zY2FubmVyLnRva2VuRW5kKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwZWN0SWRlbnRpZmllcikge1xuICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ1ZlcnRpY2FsIGxpbmUgaXMgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tDb2xvbiAmJiB0aGlzLnNjYW5uZXIudG9rZW5UeXBlID09PSBDT0xPTiQyKSB7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoSURFTlRJRklFUiQ4KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbihzdGFydCwgdGhpcy5zY2FubmVyLnRva2VuU3RhcnQpLFxuICAgICAgICBuYW1lOiB0aGlzLnNjYW5uZXIuc3Vic3RyVG9DdXJzb3Ioc3RhcnQpXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0T3BlcmF0b3IoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgdmFyIHRva2VuVHlwZSA9IHRoaXMuc2Nhbm5lci50b2tlblR5cGU7XG5cbiAgICBpZiAodG9rZW5UeXBlICE9PSBFUVVBTFNTSUdOICYmICAgICAgICAvLyA9XG4gICAgICAgIHRva2VuVHlwZSAhPT0gVElMREUkMSAmJiAgICAgICAgICAgICAvLyB+PVxuICAgICAgICB0b2tlblR5cGUgIT09IENJUkNVTUZMRVhBQ0NFTlQgJiYgIC8vIF49XG4gICAgICAgIHRva2VuVHlwZSAhPT0gRE9MTEFSU0lHTiAmJiAgICAgICAgLy8gJD1cbiAgICAgICAgdG9rZW5UeXBlICE9PSBBU1RFUklTSyQyICYmICAgICAgICAgIC8vICo9XG4gICAgICAgIHRva2VuVHlwZSAhPT0gVkVSVElDQUxMSU5FJDEgICAgICAgICAvLyB8PVxuICAgICkge1xuICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ0F0dHJpYnV0ZSBzZWxlY3RvciAoPSwgfj0sIF49LCAkPSwgKj0sIHw9KSBpcyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmICh0b2tlblR5cGUgPT09IEVRVUFMU1NJR04pIHtcbiAgICAgICAgdGhpcy5zY2FubmVyLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgICAgICB0aGlzLnNjYW5uZXIuZWF0KEVRVUFMU1NJR04pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnNjYW5uZXIuc3Vic3RyVG9DdXJzb3Ioc3RhcnQpO1xufVxuXG4vLyAnWycgUyogYXR0cmliX25hbWUgJ10nXG4vLyAnWycgUyogYXR0cmliX25hbWUgUyogYXR0cmliX21hdGNoZXIgUyogWyBJREVOVCB8IFNUUklORyBdIFMqIGF0dHJpYl9mbGFncz8gUyogJ10nXG52YXIgQXR0cmlidXRlU2VsZWN0b3IgPSB7XG4gICAgbmFtZTogJ0F0dHJpYnV0ZVNlbGVjdG9yJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgbmFtZTogJ0lkZW50aWZpZXInLFxuICAgICAgICBtYXRjaGVyOiBbU3RyaW5nLCBudWxsXSxcbiAgICAgICAgdmFsdWU6IFsnU3RyaW5nJywgJ0lkZW50aWZpZXInLCBudWxsXSxcbiAgICAgICAgZmxhZ3M6IFtTdHJpbmcsIG51bGxdXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuICAgICAgICB2YXIgbmFtZTtcbiAgICAgICAgdmFyIG1hdGNoZXIgPSBudWxsO1xuICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuICAgICAgICB2YXIgZmxhZ3MgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoTEVGVFNRVUFSRUJSQUNLRVQkMyk7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgICAgICBuYW1lID0gZ2V0QXR0cmlidXRlTmFtZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgIT09IFJJR0hUU1FVQVJFQlJBQ0tFVCQxKSB7XG4gICAgICAgICAgICAvLyBhdm9pZCBjYXNlIGBbbmFtZSBpXWBcbiAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlICE9PSBJREVOVElGSUVSJDgpIHtcbiAgICAgICAgICAgICAgICBtYXRjaGVyID0gZ2V0T3BlcmF0b3IuY2FsbCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gU1RSSU5HJDRcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLlN0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5JZGVudGlmaWVyKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZSBmbGFnc1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgPT09IElERU5USUZJRVIkOCkge1xuICAgICAgICAgICAgICAgIGZsYWdzID0gdGhpcy5zY2FubmVyLmdldFRva2VuVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNraXBTQygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdChSSUdIVFNRVUFSRUJSQUNLRVQkMSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdBdHRyaWJ1dGVTZWxlY3RvcicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBtYXRjaGVyOiBtYXRjaGVyLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHZhciBmbGFnc1ByZWZpeCA9ICcgJztcblxuICAgICAgICBwcm9jZXNzQ2h1bmsoJ1snKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZShwcm9jZXNzQ2h1bmssIG5vZGUubmFtZSk7XG5cbiAgICAgICAgaWYgKG5vZGUubWF0Y2hlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUubWF0Y2hlcik7XG5cbiAgICAgICAgICAgIGlmIChub2RlLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZShwcm9jZXNzQ2h1bmssIG5vZGUudmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gc3BhY2UgYmV0d2VlbiBzdHJpbmcgYW5kIGZsYWdzIGlzIG5vdCByZXF1aXJlZFxuICAgICAgICAgICAgICAgIGlmIChub2RlLnZhbHVlLnR5cGUgPT09ICdTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYWdzUHJlZml4ID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5vZGUuZmxhZ3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuayhmbGFnc1ByZWZpeCk7XG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmsobm9kZS5mbGFncyk7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9jZXNzQ2h1bmsoJ10nKTtcbiAgICB9XG59O1xuXG52YXIgVFlQRSQxNCA9IHRva2VuaXplciQxLlRZUEU7XG5cbnZhciBXSElURVNQQUNFJDQgPSBUWVBFJDE0LldoaXRlU3BhY2U7XG52YXIgQ09NTUVOVCQ0ID0gVFlQRSQxNC5Db21tZW50O1xudmFyIFNFTUlDT0xPTiQzID0gVFlQRSQxNC5TZW1pY29sb247XG52YXIgQVRSVUxFJDMgPSBUWVBFJDE0LkF0cnVsZTtcbnZhciBMRUZUQ1VSTFlCUkFDS0VUJDQgPSBUWVBFJDE0LkxlZnRDdXJseUJyYWNrZXQ7XG52YXIgUklHSFRDVVJMWUJSQUNLRVQkMiA9IFRZUEUkMTQuUmlnaHRDdXJseUJyYWNrZXQ7XG5cbmZ1bmN0aW9uIGNvbnN1bWVSYXckMihzdGFydFRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuUmF3KHN0YXJ0VG9rZW4sIDAsIFNFTUlDT0xPTiQzLCB0cnVlLCB0cnVlKTtcbn1cblxudmFyIEJsb2NrID0ge1xuICAgIG5hbWU6ICdCbG9jaycsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIGNoaWxkcmVuOiBbWydBdHJ1bGUnLCAnUnVsZScsICdEZWNsYXJhdGlvbiddXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGRlZmF1bHRDb25zdW1lcikge1xuICAgICAgICBpZiAoIWRlZmF1bHRDb25zdW1lcikge1xuICAgICAgICAgICAgZGVmYXVsdENvbnN1bWVyID0gdGhpcy5EZWNsYXJhdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBuZXcgbGlzdCgpO1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoTEVGVENVUkxZQlJBQ0tFVCQ0KTtcblxuICAgICAgICBzY2FuOlxuICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zY2FubmVyLnRva2VuVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgUklHSFRDVVJMWUJSQUNLRVQkMjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcblxuICAgICAgICAgICAgICAgIGNhc2UgV0hJVEVTUEFDRSQ0OlxuICAgICAgICAgICAgICAgIGNhc2UgQ09NTUVOVCQ0OlxuICAgICAgICAgICAgICAgIGNhc2UgU0VNSUNPTE9OJDM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBBVFJVTEUkMzpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uYXBwZW5kRGF0YSh0aGlzLnRvbGVyYW50UGFyc2UodGhpcy5BdHJ1bGUsIGNvbnN1bWVSYXckMikpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEodGhpcy50b2xlcmFudFBhcnNlKGRlZmF1bHRDb25zdW1lciwgY29uc3VtZVJhdyQyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMudG9sZXJhbnQgfHwgIXRoaXMuc2Nhbm5lci5lb2YpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoUklHSFRDVVJMWUJSQUNLRVQkMik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0Jsb2NrJyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbihzdGFydCwgdGhpcy5zY2FubmVyLnRva2VuU3RhcnQpLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuaygneycpO1xuICAgICAgICB0aGlzLmVhY2gocHJvY2Vzc0NodW5rLCBub2RlKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKCd9Jyk7XG4gICAgfSxcbiAgICB3YWxrQ29udGV4dDogJ2Jsb2NrJ1xufTtcblxudmFyIFRZUEUkMTUgPSB0b2tlbml6ZXIkMS5UWVBFO1xudmFyIExFRlRTUVVBUkVCUkFDS0VUJDQgPSBUWVBFJDE1LkxlZnRTcXVhcmVCcmFja2V0O1xudmFyIFJJR0hUU1FVQVJFQlJBQ0tFVCQyID0gVFlQRSQxNS5SaWdodFNxdWFyZUJyYWNrZXQ7XG5cbi8vIGN1cnJlbnRseSBvbmx5IEdyaWQgTGF5b3V0IHVzZXMgc3F1YXJlIGJyYWNrZXRzLCBidXQgbGVmdCBpdCB1bml2ZXJzYWxcbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtZ3JpZC8jdHJhY2stc2l6aW5nXG4vLyBbIGlkZW50KiBdXG52YXIgQnJhY2tldHMgPSB7XG4gICAgbmFtZTogJ0JyYWNrZXRzJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgY2hpbGRyZW46IFtbXV1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihyZWFkU2VxdWVuY2UsIHJlY29nbml6ZXIpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdChMRUZUU1FVQVJFQlJBQ0tFVCQ0KTtcbiAgICAgICAgY2hpbGRyZW4gPSByZWFkU2VxdWVuY2UuY2FsbCh0aGlzLCByZWNvZ25pemVyKTtcbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdChSSUdIVFNRVUFSRUJSQUNLRVQkMik7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdCcmFja2V0cycsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJ1snKTtcbiAgICAgICAgdGhpcy5lYWNoKHByb2Nlc3NDaHVuaywgbm9kZSk7XG4gICAgICAgIHByb2Nlc3NDaHVuaygnXScpO1xuICAgIH1cbn07XG5cbnZhciBDREMkMiA9IHRva2VuaXplciQxLlRZUEUuQ0RDO1xuXG52YXIgQ0RDXzEgPSB7XG4gICAgbmFtZTogJ0NEQycsXG4gICAgc3RydWN0dXJlOiBbXSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoQ0RDJDIpOyAvLyAtLT5cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0NEQycsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaykge1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJy0tPicpO1xuICAgIH1cbn07XG5cbnZhciBDRE8kMiA9IHRva2VuaXplciQxLlRZUEUuQ0RPO1xuXG52YXIgQ0RPXzEgPSB7XG4gICAgbmFtZTogJ0NETycsXG4gICAgc3RydWN0dXJlOiBbXSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoQ0RPJDIpOyAvLyA8IS0tXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdDRE8nLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydClcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmspIHtcbiAgICAgICAgcHJvY2Vzc0NodW5rKCc8IS0tJyk7XG4gICAgfVxufTtcblxudmFyIFRZUEUkMTYgPSB0b2tlbml6ZXIkMS5UWVBFO1xudmFyIElERU5USUZJRVIkOSA9IFRZUEUkMTYuSWRlbnRpZmllcjtcbnZhciBGVUxMU1RPUCQzID0gVFlQRSQxNi5GdWxsU3RvcDtcblxuLy8gJy4nIGlkZW50XG52YXIgQ2xhc3NTZWxlY3RvciA9IHtcbiAgICBuYW1lOiAnQ2xhc3NTZWxlY3RvcicsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIG5hbWU6IFN0cmluZ1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNjYW5uZXIuZWF0KEZVTExTVE9QJDMpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnQ2xhc3NTZWxlY3RvcicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odGhpcy5zY2FubmVyLnRva2VuU3RhcnQgLSAxLCB0aGlzLnNjYW5uZXIudG9rZW5FbmQpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5zY2FubmVyLmNvbnN1bWUoSURFTlRJRklFUiQ5KVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJy4nKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUubmFtZSk7XG4gICAgfVxufTtcblxudmFyIFRZUEUkMTcgPSB0b2tlbml6ZXIkMS5UWVBFO1xuXG52YXIgUExVU1NJR04kNSA9IFRZUEUkMTcuUGx1c1NpZ247XG52YXIgU09MSURVUyQyID0gVFlQRSQxNy5Tb2xpZHVzO1xudmFyIEdSRUFURVJUSEFOU0lHTiQyID0gVFlQRSQxNy5HcmVhdGVyVGhhblNpZ247XG52YXIgVElMREUkMiA9IFRZUEUkMTcuVGlsZGU7XG5cbi8vICsgfCA+IHwgfiB8IC9kZWVwL1xudmFyIENvbWJpbmF0b3IgPSB7XG4gICAgbmFtZTogJ0NvbWJpbmF0b3InLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICBuYW1lOiBTdHJpbmdcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIEdSRUFURVJUSEFOU0lHTiQyOlxuICAgICAgICAgICAgY2FzZSBQTFVTU0lHTiQ1OlxuICAgICAgICAgICAgY2FzZSBUSUxERSQyOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgU09MSURVUyQyOlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmV4cGVjdElkZW50aWZpZXIoJ2RlZXAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuZWF0KFNPTElEVVMkMik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVycm9yKCdDb21iaW5hdG9yIGlzIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0NvbWJpbmF0b3InLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLnNjYW5uZXIuc3Vic3RyVG9DdXJzb3Ioc3RhcnQpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLm5hbWUpO1xuICAgIH1cbn07XG5cbnZhciBUWVBFJDE4ID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIEFTVEVSSVNLJDMgPSBUWVBFJDE4LkFzdGVyaXNrO1xudmFyIFNPTElEVVMkMyA9IFRZUEUkMTguU29saWR1cztcblxuLy8gJy8qJyAuKiAnKi8nXG52YXIgQ29tbWVudCA9IHtcbiAgICBuYW1lOiAnQ29tbWVudCcsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIHZhbHVlOiBTdHJpbmdcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSB0aGlzLnNjYW5uZXIudG9rZW5FbmQ7XG5cbiAgICAgICAgaWYgKChlbmQgLSBzdGFydCArIDIpID49IDIgJiZcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdChlbmQgLSAyKSA9PT0gQVNURVJJU0skMyAmJlxuICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KGVuZCAtIDEpID09PSBTT0xJRFVTJDMpIHtcbiAgICAgICAgICAgIGVuZCAtPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zY2FubmVyLm5leHQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0NvbW1lbnQnLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnNvdXJjZS5zdWJzdHJpbmcoc3RhcnQgKyAyLCBlbmQpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuaygnLyonKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUudmFsdWUpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJyovJyk7XG4gICAgfVxufTtcblxudmFyIFRZUEUkMTkgPSB0b2tlbml6ZXIkMS5UWVBFO1xuXG52YXIgSURFTlRJRklFUiQxMCA9IFRZUEUkMTkuSWRlbnRpZmllcjtcbnZhciBDT0xPTiQzID0gVFlQRSQxOS5Db2xvbjtcbnZhciBFWENMQU1BVElPTk1BUkskMiA9IFRZUEUkMTkuRXhjbGFtYXRpb25NYXJrO1xudmFyIFNPTElEVVMkNCA9IFRZUEUkMTkuU29saWR1cztcbnZhciBBU1RFUklTSyQ0ID0gVFlQRSQxOS5Bc3RlcmlzaztcbnZhciBET0xMQVJTSUdOJDEgPSBUWVBFJDE5LkRvbGxhclNpZ247XG52YXIgSFlQSEVOTUlOVVMkNiA9IFRZUEUkMTkuSHlwaGVuTWludXM7XG52YXIgU0VNSUNPTE9OJDQgPSBUWVBFJDE5LlNlbWljb2xvbjtcbnZhciBSSUdIVENVUkxZQlJBQ0tFVCQzID0gVFlQRSQxOS5SaWdodEN1cmx5QnJhY2tldDtcbnZhciBSSUdIVFBBUkVOVEhFU0lTJDEgPSBUWVBFJDE5LlJpZ2h0UGFyZW50aGVzaXM7XG52YXIgUExVU1NJR04kNiA9IFRZUEUkMTkuUGx1c1NpZ247XG52YXIgTlVNQkVSU0lHTiQyID0gVFlQRSQxOS5OdW1iZXJTaWduO1xuXG52YXIgRGVjbGFyYXRpb24gPSB7XG4gICAgbmFtZTogJ0RlY2xhcmF0aW9uJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgaW1wb3J0YW50OiBbQm9vbGVhbiwgU3RyaW5nXSxcbiAgICAgICAgcHJvcGVydHk6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IFsnVmFsdWUnLCAnUmF3J11cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgIHZhciBwcm9wZXJ0eSA9IHJlYWRQcm9wZXJ0eS5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgaW1wb3J0YW50ID0gZmFsc2U7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoQ09MT04kMyk7XG5cbiAgICAgICAgaWYgKGlzQ3VzdG9tUHJvcGVydHkocHJvcGVydHkpID8gdGhpcy5wYXJzZUN1c3RvbVByb3BlcnR5IDogdGhpcy5wYXJzZVZhbHVlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMuVmFsdWUocHJvcGVydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLlJhdyh0aGlzLnNjYW5uZXIuY3VycmVudFRva2VuLCBFWENMQU1BVElPTk1BUkskMiwgU0VNSUNPTE9OJDQsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gRVhDTEFNQVRJT05NQVJLJDIpIHtcbiAgICAgICAgICAgIGltcG9ydGFudCA9IGdldEltcG9ydGFudCh0aGlzLnNjYW5uZXIpO1xuICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNraXBTQygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogaW5jbHVkZSBvciBub3QgdG8gaW5jbHVkZSBzZW1pY29sb24gdG8gcmFuZ2U/XG4gICAgICAgIC8vIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlID09PSBTRU1JQ09MT04pIHtcbiAgICAgICAgLy8gICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZiAoIXRoaXMuc2Nhbm5lci5lb2YgJiZcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci50b2tlblR5cGUgIT09IFNFTUlDT0xPTiQ0ICYmXG4gICAgICAgICAgICB0aGlzLnNjYW5uZXIudG9rZW5UeXBlICE9PSBSSUdIVFBBUkVOVEhFU0lTJDEgJiZcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci50b2tlblR5cGUgIT09IFJJR0hUQ1VSTFlCUkFDS0VUJDMpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5lcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdEZWNsYXJhdGlvbicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIGltcG9ydGFudDogaW1wb3J0YW50LFxuICAgICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlLCBpdGVtKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLnByb3BlcnR5KTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKCc6Jyk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGUocHJvY2Vzc0NodW5rLCBub2RlLnZhbHVlKTtcblxuICAgICAgICBpZiAobm9kZS5pbXBvcnRhbnQpIHtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuayhub2RlLmltcG9ydGFudCA9PT0gdHJ1ZSA/ICchaW1wb3J0YW50JyA6ICchJyArIG5vZGUuaW1wb3J0YW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ubmV4dCkge1xuICAgICAgICAgICAgcHJvY2Vzc0NodW5rKCc7Jyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhbGtDb250ZXh0OiAnZGVjbGFyYXRpb24nXG59O1xuXG5mdW5jdGlvbiBpc0N1c3RvbVByb3BlcnR5KG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZS5sZW5ndGggPj0gMiAmJlxuICAgICAgICAgICBuYW1lLmNoYXJDb2RlQXQoMCkgPT09IEhZUEhFTk1JTlVTJDYgJiZcbiAgICAgICAgICAgbmFtZS5jaGFyQ29kZUF0KDEpID09PSBIWVBIRU5NSU5VUyQ2O1xufVxuXG5mdW5jdGlvbiByZWFkUHJvcGVydHkoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgdmFyIHByZWZpeCA9IDA7XG5cbiAgICAvLyBoYWNrc1xuICAgIHN3aXRjaCAodGhpcy5zY2FubmVyLnRva2VuVHlwZSkge1xuICAgICAgICBjYXNlIEFTVEVSSVNLJDQ6XG4gICAgICAgIGNhc2UgRE9MTEFSU0lHTiQxOlxuICAgICAgICBjYXNlIFBMVVNTSUdOJDY6XG4gICAgICAgIGNhc2UgTlVNQkVSU0lHTiQyOlxuICAgICAgICAgICAgcHJlZml4ID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFRPRE86IG5vdCBzdXJlIHdlIHNob3VsZCBzdXBwb3J0IHRoaXMgaGFja1xuICAgICAgICBjYXNlIFNPTElEVVMkNDpcbiAgICAgICAgICAgIHByZWZpeCA9IHRoaXMuc2Nhbm5lci5sb29rdXBUeXBlKDEpID09PSBTT0xJRFVTJDQgPyAyIDogMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNjYW5uZXIubG9va3VwVHlwZShwcmVmaXgpID09PSBIWVBIRU5NSU5VUyQ2KSB7XG4gICAgICAgIHByZWZpeCsrO1xuICAgIH1cblxuICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgdGhpcy5zY2FubmVyLnNraXAocHJlZml4KTtcbiAgICB9XG5cbiAgICB0aGlzLnNjYW5uZXIuZWF0KElERU5USUZJRVIkMTApO1xuXG4gICAgcmV0dXJuIHRoaXMuc2Nhbm5lci5zdWJzdHJUb0N1cnNvcihzdGFydCk7XG59XG5cbi8vICEgd3MqIGltcG9ydGFudFxuZnVuY3Rpb24gZ2V0SW1wb3J0YW50KHNjYW5uZXIpIHtcbiAgICBzY2FubmVyLmVhdChFWENMQU1BVElPTk1BUkskMik7XG4gICAgc2Nhbm5lci5za2lwU0MoKTtcblxuICAgIHZhciBpbXBvcnRhbnQgPSBzY2FubmVyLmNvbnN1bWUoSURFTlRJRklFUiQxMCk7XG5cbiAgICAvLyBzdG9yZSBvcmlnaW5hbCB2YWx1ZSBpbiBjYXNlIGl0IGRpZmZlciBmcm9tIGBpbXBvcnRhbnRgXG4gICAgLy8gZm9yIGJldHRlciBvcmlnaW5hbCBzb3VyY2UgcmVzdG9yaW5nIGFuZCBoYWNrcyBsaWtlIGAhaWVgIHN1cHBvcnRcbiAgICByZXR1cm4gaW1wb3J0YW50ID09PSAnaW1wb3J0YW50JyA/IHRydWUgOiBpbXBvcnRhbnQ7XG59XG5cbnZhciBUWVBFJDIwID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIFdISVRFU1BBQ0UkNSA9IFRZUEUkMjAuV2hpdGVTcGFjZTtcbnZhciBDT01NRU5UJDUgPSBUWVBFJDIwLkNvbW1lbnQ7XG52YXIgU0VNSUNPTE9OJDUgPSBUWVBFJDIwLlNlbWljb2xvbjtcblxuZnVuY3Rpb24gY29uc3VtZVJhdyQzKHN0YXJ0VG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5SYXcoc3RhcnRUb2tlbiwgMCwgU0VNSUNPTE9OJDUsIHRydWUsIHRydWUpO1xufVxuXG52YXIgRGVjbGFyYXRpb25MaXN0ID0ge1xuICAgIG5hbWU6ICdEZWNsYXJhdGlvbkxpc3QnLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICBjaGlsZHJlbjogW1snRGVjbGFyYXRpb24nXV1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbmV3IGxpc3QoKTtcblxuICAgICAgICBzY2FuOlxuICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zY2FubmVyLnRva2VuVHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgV0hJVEVTUEFDRSQ1OlxuICAgICAgICAgICAgICAgIGNhc2UgQ09NTUVOVCQ1OlxuICAgICAgICAgICAgICAgIGNhc2UgU0VNSUNPTE9OJDU6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4uYXBwZW5kRGF0YSh0aGlzLnRvbGVyYW50UGFyc2UodGhpcy5EZWNsYXJhdGlvbiwgY29uc3VtZVJhdyQzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0RlY2xhcmF0aW9uTGlzdCcsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb25Gcm9tTGlzdChjaGlsZHJlbiksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmssIG5vZGUpIHtcbiAgICAgICAgdGhpcy5lYWNoKHByb2Nlc3NDaHVuaywgbm9kZSk7XG4gICAgfVxufTtcblxudmFyIE5VTUJFUiQ1ID0gdG9rZW5pemVyJDEuVFlQRS5OdW1iZXI7XG5cbi8vIHNwZWNpYWwgcmVhZGVyIGZvciB1bml0cyB0byBhdm9pZCBhZGpvaW5lZCBJRSBoYWNrcyAoaS5lLiAnMXB4XFw5JylcbmZ1bmN0aW9uIHJlYWRVbml0KHNjYW5uZXIpIHtcbiAgICB2YXIgdW5pdCA9IHNjYW5uZXIuZ2V0VG9rZW5WYWx1ZSgpO1xuICAgIHZhciBiYWNrU2xhc2hQb3MgPSB1bml0LmluZGV4T2YoJ1xcXFwnKTtcblxuICAgIGlmIChiYWNrU2xhc2hQb3MgPiAwKSB7XG4gICAgICAgIC8vIHBhdGNoIHRva2VuIG9mZnNldFxuICAgICAgICBzY2FubmVyLnRva2VuU3RhcnQgKz0gYmFja1NsYXNoUG9zO1xuXG4gICAgICAgIC8vIHJldHVybiBwYXJ0IGJlZm9yZSBiYWNrc2xhc2hcbiAgICAgICAgcmV0dXJuIHVuaXQuc3Vic3RyaW5nKDAsIGJhY2tTbGFzaFBvcyk7XG4gICAgfVxuXG4gICAgLy8gbm8gYmFja3NsYXNoIGluIHVuaXQgbmFtZVxuICAgIHNjYW5uZXIubmV4dCgpO1xuXG4gICAgcmV0dXJuIHVuaXQ7XG59XG5cbi8vIG51bWJlciBpZGVudFxudmFyIERpbWVuc2lvbiA9IHtcbiAgICBuYW1lOiAnRGltZW5zaW9uJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgdmFsdWU6IFN0cmluZyxcbiAgICAgICAgdW5pdDogU3RyaW5nXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLnNjYW5uZXIuY29uc3VtZShOVU1CRVIkNSk7XG4gICAgICAgIHZhciB1bml0ID0gcmVhZFVuaXQodGhpcy5zY2FubmVyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0RpbWVuc2lvbicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHVuaXQ6IHVuaXRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmssIG5vZGUpIHtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUudmFsdWUpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsobm9kZS51bml0KTtcbiAgICB9XG59O1xuXG52YXIgVFlQRSQyMSA9IHRva2VuaXplciQxLlRZUEU7XG52YXIgUklHSFRQQVJFTlRIRVNJUyQyID0gVFlQRSQyMS5SaWdodFBhcmVudGhlc2lzO1xuXG4vLyA8ZnVuY3Rpb24tdG9rZW4+IDxzZXF1ZW5jZT4gJyknXG52YXIgX0Z1bmN0aW9uID0ge1xuICAgIG5hbWU6ICdGdW5jdGlvbicsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIG5hbWU6IFN0cmluZyxcbiAgICAgICAgY2hpbGRyZW46IFtbXV1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihyZWFkU2VxdWVuY2UsIHJlY29nbml6ZXIpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5zY2FubmVyLmNvbnN1bWVGdW5jdGlvbk5hbWUoKTtcbiAgICAgICAgdmFyIG5hbWVMb3dlckNhc2UgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBjaGlsZHJlbjtcblxuICAgICAgICBjaGlsZHJlbiA9IHJlY29nbml6ZXIuaGFzT3duUHJvcGVydHkobmFtZUxvd2VyQ2FzZSlcbiAgICAgICAgICAgID8gcmVjb2duaXplcltuYW1lTG93ZXJDYXNlXS5jYWxsKHRoaXMsIHJlY29nbml6ZXIpXG4gICAgICAgICAgICA6IHJlYWRTZXF1ZW5jZS5jYWxsKHRoaXMsIHJlY29nbml6ZXIpO1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoUklHSFRQQVJFTlRIRVNJUyQyKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0Z1bmN0aW9uJyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbihzdGFydCwgdGhpcy5zY2FubmVyLnRva2VuU3RhcnQpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICBwcm9jZXNzQ2h1bmsobm9kZS5uYW1lKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKCcoJyk7XG4gICAgICAgIHRoaXMuZWFjaChwcm9jZXNzQ2h1bmssIG5vZGUpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJyknKTtcbiAgICB9LFxuICAgIHdhbGtDb250ZXh0OiAnZnVuY3Rpb24nXG59O1xuXG52YXIgaXNIZXgkMSA9IHRva2VuaXplciQxLmlzSGV4O1xudmFyIFRZUEUkMjIgPSB0b2tlbml6ZXIkMS5UWVBFO1xuXG52YXIgSURFTlRJRklFUiQxMSA9IFRZUEUkMjIuSWRlbnRpZmllcjtcbnZhciBOVU1CRVIkNiA9IFRZUEUkMjIuTnVtYmVyO1xudmFyIE5VTUJFUlNJR04kMyA9IFRZUEUkMjIuTnVtYmVyU2lnbjtcblxuZnVuY3Rpb24gY29uc3VtZUhleFNlcXVlbmNlKHNjYW5uZXIsIHJlcXVpcmVkKSB7XG4gICAgaWYgKCFpc0hleCQxKHNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQoc2Nhbm5lci50b2tlblN0YXJ0KSkpIHtcbiAgICAgICAgaWYgKHJlcXVpcmVkKSB7XG4gICAgICAgICAgICBzY2FubmVyLmVycm9yKCdVbmV4cGVjdGVkIGlucHV0Jywgc2Nhbm5lci50b2tlblN0YXJ0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIHBvcyA9IHNjYW5uZXIudG9rZW5TdGFydCArIDE7IHBvcyA8IHNjYW5uZXIudG9rZW5FbmQ7IHBvcysrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdChwb3MpO1xuXG4gICAgICAgIC8vIGJyZWFrIG9uIG5vbi1oZXggY2hhclxuICAgICAgICBpZiAoIWlzSGV4JDEoY29kZSkpIHtcbiAgICAgICAgICAgIC8vIGJyZWFrIHRva2VuLCBleGNsdWRlIHN5bWJvbFxuICAgICAgICAgICAgc2Nhbm5lci50b2tlblN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gdG9rZW4gaXMgZnVsbCBoZXggc2VxdWVuY2UsIGdvIHRvIG5leHQgdG9rZW5cbiAgICBzY2FubmVyLm5leHQoKTtcbn1cblxuLy8gIyBpZGVudFxudmFyIEhleENvbG9yID0ge1xuICAgIG5hbWU6ICdIZXhDb2xvcicsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIHZhbHVlOiBTdHJpbmdcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG5cbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdChOVU1CRVJTSUdOJDMpO1xuXG4gICAgICAgIHNjYW46XG4gICAgICAgIHN3aXRjaCAodGhpcy5zY2FubmVyLnRva2VuVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBOVU1CRVIkNjpcbiAgICAgICAgICAgICAgICBjb25zdW1lSGV4U2VxdWVuY2UodGhpcy5zY2FubmVyLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRva2VuIGlzIGlkZW50aWZpZXIgdGhlbiBudW1iZXIgY29uc2lzdHMgb2YgaGV4IG9ubHksXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGFkZCBpZGVudGlmaWVyIHRvIHJlc3VsdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlID09PSBJREVOVElGSUVSJDExKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN1bWVIZXhTZXF1ZW5jZSh0aGlzLnNjYW5uZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBJREVOVElGSUVSJDExOlxuICAgICAgICAgICAgICAgIGNvbnN1bWVIZXhTZXF1ZW5jZSh0aGlzLnNjYW5uZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5lcnJvcignTnVtYmVyIG9yIGlkZW50aWZpZXIgaXMgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnSGV4Q29sb3InLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLnN1YnN0clRvQ3Vyc29yKHN0YXJ0ICsgMSkgLy8gc2tpcCAjXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuaygnIycpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsobm9kZS52YWx1ZSk7XG4gICAgfVxufTtcblxudmFyIFRZUEUkMjMgPSB0b2tlbml6ZXIkMS5UWVBFO1xudmFyIElERU5USUZJRVIkMTIgPSBUWVBFJDIzLklkZW50aWZpZXI7XG5cbnZhciBJZGVudGlmaWVyID0ge1xuICAgIG5hbWU6ICdJZGVudGlmaWVyJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgbmFtZTogU3RyaW5nXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odGhpcy5zY2FubmVyLnRva2VuU3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlbkVuZCksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLnNjYW5uZXIuY29uc3VtZShJREVOVElGSUVSJDEyKVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICBwcm9jZXNzQ2h1bmsobm9kZS5uYW1lKTtcbiAgICB9XG59O1xuXG52YXIgVFlQRSQyNCA9IHRva2VuaXplciQxLlRZUEU7XG52YXIgSURFTlRJRklFUiQxMyA9IFRZUEUkMjQuSWRlbnRpZmllcjtcbnZhciBOVU1CRVJTSUdOJDQgPSBUWVBFJDI0Lk51bWJlclNpZ247XG5cbi8vICcjJyBpZGVudFxudmFyIElkU2VsZWN0b3IgPSB7XG4gICAgbmFtZTogJ0lkU2VsZWN0b3InLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICBuYW1lOiBTdHJpbmdcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdChOVU1CRVJTSUdOJDQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnSWRTZWxlY3RvcicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odGhpcy5zY2FubmVyLnRva2VuU3RhcnQgLSAxLCB0aGlzLnNjYW5uZXIudG9rZW5FbmQpLFxuICAgICAgICAgICAgbmFtZTogdGhpcy5zY2FubmVyLmNvbnN1bWUoSURFTlRJRklFUiQxMylcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmssIG5vZGUpIHtcbiAgICAgICAgcHJvY2Vzc0NodW5rKCcjJyk7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLm5hbWUpO1xuICAgIH1cbn07XG5cbnZhciBUWVBFJDI1ID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIElERU5USUZJRVIkMTQgPSBUWVBFJDI1LklkZW50aWZpZXI7XG52YXIgTlVNQkVSJDcgPSBUWVBFJDI1Lk51bWJlcjtcbnZhciBMRUZUUEFSRU5USEVTSVMkNCA9IFRZUEUkMjUuTGVmdFBhcmVudGhlc2lzO1xudmFyIFJJR0hUUEFSRU5USEVTSVMkMyA9IFRZUEUkMjUuUmlnaHRQYXJlbnRoZXNpcztcbnZhciBDT0xPTiQ0ID0gVFlQRSQyNS5Db2xvbjtcbnZhciBTT0xJRFVTJDUgPSBUWVBFJDI1LlNvbGlkdXM7XG5cbnZhciBNZWRpYUZlYXR1cmUgPSB7XG4gICAgbmFtZTogJ01lZGlhRmVhdHVyZScsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIG5hbWU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6IFsnSWRlbnRpZmllcicsICdOdW1iZXInLCAnRGltZW5zaW9uJywgJ1JhdGlvJywgbnVsbF1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoTEVGVFBBUkVOVEhFU0lTJDQpO1xuICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG5cbiAgICAgICAgbmFtZSA9IHRoaXMuc2Nhbm5lci5jb25zdW1lKElERU5USUZJRVIkMTQpO1xuICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgIT09IFJJR0hUUEFSRU5USEVTSVMkMykge1xuICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVhdChDT0xPTiQ0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBOVU1CRVIkNzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci5sb29rdXBUeXBlKDEpID09PSBJREVOVElGSUVSJDE0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuRGltZW5zaW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY2FubmVyLmxvb2t1cE5vbldTVHlwZSgxKSA9PT0gU09MSURVUyQ1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuUmF0aW8oKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBJREVOVElGSUVSJDE0OlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuSWRlbnRpZmllcigpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVycm9yKCdOdW1iZXIsIGRpbWVuc2lvbiwgcmF0aW8gb3IgaWRlbnRpZmllciBpcyBleHBlY3RlZCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjYW5uZXIuZWF0KFJJR0hUUEFSRU5USEVTSVMkMyk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdNZWRpYUZlYXR1cmUnLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuaygnKCcpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsobm9kZS5uYW1lKTtcbiAgICAgICAgaWYgKG5vZGUudmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuaygnOicpO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0ZShwcm9jZXNzQ2h1bmssIG5vZGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NDaHVuaygnKScpO1xuICAgIH1cbn07XG5cbnZhciBUWVBFJDI2ID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIFdISVRFU1BBQ0UkNiA9IFRZUEUkMjYuV2hpdGVTcGFjZTtcbnZhciBDT01NRU5UJDYgPSBUWVBFJDI2LkNvbW1lbnQ7XG52YXIgSURFTlRJRklFUiQxNSA9IFRZUEUkMjYuSWRlbnRpZmllcjtcbnZhciBMRUZUUEFSRU5USEVTSVMkNSA9IFRZUEUkMjYuTGVmdFBhcmVudGhlc2lzO1xuXG52YXIgTWVkaWFRdWVyeSA9IHtcbiAgICBuYW1lOiAnTWVkaWFRdWVyeScsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIGNoaWxkcmVuOiBbWydJZGVudGlmaWVyJywgJ01lZGlhRmVhdHVyZScsICdXaGl0ZVNwYWNlJ11dXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBuZXcgbGlzdCgpO1xuICAgICAgICB2YXIgY2hpbGQgPSBudWxsO1xuICAgICAgICB2YXIgc3BhY2UgPSBudWxsO1xuXG4gICAgICAgIHNjYW46XG4gICAgICAgIHdoaWxlICghdGhpcy5zY2FubmVyLmVvZikge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBDT01NRU5UJDY6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBXSElURVNQQUNFJDY6XG4gICAgICAgICAgICAgICAgICAgIHNwYWNlID0gdGhpcy5XaGl0ZVNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBJREVOVElGSUVSJDE1OlxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuSWRlbnRpZmllcigpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgTEVGVFBBUkVOVEhFU0lTJDU6XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkID0gdGhpcy5NZWRpYUZlYXR1cmUoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc3BhY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5hcHBlbmREYXRhKHNwYWNlKTtcbiAgICAgICAgICAgICAgICBzcGFjZSA9IG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEoY2hpbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ0lkZW50aWZpZXIgb3IgcGFyZW50aGVzaXMgaXMgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTWVkaWFRdWVyeScsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb25Gcm9tTGlzdChjaGlsZHJlbiksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmssIG5vZGUpIHtcbiAgICAgICAgdGhpcy5lYWNoKHByb2Nlc3NDaHVuaywgbm9kZSk7XG4gICAgfVxufTtcblxudmFyIENPTU1BJDIgPSB0b2tlbml6ZXIkMS5UWVBFLkNvbW1hO1xuXG52YXIgTWVkaWFRdWVyeUxpc3QgPSB7XG4gICAgbmFtZTogJ01lZGlhUXVlcnlMaXN0JyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgY2hpbGRyZW46IFtbJ01lZGlhUXVlcnknXV1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBuZXcgbGlzdCgpO1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5za2lwU0MoKTtcblxuICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEodGhpcy5NZWRpYVF1ZXJ5KHJlbGF0aXZlKSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlICE9PSBDT01NQSQyKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ01lZGlhUXVlcnlMaXN0JyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbkZyb21MaXN0KGNoaWxkcmVuKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICB0aGlzLmVhY2hDb21tYShwcm9jZXNzQ2h1bmssIG5vZGUpO1xuICAgIH1cbn07XG5cbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtc3ludGF4LTMvI3RoZS1hbmItdHlwZVxudmFyIE50aCA9IHtcbiAgICBuYW1lOiAnTnRoJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgbnRoOiBbJ0FuUGx1c0InLCAnSWRlbnRpZmllciddLFxuICAgICAgICBzZWxlY3RvcjogWydTZWxlY3Rvckxpc3QnLCBudWxsXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGFsbG93T2ZDbGF1c2UpIHtcbiAgICAgICAgdGhpcy5zY2FubmVyLnNraXBTQygpO1xuXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuICAgICAgICB2YXIgZW5kID0gc3RhcnQ7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IG51bGw7XG4gICAgICAgIHZhciBxdWVyeTtcblxuICAgICAgICBpZiAodGhpcy5zY2FubmVyLmxvb2t1cFZhbHVlKDAsICdvZGQnKSB8fCB0aGlzLnNjYW5uZXIubG9va3VwVmFsdWUoMCwgJ2V2ZW4nKSkge1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLklkZW50aWZpZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5BblBsdXNCKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG5cbiAgICAgICAgaWYgKGFsbG93T2ZDbGF1c2UgJiYgdGhpcy5zY2FubmVyLmxvb2t1cFZhbHVlKDAsICdvZicpKSB7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuXG4gICAgICAgICAgICBzZWxlY3RvciA9IHRoaXMuU2VsZWN0b3JMaXN0KCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBzZWxlY3Rvci5jaGlsZHJlbi5sYXN0KCkubG9jLmVuZC5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkUG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gcXVlcnkubG9jLmVuZC5vZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ050aCcsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIGVuZCksXG4gICAgICAgICAgICBudGg6IHF1ZXJ5LFxuICAgICAgICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGUocHJvY2Vzc0NodW5rLCBub2RlLm50aCk7XG4gICAgICAgIGlmIChub2RlLnNlbGVjdG9yICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmsoJyBvZiAnKTtcbiAgICAgICAgICAgIHRoaXMuZ2VuZXJhdGUocHJvY2Vzc0NodW5rLCBub2RlLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBOVU1CRVIkOCA9IHRva2VuaXplciQxLlRZUEUuTnVtYmVyO1xuXG52YXIgX051bWJlciA9IHtcbiAgICBuYW1lOiAnTnVtYmVyJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgdmFsdWU6IFN0cmluZ1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ051bWJlcicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odGhpcy5zY2FubmVyLnRva2VuU3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlbkVuZCksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLmNvbnN1bWUoTlVNQkVSJDgpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLnZhbHVlKTtcbiAgICB9XG59O1xuXG4vLyAnLycgfCAnKicgfCAnLCcgfCAnOicgfCAnKycgfCAnLSdcbnZhciBPcGVyYXRvciA9IHtcbiAgICBuYW1lOiAnT3BlcmF0b3InLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICB2YWx1ZTogU3RyaW5nXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5uZXh0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdPcGVyYXRvcicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuc3Vic3RyVG9DdXJzb3Ioc3RhcnQpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLnZhbHVlKTtcbiAgICB9XG59O1xuXG52YXIgVFlQRSQyNyA9IHRva2VuaXplciQxLlRZUEU7XG52YXIgTEVGVFBBUkVOVEhFU0lTJDYgPSBUWVBFJDI3LkxlZnRQYXJlbnRoZXNpcztcbnZhciBSSUdIVFBBUkVOVEhFU0lTJDQgPSBUWVBFJDI3LlJpZ2h0UGFyZW50aGVzaXM7XG5cbnZhciBQYXJlbnRoZXNlcyA9IHtcbiAgICBuYW1lOiAnUGFyZW50aGVzZXMnLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICBjaGlsZHJlbjogW1tdXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHJlYWRTZXF1ZW5jZSwgcmVjb2duaXplcikge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIudG9rZW5TdGFydDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbDtcblxuICAgICAgICB0aGlzLnNjYW5uZXIuZWF0KExFRlRQQVJFTlRIRVNJUyQ2KTtcbiAgICAgICAgY2hpbGRyZW4gPSByZWFkU2VxdWVuY2UuY2FsbCh0aGlzLCByZWNvZ25pemVyKTtcbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdChSSUdIVFBBUkVOVEhFU0lTJDQpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUGFyZW50aGVzZXMnLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmssIG5vZGUpIHtcbiAgICAgICAgcHJvY2Vzc0NodW5rKCcoJyk7XG4gICAgICAgIHRoaXMuZWFjaChwcm9jZXNzQ2h1bmssIG5vZGUpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJyknKTtcbiAgICB9XG59O1xuXG52YXIgVFlQRSQyOCA9IHRva2VuaXplciQxLlRZUEU7XG5cbnZhciBOVU1CRVIkOSA9IFRZUEUkMjguTnVtYmVyO1xudmFyIFBFUkNFTlRTSUdOJDEgPSBUWVBFJDI4LlBlcmNlbnRTaWduO1xuXG52YXIgUGVyY2VudGFnZSA9IHtcbiAgICBuYW1lOiAnUGVyY2VudGFnZScsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIHZhbHVlOiBTdHJpbmdcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgIHZhciBudW1iZXIgPSB0aGlzLnNjYW5uZXIuY29uc3VtZShOVU1CRVIkOSk7XG5cbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdChQRVJDRU5UU0lHTiQxKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BlcmNlbnRhZ2UnLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICB2YWx1ZTogbnVtYmVyXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLnZhbHVlKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKCclJyk7XG4gICAgfVxufTtcblxudmFyIFRZUEUkMjkgPSB0b2tlbml6ZXIkMS5UWVBFO1xuXG52YXIgSURFTlRJRklFUiQxNiA9IFRZUEUkMjkuSWRlbnRpZmllcjtcbnZhciBGVU5DVElPTiQ0ID0gVFlQRSQyOS5GdW5jdGlvbjtcbnZhciBDT0xPTiQ1ID0gVFlQRSQyOS5Db2xvbjtcbnZhciBSSUdIVFBBUkVOVEhFU0lTJDUgPSBUWVBFJDI5LlJpZ2h0UGFyZW50aGVzaXM7XG5cbi8vIDogaWRlbnQgWyAnKCcgLi4gJyknIF0/XG52YXIgUHNldWRvQ2xhc3NTZWxlY3RvciA9IHtcbiAgICBuYW1lOiAnUHNldWRvQ2xhc3NTZWxlY3RvcicsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIG5hbWU6IFN0cmluZyxcbiAgICAgICAgY2hpbGRyZW46IFtbJ1JhdyddLCBudWxsXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIudG9rZW5TdGFydDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIHZhciBuYW1lTG93ZXJDYXNlO1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoQ09MT04kNSk7XG5cbiAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgPT09IEZVTkNUSU9OJDQpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnNjYW5uZXIuY29uc3VtZUZ1bmN0aW9uTmFtZSgpO1xuICAgICAgICAgICAgbmFtZUxvd2VyQ2FzZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHNldWRvLmhhc093blByb3BlcnR5KG5hbWVMb3dlckNhc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNraXBTQygpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5wc2V1ZG9bbmFtZUxvd2VyQ2FzZV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gbmV3IGxpc3QoKS5hcHBlbmREYXRhKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLlJhdyh0aGlzLnNjYW5uZXIuY3VycmVudFRva2VuLCAwLCAwLCBmYWxzZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVhdChSSUdIVFBBUkVOVEhFU0lTJDUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuc2Nhbm5lci5jb25zdW1lKElERU5USUZJRVIkMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQc2V1ZG9DbGFzc1NlbGVjdG9yJyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbihzdGFydCwgdGhpcy5zY2FubmVyLnRva2VuU3RhcnQpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJzonKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUubmFtZSk7XG5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuaygnKCcpO1xuICAgICAgICAgICAgdGhpcy5lYWNoKHByb2Nlc3NDaHVuaywgbm9kZSk7XG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmsoJyknKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2Fsa0NvbnRleHQ6ICdmdW5jdGlvbidcbn07XG5cbnZhciBUWVBFJDMwID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIElERU5USUZJRVIkMTcgPSBUWVBFJDMwLklkZW50aWZpZXI7XG52YXIgRlVOQ1RJT04kNSA9IFRZUEUkMzAuRnVuY3Rpb247XG52YXIgQ09MT04kNiA9IFRZUEUkMzAuQ29sb247XG52YXIgUklHSFRQQVJFTlRIRVNJUyQ2ID0gVFlQRSQzMC5SaWdodFBhcmVudGhlc2lzO1xuXG4vLyA6OiBpZGVudCBbICcoJyAuLiAnKScgXT9cbnZhciBQc2V1ZG9FbGVtZW50U2VsZWN0b3IgPSB7XG4gICAgbmFtZTogJ1BzZXVkb0VsZW1lbnRTZWxlY3RvcicsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIG5hbWU6IFN0cmluZyxcbiAgICAgICAgY2hpbGRyZW46IFtbJ1JhdyddLCBudWxsXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIudG9rZW5TdGFydDtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgICAgdmFyIG5hbWU7XG4gICAgICAgIHZhciBuYW1lTG93ZXJDYXNlO1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoQ09MT04kNik7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoQ09MT04kNik7XG5cbiAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgPT09IEZVTkNUSU9OJDUpIHtcbiAgICAgICAgICAgIG5hbWUgPSB0aGlzLnNjYW5uZXIuY29uc3VtZUZ1bmN0aW9uTmFtZSgpO1xuICAgICAgICAgICAgbmFtZUxvd2VyQ2FzZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMucHNldWRvLmhhc093blByb3BlcnR5KG5hbWVMb3dlckNhc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLnNraXBTQygpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5wc2V1ZG9bbmFtZUxvd2VyQ2FzZV0uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gbmV3IGxpc3QoKS5hcHBlbmREYXRhKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLlJhdyh0aGlzLnNjYW5uZXIuY3VycmVudFRva2VuLCAwLCAwLCBmYWxzZSwgZmFsc2UpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVhdChSSUdIVFBBUkVOVEhFU0lTJDYpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuc2Nhbm5lci5jb25zdW1lKElERU5USUZJRVIkMTcpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQc2V1ZG9FbGVtZW50U2VsZWN0b3InLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuaygnOjonKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUubmFtZSk7XG5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByb2Nlc3NDaHVuaygnKCcpO1xuICAgICAgICAgICAgdGhpcy5lYWNoKHByb2Nlc3NDaHVuaywgbm9kZSk7XG4gICAgICAgICAgICBwcm9jZXNzQ2h1bmsoJyknKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2Fsa0NvbnRleHQ6ICdmdW5jdGlvbidcbn07XG5cbnZhciBpc051bWJlciQzID0gdG9rZW5pemVyJDEuaXNOdW1iZXI7XG52YXIgVFlQRSQzMSA9IHRva2VuaXplciQxLlRZUEU7XG52YXIgTlVNQkVSJDEwID0gVFlQRSQzMS5OdW1iZXI7XG52YXIgU09MSURVUyQ2ID0gVFlQRSQzMS5Tb2xpZHVzO1xudmFyIEZVTExTVE9QJDQgPSBUWVBFJDMxLkZ1bGxTdG9wO1xuXG4vLyBUZXJtcyBvZiA8cmF0aW8+IHNob3VsZCB0byBiZSBhIHBvc2l0aXZlIG51bWJlciAobm90IHplcm8gb3IgbmVnYXRpdmUpXG4vLyAoc2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9tZWRpYXF1ZXJpZXMtMy8jdmFsdWVzKVxuLy8gSG93ZXZlciwgLW8tbWluLWRldmljZS1waXhlbC1yYXRpbyB0YWtlcyBmcmFjdGlvbmFsIHZhbHVlcyBhcyBhIHJhdGlvJ3MgdGVybVxuLy8gYW5kIHRoaXMgaXMgdXNpbmcgYnkgdmFyaW91cyBzaXRlcy4gVGhlcmVmb3JlIHdlIHJlbGF4IGNoZWNraW5nIG9uIHBhcnNlXG4vLyB0byB0ZXN0IGEgdGVybSBpcyB1bnNpZ25lZCBudW1iZXIgd2l0aG91dCBleHBvbmVudCBwYXJ0LlxuLy8gQWRkaXRpb25hbCBjaGVja3MgbWF5IHRvIGJlIGFwcGxpZWQgb24gbGV4ZXIgdmFsaWRhdGlvbi5cbmZ1bmN0aW9uIGNvbnN1bWVOdW1iZXIoc2Nhbm5lcikge1xuICAgIHZhciB2YWx1ZSA9IHNjYW5uZXIuY29uc3VtZU5vbldTKE5VTUJFUiQxMCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gdmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKCFpc051bWJlciQzKGNvZGUpICYmIGNvZGUgIT09IEZVTExTVE9QJDQpIHtcbiAgICAgICAgICAgIHNjYW5uZXIuZXJyb3IoJ1Vuc2lnbmVkIG51bWJlciBpcyBleHBlY3RlZCcsIHNjYW5uZXIudG9rZW5TdGFydCAtIHZhbHVlLmxlbmd0aCArIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDApIHtcbiAgICAgICAgc2Nhbm5lci5lcnJvcignWmVybyBudW1iZXIgaXMgbm90IGFsbG93ZWQnLCBzY2FubmVyLnRva2VuU3RhcnQgLSB2YWx1ZS5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gPHBvc2l0aXZlLWludGVnZXI+IFMqICcvJyBTKiA8cG9zaXRpdmUtaW50ZWdlcj5cbnZhciBSYXRpbyA9IHtcbiAgICBuYW1lOiAnUmF0aW8nLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICBsZWZ0OiBTdHJpbmcsXG4gICAgICAgIHJpZ2h0OiBTdHJpbmdcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgIHZhciBsZWZ0ID0gY29uc3VtZU51bWJlcih0aGlzLnNjYW5uZXIpO1xuICAgICAgICB2YXIgcmlnaHQ7XG5cbiAgICAgICAgdGhpcy5zY2FubmVyLmVhdE5vbldTKFNPTElEVVMkNik7XG4gICAgICAgIHJpZ2h0ID0gY29uc3VtZU51bWJlcih0aGlzLnNjYW5uZXIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUmF0aW8nLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLmxlZnQpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJy8nKTtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUucmlnaHQpO1xuICAgIH1cbn07XG5cbnZhciBSYXcgPSB7XG4gICAgbmFtZTogJ1JhdycsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIHZhbHVlOiBTdHJpbmdcbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihzdGFydFRva2VuLCBlbmRUb2tlblR5cGUxLCBlbmRUb2tlblR5cGUyLCBpbmNsdWRlVG9rZW5UeXBlMiwgZXhjbHVkZVdoaXRlU3BhY2UpIHtcbiAgICAgICAgdmFyIHN0YXJ0T2Zmc2V0ID0gdGhpcy5zY2FubmVyLmdldFRva2VuU3RhcnQoc3RhcnRUb2tlbik7XG4gICAgICAgIHZhciBlbmRPZmZzZXQ7XG5cbiAgICAgICAgdGhpcy5zY2FubmVyLnNraXAoXG4gICAgICAgICAgICB0aGlzLnNjYW5uZXIuZ2V0UmF3TGVuZ3RoKFxuICAgICAgICAgICAgICAgIHN0YXJ0VG9rZW4sXG4gICAgICAgICAgICAgICAgZW5kVG9rZW5UeXBlMSxcbiAgICAgICAgICAgICAgICBlbmRUb2tlblR5cGUyLFxuICAgICAgICAgICAgICAgIGluY2x1ZGVUb2tlblR5cGUyXG4gICAgICAgICAgICApXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGV4Y2x1ZGVXaGl0ZVNwYWNlICYmIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0ID4gc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IHRoaXMuc2Nhbm5lci5nZXRPZmZzZXRFeGNsdWRlV1MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdSYXcnLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2Nhbm5lci5zb3VyY2Uuc3Vic3RyaW5nKHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLnZhbHVlKTtcbiAgICB9XG59O1xuXG52YXIgVFlQRSQzMiA9IHRva2VuaXplciQxLlRZUEU7XG5cbnZhciBMRUZUQ1VSTFlCUkFDS0VUJDUgPSBUWVBFJDMyLkxlZnRDdXJseUJyYWNrZXQ7XG5cbmZ1bmN0aW9uIGNvbnN1bWVSYXckNChzdGFydFRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuUmF3KHN0YXJ0VG9rZW4sIExFRlRDVVJMWUJSQUNLRVQkNSwgMCwgZmFsc2UsIHRydWUpO1xufVxuXG52YXIgUnVsZSA9IHtcbiAgICBuYW1lOiAnUnVsZScsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIHNlbGVjdG9yOiBbJ1NlbGVjdG9yTGlzdCcsICdSYXcnXSxcbiAgICAgICAgYmxvY2s6IFsnQmxvY2snXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnRUb2tlbiA9IHRoaXMuc2Nhbm5lci5jdXJyZW50VG9rZW47XG4gICAgICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSB0aGlzLnBhcnNlU2VsZWN0b3JcbiAgICAgICAgICAgID8gdGhpcy50b2xlcmFudFBhcnNlKHRoaXMuU2VsZWN0b3JMaXN0LCBjb25zdW1lUmF3JDQpXG4gICAgICAgICAgICA6IGNvbnN1bWVSYXckNC5jYWxsKHRoaXMsIHN0YXJ0VG9rZW4pO1xuICAgICAgICB2YXIgYmxvY2sgPSB0aGlzLkJsb2NrKHRoaXMuRGVjbGFyYXRpb24pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnUnVsZScsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnRPZmZzZXQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIHNlbGVjdG9yOiBzZWxlY3RvcixcbiAgICAgICAgICAgIGJsb2NrOiBibG9ja1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICB0aGlzLmdlbmVyYXRlKHByb2Nlc3NDaHVuaywgbm9kZS5zZWxlY3Rvcik7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGUocHJvY2Vzc0NodW5rLCBub2RlLmJsb2NrKTtcbiAgICB9LFxuICAgIHdhbGtDb250ZXh0OiAncnVsZSdcbn07XG5cbnZhciBTZWxlY3RvciA9IHtcbiAgICBuYW1lOiAnU2VsZWN0b3InLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICBjaGlsZHJlbjogW1tcbiAgICAgICAgICAgICdUeXBlU2VsZWN0b3InLFxuICAgICAgICAgICAgJ0lkU2VsZWN0b3InLFxuICAgICAgICAgICAgJ0NsYXNzU2VsZWN0b3InLFxuICAgICAgICAgICAgJ0F0dHJpYnV0ZVNlbGVjdG9yJyxcbiAgICAgICAgICAgICdQc2V1ZG9DbGFzc1NlbGVjdG9yJyxcbiAgICAgICAgICAgICdQc2V1ZG9FbGVtZW50U2VsZWN0b3InLFxuICAgICAgICAgICAgJ0NvbWJpbmF0b3InLFxuICAgICAgICAgICAgJ1doaXRlU3BhY2UnXG4gICAgICAgIF1dXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucmVhZFNlcXVlbmNlKHRoaXMuc2NvcGUuU2VsZWN0b3IpO1xuXG4gICAgICAgIC8vIG5vdGhpbmcgd2VyZSBjb25zdW1lZFxuICAgICAgICBpZiAoY2hpbGRyZW4uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ1NlbGVjdG9yIGlzIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1NlbGVjdG9yJyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbkZyb21MaXN0KGNoaWxkcmVuKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICB0aGlzLmVhY2gocHJvY2Vzc0NodW5rLCBub2RlKTtcbiAgICB9XG59O1xuXG52YXIgVFlQRSQzMyA9IHRva2VuaXplciQxLlRZUEU7XG5cbnZhciBDT01NQSQzID0gVFlQRSQzMy5Db21tYTtcbnZhciBMRUZUQ1VSTFlCUkFDS0VUJDYgPSBUWVBFJDMzLkxlZnRDdXJseUJyYWNrZXQ7XG5cbnZhciBTZWxlY3Rvckxpc3QgPSB7XG4gICAgbmFtZTogJ1NlbGVjdG9yTGlzdCcsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIGNoaWxkcmVuOiBbWydTZWxlY3RvcicsICdSYXcnXV1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbmV3IGxpc3QoKTtcblxuICAgICAgICB3aGlsZSAoIXRoaXMuc2Nhbm5lci5lb2YpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLmFwcGVuZERhdGEodGhpcy5wYXJzZVNlbGVjdG9yXG4gICAgICAgICAgICAgICAgPyB0aGlzLlNlbGVjdG9yKClcbiAgICAgICAgICAgICAgICA6IHRoaXMuUmF3KHRoaXMuc2Nhbm5lci5jdXJyZW50VG9rZW4sIENPTU1BJDMsIExFRlRDVVJMWUJSQUNLRVQkNiwgZmFsc2UsIGZhbHNlKVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgPT09IENPTU1BJDMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnU2VsZWN0b3JMaXN0JyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbkZyb21MaXN0KGNoaWxkcmVuKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICB0aGlzLmVhY2hDb21tYShwcm9jZXNzQ2h1bmssIG5vZGUpO1xuICAgIH0sXG4gICAgd2Fsa0NvbnRleHQ6ICdzZWxlY3Rvcidcbn07XG5cbnZhciBTVFJJTkckNSA9IHRva2VuaXplciQxLlRZUEUuU3RyaW5nO1xuXG52YXIgX1N0cmluZyA9IHtcbiAgICBuYW1lOiAnU3RyaW5nJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgdmFsdWU6IFN0cmluZ1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1N0cmluZycsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24odGhpcy5zY2FubmVyLnRva2VuU3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlbkVuZCksXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy5zY2FubmVyLmNvbnN1bWUoU1RSSU5HJDUpXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBnZW5lcmF0ZTogZnVuY3Rpb24ocHJvY2Vzc0NodW5rLCBub2RlKSB7XG4gICAgICAgIHByb2Nlc3NDaHVuayhub2RlLnZhbHVlKTtcbiAgICB9XG59O1xuXG52YXIgVFlQRSQzNCA9IHRva2VuaXplciQxLlRZUEU7XG5cbnZhciBXSElURVNQQUNFJDcgPSBUWVBFJDM0LldoaXRlU3BhY2U7XG52YXIgQ09NTUVOVCQ3ID0gVFlQRSQzNC5Db21tZW50O1xudmFyIEVYQ0xBTUFUSU9OTUFSSyQzID0gVFlQRSQzNC5FeGNsYW1hdGlvbk1hcms7XG52YXIgQVRSVUxFJDQgPSBUWVBFJDM0LkF0cnVsZTtcbnZhciBDRE8kMyA9IFRZUEUkMzQuQ0RPO1xudmFyIENEQyQzID0gVFlQRSQzNC5DREM7XG5cbmZ1bmN0aW9uIGNvbnN1bWVSYXckNShzdGFydFRva2VuKSB7XG4gICAgcmV0dXJuIHRoaXMuUmF3KHN0YXJ0VG9rZW4sIDAsIDAsIGZhbHNlLCBmYWxzZSk7XG59XG5cbnZhciBTdHlsZVNoZWV0ID0ge1xuICAgIG5hbWU6ICdTdHlsZVNoZWV0JyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgY2hpbGRyZW46IFtbJ0NvbW1lbnQnLCAnQXRydWxlJywgJ1J1bGUnLCAnUmF3J11dXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBuZXcgbGlzdCgpO1xuICAgICAgICB2YXIgY2hpbGQ7XG5cbiAgICAgICAgc2NhbjpcbiAgICAgICAgd2hpbGUgKCF0aGlzLnNjYW5uZXIuZW9mKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc2Nhbm5lci50b2tlblR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFdISVRFU1BBQ0UkNzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBjYXNlIENPTU1FTlQkNzpcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIGNvbW1lbnRzIGV4Y2VwdCBleGNsYW1hdGlvbiBjb21tZW50cyAoaS5lLiAvKiEgLi4gKi8pIG9uIHRvcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLnNvdXJjZS5jaGFyQ29kZUF0KHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0ICsgMikgIT09IEVYQ0xBTUFUSU9OTUFSSyQzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuQ29tbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgQ0RPJDM6IC8vIDwhLS1cbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLkNETygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgQ0RDJDM6IC8vIC0tPlxuICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IHRoaXMuQ0RDKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLy8gQ1NTIFN5bnRheCBNb2R1bGUgTGV2ZWwgM1xuICAgICAgICAgICAgICAgIC8vIMKnMi4yIEVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgLy8gQXQgdGhlIFwidG9wIGxldmVsXCIgb2YgYSBzdHlsZXNoZWV0LCBhbiA8YXQta2V5d29yZC10b2tlbj4gc3RhcnRzIGFuIGF0LXJ1bGUuXG4gICAgICAgICAgICAgICAgY2FzZSBBVFJVTEUkNDpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLkF0cnVsZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8vIEFueXRoaW5nIGVsc2Ugc3RhcnRzIGEgcXVhbGlmaWVkIHJ1bGUgLi4uXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLnRvbGVyYW50UGFyc2UodGhpcy5SdWxlLCBjb25zdW1lUmF3JDUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjaGlsZHJlbi5hcHBlbmREYXRhKGNoaWxkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnU3R5bGVTaGVldCcsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICB0aGlzLmVhY2gocHJvY2Vzc0NodW5rLCBub2RlKTtcbiAgICB9LFxuICAgIHdhbGtDb250ZXh0OiAnc3R5bGVzaGVldCdcbn07XG5cbnZhciBUWVBFJDM1ID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIElERU5USUZJRVIkMTggPSBUWVBFJDM1LklkZW50aWZpZXI7XG52YXIgQVNURVJJU0skNSA9IFRZUEUkMzUuQXN0ZXJpc2s7XG52YXIgVkVSVElDQUxMSU5FJDIgPSBUWVBFJDM1LlZlcnRpY2FsTGluZTtcblxuZnVuY3Rpb24gZWF0SWRlbnRpZmllck9yQXN0ZXJpc2soKSB7XG4gICAgaWYgKHRoaXMuc2Nhbm5lci50b2tlblR5cGUgIT09IElERU5USUZJRVIkMTggJiZcbiAgICAgICAgdGhpcy5zY2FubmVyLnRva2VuVHlwZSAhPT0gQVNURVJJU0skNSkge1xuICAgICAgICB0aGlzLnNjYW5uZXIuZXJyb3IoJ0lkZW50aWZpZXIgb3IgYXN0ZXJpc2sgaXMgZXhwZWN0ZWQnKTtcbiAgICB9XG5cbiAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xufVxuXG4vLyBpZGVudFxuLy8gaWRlbnR8aWRlbnRcbi8vIGlkZW50fCpcbi8vICpcbi8vICp8aWRlbnRcbi8vICp8KlxuLy8gfGlkZW50XG4vLyB8KlxudmFyIFR5cGVTZWxlY3RvciA9IHtcbiAgICBuYW1lOiAnVHlwZVNlbGVjdG9yJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgbmFtZTogU3RyaW5nXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0O1xuXG4gICAgICAgIGlmICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlID09PSBWRVJUSUNBTExJTkUkMikge1xuICAgICAgICAgICAgdGhpcy5zY2FubmVyLm5leHQoKTtcbiAgICAgICAgICAgIGVhdElkZW50aWZpZXJPckFzdGVyaXNrLmNhbGwodGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlYXRJZGVudGlmaWVyT3JBc3Rlcmlzay5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zY2FubmVyLnRva2VuVHlwZSA9PT0gVkVSVElDQUxMSU5FJDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgICAgIGVhdElkZW50aWZpZXJPckFzdGVyaXNrLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1R5cGVTZWxlY3RvcicsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIG5hbWU6IHRoaXMuc2Nhbm5lci5zdWJzdHJUb0N1cnNvcihzdGFydClcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmssIG5vZGUpIHtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUubmFtZSk7XG4gICAgfVxufTtcblxudmFyIGlzSGV4JDIgPSB0b2tlbml6ZXIkMS5pc0hleDtcbnZhciBUWVBFJDM2ID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIElERU5USUZJRVIkMTkgPSBUWVBFJDM2LklkZW50aWZpZXI7XG52YXIgTlVNQkVSJDExID0gVFlQRSQzNi5OdW1iZXI7XG52YXIgUExVU1NJR04kNyA9IFRZUEUkMzYuUGx1c1NpZ247XG52YXIgSFlQSEVOTUlOVVMkNyA9IFRZUEUkMzYuSHlwaGVuTWludXM7XG52YXIgRlVMTFNUT1AkNSA9IFRZUEUkMzYuRnVsbFN0b3A7XG52YXIgUVVFU1RJT05NQVJLID0gVFlQRSQzNi5RdWVzdGlvbk1hcms7XG5cbmZ1bmN0aW9uIHNjYW5Vbmljb2RlTnVtYmVyKHNjYW5uZXIpIHtcbiAgICBmb3IgKHZhciBwb3MgPSBzY2FubmVyLnRva2VuU3RhcnQgKyAxOyBwb3MgPCBzY2FubmVyLnRva2VuRW5kOyBwb3MrKykge1xuICAgICAgICB2YXIgY29kZSA9IHNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQocG9zKTtcblxuICAgICAgICAvLyBicmVhayBvbiBmdWxsc3RvcCBvciBoeXBlcm1pbnVzL3BsdXNzaWduIGFmdGVyIGV4cG9uZW50XG4gICAgICAgIGlmIChjb2RlID09PSBGVUxMU1RPUCQ1IHx8IGNvZGUgPT09IFBMVVNTSUdOJDcpIHtcbiAgICAgICAgICAgIC8vIGJyZWFrIHRva2VuLCBleGNsdWRlIHN5bWJvbFxuICAgICAgICAgICAgc2Nhbm5lci50b2tlblN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtc3ludGF4LTMvI3VyYW5nZVxuZnVuY3Rpb24gc2NhblVuaWNvZGVSYW5nZShzY2FubmVyKSB7XG4gICAgdmFyIGhleFN0YXJ0ID0gc2Nhbm5lci50b2tlblN0YXJ0ICsgMTsgLy8gc2tpcCArXG4gICAgdmFyIGhleExlbmd0aCA9IDA7XG5cbiAgICBzY2FuOiB7XG4gICAgICAgIGlmIChzY2FubmVyLnRva2VuVHlwZSA9PT0gTlVNQkVSJDExKSB7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdChzY2FubmVyLnRva2VuU3RhcnQpICE9PSBGVUxMU1RPUCQ1ICYmIHNjYW5Vbmljb2RlTnVtYmVyKHNjYW5uZXIpKSB7XG4gICAgICAgICAgICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNjYW5uZXIuc291cmNlLmNoYXJDb2RlQXQoc2Nhbm5lci50b2tlblN0YXJ0KSAhPT0gSFlQSEVOTUlOVVMkNykge1xuICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY2FubmVyLm5leHQoKTsgLy8gUExVU1NJR05cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzY2FubmVyLnRva2VuVHlwZSA9PT0gSFlQSEVOTUlOVVMkNykge1xuICAgICAgICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Nhbm5lci50b2tlblR5cGUgPT09IE5VTUJFUiQxMSkge1xuICAgICAgICAgICAgc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Nhbm5lci50b2tlblR5cGUgPT09IElERU5USUZJRVIkMTkpIHtcbiAgICAgICAgICAgIHNjYW5uZXIubmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNjYW5uZXIudG9rZW5TdGFydCA9PT0gaGV4U3RhcnQpIHtcbiAgICAgICAgICAgIHNjYW5uZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQnLCBoZXhTdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB2YWxpZGF0ZSBmb3IgVSt4ezEsNn0gb3IgVSt4ezEsNn0teHsxLDZ9XG4gICAgLy8gd2hlcmUgeCBpcyBbMC05YS1mQS1GXVxuICAgIGZvciAodmFyIGkgPSBoZXhTdGFydCwgd2FzSHlwaGVuTWludXMgPSBmYWxzZTsgaSA8IHNjYW5uZXIudG9rZW5TdGFydDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc2Nhbm5lci5zb3VyY2UuY2hhckNvZGVBdChpKTtcblxuICAgICAgICBpZiAoaXNIZXgkMihjb2RlKSA9PT0gZmFsc2UgJiYgKGNvZGUgIT09IEhZUEhFTk1JTlVTJDcgfHwgd2FzSHlwaGVuTWludXMpKSB7XG4gICAgICAgICAgICBzY2FubmVyLmVycm9yKCdVbmV4cGVjdGVkIGlucHV0JywgaSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29kZSA9PT0gSFlQSEVOTUlOVVMkNykge1xuICAgICAgICAgICAgLy8gaGV4IHNlcXVlbmNlIHNob3VsZG4ndCBiZSBhbiBlbXB0eVxuICAgICAgICAgICAgaWYgKGhleExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNjYW5uZXIuZXJyb3IoJ1VuZXhwZWN0ZWQgaW5wdXQnLCBpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2FzSHlwaGVuTWludXMgPSB0cnVlO1xuICAgICAgICAgICAgaGV4TGVuZ3RoID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhleExlbmd0aCsrO1xuXG4gICAgICAgICAgICAvLyB0b28gbG9uZyBoZXggc2VxdWVuY2VcbiAgICAgICAgICAgIGlmIChoZXhMZW5ndGggPiA2KSB7XG4gICAgICAgICAgICAgICAgc2Nhbm5lci5lcnJvcignVG9vIGxvbmcgaGV4IHNlcXVlbmNlJywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIC8vIGNoZWNrIHdlIGhhdmUgYSBub24temVybyBzZXF1ZW5jZVxuICAgIGlmIChoZXhMZW5ndGggPT09IDApIHtcbiAgICAgICAgc2Nhbm5lci5lcnJvcignVW5leHBlY3RlZCBpbnB1dCcsIGkgLSAxKTtcbiAgICB9XG5cbiAgICAvLyBVK2FiYz8/P1xuICAgIGlmICghd2FzSHlwaGVuTWludXMpIHtcbiAgICAgICAgLy8gY29uc3VtZSBhcyBtYW55IFUrMDAzRiBRVUVTVElPTiBNQVJLICg/KSBjb2RlIHBvaW50cyBhcyBwb3NzaWJsZVxuICAgICAgICBmb3IgKDsgaGV4TGVuZ3RoIDwgNiAmJiAhc2Nhbm5lci5lb2Y7IHNjYW5uZXIubmV4dCgpKSB7XG4gICAgICAgICAgICBpZiAoc2Nhbm5lci50b2tlblR5cGUgIT09IFFVRVNUSU9OTUFSSykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBoZXhMZW5ndGgrKztcbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIFVuaWNvZGVSYW5nZSA9IHtcbiAgICBuYW1lOiAnVW5pY29kZVJhbmdlJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgdmFsdWU6IFN0cmluZ1xuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIudG9rZW5TdGFydDtcblxuICAgICAgICB0aGlzLnNjYW5uZXIubmV4dCgpOyAvLyBVIG9yIHVcbiAgICAgICAgc2NhblVuaWNvZGVSYW5nZSh0aGlzLnNjYW5uZXIpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnVW5pY29kZVJhbmdlJyxcbiAgICAgICAgICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbihzdGFydCwgdGhpcy5zY2FubmVyLnRva2VuU3RhcnQpLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuc2Nhbm5lci5zdWJzdHJUb0N1cnNvcihzdGFydClcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmssIG5vZGUpIHtcbiAgICAgICAgcHJvY2Vzc0NodW5rKG5vZGUudmFsdWUpO1xuICAgIH1cbn07XG5cbnZhciBUWVBFJDM3ID0gdG9rZW5pemVyJDEuVFlQRTtcblxudmFyIFNUUklORyQ2ID0gVFlQRSQzNy5TdHJpbmc7XG52YXIgVVJMJDQgPSBUWVBFJDM3LlVybDtcbnZhciBSQVckMiA9IFRZUEUkMzcuUmF3O1xudmFyIFJJR0hUUEFSRU5USEVTSVMkNyA9IFRZUEUkMzcuUmlnaHRQYXJlbnRoZXNpcztcblxuLy8gdXJsICcoJyBTKiAoc3RyaW5nIHwgcmF3KSBTKiAnKSdcbnZhciBVcmwgPSB7XG4gICAgbmFtZTogJ1VybCcsXG4gICAgc3RydWN0dXJlOiB7XG4gICAgICAgIHZhbHVlOiBbJ1N0cmluZycsICdSYXcnXVxuICAgIH0sXG4gICAgcGFyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLnNjYW5uZXIudG9rZW5TdGFydDtcbiAgICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoVVJMJDQpO1xuICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLnNjYW5uZXIudG9rZW5UeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFNUUklORyQ2OlxuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBSQVckMjpcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuUmF3KHRoaXMuc2Nhbm5lci5jdXJyZW50VG9rZW4sIDAsIFJBVyQyLCB0cnVlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zY2FubmVyLmVycm9yKCdTdHJpbmcgb3IgUmF3IGlzIGV4cGVjdGVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoUklHSFRQQVJFTlRIRVNJUyQ3KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1VybCcsXG4gICAgICAgICAgICBsb2M6IHRoaXMuZ2V0TG9jYXRpb24oc3RhcnQsIHRoaXMuc2Nhbm5lci50b2tlblN0YXJ0KSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJ3VybCcpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJygnKTtcbiAgICAgICAgdGhpcy5nZW5lcmF0ZShwcm9jZXNzQ2h1bmssIG5vZGUudmFsdWUpO1xuICAgICAgICBwcm9jZXNzQ2h1bmsoJyknKTtcbiAgICB9XG59O1xuXG52YXIgZW5kc1dpdGgkMSA9IHRva2VuaXplciQxLmVuZHNXaXRoO1xudmFyIFRZUEUkMzggPSB0b2tlbml6ZXIkMS5UWVBFO1xuXG52YXIgV0hJVEVTUEFDRSQ4ID0gVFlQRSQzOC5XaGl0ZVNwYWNlO1xudmFyIENPTU1FTlQkOCA9IFRZUEUkMzguQ29tbWVudDtcbnZhciBGVU5DVElPTiQ2ID0gVFlQRSQzOC5GdW5jdGlvbjtcbnZhciBDT0xPTiQ3ID0gVFlQRSQzOC5Db2xvbjtcbnZhciBTRU1JQ09MT04kNiA9IFRZUEUkMzguU2VtaWNvbG9uO1xudmFyIEVYQ0xBTUFUSU9OTUFSSyQ0ID0gVFlQRSQzOC5FeGNsYW1hdGlvbk1hcms7XG5cbi8vICdwcm9naWQ6JyB3cyogJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LicgaWRlbnQgd3MqICcoJyAuKiAnKSdcbmZ1bmN0aW9uIGNoZWNrUHJvZ2lkKHNjYW5uZXIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGZvciAodmFyIHR5cGU7IHR5cGUgPSBzY2FubmVyLmxvb2t1cFR5cGUob2Zmc2V0KTsgb2Zmc2V0KyspIHtcbiAgICAgICAgaWYgKHR5cGUgIT09IFdISVRFU1BBQ0UkOCAmJiB0eXBlICE9PSBDT01NRU5UJDgpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNjYW5uZXIubG9va3VwVmFsdWUob2Zmc2V0LCAnYWxwaGEoJykgfHxcbiAgICAgICAgc2Nhbm5lci5sb29rdXBWYWx1ZShvZmZzZXQsICdjaHJvbWEoJykgfHxcbiAgICAgICAgc2Nhbm5lci5sb29rdXBWYWx1ZShvZmZzZXQsICdkcm9wc2hhZG93KCcpKSB7XG4gICAgICAgIGlmIChzY2FubmVyLmxvb2t1cFR5cGUob2Zmc2V0KSAhPT0gRlVOQ1RJT04kNikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHNjYW5uZXIubG9va3VwVmFsdWUob2Zmc2V0LCAncHJvZ2lkJykgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICBzY2FubmVyLmxvb2t1cFR5cGUob2Zmc2V0ICsgMSkgIT09IENPTE9OJDcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xufVxuXG52YXIgVmFsdWUgPSB7XG4gICAgbmFtZTogJ1ZhbHVlJyxcbiAgICBzdHJ1Y3R1cmU6IHtcbiAgICAgICAgY2hpbGRyZW46IFtbXV1cbiAgICB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbihwcm9wZXJ0eSkge1xuICAgICAgICAvLyBzcGVjaWFsIHBhcnNlciBmb3IgZmlsdGVyIHByb3BlcnR5IHNpbmNlIGl0IGNhbiBjb250YWlucyBub24tc3RhbmRhcnQgc3ludGF4IGZvciBvbGQgSUVcbiAgICAgICAgaWYgKHByb3BlcnR5ICE9PSBudWxsICYmIGVuZHNXaXRoJDEocHJvcGVydHksICdmaWx0ZXInKSAmJiBjaGVja1Byb2dpZCh0aGlzLnNjYW5uZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnNjYW5uZXIuc2tpcFNDKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5SYXcodGhpcy5zY2FubmVyLmN1cnJlbnRUb2tlbiwgRVhDTEFNQVRJT05NQVJLJDQsIFNFTUlDT0xPTiQ2LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5zY2FubmVyLnRva2VuU3RhcnQ7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucmVhZFNlcXVlbmNlKHRoaXMuc2NvcGUuVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnVmFsdWUnLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmdldExvY2F0aW9uKHN0YXJ0LCB0aGlzLnNjYW5uZXIudG9rZW5TdGFydCksXG4gICAgICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihwcm9jZXNzQ2h1bmssIG5vZGUpIHtcbiAgICAgICAgdGhpcy5lYWNoKHByb2Nlc3NDaHVuaywgbm9kZSk7XG4gICAgfVxufTtcblxudmFyIFdISVRFU1BBQ0UkOSA9IHRva2VuaXplciQxLlRZUEUuV2hpdGVTcGFjZTtcbnZhciBTUEFDRSQyID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgdHlwZTogJ1doaXRlU3BhY2UnLFxuICAgIGxvYzogbnVsbCxcbiAgICB2YWx1ZTogJyAnXG59KTtcblxudmFyIFdoaXRlU3BhY2UgPSB7XG4gICAgbmFtZTogJ1doaXRlU3BhY2UnLFxuICAgIHN0cnVjdHVyZToge1xuICAgICAgICB2YWx1ZTogU3RyaW5nXG4gICAgfSxcbiAgICBwYXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2Nhbm5lci5lYXQoV0hJVEVTUEFDRSQ5KTtcbiAgICAgICAgcmV0dXJuIFNQQUNFJDI7XG5cbiAgICAgICAgLy8gcmV0dXJuIHtcbiAgICAgICAgLy8gICAgIHR5cGU6ICdXaGl0ZVNwYWNlJyxcbiAgICAgICAgLy8gICAgIGxvYzogdGhpcy5nZXRMb2NhdGlvbih0aGlzLnNjYW5uZXIudG9rZW5TdGFydCwgdGhpcy5zY2FubmVyLnRva2VuRW5kKSxcbiAgICAgICAgLy8gICAgIHZhbHVlOiB0aGlzLnNjYW5uZXIuY29uc3VtZShXSElURVNQQUNFKVxuICAgICAgICAvLyB9O1xuICAgIH0sXG4gICAgZ2VuZXJhdGU6IGZ1bmN0aW9uKHByb2Nlc3NDaHVuaywgbm9kZSkge1xuICAgICAgICBwcm9jZXNzQ2h1bmsobm9kZS52YWx1ZSk7XG4gICAgfVxufTtcblxudmFyIG5vZGUgPSB7XG4gICAgQW5QbHVzQjogQW5QbHVzQixcbiAgICBBdHJ1bGU6IEF0cnVsZSxcbiAgICBBdHJ1bGVFeHByZXNzaW9uOiBBdHJ1bGVFeHByZXNzaW9uLFxuICAgIEF0dHJpYnV0ZVNlbGVjdG9yOiBBdHRyaWJ1dGVTZWxlY3RvcixcbiAgICBCbG9jazogQmxvY2ssXG4gICAgQnJhY2tldHM6IEJyYWNrZXRzLFxuICAgIENEQzogQ0RDXzEsXG4gICAgQ0RPOiBDRE9fMSxcbiAgICBDbGFzc1NlbGVjdG9yOiBDbGFzc1NlbGVjdG9yLFxuICAgIENvbWJpbmF0b3I6IENvbWJpbmF0b3IsXG4gICAgQ29tbWVudDogQ29tbWVudCxcbiAgICBEZWNsYXJhdGlvbjogRGVjbGFyYXRpb24sXG4gICAgRGVjbGFyYXRpb25MaXN0OiBEZWNsYXJhdGlvbkxpc3QsXG4gICAgRGltZW5zaW9uOiBEaW1lbnNpb24sXG4gICAgRnVuY3Rpb246IF9GdW5jdGlvbixcbiAgICBIZXhDb2xvcjogSGV4Q29sb3IsXG4gICAgSWRlbnRpZmllcjogSWRlbnRpZmllcixcbiAgICBJZFNlbGVjdG9yOiBJZFNlbGVjdG9yLFxuICAgIE1lZGlhRmVhdHVyZTogTWVkaWFGZWF0dXJlLFxuICAgIE1lZGlhUXVlcnk6IE1lZGlhUXVlcnksXG4gICAgTWVkaWFRdWVyeUxpc3Q6IE1lZGlhUXVlcnlMaXN0LFxuICAgIE50aDogTnRoLFxuICAgIE51bWJlcjogX051bWJlcixcbiAgICBPcGVyYXRvcjogT3BlcmF0b3IsXG4gICAgUGFyZW50aGVzZXM6IFBhcmVudGhlc2VzLFxuICAgIFBlcmNlbnRhZ2U6IFBlcmNlbnRhZ2UsXG4gICAgUHNldWRvQ2xhc3NTZWxlY3RvcjogUHNldWRvQ2xhc3NTZWxlY3RvcixcbiAgICBQc2V1ZG9FbGVtZW50U2VsZWN0b3I6IFBzZXVkb0VsZW1lbnRTZWxlY3RvcixcbiAgICBSYXRpbzogUmF0aW8sXG4gICAgUmF3OiBSYXcsXG4gICAgUnVsZTogUnVsZSxcbiAgICBTZWxlY3RvcjogU2VsZWN0b3IsXG4gICAgU2VsZWN0b3JMaXN0OiBTZWxlY3Rvckxpc3QsXG4gICAgU3RyaW5nOiBfU3RyaW5nLFxuICAgIFN0eWxlU2hlZXQ6IFN0eWxlU2hlZXQsXG4gICAgVHlwZVNlbGVjdG9yOiBUeXBlU2VsZWN0b3IsXG4gICAgVW5pY29kZVJhbmdlOiBVbmljb2RlUmFuZ2UsXG4gICAgVXJsOiBVcmwsXG4gICAgVmFsdWU6IFZhbHVlLFxuICAgIFdoaXRlU3BhY2U6IFdoaXRlU3BhY2Vcbn07XG5cbnZhciBwYXJzZXIkMSA9IHtcbiAgICBwYXJzZUNvbnRleHQ6IHtcbiAgICAgICAgZGVmYXVsdDogJ1N0eWxlU2hlZXQnLFxuICAgICAgICBzdHlsZXNoZWV0OiAnU3R5bGVTaGVldCcsXG4gICAgICAgIGF0cnVsZTogJ0F0cnVsZScsXG4gICAgICAgIGF0cnVsZUV4cHJlc3Npb246IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkF0cnVsZUV4cHJlc3Npb24ob3B0aW9ucy5hdHJ1bGUgPyBTdHJpbmcob3B0aW9ucy5hdHJ1bGUpIDogbnVsbCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lZGlhUXVlcnlMaXN0OiAnTWVkaWFRdWVyeUxpc3QnLFxuICAgICAgICBtZWRpYVF1ZXJ5OiAnTWVkaWFRdWVyeScsXG4gICAgICAgIHJ1bGU6ICdSdWxlJyxcbiAgICAgICAgc2VsZWN0b3JMaXN0OiAnU2VsZWN0b3JMaXN0JyxcbiAgICAgICAgc2VsZWN0b3I6ICdTZWxlY3RvcicsXG4gICAgICAgIGJsb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkJsb2NrKHRoaXMuRGVjbGFyYXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBkZWNsYXJhdGlvbkxpc3Q6ICdEZWNsYXJhdGlvbkxpc3QnLFxuICAgICAgICBkZWNsYXJhdGlvbjogJ0RlY2xhcmF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlZhbHVlKG9wdGlvbnMucHJvcGVydHkgPyBTdHJpbmcob3B0aW9ucy5wcm9wZXJ0eSkgOiBudWxsKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2NvcGU6IHNjb3BlLFxuICAgIGF0cnVsZTogYXRydWxlLFxuICAgIHBzZXVkbzogcHNldWRvLFxuICAgIG5vZGU6IG5vZGVcbn07XG5cbnZhciBwYXJzZXIgPSBjcmVhdGUkMShwYXJzZXIkMSk7XG5cbmZ1bmN0aW9uIHdhbGsgKCBhc3QsIHJlZikge1xuXHR2YXIgZW50ZXIgPSByZWYuZW50ZXI7XG5cdHZhciBsZWF2ZSA9IHJlZi5sZWF2ZTtcblxuXHR2aXNpdCggYXN0LCBudWxsLCBlbnRlciwgbGVhdmUgKTtcbn1cblxudmFyIHNob3VsZFNraXAgPSBmYWxzZTtcbnZhciBjb250ZXh0ID0geyBza2lwOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzaG91bGRTa2lwID0gdHJ1ZTsgfSB9O1xuXG52YXIgY2hpbGRLZXlzID0ge307XG5cbnZhciB0b1N0cmluZyQxID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gaXNBcnJheSQxICggdGhpbmcgKSB7XG5cdHJldHVybiB0b1N0cmluZyQxLmNhbGwoIHRoaW5nICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbmZ1bmN0aW9uIHZpc2l0ICggbm9kZSwgcGFyZW50LCBlbnRlciwgbGVhdmUsIHByb3AsIGluZGV4ICkge1xuXHRpZiAoICFub2RlICkgeyByZXR1cm47IH1cblxuXHRpZiAoIGVudGVyICkge1xuXHRcdHZhciBfc2hvdWxkU2tpcCA9IHNob3VsZFNraXA7XG5cdFx0c2hvdWxkU2tpcCA9IGZhbHNlO1xuXHRcdGVudGVyLmNhbGwoIGNvbnRleHQsIG5vZGUsIHBhcmVudCwgcHJvcCwgaW5kZXggKTtcblx0XHR2YXIgc2tpcHBlZCA9IHNob3VsZFNraXA7XG5cdFx0c2hvdWxkU2tpcCA9IF9zaG91bGRTa2lwO1xuXG5cdFx0aWYgKCBza2lwcGVkICkgeyByZXR1cm47IH1cblx0fVxuXG5cdHZhciBrZXlzID0gY2hpbGRLZXlzWyBub2RlLnR5cGUgXSB8fCAoXG5cdFx0Y2hpbGRLZXlzWyBub2RlLnR5cGUgXSA9IE9iamVjdC5rZXlzKCBub2RlICkuZmlsdGVyKCBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiB0eXBlb2Ygbm9kZVsga2V5IF0gPT09ICdvYmplY3QnOyB9IClcblx0KTtcblxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdHZhciB2YWx1ZSA9IG5vZGVbIGtleSBdO1xuXG5cdFx0aWYgKCBpc0FycmF5JDEoIHZhbHVlICkgKSB7XG5cdFx0XHRmb3IgKCB2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGogKz0gMSApIHtcblx0XHRcdFx0dmlzaXQoIHZhbHVlW2pdLCBub2RlLCBlbnRlciwgbGVhdmUsIGtleSwgaiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGVsc2UgaWYgKCB2YWx1ZSAmJiB2YWx1ZS50eXBlICkge1xuXHRcdFx0dmlzaXQoIHZhbHVlLCBub2RlLCBlbnRlciwgbGVhdmUsIGtleSwgbnVsbCApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggbGVhdmUgKSB7XG5cdFx0bGVhdmUoIG5vZGUsIHBhcmVudCwgcHJvcCwgaW5kZXggKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZWFkU3R5bGUocGFyc2VyJCQxLCBzdGFydCwgYXR0cmlidXRlcykge1xuICAgIHZhciBjb250ZW50U3RhcnQgPSBwYXJzZXIkJDEuaW5kZXg7XG4gICAgdmFyIHN0eWxlcyA9IHBhcnNlciQkMS5yZWFkVW50aWwoLzxcXC9zdHlsZT4vKTtcbiAgICB2YXIgY29udGVudEVuZCA9IHBhcnNlciQkMS5pbmRleDtcbiAgICB2YXIgYXN0O1xuICAgIHRyeSB7XG4gICAgICAgIGFzdCA9IHBhcnNlcihzdHlsZXMsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uczogdHJ1ZSxcbiAgICAgICAgICAgIG9mZnNldDogY29udGVudFN0YXJ0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChlcnIubmFtZSA9PT0gJ0Nzc1N5bnRheEVycm9yJykge1xuICAgICAgICAgICAgcGFyc2VyJCQxLmVycm9yKGVyci5tZXNzYWdlLCBlcnIub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3QgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGFzdCkpO1xuICAgIC8vIHRpZHkgdXAgQVNUXG4gICAgd2Fsayhhc3QsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyByZXBsYWNlIGByZWY6YWAgbm9kZXNcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdTZWxlY3RvcicpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYiA9IG5vZGUuY2hpbGRyZW5baSArIDFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWZTZWxlY3RvcihhLCBiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaSwgMiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSZWZTZWxlY3RvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGEubG9jLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IGIubG9jLmVuZC5vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogYi5uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmxvYykge1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhcnQgPSBub2RlLmxvYy5zdGFydC5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgbm9kZS5lbmQgPSBub2RlLmxvYy5lbmQub2Zmc2V0O1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLmxvYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHBhcnNlciQkMS5lYXQoJzwvc3R5bGU+JywgdHJ1ZSk7XG4gICAgdmFyIGVuZCA9IHBhcnNlciQkMS5pbmRleDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogZW5kLFxuICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxuICAgICAgICBjaGlsZHJlbjogYXN0LmNoaWxkcmVuLFxuICAgICAgICBjb250ZW50OiB7XG4gICAgICAgICAgICBzdGFydDogY29udGVudFN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBjb250ZW50RW5kLFxuICAgICAgICAgICAgc3R5bGVzOiBzdHlsZXNcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBpc1JlZlNlbGVjdG9yKGEsIGIpIHtcbiAgICBpZiAoIWIpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gKGEudHlwZSA9PT0gJ1R5cGVTZWxlY3RvcicgJiZcbiAgICAgICAgYS5uYW1lID09PSAncmVmJyAmJlxuICAgICAgICBiLnR5cGUgPT09ICdQc2V1ZG9DbGFzc1NlbGVjdG9yJyk7XG59XG5cbmZ1bmN0aW9uIHJlYWRFeHByZXNzaW9uJDEocGFyc2VyLCBzdGFydCwgcXVvdGVNYXJrKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgcGFyc2VyLnRlbXBsYXRlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFyc2VyLnRlbXBsYXRlW2ldO1xuICAgICAgICBpZiAocXVvdGVNYXJrKSB7XG4gICAgICAgICAgICBpZiAoY2hhciA9PT0gcXVvdGVNYXJrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyICs9IHF1b3RlTWFyaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gJ1xcXFwnICsgY2hhcjtcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0ciArPSBjaGFyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9cXHMvLnRlc3QoY2hhcikpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RyICs9IGNoYXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZUV4cHJlc3Npb25BdChyZXBlYXQoJyAnLCBzdGFydCkgKyBzdHIsIHN0YXJ0KTtcbiAgICBwYXJzZXIuaW5kZXggPSBleHByZXNzaW9uLmVuZDtcbiAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgaWYgKHF1b3RlTWFyaylcbiAgICAgICAgcGFyc2VyLmVhdChxdW90ZU1hcmssIHRydWUpO1xuICAgIHJldHVybiBleHByZXNzaW9uO1xufVxuZnVuY3Rpb24gcmVhZEV2ZW50SGFuZGxlckRpcmVjdGl2ZShwYXJzZXIsIHN0YXJ0LCBuYW1lLCBoYXNWYWx1ZSkge1xuICAgIHZhciBleHByZXNzaW9uO1xuICAgIGlmIChoYXNWYWx1ZSkge1xuICAgICAgICB2YXIgcXVvdGVNYXJrID0gcGFyc2VyLmVhdChcIidcIikgPyBcIidcIiA6IHBhcnNlci5lYXQoXCJcXFwiXCIpID8gXCJcXFwiXCIgOiBudWxsO1xuICAgICAgICB2YXIgZXhwcmVzc2lvblN0YXJ0ID0gcGFyc2VyLmluZGV4O1xuICAgICAgICBleHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb24kMShwYXJzZXIsIGV4cHJlc3Npb25TdGFydCwgcXVvdGVNYXJrKTtcbiAgICAgICAgaWYgKGV4cHJlc3Npb24udHlwZSAhPT0gJ0NhbGxFeHByZXNzaW9uJykge1xuICAgICAgICAgICAgcGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgY2FsbCBleHByZXNzaW9uXCIsIGV4cHJlc3Npb25TdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IHBhcnNlci5pbmRleCxcbiAgICAgICAgdHlwZTogJ0V2ZW50SGFuZGxlcicsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZEJpbmRpbmdEaXJlY3RpdmUocGFyc2VyLCBzdGFydCwgbmFtZSkge1xuICAgIHZhciB2YWx1ZTtcbiAgICBpZiAocGFyc2VyLmVhdCgnPScpKSB7XG4gICAgICAgIHZhciBxdW90ZU1hcmsgPSBwYXJzZXIuZWF0KFwiJ1wiKSA/IFwiJ1wiIDogcGFyc2VyLmVhdChcIlxcXCJcIikgPyBcIlxcXCJcIiA6IG51bGw7XG4gICAgICAgIHZhciBhID0gcGFyc2VyLmluZGV4O1xuICAgICAgICBpZiAocGFyc2VyLmVhdCgne3snKSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAnYm91bmQgdmFsdWVzIHNob3VsZCBub3QgYmUgd3JhcHBlZCc7XG4gICAgICAgICAgICB2YXIgYl8xID0gcGFyc2VyLnRlbXBsYXRlLmluZGV4T2YoJ319JywgYSk7XG4gICAgICAgICAgICBpZiAoYl8xICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZV8xID0gcGFyc2VyLnRlbXBsYXRlLnNsaWNlKHBhcnNlci5pbmRleCwgYl8xKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IFwiIFxcdTIwMTQgdXNlICdcIiArIHZhbHVlXzEgKyBcIicsIG5vdCAne3tcIiArIHZhbHVlXzEgKyBcIn19J1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VyLmVycm9yKG1lc3NhZ2UsIGEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrIHNvIHRoYXQgd2UgY2FuIGdpdmUgQWNvcm4gc29tZXRoaW5nIHBhcnNlYWJsZVxuICAgICAgICB2YXIgYiA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHF1b3RlTWFyaykge1xuICAgICAgICAgICAgYiA9IHBhcnNlci5pbmRleCA9IHBhcnNlci50ZW1wbGF0ZS5pbmRleE9mKHF1b3RlTWFyaywgcGFyc2VyLmluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5yZWFkVW50aWwoL1tcXHNcXHJcXG5cXC8+XS8pO1xuICAgICAgICAgICAgYiA9IHBhcnNlci5pbmRleDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc291cmNlID0gcmVwZWF0KCcgJywgYSkgKyBwYXJzZXIudGVtcGxhdGUuc2xpY2UoYSwgYik7XG4gICAgICAgIHZhbHVlID0gcGFyc2VFeHByZXNzaW9uQXQoc291cmNlLCBhKTtcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdJZGVudGlmaWVyJyAmJiB2YWx1ZS50eXBlICE9PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIkNhbm5vdCBiaW5kIHRvIHJ2YWx1ZVwiLCB2YWx1ZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICBpZiAocXVvdGVNYXJrKSB7XG4gICAgICAgICAgICBwYXJzZXIuZWF0KHF1b3RlTWFyaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHNob3J0aGFuZCDigJMgYmluZDpmb28gZXF1aXZhbGVudCB0byBiaW5kOmZvbz0nZm9vJ1xuICAgICAgICB2YWx1ZSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCArIDUsXG4gICAgICAgICAgICBlbmQ6IHBhcnNlci5pbmRleCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IHBhcnNlci5pbmRleCxcbiAgICAgICAgdHlwZTogJ0JpbmRpbmcnLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVhZFRyYW5zaXRpb25EaXJlY3RpdmUocGFyc2VyLCBzdGFydCwgbmFtZSwgdHlwZSkge1xuICAgIHZhciBleHByZXNzaW9uID0gbnVsbDtcbiAgICBpZiAocGFyc2VyLmVhdCgnPScpKSB7XG4gICAgICAgIHZhciBxdW90ZU1hcmsgPSBwYXJzZXIuZWF0KFwiJ1wiKSA/IFwiJ1wiIDogcGFyc2VyLmVhdChcIlxcXCJcIikgPyBcIlxcXCJcIiA6IG51bGw7XG4gICAgICAgIHZhciBleHByZXNzaW9uU3RhcnQgPSBwYXJzZXIuaW5kZXg7XG4gICAgICAgIGV4cHJlc3Npb24gPSByZWFkRXhwcmVzc2lvbiQxKHBhcnNlciwgZXhwcmVzc2lvblN0YXJ0LCBxdW90ZU1hcmspO1xuICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlICE9PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIG9iamVjdCBleHByZXNzaW9uXCIsIGV4cHJlc3Npb25TdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IHBhcnNlci5pbmRleCxcbiAgICAgICAgdHlwZTogJ1RyYW5zaXRpb24nLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBpbnRybzogdHlwZSA9PT0gJ2luJyB8fCB0eXBlID09PSAndHJhbnNpdGlvbicsXG4gICAgICAgIG91dHJvOiB0eXBlID09PSAnb3V0JyB8fCB0eXBlID09PSAndHJhbnNpdGlvbicsXG4gICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICB9O1xufVxuXG4vLyBodHRwczovL2Rldi53My5vcmcvaHRtbDUvaHRtbC1hdXRob3IvY2hhcnJlZlxudmFyIGh0bWxFbnRpdGllcyA9IHtcbiAgICBDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsOiA4NzU1LFxuICAgIENsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbDogODc1NCxcbiAgICBEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3c6IDEwMjM0LFxuICAgIERpYWNyaXRpY2FsRG91YmxlQWN1dGU6IDczMyxcbiAgICBOb3RTcXVhcmVTdXBlcnNldEVxdWFsOiA4OTMxLFxuICAgIENsb3NlQ3VybHlEb3VibGVRdW90ZTogODIyMSxcbiAgICBEb3VibGVDb250b3VySW50ZWdyYWw6IDg3NTEsXG4gICAgRmlsbGVkVmVyeVNtYWxsU3F1YXJlOiA5NjQyLFxuICAgIE5lZ2F0aXZlVmVyeVRoaW5TcGFjZTogODIwMyxcbiAgICBOb3RQcmVjZWRlc1NsYW50RXF1YWw6IDg5MjgsXG4gICAgTm90UmlnaHRUcmlhbmdsZUVxdWFsOiA4OTQxLFxuICAgIE5vdFN1Y2NlZWRzU2xhbnRFcXVhbDogODkyOSxcbiAgICBDYXBpdGFsRGlmZmVyZW50aWFsRDogODUxNyxcbiAgICBEb3VibGVMZWZ0UmlnaHRBcnJvdzogODY2MCxcbiAgICBEb3VibGVMb25nUmlnaHRBcnJvdzogMTAyMzMsXG4gICAgRW1wdHlWZXJ5U21hbGxTcXVhcmU6IDk2NDMsXG4gICAgTmVzdGVkR3JlYXRlckdyZWF0ZXI6IDg4MTEsXG4gICAgTm90RG91YmxlVmVydGljYWxCYXI6IDg3NDIsXG4gICAgTm90TGVmdFRyaWFuZ2xlRXF1YWw6IDg5NDAsXG4gICAgTm90U3F1YXJlU3Vic2V0RXF1YWw6IDg5MzAsXG4gICAgT3BlbkN1cmx5RG91YmxlUXVvdGU6IDgyMjAsXG4gICAgUmV2ZXJzZVVwRXF1aWxpYnJpdW06IDEwNjA3LFxuICAgIERvdWJsZUxvbmdMZWZ0QXJyb3c6IDEwMjMyLFxuICAgIERvd25MZWZ0UmlnaHRWZWN0b3I6IDEwNTc2LFxuICAgIExlZnRBcnJvd1JpZ2h0QXJyb3c6IDg2NDYsXG4gICAgTmVnYXRpdmVNZWRpdW1TcGFjZTogODIwMyxcbiAgICBSaWdodEFycm93TGVmdEFycm93OiA4NjQ0LFxuICAgIFNxdWFyZVN1cGVyc2V0RXF1YWw6IDg4NTAsXG4gICAgbGVmdHJpZ2h0c3F1aWdhcnJvdzogODYyMSxcbiAgICBEb3duUmlnaHRUZWVWZWN0b3I6IDEwNTkxLFxuICAgIERvd25SaWdodFZlY3RvckJhcjogMTA1ODMsXG4gICAgTG9uZ0xlZnRSaWdodEFycm93OiAxMDIzMSxcbiAgICBMb25nbGVmdHJpZ2h0YXJyb3c6IDEwMjM0LFxuICAgIE5lZ2F0aXZlVGhpY2tTcGFjZTogODIwMyxcbiAgICBQcmVjZWRlc1NsYW50RXF1YWw6IDg4MjgsXG4gICAgUmV2ZXJzZUVxdWlsaWJyaXVtOiA4NjUxLFxuICAgIFJpZ2h0RG91YmxlQnJhY2tldDogMTAyMTUsXG4gICAgUmlnaHREb3duVGVlVmVjdG9yOiAxMDU4OSxcbiAgICBSaWdodERvd25WZWN0b3JCYXI6IDEwNTgxLFxuICAgIFJpZ2h0VHJpYW5nbGVFcXVhbDogODg4NSxcbiAgICBTcXVhcmVJbnRlcnNlY3Rpb246IDg4NTEsXG4gICAgU3VjY2VlZHNTbGFudEVxdWFsOiA4ODI5LFxuICAgIGJsYWNrdHJpYW5nbGVyaWdodDogOTY1NixcbiAgICBsb25nbGVmdHJpZ2h0YXJyb3c6IDEwMjMxLFxuICAgIERvdWJsZVVwRG93bkFycm93OiA4NjYxLFxuICAgIERvdWJsZVZlcnRpY2FsQmFyOiA4NzQxLFxuICAgIERvd25MZWZ0VGVlVmVjdG9yOiAxMDU5MCxcbiAgICBEb3duTGVmdFZlY3RvckJhcjogMTA1ODIsXG4gICAgRmlsbGVkU21hbGxTcXVhcmU6IDk3MjQsXG4gICAgR3JlYXRlclNsYW50RXF1YWw6IDEwODc4LFxuICAgIExlZnREb3VibGVCcmFja2V0OiAxMDIxNCxcbiAgICBMZWZ0RG93blRlZVZlY3RvcjogMTA1OTMsXG4gICAgTGVmdERvd25WZWN0b3JCYXI6IDEwNTg1LFxuICAgIExlZnRUcmlhbmdsZUVxdWFsOiA4ODg0LFxuICAgIE5lZ2F0aXZlVGhpblNwYWNlOiA4MjAzLFxuICAgIE5vdFJldmVyc2VFbGVtZW50OiA4NzE2LFxuICAgIE5vdFRpbGRlRnVsbEVxdWFsOiA4Nzc1LFxuICAgIFJpZ2h0QW5nbGVCcmFja2V0OiAxMDIxNyxcbiAgICBSaWdodFVwRG93blZlY3RvcjogMTA1NzUsXG4gICAgU3F1YXJlU3Vic2V0RXF1YWw6IDg4NDksXG4gICAgVmVydGljYWxTZXBhcmF0b3I6IDEwMDcyLFxuICAgIGJsYWNrdHJpYW5nbGVkb3duOiA5NjYyLFxuICAgIGJsYWNrdHJpYW5nbGVsZWZ0OiA5NjY2LFxuICAgIGxlZnRyaWdodGhhcnBvb25zOiA4NjUxLFxuICAgIHJpZ2h0bGVmdGhhcnBvb25zOiA4NjUyLFxuICAgIHR3b2hlYWRyaWdodGFycm93OiA4NjA4LFxuICAgIERpYWNyaXRpY2FsQWN1dGU6IDE4MCxcbiAgICBEaWFjcml0aWNhbEdyYXZlOiA5NixcbiAgICBEaWFjcml0aWNhbFRpbGRlOiA3MzIsXG4gICAgRG91YmxlUmlnaHRBcnJvdzogODY1OCxcbiAgICBEb3duQXJyb3dVcEFycm93OiA4NjkzLFxuICAgIEVtcHR5U21hbGxTcXVhcmU6IDk3MjMsXG4gICAgR3JlYXRlckVxdWFsTGVzczogODkyMyxcbiAgICBHcmVhdGVyRnVsbEVxdWFsOiA4ODA3LFxuICAgIExlZnRBbmdsZUJyYWNrZXQ6IDEwMjE2LFxuICAgIExlZnRVcERvd25WZWN0b3I6IDEwNTc3LFxuICAgIExlc3NFcXVhbEdyZWF0ZXI6IDg5MjIsXG4gICAgTm9uQnJlYWtpbmdTcGFjZTogMTYwLFxuICAgIE5vdFJpZ2h0VHJpYW5nbGU6IDg5MzksXG4gICAgTm90U3VwZXJzZXRFcXVhbDogODg0MSxcbiAgICBSaWdodFRyaWFuZ2xlQmFyOiAxMDcwNCxcbiAgICBSaWdodFVwVGVlVmVjdG9yOiAxMDU4OCxcbiAgICBSaWdodFVwVmVjdG9yQmFyOiAxMDU4MCxcbiAgICBVbmRlclBhcmVudGhlc2lzOiA5MTgxLFxuICAgIFVwQXJyb3dEb3duQXJyb3c6IDg2NDUsXG4gICAgY2lyY2xlYXJyb3dyaWdodDogODYzNSxcbiAgICBkb3duaGFycG9vbnJpZ2h0OiA4NjQyLFxuICAgIG50cmlhbmdsZXJpZ2h0ZXE6IDg5NDEsXG4gICAgcmlnaHRoYXJwb29uZG93bjogODY0MSxcbiAgICByaWdodHJpZ2h0YXJyb3dzOiA4NjQ5LFxuICAgIHR3b2hlYWRsZWZ0YXJyb3c6IDg2MDYsXG4gICAgdmFydHJpYW5nbGVyaWdodDogODg4MyxcbiAgICBDbG9zZUN1cmx5UXVvdGU6IDgyMTcsXG4gICAgQ29udG91ckludGVncmFsOiA4NzUwLFxuICAgIERvdWJsZURvd25BcnJvdzogODY1OSxcbiAgICBEb3VibGVMZWZ0QXJyb3c6IDg2NTYsXG4gICAgRG93blJpZ2h0VmVjdG9yOiA4NjQxLFxuICAgIExlZnRSaWdodFZlY3RvcjogMTA1NzQsXG4gICAgTGVmdFRyaWFuZ2xlQmFyOiAxMDcwMyxcbiAgICBMZWZ0VXBUZWVWZWN0b3I6IDEwNTkyLFxuICAgIExlZnRVcFZlY3RvckJhcjogMTA1ODQsXG4gICAgTG93ZXJSaWdodEFycm93OiA4NjAwLFxuICAgIE5vdEdyZWF0ZXJFcXVhbDogODgxNyxcbiAgICBOb3RHcmVhdGVyVGlsZGU6IDg4MjEsXG4gICAgTm90TGVmdFRyaWFuZ2xlOiA4OTM4LFxuICAgIE92ZXJQYXJlbnRoZXNpczogOTE4MCxcbiAgICBSaWdodERvd25WZWN0b3I6IDg2NDIsXG4gICAgU2hvcnRSaWdodEFycm93OiA4NTk0LFxuICAgIFVwcGVyUmlnaHRBcnJvdzogODU5OSxcbiAgICBiaWd0cmlhbmdsZWRvd246IDk2NjEsXG4gICAgY2lyY2xlYXJyb3dsZWZ0OiA4NjM0LFxuICAgIGN1cnZlYXJyb3dyaWdodDogODYzMSxcbiAgICBkb3duaGFycG9vbmxlZnQ6IDg2NDMsXG4gICAgbGVmdGhhcnBvb25kb3duOiA4NjM3LFxuICAgIGxlZnRyaWdodGFycm93czogODY0NixcbiAgICBuTGVmdHJpZ2h0YXJyb3c6IDg2NTQsXG4gICAgbmxlZnRyaWdodGFycm93OiA4NjIyLFxuICAgIG50cmlhbmdsZWxlZnRlcTogODk0MCxcbiAgICByaWdodGxlZnRhcnJvd3M6IDg2NDQsXG4gICAgcmlnaHRzcXVpZ2Fycm93OiA4NjA1LFxuICAgIHJpZ2h0dGhyZWV0aW1lczogODkwOCxcbiAgICBzdHJhaWdodGVwc2lsb246IDEwMTMsXG4gICAgdHJpYW5nbGVyaWdodGVxOiA4ODg1LFxuICAgIHZhcnRyaWFuZ2xlbGVmdDogODg4MixcbiAgICBEaWFjcml0aWNhbERvdDogNzI5LFxuICAgIERvdWJsZVJpZ2h0VGVlOiA4ODcyLFxuICAgIERvd25MZWZ0VmVjdG9yOiA4NjM3LFxuICAgIEdyZWF0ZXJHcmVhdGVyOiAxMDkxNCxcbiAgICBIb3Jpem9udGFsTGluZTogOTQ3MixcbiAgICBJbnZpc2libGVDb21tYTogODI5MSxcbiAgICBJbnZpc2libGVUaW1lczogODI5MCxcbiAgICBMZWZ0RG93blZlY3RvcjogODY0MyxcbiAgICBMZWZ0UmlnaHRBcnJvdzogODU5NixcbiAgICBMZWZ0cmlnaHRhcnJvdzogODY2MCxcbiAgICBMZXNzU2xhbnRFcXVhbDogMTA4NzcsXG4gICAgTG9uZ1JpZ2h0QXJyb3c6IDEwMjMwLFxuICAgIExvbmdyaWdodGFycm93OiAxMDIzMyxcbiAgICBMb3dlckxlZnRBcnJvdzogODYwMSxcbiAgICBOZXN0ZWRMZXNzTGVzczogODgxMCxcbiAgICBOb3RHcmVhdGVyTGVzczogODgyNSxcbiAgICBOb3RMZXNzR3JlYXRlcjogODgyNCxcbiAgICBOb3RTdWJzZXRFcXVhbDogODg0MCxcbiAgICBOb3RWZXJ0aWNhbEJhcjogODc0MCxcbiAgICBPcGVuQ3VybHlRdW90ZTogODIxNixcbiAgICBSZXZlcnNlRWxlbWVudDogODcxNSxcbiAgICBSaWdodFRlZVZlY3RvcjogMTA1ODcsXG4gICAgUmlnaHRWZWN0b3JCYXI6IDEwNTc5LFxuICAgIFNob3J0RG93bkFycm93OiA4NTk1LFxuICAgIFNob3J0TGVmdEFycm93OiA4NTkyLFxuICAgIFNxdWFyZVN1cGVyc2V0OiA4ODQ4LFxuICAgIFRpbGRlRnVsbEVxdWFsOiA4NzczLFxuICAgIFVwcGVyTGVmdEFycm93OiA4NTk4LFxuICAgIFplcm9XaWR0aFNwYWNlOiA4MjAzLFxuICAgIGN1cnZlYXJyb3dsZWZ0OiA4NjMwLFxuICAgIGRvdWJsZWJhcndlZGdlOiA4OTY2LFxuICAgIGRvd25kb3duYXJyb3dzOiA4NjUwLFxuICAgIGhvb2tyaWdodGFycm93OiA4NjE4LFxuICAgIGxlZnRsZWZ0YXJyb3dzOiA4NjQ3LFxuICAgIGxlZnRyaWdodGFycm93OiA4NTk2LFxuICAgIGxlZnR0aHJlZXRpbWVzOiA4OTA3LFxuICAgIGxvbmdyaWdodGFycm93OiAxMDIzMCxcbiAgICBsb29wYXJyb3dyaWdodDogODYyMCxcbiAgICBuc2hvcnRwYXJhbGxlbDogODc0MixcbiAgICBudHJpYW5nbGVyaWdodDogODkzOSxcbiAgICByaWdodGFycm93dGFpbDogODYxMSxcbiAgICByaWdodGhhcnBvb251cDogODY0MCxcbiAgICB0cmlhbmdsZWxlZnRlcTogODg4NCxcbiAgICB1cGhhcnBvb25yaWdodDogODYzOCxcbiAgICBBcHBseUZ1bmN0aW9uOiA4Mjg5LFxuICAgIERpZmZlcmVudGlhbEQ6IDg1MTgsXG4gICAgRG91YmxlTGVmdFRlZTogMTA5ODAsXG4gICAgRG91YmxlVXBBcnJvdzogODY1NyxcbiAgICBMZWZ0VGVlVmVjdG9yOiAxMDU4NixcbiAgICBMZWZ0VmVjdG9yQmFyOiAxMDU3OCxcbiAgICBMZXNzRnVsbEVxdWFsOiA4ODA2LFxuICAgIExvbmdMZWZ0QXJyb3c6IDEwMjI5LFxuICAgIExvbmdsZWZ0YXJyb3c6IDEwMjMyLFxuICAgIE5vdFRpbGRlRXF1YWw6IDg3NzIsXG4gICAgTm90VGlsZGVUaWxkZTogODc3NyxcbiAgICBQb2luY2FyZXBsYW5lOiA4NDYwLFxuICAgIFByZWNlZGVzRXF1YWw6IDEwOTI3LFxuICAgIFByZWNlZGVzVGlsZGU6IDg4MzAsXG4gICAgUmlnaHRBcnJvd0JhcjogODY3NyxcbiAgICBSaWdodFRlZUFycm93OiA4NjE0LFxuICAgIFJpZ2h0VHJpYW5nbGU6IDg4ODMsXG4gICAgUmlnaHRVcFZlY3RvcjogODYzOCxcbiAgICBTdWNjZWVkc0VxdWFsOiAxMDkyOCxcbiAgICBTdWNjZWVkc1RpbGRlOiA4ODMxLFxuICAgIFN1cGVyc2V0RXF1YWw6IDg4MzksXG4gICAgVXBFcXVpbGlicml1bTogMTA2MDYsXG4gICAgVmVydGljYWxUaWxkZTogODc2OCxcbiAgICBWZXJ5VGhpblNwYWNlOiA4MjAyLFxuICAgIGJpZ3RyaWFuZ2xldXA6IDk2NTEsXG4gICAgYmxhY2t0cmlhbmdsZTogOTY1MixcbiAgICBkaXZpZGVvbnRpbWVzOiA4OTAzLFxuICAgIGZhbGxpbmdkb3RzZXE6IDg3ODYsXG4gICAgaG9va2xlZnRhcnJvdzogODYxNyxcbiAgICBsZWZ0YXJyb3d0YWlsOiA4NjEwLFxuICAgIGxlZnRoYXJwb29udXA6IDg2MzYsXG4gICAgbG9uZ2xlZnRhcnJvdzogMTAyMjksXG4gICAgbG9vcGFycm93bGVmdDogODYxOSxcbiAgICBtZWFzdXJlZGFuZ2xlOiA4NzM3LFxuICAgIG50cmlhbmdsZWxlZnQ6IDg5MzgsXG4gICAgc2hvcnRwYXJhbGxlbDogODc0MSxcbiAgICBzbWFsbHNldG1pbnVzOiA4NzI2LFxuICAgIHRyaWFuZ2xlcmlnaHQ6IDk2NTcsXG4gICAgdXBoYXJwb29ubGVmdDogODYzOSxcbiAgICBEb3duQXJyb3dCYXI6IDEwNTE1LFxuICAgIERvd25UZWVBcnJvdzogODYxNSxcbiAgICBFeHBvbmVudGlhbEU6IDg1MTksXG4gICAgR3JlYXRlckVxdWFsOiA4ODA1LFxuICAgIEdyZWF0ZXJUaWxkZTogODgxOSxcbiAgICBIaWxiZXJ0U3BhY2U6IDg0NTksXG4gICAgSHVtcERvd25IdW1wOiA4NzgyLFxuICAgIEludGVyc2VjdGlvbjogODg5OCxcbiAgICBMZWZ0QXJyb3dCYXI6IDg2NzYsXG4gICAgTGVmdFRlZUFycm93OiA4NjEyLFxuICAgIExlZnRUcmlhbmdsZTogODg4MixcbiAgICBMZWZ0VXBWZWN0b3I6IDg2MzksXG4gICAgTm90Q29uZ3J1ZW50OiA4ODAyLFxuICAgIE5vdExlc3NFcXVhbDogODgxNixcbiAgICBOb3RMZXNzVGlsZGU6IDg4MjAsXG4gICAgUHJvcG9ydGlvbmFsOiA4NzMzLFxuICAgIFJpZ2h0Q2VpbGluZzogODk2OSxcbiAgICBSb3VuZEltcGxpZXM6IDEwNjA4LFxuICAgIFNob3J0VXBBcnJvdzogODU5MyxcbiAgICBTcXVhcmVTdWJzZXQ6IDg4NDcsXG4gICAgVW5kZXJCcmFja2V0OiA5MTQxLFxuICAgIFZlcnRpY2FsTGluZTogMTI0LFxuICAgIGJsYWNrbG96ZW5nZTogMTA3MzEsXG4gICAgZXhwb25lbnRpYWxlOiA4NTE5LFxuICAgIHJpc2luZ2RvdHNlcTogODc4NyxcbiAgICB0cmlhbmdsZWRvd246IDk2NjMsXG4gICAgdHJpYW5nbGVsZWZ0OiA5NjY3LFxuICAgIENpcmNsZU1pbnVzOiA4ODU0LFxuICAgIENpcmNsZVRpbWVzOiA4ODU1LFxuICAgIEVxdWlsaWJyaXVtOiA4NjUyLFxuICAgIEdyZWF0ZXJMZXNzOiA4ODIzLFxuICAgIExlZnRDZWlsaW5nOiA4OTY4LFxuICAgIExlc3NHcmVhdGVyOiA4ODIyLFxuICAgIE1lZGl1bVNwYWNlOiA4Mjg3LFxuICAgIE5vdFByZWNlZGVzOiA4ODMyLFxuICAgIE5vdFN1Y2NlZWRzOiA4ODMzLFxuICAgIE92ZXJCcmFja2V0OiA5MTQwLFxuICAgIFJpZ2h0VmVjdG9yOiA4NjQwLFxuICAgIFJyaWdodGFycm93OiA4NjY3LFxuICAgIFJ1bGVEZWxheWVkOiAxMDc0MCxcbiAgICBTbWFsbENpcmNsZTogODcyOCxcbiAgICBTcXVhcmVVbmlvbjogODg1MixcbiAgICBTdWJzZXRFcXVhbDogODgzOCxcbiAgICBVcERvd25BcnJvdzogODU5NyxcbiAgICBVcGRvd25hcnJvdzogODY2MSxcbiAgICBWZXJ0aWNhbEJhcjogODczOSxcbiAgICBiYWNrZXBzaWxvbjogMTAxNCxcbiAgICBibGFja3NxdWFyZTogOTY0MixcbiAgICBjaXJjbGVkY2lyYzogODg1OCxcbiAgICBjaXJjbGVkZGFzaDogODg2MSxcbiAgICBjdXJseWVxcHJlYzogODkyNixcbiAgICBjdXJseWVxc3VjYzogODkyNyxcbiAgICBkaWFtb25kc3VpdDogOTgzMCxcbiAgICBlcXNsYW50bGVzczogMTA5MDEsXG4gICAgZXhwZWN0YXRpb246IDg0OTYsXG4gICAgblJpZ2h0YXJyb3c6IDg2NTUsXG4gICAgbnJpZ2h0YXJyb3c6IDg2MDMsXG4gICAgcHJlY2N1cmx5ZXE6IDg4MjgsXG4gICAgcHJlY25hcHByb3g6IDEwOTM3LFxuICAgIHF1YXRlcm5pb25zOiA4NDYxLFxuICAgIHN0cmFpZ2h0cGhpOiA5ODEsXG4gICAgc3VjY2N1cmx5ZXE6IDg4MjksXG4gICAgc3VjY25hcHByb3g6IDEwOTM4LFxuICAgIHRoaWNrYXBwcm94OiA4Nzc2LFxuICAgIHVwZG93bmFycm93OiA4NTk3LFxuICAgIEJlcm5vdWxsaXM6IDg0OTIsXG4gICAgQ2lyY2xlUGx1czogODg1MyxcbiAgICBFcXVhbFRpbGRlOiA4NzcwLFxuICAgIEZvdXJpZXJ0cmY6IDg0OTcsXG4gICAgSW1hZ2luYXJ5STogODUyMCxcbiAgICBMYXBsYWNldHJmOiA4NDY2LFxuICAgIExlZnRWZWN0b3I6IDg2MzYsXG4gICAgTGxlZnRhcnJvdzogODY2NixcbiAgICBOb3RFbGVtZW50OiA4NzEzLFxuICAgIE5vdEdyZWF0ZXI6IDg4MTUsXG4gICAgUHJvcG9ydGlvbjogODc1OSxcbiAgICBSaWdodEFycm93OiA4NTk0LFxuICAgIFJpZ2h0Rmxvb3I6IDg5NzEsXG4gICAgUmlnaHRhcnJvdzogODY1OCxcbiAgICBUaWxkZUVxdWFsOiA4NzcxLFxuICAgIFRpbGRlVGlsZGU6IDg3NzYsXG4gICAgVW5kZXJCcmFjZTogOTE4MyxcbiAgICBVcEFycm93QmFyOiAxMDUxNCxcbiAgICBVcFRlZUFycm93OiA4NjEzLFxuICAgIGNpcmNsZWRhc3Q6IDg4NTksXG4gICAgY29tcGxlbWVudDogODcwNSxcbiAgICBjdXJseXdlZGdlOiA4OTExLFxuICAgIGVxc2xhbnRndHI6IDEwOTAyLFxuICAgIGd0cmVxcWxlc3M6IDEwODkyLFxuICAgIGxlc3NhcHByb3g6IDEwODg1LFxuICAgIGxlc3NlcXFndHI6IDEwODkxLFxuICAgIGxtb3VzdGFjaGU6IDkxMzYsXG4gICAgbG9uZ21hcHN0bzogMTAyMzYsXG4gICAgbWFwc3RvZG93bjogODYxNSxcbiAgICBtYXBzdG9sZWZ0OiA4NjEyLFxuICAgIG5MZWZ0YXJyb3c6IDg2NTMsXG4gICAgbmxlZnRhcnJvdzogODYwMixcbiAgICBwcmVjYXBwcm94OiAxMDkzNSxcbiAgICByaWdodGFycm93OiA4NTk0LFxuICAgIHJtb3VzdGFjaGU6IDkxMzcsXG4gICAgc3FzdWJzZXRlcTogODg0OSxcbiAgICBzcXN1cHNldGVxOiA4ODUwLFxuICAgIHN1YnNldG5lcXE6IDEwOTU1LFxuICAgIHN1Y2NhcHByb3g6IDEwOTM2LFxuICAgIHN1cHNldG5lcXE6IDEwOTU2LFxuICAgIHVwdXBhcnJvd3M6IDg2NDgsXG4gICAgdmFyZXBzaWxvbjogOTQ5LFxuICAgIHZhcm5vdGhpbmc6IDg3MDksXG4gICAgQmFja3NsYXNoOiA4NzI2LFxuICAgIENlbnRlckRvdDogMTgzLFxuICAgIENpcmNsZURvdDogODg1NyxcbiAgICBDb25ncnVlbnQ6IDg4MDEsXG4gICAgQ29wcm9kdWN0OiA4NzIwLFxuICAgIERvdWJsZURvdDogMTY4LFxuICAgIERvd25BcnJvdzogODU5NSxcbiAgICBEb3duQnJldmU6IDc4NSxcbiAgICBEb3duYXJyb3c6IDg2NTksXG4gICAgSHVtcEVxdWFsOiA4NzgzLFxuICAgIExlZnRBcnJvdzogODU5MixcbiAgICBMZWZ0Rmxvb3I6IDg5NzAsXG4gICAgTGVmdGFycm93OiA4NjU2LFxuICAgIExlc3NUaWxkZTogODgxOCxcbiAgICBNZWxsaW50cmY6IDg0OTksXG4gICAgTWludXNQbHVzOiA4NzIzLFxuICAgIE5vdEN1cENhcDogODgxMyxcbiAgICBOb3RFeGlzdHM6IDg3MDgsXG4gICAgT3ZlckJyYWNlOiA5MTgyLFxuICAgIFBsdXNNaW51czogMTc3LFxuICAgIFRoZXJlZm9yZTogODc1NixcbiAgICBUaGluU3BhY2U6IDgyMDEsXG4gICAgVHJpcGxlRG90OiA4NDExLFxuICAgIFVuaW9uUGx1czogODg0NixcbiAgICBiYWNrcHJpbWU6IDgyNDUsXG4gICAgYmFja3NpbWVxOiA4OTA5LFxuICAgIGJpZ290aW1lczogMTA3NTQsXG4gICAgY2VudGVyZG90OiAxODMsXG4gICAgY2hlY2ttYXJrOiAxMDAwMyxcbiAgICBjb21wbGV4ZXM6IDg0NTAsXG4gICAgZG90c3F1YXJlOiA4ODY1LFxuICAgIGRvd25hcnJvdzogODU5NSxcbiAgICBndHJhcHByb3g6IDEwODg2LFxuICAgIGd0cmVxbGVzczogODkyMyxcbiAgICBoZWFydHN1aXQ6IDk4MjksXG4gICAgbGVmdGFycm93OiA4NTkyLFxuICAgIGxlc3NlcWd0cjogODkyMixcbiAgICBucGFyYWxsZWw6IDg3NDIsXG4gICAgbnNob3J0bWlkOiA4NzQwLFxuICAgIG5zdWJzZXRlcTogODg0MCxcbiAgICBuc3Vwc2V0ZXE6IDg4NDEsXG4gICAgcGl0Y2hmb3JrOiA4OTE2LFxuICAgIHJhdGlvbmFsczogODQ3NCxcbiAgICBzcGFkZXN1aXQ6IDk4MjQsXG4gICAgc3Vic2V0ZXFxOiAxMDk0OSxcbiAgICBzdWJzZXRuZXE6IDg4NDIsXG4gICAgc3Vwc2V0ZXFxOiAxMDk1MCxcbiAgICBzdXBzZXRuZXE6IDg4NDMsXG4gICAgdGhlcmVmb3JlOiA4NzU2LFxuICAgIHRyaWFuZ2xlcTogODc5NixcbiAgICB2YXJwcm9wdG86IDg3MzMsXG4gICAgRERvdHJhaGQ6IDEwNTEzLFxuICAgIERvdEVxdWFsOiA4Nzg0LFxuICAgIEludGVncmFsOiA4NzQ3LFxuICAgIExlc3NMZXNzOiAxMDkxMyxcbiAgICBOb3RFcXVhbDogODgwMCxcbiAgICBOb3RUaWxkZTogODc2OSxcbiAgICBQYXJ0aWFsRDogODcwNixcbiAgICBQcmVjZWRlczogODgyNixcbiAgICBSaWdodFRlZTogODg2NixcbiAgICBTdWNjZWVkczogODgyNyxcbiAgICBTdWNoVGhhdDogODcxNSxcbiAgICBTdXBlcnNldDogODgzNSxcbiAgICBVYXJyb2NpcjogMTA1NjksXG4gICAgVW5kZXJCYXI6IDgxOCxcbiAgICBhbmRzbG9wZTogMTA4NDAsXG4gICAgYW5nbXNkYWE6IDEwNjY0LFxuICAgIGFuZ21zZGFiOiAxMDY2NSxcbiAgICBhbmdtc2RhYzogMTA2NjYsXG4gICAgYW5nbXNkYWQ6IDEwNjY3LFxuICAgIGFuZ21zZGFlOiAxMDY2OCxcbiAgICBhbmdtc2RhZjogMTA2NjksXG4gICAgYW5nbXNkYWc6IDEwNjcwLFxuICAgIGFuZ21zZGFoOiAxMDY3MSxcbiAgICBhbmdydHZiZDogMTA2NTMsXG4gICAgYXBwcm94ZXE6IDg3NzgsXG4gICAgYXdjb25pbnQ6IDg3NTUsXG4gICAgYmFja2Nvbmc6IDg3ODAsXG4gICAgYmFyd2VkZ2U6IDg5NjUsXG4gICAgYmJya3Ricms6IDkxNDIsXG4gICAgYmlnb3BsdXM6IDEwNzUzLFxuICAgIGJpZ3NxY3VwOiAxMDc1OCxcbiAgICBiaWd1cGx1czogMTA3NTYsXG4gICAgYmlnd2VkZ2U6IDg4OTYsXG4gICAgYm94bWludXM6IDg4NjMsXG4gICAgYm94dGltZXM6IDg4NjQsXG4gICAgY2FwYnJjdXA6IDEwODI1LFxuICAgIGNpcmNsZWRSOiAxNzQsXG4gICAgY2lyY2xlZFM6IDk0MTYsXG4gICAgY2lyZm5pbnQ6IDEwNzY4LFxuICAgIGNsdWJzdWl0OiA5ODI3LFxuICAgIGN1cGJyY2FwOiAxMDgyNCxcbiAgICBjdXJseXZlZTogODkxMCxcbiAgICBjd2NvbmludDogODc1NCxcbiAgICBkb3RlcWRvdDogODc4NSxcbiAgICBkb3RtaW51czogODc2MCxcbiAgICBkcmJrYXJvdzogMTA1MTIsXG4gICAgZHppZ3JhcnI6IDEwMjM5LFxuICAgIGVsaW50ZXJzOiA5MTkxLFxuICAgIGVtcHR5c2V0OiA4NzA5LFxuICAgIGVxdnBhcnNsOiAxMDcyNSxcbiAgICBmcGFydGludDogMTA3NjUsXG4gICAgZ2Vxc2xhbnQ6IDEwODc4LFxuICAgIGdlc2RvdG9sOiAxMDg4NCxcbiAgICBnbmFwcHJveDogMTA4OTAsXG4gICAgaGtzZWFyb3c6IDEwNTMzLFxuICAgIGhrc3dhcm93OiAxMDUzNCxcbiAgICBpbWFnbGluZTogODQ2NCxcbiAgICBpbWFncGFydDogODQ2NSxcbiAgICBpbmZpbnRpZTogMTA3MTcsXG4gICAgaW50ZWdlcnM6IDg0ODQsXG4gICAgaW50ZXJjYWw6IDg4OTAsXG4gICAgaW50bGFyaGs6IDEwNzc1LFxuICAgIGxhZW1wdHl2OiAxMDY3NixcbiAgICBsZHJ1c2hhcjogMTA1NzEsXG4gICAgbGVxc2xhbnQ6IDEwODc3LFxuICAgIGxlc2RvdG9yOiAxMDg4MyxcbiAgICBsbGNvcm5lcjogODk5MCxcbiAgICBsbmFwcHJveDogMTA4ODksXG4gICAgbHJjb3JuZXI6IDg5OTEsXG4gICAgbHVyZHNoYXI6IDEwNTcwLFxuICAgIG1hcHN0b3VwOiA4NjEzLFxuICAgIG11bHRpbWFwOiA4ODg4LFxuICAgIG5hdHVyYWxzOiA4NDY5LFxuICAgIG90aW1lc2FzOiAxMDgwNixcbiAgICBwYXJhbGxlbDogODc0MSxcbiAgICBwbHVzYWNpcjogMTA3ODcsXG4gICAgcG9pbnRpbnQ6IDEwNzczLFxuICAgIHByZWNuZXFxOiAxMDkzMyxcbiAgICBwcmVjbnNpbTogODkzNixcbiAgICBwcm9mYWxhcjogOTAwNixcbiAgICBwcm9mbGluZTogODk3OCxcbiAgICBwcm9mc3VyZjogODk3OSxcbiAgICByYWVtcHR5djogMTA2NzUsXG4gICAgcmVhbHBhcnQ6IDg0NzYsXG4gICAgcnBwb2xpbnQ6IDEwNzcwLFxuICAgIHJ0cmlsdHJpOiAxMDcwMixcbiAgICBzY3BvbGludDogMTA3NzEsXG4gICAgc2V0bWludXM6IDg3MjYsXG4gICAgc2hvcnRtaWQ6IDg3MzksXG4gICAgc21lcGFyc2w6IDEwNzI0LFxuICAgIHNxc3Vic2V0OiA4ODQ3LFxuICAgIHNxc3Vwc2V0OiA4ODQ4LFxuICAgIHN1YnNldGVxOiA4ODM4LFxuICAgIHN1Y2NuZXFxOiAxMDkzNCxcbiAgICBzdWNjbnNpbTogODkzNyxcbiAgICBzdXBzZXRlcTogODgzOSxcbiAgICB0aGV0YXN5bTogOTc3LFxuICAgIHRoaWNrc2ltOiA4NzY0LFxuICAgIHRpbWVzYmFyOiAxMDgwMSxcbiAgICB0cmlhbmdsZTogOTY1MyxcbiAgICB0cmltaW51czogMTA4MTAsXG4gICAgdHJwZXppdW06IDkxODYsXG4gICAgdWxjb3JuZXI6IDg5ODgsXG4gICAgdXJjb3JuZXI6IDg5ODksXG4gICAgdmFya2FwcGE6IDEwMDgsXG4gICAgdmFyc2lnbWE6IDk2MixcbiAgICB2YXJ0aGV0YTogOTc3LFxuICAgIEJlY2F1c2U6IDg3NTcsXG4gICAgQ2F5bGV5czogODQ5MyxcbiAgICBDY29uaW50OiA4NzUyLFxuICAgIENlZGlsbGE6IDE4NCxcbiAgICBEaWFtb25kOiA4OTAwLFxuICAgIERvd25UZWU6IDg4NjgsXG4gICAgRWxlbWVudDogODcxMixcbiAgICBFcHNpbG9uOiA5MTcsXG4gICAgSW1wbGllczogODY1OCxcbiAgICBMZWZ0VGVlOiA4ODY3LFxuICAgIE5ld0xpbmU6IDEwLFxuICAgIE5vQnJlYWs6IDgyODgsXG4gICAgTm90TGVzczogODgxNCxcbiAgICBPbWljcm9uOiA5MjcsXG4gICAgT3ZlckJhcjogMTc1LFxuICAgIFByb2R1Y3Q6IDg3MTksXG4gICAgVXBBcnJvdzogODU5MyxcbiAgICBVcGFycm93OiA4NjU3LFxuICAgIFVwc2lsb246IDkzMyxcbiAgICBhbGVmc3ltOiA4NTAxLFxuICAgIGFuZ3J0dmI6IDg4OTQsXG4gICAgYW5nemFycjogOTA4NCxcbiAgICBhc3ltcGVxOiA4NzgxLFxuICAgIGJhY2tzaW06IDg3NjUsXG4gICAgYmVjYXVzZTogODc1NyxcbiAgICBiZW1wdHl2OiAxMDY3MixcbiAgICBiZXR3ZWVuOiA4ODEyLFxuICAgIGJpZ2NpcmM6IDk3MTEsXG4gICAgYmlnb2RvdDogMTA3NTIsXG4gICAgYmlnc3RhcjogOTczMyxcbiAgICBib3hwbHVzOiA4ODYyLFxuICAgIGNjdXBzc206IDEwODMyLFxuICAgIGNlbXB0eXY6IDEwNjc0LFxuICAgIGNpcnNjaXI6IDEwNjkwLFxuICAgIGNvbG9uZXE6IDg3ODgsXG4gICAgY29uZ2RvdDogMTA4NjEsXG4gICAgY3VkYXJybDogMTA1NTIsXG4gICAgY3VkYXJycjogMTA1NDksXG4gICAgY3VsYXJycDogMTA1NTcsXG4gICAgY3VyYXJybTogMTA1NTYsXG4gICAgZGJrYXJvdzogMTA1MTEsXG4gICAgZGRhZ2dlcjogODIyNSxcbiAgICBkZG90c2VxOiAxMDg3MSxcbiAgICBkZW1wdHl2OiAxMDY3MyxcbiAgICBkaWFtb25kOiA4OTAwLFxuICAgIGRpZ2FtbWE6IDk4OSxcbiAgICBkb3RwbHVzOiA4NzI0LFxuICAgIGR3YW5nbGU6IDEwNjYyLFxuICAgIGVwc2lsb246IDk0OSxcbiAgICBlcWNvbG9uOiA4Nzg5LFxuICAgIGVxdWl2REQ6IDEwODcyLFxuICAgIGdlc2RvdG86IDEwODgyLFxuICAgIGd0cXVlc3Q6IDEwODc2LFxuICAgIGd0cmxlc3M6IDg4MjMsXG4gICAgaGFycmNpcjogMTA1NjgsXG4gICAgaW50cHJvZDogMTA4MTIsXG4gICAgaXNpbmRvdDogODk0OSxcbiAgICBsYXJyYmZzOiAxMDUyNyxcbiAgICBsYXJyc2ltOiAxMDYxMSxcbiAgICBsYnJrc2xkOiAxMDYzOSxcbiAgICBsYnJrc2x1OiAxMDYzNyxcbiAgICBsZHJkaGFyOiAxMDU5OSxcbiAgICBsZXNkb3RvOiAxMDg4MSxcbiAgICBsZXNzZG90OiA4OTE4LFxuICAgIGxlc3NndHI6IDg4MjIsXG4gICAgbGVzc3NpbTogODgxOCxcbiAgICBsb3RpbWVzOiAxMDgwNCxcbiAgICBsb3plbmdlOiA5Njc0LFxuICAgIGx0cXVlc3Q6IDEwODc1LFxuICAgIGx1cnVoYXI6IDEwNTk4LFxuICAgIG1hbHRlc2U6IDEwMDE2LFxuICAgIG1pbnVzZHU6IDEwNzk0LFxuICAgIG5hcHByb3g6IDg3NzcsXG4gICAgbmF0dXJhbDogOTgzOCxcbiAgICBuZWFycm93OiA4NTk5LFxuICAgIG5leGlzdHM6IDg3MDgsXG4gICAgbm90aW52YTogODcxMyxcbiAgICBub3RpbnZiOiA4OTUxLFxuICAgIG5vdGludmM6IDg5NTAsXG4gICAgbm90bml2YTogODcxNixcbiAgICBub3RuaXZiOiA4OTU4LFxuICAgIG5vdG5pdmM6IDg5NTcsXG4gICAgbnBvbGludDogMTA3NzIsXG4gICAgbnNxc3ViZTogODkzMCxcbiAgICBuc3FzdXBlOiA4OTMxLFxuICAgIG52aW5maW46IDEwNzE4LFxuICAgIG53YXJyb3c6IDg1OTgsXG4gICAgb2xjcm9zczogMTA2ODMsXG4gICAgb21pY3JvbjogOTU5LFxuICAgIG9yZGVyb2Y6IDg1MDAsXG4gICAgb3JzbG9wZTogMTA4MzksXG4gICAgcGVydGVuazogODI0MSxcbiAgICBwbGFuY2toOiA4NDYyLFxuICAgIHBsdXNjaXI6IDEwNzg2LFxuICAgIHBsdXNzaW06IDEwNzkwLFxuICAgIHBsdXN0d286IDEwNzkxLFxuICAgIHByZWNzaW06IDg4MzAsXG4gICAgcXVhdGludDogMTA3NzQsXG4gICAgcXVlc3RlcTogODc5OSxcbiAgICByYXJyYmZzOiAxMDUyOCxcbiAgICByYXJyc2ltOiAxMDYxMixcbiAgICByYnJrc2xkOiAxMDYzOCxcbiAgICByYnJrc2x1OiAxMDY0MCxcbiAgICByZGxkaGFyOiAxMDYwMSxcbiAgICByZWFsaW5lOiA4NDc1LFxuICAgIHJvdGltZXM6IDEwODA1LFxuICAgIHJ1bHVoYXI6IDEwNjAwLFxuICAgIHNlYXJyb3c6IDg2MDAsXG4gICAgc2ltcGx1czogMTA3ODgsXG4gICAgc2ltcmFycjogMTA2MTAsXG4gICAgc3ViZWRvdDogMTA5NDcsXG4gICAgc3VibXVsdDogMTA5NDUsXG4gICAgc3VicGx1czogMTA5NDMsXG4gICAgc3VicmFycjogMTA2MTcsXG4gICAgc3VjY3NpbTogODgzMSxcbiAgICBzdXBkc3ViOiAxMDk2OCxcbiAgICBzdXBlZG90OiAxMDk0OCxcbiAgICBzdXBoc3ViOiAxMDk2NyxcbiAgICBzdXBsYXJyOiAxMDYxOSxcbiAgICBzdXBtdWx0OiAxMDk0NixcbiAgICBzdXBwbHVzOiAxMDk0NCxcbiAgICBzd2Fycm93OiA4NjAxLFxuICAgIHRvcGZvcms6IDEwOTcwLFxuICAgIHRyaXBsdXM6IDEwODA5LFxuICAgIHRyaXRpbWU6IDEwODExLFxuICAgIHVwYXJyb3c6IDg1OTMsXG4gICAgdXBzaWxvbjogOTY1LFxuICAgIHV3YW5nbGU6IDEwNjYzLFxuICAgIHZ6aWd6YWc6IDEwNjUwLFxuICAgIHppZ3JhcnI6IDg2NjksXG4gICAgQWFjdXRlOiAxOTMsXG4gICAgQWJyZXZlOiAyNTgsXG4gICAgQWdyYXZlOiAxOTIsXG4gICAgQXNzaWduOiA4Nzg4LFxuICAgIEF0aWxkZTogMTk1LFxuICAgIEJhcndlZDogODk2NixcbiAgICBCdW1wZXE6IDg3ODIsXG4gICAgQ2FjdXRlOiAyNjIsXG4gICAgQ2Nhcm9uOiAyNjgsXG4gICAgQ2NlZGlsOiAxOTksXG4gICAgQ29sb25lOiAxMDg2OCxcbiAgICBDb25pbnQ6IDg3NTEsXG4gICAgQ3VwQ2FwOiA4NzgxLFxuICAgIERhZ2dlcjogODIyNSxcbiAgICBEY2Fyb246IDI3MCxcbiAgICBEb3REb3Q6IDg0MTIsXG4gICAgRHN0cm9rOiAyNzIsXG4gICAgRWFjdXRlOiAyMDEsXG4gICAgRWNhcm9uOiAyODIsXG4gICAgRWdyYXZlOiAyMDAsXG4gICAgRXhpc3RzOiA4NzA3LFxuICAgIEZvckFsbDogODcwNCxcbiAgICBHYW1tYWQ6IDk4OCxcbiAgICBHYnJldmU6IDI4NixcbiAgICBHY2VkaWw6IDI5MCxcbiAgICBIQVJEY3k6IDEwNjYsXG4gICAgSHN0cm9rOiAyOTQsXG4gICAgSWFjdXRlOiAyMDUsXG4gICAgSWdyYXZlOiAyMDQsXG4gICAgSXRpbGRlOiAyOTYsXG4gICAgSnNlcmN5OiAxMDMyLFxuICAgIEtjZWRpbDogMzEwLFxuICAgIExhY3V0ZTogMzEzLFxuICAgIExhbWJkYTogOTIzLFxuICAgIExjYXJvbjogMzE3LFxuICAgIExjZWRpbDogMzE1LFxuICAgIExtaWRvdDogMzE5LFxuICAgIExzdHJvazogMzIxLFxuICAgIE5hY3V0ZTogMzIzLFxuICAgIE5jYXJvbjogMzI3LFxuICAgIE5jZWRpbDogMzI1LFxuICAgIE50aWxkZTogMjA5LFxuICAgIE9hY3V0ZTogMjExLFxuICAgIE9kYmxhYzogMzM2LFxuICAgIE9ncmF2ZTogMjEwLFxuICAgIE9zbGFzaDogMjE2LFxuICAgIE90aWxkZTogMjEzLFxuICAgIE90aW1lczogMTA4MDcsXG4gICAgUmFjdXRlOiAzNDAsXG4gICAgUmFycnRsOiAxMDUxOCxcbiAgICBSY2Fyb246IDM0NCxcbiAgICBSY2VkaWw6IDM0MixcbiAgICBTSENIY3k6IDEwNjUsXG4gICAgU09GVGN5OiAxMDY4LFxuICAgIFNhY3V0ZTogMzQ2LFxuICAgIFNjYXJvbjogMzUyLFxuICAgIFNjZWRpbDogMzUwLFxuICAgIFNxdWFyZTogOTYzMyxcbiAgICBTdWJzZXQ6IDg5MTIsXG4gICAgU3Vwc2V0OiA4OTEzLFxuICAgIFRjYXJvbjogMzU2LFxuICAgIFRjZWRpbDogMzU0LFxuICAgIFRzdHJvazogMzU4LFxuICAgIFVhY3V0ZTogMjE4LFxuICAgIFVicmV2ZTogMzY0LFxuICAgIFVkYmxhYzogMzY4LFxuICAgIFVncmF2ZTogMjE3LFxuICAgIFV0aWxkZTogMzYwLFxuICAgIFZkYXNobDogMTA5ODIsXG4gICAgVmVyYmFyOiA4MjE0LFxuICAgIFZ2ZGFzaDogODg3NCxcbiAgICBZYWN1dGU6IDIyMSxcbiAgICBaYWN1dGU6IDM3NyxcbiAgICBaY2Fyb246IDM4MSxcbiAgICBhYWN1dGU6IDIyNSxcbiAgICBhYnJldmU6IDI1OSxcbiAgICBhZ3JhdmU6IDIyNCxcbiAgICBhbmRhbmQ6IDEwODM3LFxuICAgIGFuZ21zZDogODczNyxcbiAgICBhbmdzcGg6IDg3MzgsXG4gICAgYXBhY2lyOiAxMDg2MyxcbiAgICBhcHByb3g6IDg3NzYsXG4gICAgYXRpbGRlOiAyMjcsXG4gICAgYmFydmVlOiA4ODkzLFxuICAgIGJhcndlZDogODk2NSxcbiAgICBiZWNhdXM6IDg3NTcsXG4gICAgYmVybm91OiA4NDkyLFxuICAgIGJpZ2NhcDogODg5OCxcbiAgICBiaWdjdXA6IDg4OTksXG4gICAgYmlndmVlOiA4ODk3LFxuICAgIGJrYXJvdzogMTA1MDksXG4gICAgYm90dG9tOiA4ODY5LFxuICAgIGJvd3RpZTogODkwNCxcbiAgICBib3hib3g6IDEwNjk3LFxuICAgIGJwcmltZTogODI0NSxcbiAgICBicnZiYXI6IDE2NixcbiAgICBidWxsZXQ6IDgyMjYsXG4gICAgYnVtcGVxOiA4NzgzLFxuICAgIGNhY3V0ZTogMjYzLFxuICAgIGNhcGFuZDogMTA4MjAsXG4gICAgY2FwY2FwOiAxMDgyNyxcbiAgICBjYXBjdXA6IDEwODIzLFxuICAgIGNhcGRvdDogMTA4MTYsXG4gICAgY2Nhcm9uOiAyNjksXG4gICAgY2NlZGlsOiAyMzEsXG4gICAgY2lyY2VxOiA4NzkxLFxuICAgIGNpcm1pZDogMTA5OTEsXG4gICAgY29sb25lOiA4Nzg4LFxuICAgIGNvbW1hdDogNjQsXG4gICAgY29tcGZuOiA4NzI4LFxuICAgIGNvbmludDogODc1MCxcbiAgICBjb3Byb2Q6IDg3MjAsXG4gICAgY29weXNyOiA4NDcxLFxuICAgIGN1bGFycjogODYzMCxcbiAgICBjdXBjYXA6IDEwODIyLFxuICAgIGN1cGN1cDogMTA4MjYsXG4gICAgY3VwZG90OiA4ODQ1LFxuICAgIGN1cmFycjogODYzMSxcbiAgICBjdXJyZW46IDE2NCxcbiAgICBjeWxjdHk6IDkwMDUsXG4gICAgZGFnZ2VyOiA4MjI0LFxuICAgIGRhbGV0aDogODUwNCxcbiAgICBkY2Fyb246IDI3MSxcbiAgICBkZmlzaHQ6IDEwNjIzLFxuICAgIGRpdmlkZTogMjQ3LFxuICAgIGRpdm9ueDogODkwMyxcbiAgICBkbGNvcm46IDg5OTAsXG4gICAgZGxjcm9wOiA4OTczLFxuICAgIGRvbGxhcjogMzYsXG4gICAgZHJjb3JuOiA4OTkxLFxuICAgIGRyY3JvcDogODk3MixcbiAgICBkc3Ryb2s6IDI3MyxcbiAgICBlYWN1dGU6IDIzMyxcbiAgICBlYXN0ZXI6IDEwODYyLFxuICAgIGVjYXJvbjogMjgzLFxuICAgIGVjb2xvbjogODc4OSxcbiAgICBlZ3JhdmU6IDIzMixcbiAgICBlZ3Nkb3Q6IDEwOTA0LFxuICAgIGVsc2RvdDogMTA5MDMsXG4gICAgZW1wdHl2OiA4NzA5LFxuICAgIGVtc3AxMzogODE5NixcbiAgICBlbXNwMTQ6IDgxOTcsXG4gICAgZXBhcnNsOiAxMDcyMyxcbiAgICBlcWNpcmM6IDg3OTAsXG4gICAgZXF1YWxzOiA2MSxcbiAgICBlcXVlc3Q6IDg3OTksXG4gICAgZmVtYWxlOiA5NzkyLFxuICAgIGZmaWxpZzogNjQyNTksXG4gICAgZmZsbGlnOiA2NDI2MCxcbiAgICBmb3JhbGw6IDg3MDQsXG4gICAgZnJhYzEyOiAxODksXG4gICAgZnJhYzEzOiA4NTMxLFxuICAgIGZyYWMxNDogMTg4LFxuICAgIGZyYWMxNTogODUzMyxcbiAgICBmcmFjMTY6IDg1MzcsXG4gICAgZnJhYzE4OiA4NTM5LFxuICAgIGZyYWMyMzogODUzMixcbiAgICBmcmFjMjU6IDg1MzQsXG4gICAgZnJhYzM0OiAxOTAsXG4gICAgZnJhYzM1OiA4NTM1LFxuICAgIGZyYWMzODogODU0MCxcbiAgICBmcmFjNDU6IDg1MzYsXG4gICAgZnJhYzU2OiA4NTM4LFxuICAgIGZyYWM1ODogODU0MSxcbiAgICBmcmFjNzg6IDg1NDIsXG4gICAgZ2FjdXRlOiA1MDEsXG4gICAgZ2FtbWFkOiA5ODksXG4gICAgZ2JyZXZlOiAyODcsXG4gICAgZ2VzZG90OiAxMDg4MCxcbiAgICBnZXNsZXM6IDEwOTAwLFxuICAgIGd0bFBhcjogMTA2NDUsXG4gICAgZ3RyYXJyOiAxMDYxNixcbiAgICBndHJkb3Q6IDg5MTksXG4gICAgZ3Ryc2ltOiA4ODE5LFxuICAgIGhhaXJzcDogODIwMixcbiAgICBoYW1pbHQ6IDg0NTksXG4gICAgaGFyZGN5OiAxMDk4LFxuICAgIGhlYXJ0czogOTgyOSxcbiAgICBoZWxsaXA6IDgyMzAsXG4gICAgaGVyY29uOiA4ODg5LFxuICAgIGhvbXRodDogODc2MyxcbiAgICBob3JiYXI6IDgyMTMsXG4gICAgaHNsYXNoOiA4NDYzLFxuICAgIGhzdHJvazogMjk1LFxuICAgIGh5YnVsbDogODI1OSxcbiAgICBoeXBoZW46IDgyMDgsXG4gICAgaWFjdXRlOiAyMzcsXG4gICAgaWdyYXZlOiAyMzYsXG4gICAgaWlpaW50OiAxMDc2NCxcbiAgICBpaW5maW46IDEwNzE2LFxuICAgIGluY2FyZTogODQ1MyxcbiAgICBpbm9kb3Q6IDMwNSxcbiAgICBpbnRjYWw6IDg4OTAsXG4gICAgaXF1ZXN0OiAxOTEsXG4gICAgaXNpbnN2OiA4OTQ3LFxuICAgIGl0aWxkZTogMjk3LFxuICAgIGpzZXJjeTogMTExMixcbiAgICBrYXBwYXY6IDEwMDgsXG4gICAga2NlZGlsOiAzMTEsXG4gICAga2dyZWVuOiAzMTIsXG4gICAgbEF0YWlsOiAxMDUyMyxcbiAgICBsYWN1dGU6IDMxNCxcbiAgICBsYWdyYW46IDg0NjYsXG4gICAgbGFtYmRhOiA5NTUsXG4gICAgbGFuZ2xlOiAxMDIxNixcbiAgICBsYXJyZnM6IDEwNTI1LFxuICAgIGxhcnJoazogODYxNyxcbiAgICBsYXJybHA6IDg2MTksXG4gICAgbGFycnBsOiAxMDU1MyxcbiAgICBsYXJydGw6IDg2MTAsXG4gICAgbGF0YWlsOiAxMDUyMSxcbiAgICBsYnJhY2U6IDEyMyxcbiAgICBsYnJhY2s6IDkxLFxuICAgIGxjYXJvbjogMzE4LFxuICAgIGxjZWRpbDogMzE2LFxuICAgIGxkcXVvcjogODIyMixcbiAgICBsZXNkb3Q6IDEwODc5LFxuICAgIGxlc2dlczogMTA4OTksXG4gICAgbGZpc2h0OiAxMDYyMCxcbiAgICBsZmxvb3I6IDg5NzAsXG4gICAgbGhhcnVsOiAxMDYwMixcbiAgICBsbGhhcmQ6IDEwNjAzLFxuICAgIGxtaWRvdDogMzIwLFxuICAgIGxtb3VzdDogOTEzNixcbiAgICBsb3BsdXM6IDEwNzk3LFxuICAgIGxvd2FzdDogODcyNyxcbiAgICBsb3diYXI6IDk1LFxuICAgIGxwYXJsdDogMTA2NDMsXG4gICAgbHJoYXJkOiAxMDYwNSxcbiAgICBsc2FxdW86IDgyNDksXG4gICAgbHNxdW9yOiA4MjE4LFxuICAgIGxzdHJvazogMzIyLFxuICAgIGx0aHJlZTogODkwNyxcbiAgICBsdGltZXM6IDg5MDUsXG4gICAgbHRsYXJyOiAxMDYxNCxcbiAgICBsdHJQYXI6IDEwNjQ2LFxuICAgIG1hcHN0bzogODYxNCxcbiAgICBtYXJrZXI6IDk2NDYsXG4gICAgbWNvbW1hOiAxMDc5MyxcbiAgICBtaWRhc3Q6IDQyLFxuICAgIG1pZGNpcjogMTA5OTIsXG4gICAgbWlkZG90OiAxODMsXG4gICAgbWludXNiOiA4ODYzLFxuICAgIG1pbnVzZDogODc2MCxcbiAgICBtbnBsdXM6IDg3MjMsXG4gICAgbW9kZWxzOiA4ODcxLFxuICAgIG1zdHBvczogODc2NixcbiAgICBuVkRhc2g6IDg4NzksXG4gICAgblZkYXNoOiA4ODc4LFxuICAgIG5hY3V0ZTogMzI0LFxuICAgIG5jYXJvbjogMzI4LFxuICAgIG5jZWRpbDogMzI2LFxuICAgIG5lYXJoazogMTA1MzIsXG4gICAgbmVxdWl2OiA4ODAyLFxuICAgIG5lc2VhcjogMTA1MzYsXG4gICAgbmV4aXN0OiA4NzA4LFxuICAgIG5sdHJpZTogODk0MCxcbiAgICBucHJjdWU6IDg5MjgsXG4gICAgbnJ0cmllOiA4OTQxLFxuICAgIG5zY2N1ZTogODkyOSxcbiAgICBuc2ltZXE6IDg3NzIsXG4gICAgbnRpbGRlOiAyNDEsXG4gICAgbnVtZXJvOiA4NDcwLFxuICAgIG52RGFzaDogODg3NyxcbiAgICBudkhhcnI6IDEwNTAwLFxuICAgIG52ZGFzaDogODg3NixcbiAgICBudmxBcnI6IDEwNDk4LFxuICAgIG52ckFycjogMTA0OTksXG4gICAgbndhcmhrOiAxMDUzMSxcbiAgICBud25lYXI6IDEwNTM1LFxuICAgIG9hY3V0ZTogMjQzLFxuICAgIG9kYmxhYzogMzM3LFxuICAgIG9kc29sZDogMTA2ODQsXG4gICAgb2dyYXZlOiAyNDIsXG4gICAgb21pbnVzOiA4ODU0LFxuICAgIG9yaWdvZjogODg4NixcbiAgICBvc2xhc2g6IDI0OCxcbiAgICBvdGlsZGU6IDI0NSxcbiAgICBvdGltZXM6IDg4NTUsXG4gICAgcGFyc2ltOiAxMDk5NSxcbiAgICBwZXJjbnQ6IDM3LFxuICAgIHBlcmlvZDogNDYsXG4gICAgcGVybWlsOiA4MjQwLFxuICAgIHBobW1hdDogODQ5OSxcbiAgICBwbGFuY2s6IDg0NjMsXG4gICAgcGxhbmt2OiA4NDYzLFxuICAgIHBsdXNkbzogODcyNCxcbiAgICBwbHVzZHU6IDEwNzg5LFxuICAgIHBsdXNtbjogMTc3LFxuICAgIHByZWNlcTogMTA5MjcsXG4gICAgcHJpbWVzOiA4NDczLFxuICAgIHBybnNpbTogODkzNixcbiAgICBwcm9wdG86IDg3MzMsXG4gICAgcHJ1cmVsOiA4ODgwLFxuICAgIHB1bmNzcDogODIwMCxcbiAgICBxcHJpbWU6IDgyNzksXG4gICAgckF0YWlsOiAxMDUyNCxcbiAgICByYWN1dGU6IDM0MSxcbiAgICByYW5nbGU6IDEwMjE3LFxuICAgIHJhcnJhcDogMTA2MTMsXG4gICAgcmFycmZzOiAxMDUyNixcbiAgICByYXJyaGs6IDg2MTgsXG4gICAgcmFycmxwOiA4NjIwLFxuICAgIHJhcnJwbDogMTA1NjUsXG4gICAgcmFycnRsOiA4NjExLFxuICAgIHJhdGFpbDogMTA1MjIsXG4gICAgcmJyYWNlOiAxMjUsXG4gICAgcmJyYWNrOiA5MyxcbiAgICByY2Fyb246IDM0NSxcbiAgICByY2VkaWw6IDM0MyxcbiAgICByZHF1b3I6IDgyMjEsXG4gICAgcmZpc2h0OiAxMDYyMSxcbiAgICByZmxvb3I6IDg5NzEsXG4gICAgcmhhcnVsOiAxMDYwNCxcbiAgICBybW91c3Q6IDkxMzcsXG4gICAgcm9wbHVzOiAxMDc5OCxcbiAgICBycGFyZ3Q6IDEwNjQ0LFxuICAgIHJzYXF1bzogODI1MCxcbiAgICByc3F1b3I6IDgyMTcsXG4gICAgcnRocmVlOiA4OTA4LFxuICAgIHJ0aW1lczogODkwNixcbiAgICBzYWN1dGU6IDM0NyxcbiAgICBzY2Fyb246IDM1MyxcbiAgICBzY2VkaWw6IDM1MSxcbiAgICBzY25zaW06IDg5MzcsXG4gICAgc2VhcmhrOiAxMDUzMyxcbiAgICBzZXN3YXI6IDEwNTM3LFxuICAgIHNmcm93bjogODk5NCxcbiAgICBzaGNoY3k6IDEwOTcsXG4gICAgc2lnbWFmOiA5NjIsXG4gICAgc2lnbWF2OiA5NjIsXG4gICAgc2ltZG90OiAxMDg1OCxcbiAgICBzbWFzaHA6IDEwODAzLFxuICAgIHNvZnRjeTogMTEwMCxcbiAgICBzb2xiYXI6IDkwMjMsXG4gICAgc3BhZGVzOiA5ODI0LFxuICAgIHNxc3ViZTogODg0OSxcbiAgICBzcXN1cGU6IDg4NTAsXG4gICAgc3F1YXJlOiA5NjMzLFxuICAgIHNxdWFyZjogOTY0MixcbiAgICBzc2V0bW46IDg3MjYsXG4gICAgc3NtaWxlOiA4OTk1LFxuICAgIHNzdGFyZjogODkwMixcbiAgICBzdWJkb3Q6IDEwOTQxLFxuICAgIHN1YnNldDogODgzNCxcbiAgICBzdWJzaW06IDEwOTUxLFxuICAgIHN1YnN1YjogMTA5NjUsXG4gICAgc3Vic3VwOiAxMDk2MyxcbiAgICBzdWNjZXE6IDEwOTI4LFxuICAgIHN1cGRvdDogMTA5NDIsXG4gICAgc3Vwc2V0OiA4ODM1LFxuICAgIHN1cHNpbTogMTA5NTIsXG4gICAgc3Vwc3ViOiAxMDk2NCxcbiAgICBzdXBzdXA6IDEwOTY2LFxuICAgIHN3YXJoazogMTA1MzQsXG4gICAgc3dud2FyOiAxMDUzOCxcbiAgICB0YXJnZXQ6IDg5ODIsXG4gICAgdGNhcm9uOiAzNTcsXG4gICAgdGNlZGlsOiAzNTUsXG4gICAgdGVscmVjOiA4OTgxLFxuICAgIHRoZXJlNDogODc1NixcbiAgICB0aGV0YXY6IDk3NyxcbiAgICB0aGluc3A6IDgyMDEsXG4gICAgdGhrc2ltOiA4NzY0LFxuICAgIHRpbWVzYjogODg2NCxcbiAgICB0aW1lc2Q6IDEwODAwLFxuICAgIHRvcGJvdDogOTAxNCxcbiAgICB0b3BjaXI6IDEwOTkzLFxuICAgIHRwcmltZTogODI0NCxcbiAgICB0cmlkb3Q6IDk3MDgsXG4gICAgdHN0cm9rOiAzNTksXG4gICAgdWFjdXRlOiAyNTAsXG4gICAgdWJyZXZlOiAzNjUsXG4gICAgdWRibGFjOiAzNjksXG4gICAgdWZpc2h0OiAxMDYyMixcbiAgICB1Z3JhdmU6IDI0OSxcbiAgICB1bGNvcm46IDg5ODgsXG4gICAgdWxjcm9wOiA4OTc1LFxuICAgIHVyY29ybjogODk4OSxcbiAgICB1cmNyb3A6IDg5NzQsXG4gICAgdXRpbGRlOiAzNjEsXG4gICAgdmFuZ3J0OiAxMDY1MixcbiAgICB2YXJwaGk6IDk2NixcbiAgICB2YXJyaG86IDEwMDksXG4gICAgdmVlYmFyOiA4ODkxLFxuICAgIHZlbGxpcDogODk0MixcbiAgICB2ZXJiYXI6IDEyNCxcbiAgICB3ZWRiYXI6IDEwODQ3LFxuICAgIHdlZGdlcTogODc5MyxcbiAgICB3ZWllcnA6IDg0NzIsXG4gICAgd3JlYXRoOiA4NzY4LFxuICAgIHhvcGx1czogMTA3NTMsXG4gICAgeG90aW1lOiAxMDc1NCxcbiAgICB4c3FjdXA6IDEwNzU4LFxuICAgIHh1cGx1czogMTA3NTYsXG4gICAgeHdlZGdlOiA4ODk2LFxuICAgIHlhY3V0ZTogMjUzLFxuICAgIHphY3V0ZTogMzc4LFxuICAgIHpjYXJvbjogMzgyLFxuICAgIHplZXRyZjogODQ4OCxcbiAgICBBRWxpZzogMTk4LFxuICAgIEFjaXJjOiAxOTQsXG4gICAgQWxwaGE6IDkxMyxcbiAgICBBbWFjcjogMjU2LFxuICAgIEFvZ29uOiAyNjAsXG4gICAgQXJpbmc6IDE5NyxcbiAgICBCcmV2ZTogNzI4LFxuICAgIENjaXJjOiAyNjQsXG4gICAgQ29sb246IDg3NTksXG4gICAgQ3Jvc3M6IDEwNzk5LFxuICAgIERhc2h2OiAxMDk4MCxcbiAgICBEZWx0YTogOTE2LFxuICAgIEVjaXJjOiAyMDIsXG4gICAgRW1hY3I6IDI3NCxcbiAgICBFb2dvbjogMjgwLFxuICAgIEVxdWFsOiAxMDg2OSxcbiAgICBHYW1tYTogOTE1LFxuICAgIEdjaXJjOiAyODQsXG4gICAgSGFjZWs6IDcxMSxcbiAgICBIY2lyYzogMjkyLFxuICAgIElKbGlnOiAzMDYsXG4gICAgSWNpcmM6IDIwNixcbiAgICBJbWFjcjogMjk4LFxuICAgIElvZ29uOiAzMDIsXG4gICAgSXVrY3k6IDEwMzAsXG4gICAgSmNpcmM6IDMwOCxcbiAgICBKdWtjeTogMTAyOCxcbiAgICBLYXBwYTogOTIyLFxuICAgIE9FbGlnOiAzMzgsXG4gICAgT2NpcmM6IDIxMixcbiAgICBPbWFjcjogMzMyLFxuICAgIE9tZWdhOiA5MzcsXG4gICAgUHJpbWU6IDgyNDMsXG4gICAgUkJhcnI6IDEwNTEyLFxuICAgIFNjaXJjOiAzNDgsXG4gICAgU2lnbWE6IDkzMSxcbiAgICBUSE9STjogMjIyLFxuICAgIFRSQURFOiA4NDgyLFxuICAgIFRTSGN5OiAxMDM1LFxuICAgIFRoZXRhOiA5MjAsXG4gICAgVGlsZGU6IDg3NjQsXG4gICAgVWJyY3k6IDEwMzgsXG4gICAgVWNpcmM6IDIxOSxcbiAgICBVbWFjcjogMzYyLFxuICAgIFVuaW9uOiA4ODk5LFxuICAgIFVvZ29uOiAzNzAsXG4gICAgVXBUZWU6IDg4NjksXG4gICAgVXJpbmc6IDM2NixcbiAgICBWRGFzaDogODg3NSxcbiAgICBWZGFzaDogODg3MyxcbiAgICBXY2lyYzogMzcyLFxuICAgIFdlZGdlOiA4ODk2LFxuICAgIFljaXJjOiAzNzQsXG4gICAgYWNpcmM6IDIyNixcbiAgICBhY3V0ZTogMTgwLFxuICAgIGFlbGlnOiAyMzAsXG4gICAgYWxlcGg6IDg1MDEsXG4gICAgYWxwaGE6IDk0NSxcbiAgICBhbWFjcjogMjU3LFxuICAgIGFtYWxnOiAxMDgxNSxcbiAgICBhbmdsZTogODczNixcbiAgICBhbmdydDogODczNSxcbiAgICBhbmdzdDogODQ5MSxcbiAgICBhb2dvbjogMjYxLFxuICAgIGFyaW5nOiAyMjksXG4gICAgYXN5bXA6IDg3NzYsXG4gICAgYXdpbnQ6IDEwNzY5LFxuICAgIGJjb25nOiA4NzgwLFxuICAgIGJkcXVvOiA4MjIyLFxuICAgIGJlcHNpOiAxMDE0LFxuICAgIGJsYW5rOiA5MjUxLFxuICAgIGJsazEyOiA5NjE4LFxuICAgIGJsazE0OiA5NjE3LFxuICAgIGJsazM0OiA5NjE5LFxuICAgIGJsb2NrOiA5NjA4LFxuICAgIGJveERMOiA5NTU5LFxuICAgIGJveERSOiA5NTU2LFxuICAgIGJveERsOiA5NTU4LFxuICAgIGJveERyOiA5NTU1LFxuICAgIGJveEhEOiA5NTc0LFxuICAgIGJveEhVOiA5NTc3LFxuICAgIGJveEhkOiA5NTcyLFxuICAgIGJveEh1OiA5NTc1LFxuICAgIGJveFVMOiA5NTY1LFxuICAgIGJveFVSOiA5NTYyLFxuICAgIGJveFVsOiA5NTY0LFxuICAgIGJveFVyOiA5NTYxLFxuICAgIGJveFZIOiA5NTgwLFxuICAgIGJveFZMOiA5NTcxLFxuICAgIGJveFZSOiA5NTY4LFxuICAgIGJveFZoOiA5NTc5LFxuICAgIGJveFZsOiA5NTcwLFxuICAgIGJveFZyOiA5NTY3LFxuICAgIGJveGRMOiA5NTU3LFxuICAgIGJveGRSOiA5NTU0LFxuICAgIGJveGRsOiA5NDg4LFxuICAgIGJveGRyOiA5NDg0LFxuICAgIGJveGhEOiA5NTczLFxuICAgIGJveGhVOiA5NTc2LFxuICAgIGJveGhkOiA5NTE2LFxuICAgIGJveGh1OiA5NTI0LFxuICAgIGJveHVMOiA5NTYzLFxuICAgIGJveHVSOiA5NTYwLFxuICAgIGJveHVsOiA5NDk2LFxuICAgIGJveHVyOiA5NDkyLFxuICAgIGJveHZIOiA5NTc4LFxuICAgIGJveHZMOiA5NTY5LFxuICAgIGJveHZSOiA5NTY2LFxuICAgIGJveHZoOiA5NTMyLFxuICAgIGJveHZsOiA5NTA4LFxuICAgIGJveHZyOiA5NTAwLFxuICAgIGJyZXZlOiA3MjgsXG4gICAgYnNlbWk6IDgyNzEsXG4gICAgYnNpbWU6IDg5MDksXG4gICAgYnNvbGI6IDEwNjkzLFxuICAgIGJ1bXBFOiAxMDkyNixcbiAgICBidW1wZTogODc4MyxcbiAgICBjYXJldDogODI1NyxcbiAgICBjYXJvbjogNzExLFxuICAgIGNjYXBzOiAxMDgyOSxcbiAgICBjY2lyYzogMjY1LFxuICAgIGNjdXBzOiAxMDgyOCxcbiAgICBjZWRpbDogMTg0LFxuICAgIGNoZWNrOiAxMDAwMyxcbiAgICBjbHViczogOTgyNyxcbiAgICBjb2xvbjogNTgsXG4gICAgY29tbWE6IDQ0LFxuICAgIGNyYXJyOiA4NjI5LFxuICAgIGNyb3NzOiAxMDAwNyxcbiAgICBjc3ViZTogMTA5NjEsXG4gICAgY3N1cGU6IDEwOTYyLFxuICAgIGN0ZG90OiA4OTQzLFxuICAgIGN1ZXByOiA4OTI2LFxuICAgIGN1ZXNjOiA4OTI3LFxuICAgIGN1cG9yOiAxMDgyMSxcbiAgICBjdXZlZTogODkxMCxcbiAgICBjdXdlZDogODkxMSxcbiAgICBjd2ludDogODc1MyxcbiAgICBkYXNodjogODg2NyxcbiAgICBkYmxhYzogNzMzLFxuICAgIGRkYXJyOiA4NjUwLFxuICAgIGRlbHRhOiA5NDgsXG4gICAgZGhhcmw6IDg2NDMsXG4gICAgZGhhcnI6IDg2NDIsXG4gICAgZGlhbXM6IDk4MzAsXG4gICAgZGlzaW46IDg5NDYsXG4gICAgZG90ZXE6IDg3ODQsXG4gICAgZHRkb3Q6IDg5NDUsXG4gICAgZHRyaWY6IDk2NjIsXG4gICAgZHVhcnI6IDg2OTMsXG4gICAgZHVoYXI6IDEwNjA3LFxuICAgIGVERG90OiAxMDg3MSxcbiAgICBlY2lyYzogMjM0LFxuICAgIGVmRG90OiA4Nzg2LFxuICAgIGVtYWNyOiAyNzUsXG4gICAgZW1wdHk6IDg3MDksXG4gICAgZW9nb246IDI4MSxcbiAgICBlcGx1czogMTA4NjUsXG4gICAgZXBzaXY6IDk0OSxcbiAgICBlcXNpbTogODc3MCxcbiAgICBlcXVpdjogODgwMSxcbiAgICBlckRvdDogODc4NyxcbiAgICBlcmFycjogMTA2MDksXG4gICAgZXNkb3Q6IDg3ODQsXG4gICAgZXhpc3Q6IDg3MDcsXG4gICAgZmZsaWc6IDY0MjU2LFxuICAgIGZpbGlnOiA2NDI1NyxcbiAgICBmbGxpZzogNjQyNTgsXG4gICAgZmx0bnM6IDk2NDksXG4gICAgZm9ya3Y6IDEwOTY5LFxuICAgIGZyYXNsOiA4MjYwLFxuICAgIGZyb3duOiA4OTk0LFxuICAgIGdhbW1hOiA5NDcsXG4gICAgZ2NpcmM6IDI4NSxcbiAgICBnZXNjYzogMTA5MjEsXG4gICAgZ2ltZWw6IDg1MDMsXG4gICAgZ25lcXE6IDg4MDksXG4gICAgZ25zaW06IDg5MzUsXG4gICAgZ3JhdmU6IDk2LFxuICAgIGdzaW1lOiAxMDg5NCxcbiAgICBnc2ltbDogMTA4OTYsXG4gICAgZ3RjaXI6IDEwODc0LFxuICAgIGd0ZG90OiA4OTE5LFxuICAgIGhhcnJ3OiA4NjIxLFxuICAgIGhjaXJjOiAyOTMsXG4gICAgaG9hcnI6IDg3MDMsXG4gICAgaWNpcmM6IDIzOCxcbiAgICBpZXhjbDogMTYxLFxuICAgIGlpaW50OiA4NzQ5LFxuICAgIGlpb3RhOiA4NDg5LFxuICAgIGlqbGlnOiAzMDcsXG4gICAgaW1hY3I6IDI5OSxcbiAgICBpbWFnZTogODQ2NSxcbiAgICBpbWF0aDogMzA1LFxuICAgIGltcGVkOiA0MzcsXG4gICAgaW5maW46IDg3MzQsXG4gICAgaW9nb246IDMwMyxcbiAgICBpcHJvZDogMTA4MTIsXG4gICAgaXNpbkU6IDg5NTMsXG4gICAgaXNpbnM6IDg5NDgsXG4gICAgaXNpbnY6IDg3MTIsXG4gICAgaXVrY3k6IDExMTAsXG4gICAgamNpcmM6IDMwOSxcbiAgICBqbWF0aDogNTY3LFxuICAgIGp1a2N5OiAxMTA4LFxuICAgIGthcHBhOiA5NTQsXG4gICAgbEFhcnI6IDg2NjYsXG4gICAgbEJhcnI6IDEwNTEwLFxuICAgIGxhbmdkOiAxMDY0MSxcbiAgICBsYXF1bzogMTcxLFxuICAgIGxhcnJiOiA4Njc2LFxuICAgIGxiYXJyOiAxMDUwOCxcbiAgICBsYmJyazogMTAwOTgsXG4gICAgbGJya2U6IDEwNjM1LFxuICAgIGxjZWlsOiA4OTY4LFxuICAgIGxkcXVvOiA4MjIwLFxuICAgIGxlc2NjOiAxMDkyMCxcbiAgICBsaGFyZDogODYzNyxcbiAgICBsaGFydTogODYzNixcbiAgICBsaGJsazogOTYwNCxcbiAgICBsbGFycjogODY0NyxcbiAgICBsbHRyaTogOTcyMixcbiAgICBsbmVxcTogODgwOCxcbiAgICBsbnNpbTogODkzNCxcbiAgICBsb2FuZzogMTAyMjAsXG4gICAgbG9hcnI6IDg3MDEsXG4gICAgbG9icms6IDEwMjE0LFxuICAgIGxvcGFyOiAxMDYyOSxcbiAgICBscmFycjogODY0NixcbiAgICBscmhhcjogODY1MSxcbiAgICBscnRyaTogODg5NSxcbiAgICBsc2ltZTogMTA4OTMsXG4gICAgbHNpbWc6IDEwODk1LFxuICAgIGxzcXVvOiA4MjE2LFxuICAgIGx0Y2lyOiAxMDg3MyxcbiAgICBsdGRvdDogODkxOCxcbiAgICBsdHJpZTogODg4NCxcbiAgICBsdHJpZjogOTY2NixcbiAgICBtRERvdDogODc2MixcbiAgICBtZGFzaDogODIxMixcbiAgICBtaWNybzogMTgxLFxuICAgIG1pbnVzOiA4NzIyLFxuICAgIG11bWFwOiA4ODg4LFxuICAgIG5hYmxhOiA4NzExLFxuICAgIG5hcG9zOiAzMjksXG4gICAgbmF0dXI6IDk4MzgsXG4gICAgbmNvbmc6IDg3NzUsXG4gICAgbmRhc2g6IDgyMTEsXG4gICAgbmVBcnI6IDg2NjMsXG4gICAgbmVhcnI6IDg1OTksXG4gICAgbmdzaW06IDg4MjEsXG4gICAgbmhBcnI6IDg2NTQsXG4gICAgbmhhcnI6IDg2MjIsXG4gICAgbmhwYXI6IDEwOTk0LFxuICAgIG5sQXJyOiA4NjUzLFxuICAgIG5sYXJyOiA4NjAyLFxuICAgIG5sZXNzOiA4ODE0LFxuICAgIG5sc2ltOiA4ODIwLFxuICAgIG5sdHJpOiA4OTM4LFxuICAgIG5vdGluOiA4NzEzLFxuICAgIG5vdG5pOiA4NzE2LFxuICAgIG5wcmVjOiA4ODMyLFxuICAgIG5yQXJyOiA4NjU1LFxuICAgIG5yYXJyOiA4NjAzLFxuICAgIG5ydHJpOiA4OTM5LFxuICAgIG5zaW1lOiA4NzcyLFxuICAgIG5zbWlkOiA4NzQwLFxuICAgIG5zcGFyOiA4NzQyLFxuICAgIG5zdWJlOiA4ODQwLFxuICAgIG5zdWNjOiA4ODMzLFxuICAgIG5zdXBlOiA4ODQxLFxuICAgIG51bXNwOiA4MTk5LFxuICAgIG53QXJyOiA4NjYyLFxuICAgIG53YXJyOiA4NTk4LFxuICAgIG9jaXJjOiAyNDQsXG4gICAgb2Rhc2g6IDg4NjEsXG4gICAgb2VsaWc6IDMzOSxcbiAgICBvZmNpcjogMTA2ODcsXG4gICAgb2hiYXI6IDEwNjc3LFxuICAgIG9sYXJyOiA4NjM0LFxuICAgIG9sY2lyOiAxMDY4NixcbiAgICBvbGluZTogODI1NCxcbiAgICBvbWFjcjogMzMzLFxuICAgIG9tZWdhOiA5NjksXG4gICAgb3BlcnA6IDEwNjgxLFxuICAgIG9wbHVzOiA4ODUzLFxuICAgIG9yYXJyOiA4NjM1LFxuICAgIG9yZGVyOiA4NTAwLFxuICAgIG92YmFyOiA5MDIxLFxuICAgIHBhcnNsOiAxMTAwNSxcbiAgICBwaG9uZTogOTc0MixcbiAgICBwbHVzYjogODg2MixcbiAgICBwbHVzZTogMTA4NjYsXG4gICAgcG91bmQ6IDE2MyxcbiAgICBwcmN1ZTogODgyOCxcbiAgICBwcmltZTogODI0MixcbiAgICBwcm5hcDogMTA5MzcsXG4gICAgcHJzaW06IDg4MzAsXG4gICAgcXVlc3Q6IDYzLFxuICAgIHJBYXJyOiA4NjY3LFxuICAgIHJCYXJyOiAxMDUxMSxcbiAgICByYWRpYzogODczMCxcbiAgICByYW5nZDogMTA2NDIsXG4gICAgcmFuZ2U6IDEwNjYxLFxuICAgIHJhcXVvOiAxODcsXG4gICAgcmFycmI6IDg2NzcsXG4gICAgcmFycmM6IDEwNTQ3LFxuICAgIHJhcnJ3OiA4NjA1LFxuICAgIHJhdGlvOiA4NzU4LFxuICAgIHJiYXJyOiAxMDUwOSxcbiAgICByYmJyazogMTAwOTksXG4gICAgcmJya2U6IDEwNjM2LFxuICAgIHJjZWlsOiA4OTY5LFxuICAgIHJkcXVvOiA4MjIxLFxuICAgIHJlYWxzOiA4NDc3LFxuICAgIHJoYXJkOiA4NjQxLFxuICAgIHJoYXJ1OiA4NjQwLFxuICAgIHJsYXJyOiA4NjQ0LFxuICAgIHJsaGFyOiA4NjUyLFxuICAgIHJubWlkOiAxMDk5MCxcbiAgICByb2FuZzogMTAyMjEsXG4gICAgcm9hcnI6IDg3MDIsXG4gICAgcm9icms6IDEwMjE1LFxuICAgIHJvcGFyOiAxMDYzMCxcbiAgICBycmFycjogODY0OSxcbiAgICByc3F1bzogODIxNyxcbiAgICBydHJpZTogODg4NSxcbiAgICBydHJpZjogOTY1NixcbiAgICBzYnF1bzogODIxOCxcbiAgICBzY2N1ZTogODgyOSxcbiAgICBzY2lyYzogMzQ5LFxuICAgIHNjbmFwOiAxMDkzOCxcbiAgICBzY3NpbTogODgzMSxcbiAgICBzZG90YjogODg2NSxcbiAgICBzZG90ZTogMTA4NTQsXG4gICAgc2VBcnI6IDg2NjQsXG4gICAgc2VhcnI6IDg2MDAsXG4gICAgc2V0bW46IDg3MjYsXG4gICAgc2hhcnA6IDk4MzksXG4gICAgc2lnbWE6IDk2MyxcbiAgICBzaW1lcTogODc3MSxcbiAgICBzaW1nRTogMTA5MTIsXG4gICAgc2ltbEU6IDEwOTExLFxuICAgIHNpbW5lOiA4Nzc0LFxuICAgIHNsYXJyOiA4NTkyLFxuICAgIHNtaWxlOiA4OTk1LFxuICAgIHNxY2FwOiA4ODUxLFxuICAgIHNxY3VwOiA4ODUyLFxuICAgIHNxc3ViOiA4ODQ3LFxuICAgIHNxc3VwOiA4ODQ4LFxuICAgIHNyYXJyOiA4NTk0LFxuICAgIHN0YXJmOiA5NzMzLFxuICAgIHN0cm5zOiAxNzUsXG4gICAgc3VibkU6IDEwOTU1LFxuICAgIHN1Ym5lOiA4ODQyLFxuICAgIHN1cG5FOiAxMDk1NixcbiAgICBzdXBuZTogODg0MyxcbiAgICBzd0FycjogODY2NSxcbiAgICBzd2FycjogODYwMSxcbiAgICBzemxpZzogMjIzLFxuICAgIHRoZXRhOiA5NTIsXG4gICAgdGhrYXA6IDg3NzYsXG4gICAgdGhvcm46IDI1NCxcbiAgICB0aWxkZTogNzMyLFxuICAgIHRpbWVzOiAyMTUsXG4gICAgdHJhZGU6IDg0ODIsXG4gICAgdHJpc2I6IDEwNzAxLFxuICAgIHRzaGN5OiAxMTE1LFxuICAgIHR3aXh0OiA4ODEyLFxuICAgIHVicmN5OiAxMTE4LFxuICAgIHVjaXJjOiAyNTEsXG4gICAgdWRhcnI6IDg2NDUsXG4gICAgdWRoYXI6IDEwNjA2LFxuICAgIHVoYXJsOiA4NjM5LFxuICAgIHVoYXJyOiA4NjM4LFxuICAgIHVoYmxrOiA5NjAwLFxuICAgIHVsdHJpOiA5NzIwLFxuICAgIHVtYWNyOiAzNjMsXG4gICAgdW9nb246IDM3MSxcbiAgICB1cGx1czogODg0NixcbiAgICB1cHNpaDogOTc4LFxuICAgIHVyaW5nOiAzNjcsXG4gICAgdXJ0cmk6IDk3MjEsXG4gICAgdXRkb3Q6IDg5NDQsXG4gICAgdXRyaWY6IDk2NTIsXG4gICAgdXVhcnI6IDg2NDgsXG4gICAgdkJhcnY6IDEwOTg1LFxuICAgIHZEYXNoOiA4ODcyLFxuICAgIHZhcnBpOiA5ODIsXG4gICAgdmRhc2g6IDg4NjYsXG4gICAgdmVlZXE6IDg3OTQsXG4gICAgdmx0cmk6IDg4ODIsXG4gICAgdnByb3A6IDg3MzMsXG4gICAgdnJ0cmk6IDg4ODMsXG4gICAgd2NpcmM6IDM3MyxcbiAgICB3ZWRnZTogODc0MyxcbiAgICB4Y2lyYzogOTcxMSxcbiAgICB4ZHRyaTogOTY2MSxcbiAgICB4aEFycjogMTAyMzQsXG4gICAgeGhhcnI6IDEwMjMxLFxuICAgIHhsQXJyOiAxMDIzMixcbiAgICB4bGFycjogMTAyMjksXG4gICAgeG9kb3Q6IDEwNzUyLFxuICAgIHhyQXJyOiAxMDIzMyxcbiAgICB4cmFycjogMTAyMzAsXG4gICAgeHV0cmk6IDk2NTEsXG4gICAgeWNpcmM6IDM3NSxcbiAgICBBb3BmOiAxMjAxMjAsXG4gICAgQXNjcjogMTE5OTY0LFxuICAgIEF1bWw6IDE5NixcbiAgICBCYXJ2OiAxMDk4MyxcbiAgICBCZXRhOiA5MTQsXG4gICAgQm9wZjogMTIwMTIxLFxuICAgIEJzY3I6IDg0OTIsXG4gICAgQ0hjeTogMTA2MyxcbiAgICBDT1BZOiAxNjksXG4gICAgQ2RvdDogMjY2LFxuICAgIENvcGY6IDg0NTAsXG4gICAgQ3NjcjogMTE5OTY2LFxuICAgIERKY3k6IDEwMjYsXG4gICAgRFNjeTogMTAyOSxcbiAgICBEWmN5OiAxMDM5LFxuICAgIERhcnI6IDg2MDksXG4gICAgRG9wZjogMTIwMTIzLFxuICAgIERzY3I6IDExOTk2NyxcbiAgICBFZG90OiAyNzgsXG4gICAgRW9wZjogMTIwMTI0LFxuICAgIEVzY3I6IDg0OTYsXG4gICAgRXNpbTogMTA4NjcsXG4gICAgRXVtbDogMjAzLFxuICAgIEZvcGY6IDEyMDEyNSxcbiAgICBGc2NyOiA4NDk3LFxuICAgIEdKY3k6IDEwMjcsXG4gICAgR2RvdDogMjg4LFxuICAgIEdvcGY6IDEyMDEyNixcbiAgICBHc2NyOiAxMTk5NzAsXG4gICAgSG9wZjogODQ2MSxcbiAgICBIc2NyOiA4NDU5LFxuICAgIElFY3k6IDEwNDUsXG4gICAgSU9jeTogMTAyNSxcbiAgICBJZG90OiAzMDQsXG4gICAgSW9wZjogMTIwMTI4LFxuICAgIElvdGE6IDkyMSxcbiAgICBJc2NyOiA4NDY0LFxuICAgIEl1bWw6IDIwNyxcbiAgICBKb3BmOiAxMjAxMjksXG4gICAgSnNjcjogMTE5OTczLFxuICAgIEtIY3k6IDEwNjEsXG4gICAgS0pjeTogMTAzNixcbiAgICBLb3BmOiAxMjAxMzAsXG4gICAgS3NjcjogMTE5OTc0LFxuICAgIExKY3k6IDEwMzMsXG4gICAgTGFuZzogMTAyMTgsXG4gICAgTGFycjogODYwNixcbiAgICBMb3BmOiAxMjAxMzEsXG4gICAgTHNjcjogODQ2NixcbiAgICBNb3BmOiAxMjAxMzIsXG4gICAgTXNjcjogODQ5OSxcbiAgICBOSmN5OiAxMDM0LFxuICAgIE5vcGY6IDg0NjksXG4gICAgTnNjcjogMTE5OTc3LFxuICAgIE9vcGY6IDEyMDEzNCxcbiAgICBPc2NyOiAxMTk5NzgsXG4gICAgT3VtbDogMjE0LFxuICAgIFBvcGY6IDg0NzMsXG4gICAgUHNjcjogMTE5OTc5LFxuICAgIFFVT1Q6IDM0LFxuICAgIFFvcGY6IDg0NzQsXG4gICAgUXNjcjogMTE5OTgwLFxuICAgIFJhbmc6IDEwMjE5LFxuICAgIFJhcnI6IDg2MDgsXG4gICAgUm9wZjogODQ3NyxcbiAgICBSc2NyOiA4NDc1LFxuICAgIFNIY3k6IDEwNjQsXG4gICAgU29wZjogMTIwMTM4LFxuICAgIFNxcnQ6IDg3MzAsXG4gICAgU3NjcjogMTE5OTgyLFxuICAgIFN0YXI6IDg5MDIsXG4gICAgVFNjeTogMTA2MixcbiAgICBUb3BmOiAxMjAxMzksXG4gICAgVHNjcjogMTE5OTgzLFxuICAgIFVhcnI6IDg2MDcsXG4gICAgVW9wZjogMTIwMTQwLFxuICAgIFVwc2k6IDk3OCxcbiAgICBVc2NyOiAxMTk5ODQsXG4gICAgVXVtbDogMjIwLFxuICAgIFZiYXI6IDEwOTg3LFxuICAgIFZlcnQ6IDgyMTQsXG4gICAgVm9wZjogMTIwMTQxLFxuICAgIFZzY3I6IDExOTk4NSxcbiAgICBXb3BmOiAxMjAxNDIsXG4gICAgV3NjcjogMTE5OTg2LFxuICAgIFhvcGY6IDEyMDE0MyxcbiAgICBYc2NyOiAxMTk5ODcsXG4gICAgWUFjeTogMTA3MSxcbiAgICBZSWN5OiAxMDMxLFxuICAgIFlVY3k6IDEwNzAsXG4gICAgWW9wZjogMTIwMTQ0LFxuICAgIFlzY3I6IDExOTk4OCxcbiAgICBZdW1sOiAzNzYsXG4gICAgWkhjeTogMTA0NixcbiAgICBaZG90OiAzNzksXG4gICAgWmV0YTogOTE4LFxuICAgIFpvcGY6IDg0ODQsXG4gICAgWnNjcjogMTE5OTg5LFxuICAgIGFuZGQ6IDEwODQ0LFxuICAgIGFuZHY6IDEwODQyLFxuICAgIGFuZ2U6IDEwNjYwLFxuICAgIGFvcGY6IDEyMDE0NixcbiAgICBhcGlkOiA4Nzc5LFxuICAgIGFwb3M6IDM5LFxuICAgIGFzY3I6IDExOTk5MCxcbiAgICBhdW1sOiAyMjgsXG4gICAgYk5vdDogMTA5ODksXG4gICAgYmJyazogOTE0MSxcbiAgICBiZXRhOiA5NDYsXG4gICAgYmV0aDogODUwMixcbiAgICBibm90OiA4OTc2LFxuICAgIGJvcGY6IDEyMDE0NyxcbiAgICBib3hIOiA5NTUyLFxuICAgIGJveFY6IDk1NTMsXG4gICAgYm94aDogOTQ3MixcbiAgICBib3h2OiA5NDc0LFxuICAgIGJzY3I6IDExOTk5MSxcbiAgICBic2ltOiA4NzY1LFxuICAgIGJzb2w6IDkyLFxuICAgIGJ1bGw6IDgyMjYsXG4gICAgYnVtcDogODc4MixcbiAgICBjZG90OiAyNjcsXG4gICAgY2VudDogMTYyLFxuICAgIGNoY3k6IDEwOTUsXG4gICAgY2lyRTogMTA2OTEsXG4gICAgY2lyYzogNzEwLFxuICAgIGNpcmU6IDg3OTEsXG4gICAgY29tcDogODcwNSxcbiAgICBjb25nOiA4NzczLFxuICAgIGNvcGY6IDEyMDE0OCxcbiAgICBjb3B5OiAxNjksXG4gICAgY3NjcjogMTE5OTkyLFxuICAgIGNzdWI6IDEwOTU5LFxuICAgIGNzdXA6IDEwOTYwLFxuICAgIGRBcnI6IDg2NTksXG4gICAgZEhhcjogMTA1OTcsXG4gICAgZGFycjogODU5NSxcbiAgICBkYXNoOiA4MjA4LFxuICAgIGRpYW06IDg5MDAsXG4gICAgZGpjeTogMTEwNixcbiAgICBkb3BmOiAxMjAxNDksXG4gICAgZHNjcjogMTE5OTkzLFxuICAgIGRzY3k6IDExMDksXG4gICAgZHNvbDogMTA3NDIsXG4gICAgZHRyaTogOTY2MyxcbiAgICBkemN5OiAxMTE5LFxuICAgIGVEb3Q6IDg3ODUsXG4gICAgZWNpcjogODc5MCxcbiAgICBlZG90OiAyNzksXG4gICAgZW1zcDogODE5NSxcbiAgICBlbnNwOiA4MTk0LFxuICAgIGVvcGY6IDEyMDE1MCxcbiAgICBlcGFyOiA4OTE3LFxuICAgIGVwc2k6IDEwMTMsXG4gICAgZXNjcjogODQ5NSxcbiAgICBlc2ltOiA4NzcwLFxuICAgIGV1bWw6IDIzNSxcbiAgICBldXJvOiA4MzY0LFxuICAgIGV4Y2w6IDMzLFxuICAgIGZsYXQ6IDk4MzcsXG4gICAgZm5vZjogNDAyLFxuICAgIGZvcGY6IDEyMDE1MSxcbiAgICBmb3JrOiA4OTE2LFxuICAgIGZzY3I6IDExOTk5NSxcbiAgICBnZG90OiAyODksXG4gICAgZ2VxcTogODgwNyxcbiAgICBnamN5OiAxMTA3LFxuICAgIGduYXA6IDEwODkwLFxuICAgIGduZXE6IDEwODg4LFxuICAgIGdvcGY6IDEyMDE1MixcbiAgICBnc2NyOiA4NDU4LFxuICAgIGdzaW06IDg4MTksXG4gICAgZ3RjYzogMTA5MTksXG4gICAgaEFycjogODY2MCxcbiAgICBoYWxmOiAxODksXG4gICAgaGFycjogODU5NixcbiAgICBoYmFyOiA4NDYzLFxuICAgIGhvcGY6IDEyMDE1MyxcbiAgICBoc2NyOiAxMTk5OTcsXG4gICAgaWVjeTogMTA3NyxcbiAgICBpbW9mOiA4ODg3LFxuICAgIGlvY3k6IDExMDUsXG4gICAgaW9wZjogMTIwMTU0LFxuICAgIGlvdGE6IDk1MyxcbiAgICBpc2NyOiAxMTk5OTgsXG4gICAgaXNpbjogODcxMixcbiAgICBpdW1sOiAyMzksXG4gICAgam9wZjogMTIwMTU1LFxuICAgIGpzY3I6IDExOTk5OSxcbiAgICBraGN5OiAxMDkzLFxuICAgIGtqY3k6IDExMTYsXG4gICAga29wZjogMTIwMTU2LFxuICAgIGtzY3I6IDEyMDAwMCxcbiAgICBsQXJyOiA4NjU2LFxuICAgIGxIYXI6IDEwNTk0LFxuICAgIGxhbmc6IDEwMjE2LFxuICAgIGxhcnI6IDg1OTIsXG4gICAgbGF0ZTogMTA5MjUsXG4gICAgbGN1YjogMTIzLFxuICAgIGxkY2E6IDEwNTUwLFxuICAgIGxkc2g6IDg2MjYsXG4gICAgbGVxcTogODgwNixcbiAgICBsamN5OiAxMTEzLFxuICAgIGxuYXA6IDEwODg5LFxuICAgIGxuZXE6IDEwODg3LFxuICAgIGxvcGY6IDEyMDE1NyxcbiAgICBsb3pmOiAxMDczMSxcbiAgICBscGFyOiA0MCxcbiAgICBsc2NyOiAxMjAwMDEsXG4gICAgbHNpbTogODgxOCxcbiAgICBsc3FiOiA5MSxcbiAgICBsdGNjOiAxMDkxOCxcbiAgICBsdHJpOiA5NjY3LFxuICAgIG1hY3I6IDE3NSxcbiAgICBtYWxlOiA5Nzk0LFxuICAgIG1hbHQ6IDEwMDE2LFxuICAgIG1sY3A6IDEwOTcxLFxuICAgIG1sZHI6IDgyMzAsXG4gICAgbW9wZjogMTIwMTU4LFxuICAgIG1zY3I6IDEyMDAwMixcbiAgICBuYnNwOiAxNjAsXG4gICAgbmNhcDogMTA4MTksXG4gICAgbmN1cDogMTA4MTgsXG4gICAgbmdlcTogODgxNyxcbiAgICBuZ3RyOiA4ODE1LFxuICAgIG5pc2Q6IDg5NTQsXG4gICAgbmpjeTogMTExNCxcbiAgICBubGRyOiA4MjI5LFxuICAgIG5sZXE6IDg4MTYsXG4gICAgbm1pZDogODc0MCxcbiAgICBub3BmOiAxMjAxNTksXG4gICAgbnBhcjogODc0MixcbiAgICBuc2NyOiAxMjAwMDMsXG4gICAgbnNpbTogODc2OSxcbiAgICBuc3ViOiA4ODM2LFxuICAgIG5zdXA6IDg4MzcsXG4gICAgbnRnbDogODgyNSxcbiAgICBudGxnOiA4ODI0LFxuICAgIG9hc3Q6IDg4NTksXG4gICAgb2NpcjogODg1OCxcbiAgICBvZGl2OiAxMDgwOCxcbiAgICBvZG90OiA4ODU3LFxuICAgIG9nb246IDczMSxcbiAgICBvaW50OiA4NzUwLFxuICAgIG9taWQ6IDEwNjc4LFxuICAgIG9vcGY6IDEyMDE2MCxcbiAgICBvcGFyOiAxMDY3OSxcbiAgICBvcmRmOiAxNzAsXG4gICAgb3JkbTogMTg2LFxuICAgIG9yb3I6IDEwODM4LFxuICAgIG9zY3I6IDg1MDAsXG4gICAgb3NvbDogODg1NixcbiAgICBvdW1sOiAyNDYsXG4gICAgcGFyYTogMTgyLFxuICAgIHBhcnQ6IDg3MDYsXG4gICAgcGVycDogODg2OSxcbiAgICBwaGl2OiA5NjYsXG4gICAgcGx1czogNDMsXG4gICAgcG9wZjogMTIwMTYxLFxuICAgIHByYXA6IDEwOTM1LFxuICAgIHByZWM6IDg4MjYsXG4gICAgcHJuRTogMTA5MzMsXG4gICAgcHJvZDogODcxOSxcbiAgICBwcm9wOiA4NzMzLFxuICAgIHBzY3I6IDEyMDAwNSxcbiAgICBxaW50OiAxMDc2NCxcbiAgICBxb3BmOiAxMjAxNjIsXG4gICAgcXNjcjogMTIwMDA2LFxuICAgIHF1b3Q6IDM0LFxuICAgIHJBcnI6IDg2NTgsXG4gICAgckhhcjogMTA1OTYsXG4gICAgcmFjZTogMTA3MTQsXG4gICAgcmFuZzogMTAyMTcsXG4gICAgcmFycjogODU5NCxcbiAgICByY3ViOiAxMjUsXG4gICAgcmRjYTogMTA1NTEsXG4gICAgcmRzaDogODYyNyxcbiAgICByZWFsOiA4NDc2LFxuICAgIHJlY3Q6IDk2NDUsXG4gICAgcmhvdjogMTAwOSxcbiAgICByaW5nOiA3MzAsXG4gICAgcm9wZjogMTIwMTYzLFxuICAgIHJwYXI6IDQxLFxuICAgIHJzY3I6IDEyMDAwNyxcbiAgICByc3FiOiA5MyxcbiAgICBydHJpOiA5NjU3LFxuICAgIHNjYXA6IDEwOTM2LFxuICAgIHNjbkU6IDEwOTM0LFxuICAgIHNkb3Q6IDg5MDEsXG4gICAgc2VjdDogMTY3LFxuICAgIHNlbWk6IDU5LFxuICAgIHNleHQ6IDEwMDM4LFxuICAgIHNoY3k6IDEwOTYsXG4gICAgc2ltZTogODc3MSxcbiAgICBzaW1nOiAxMDkxMCxcbiAgICBzaW1sOiAxMDkwOSxcbiAgICBzbWlkOiA4NzM5LFxuICAgIHNtdGU6IDEwOTI0LFxuICAgIHNvbGI6IDEwNjkyLFxuICAgIHNvcGY6IDEyMDE2NCxcbiAgICBzcGFyOiA4NzQxLFxuICAgIHNxdWY6IDk2NDIsXG4gICAgc3NjcjogMTIwMDA4LFxuICAgIHN0YXI6IDk3MzQsXG4gICAgc3ViRTogMTA5NDksXG4gICAgc3ViZTogODgzOCxcbiAgICBzdWNjOiA4ODI3LFxuICAgIHN1bmc6IDk4MzQsXG4gICAgc3VwMTogMTg1LFxuICAgIHN1cDI6IDE3OCxcbiAgICBzdXAzOiAxNzksXG4gICAgc3VwRTogMTA5NTAsXG4gICAgc3VwZTogODgzOSxcbiAgICB0YnJrOiA5MTQwLFxuICAgIHRkb3Q6IDg0MTEsXG4gICAgdGludDogODc0OSxcbiAgICB0b2VhOiAxMDUzNixcbiAgICB0b3BmOiAxMjAxNjUsXG4gICAgdG9zYTogMTA1MzcsXG4gICAgdHJpZTogODc5NixcbiAgICB0c2NyOiAxMjAwMDksXG4gICAgdHNjeTogMTA5NCxcbiAgICB1QXJyOiA4NjU3LFxuICAgIHVIYXI6IDEwNTk1LFxuICAgIHVhcnI6IDg1OTMsXG4gICAgdW9wZjogMTIwMTY2LFxuICAgIHVwc2k6IDk2NSxcbiAgICB1c2NyOiAxMjAwMTAsXG4gICAgdXRyaTogOTY1MyxcbiAgICB1dW1sOiAyNTIsXG4gICAgdkFycjogODY2MSxcbiAgICB2QmFyOiAxMDk4NCxcbiAgICB2YXJyOiA4NTk3LFxuICAgIHZlcnQ6IDEyNCxcbiAgICB2b3BmOiAxMjAxNjcsXG4gICAgdnNjcjogMTIwMDExLFxuICAgIHdvcGY6IDEyMDE2OCxcbiAgICB3c2NyOiAxMjAwMTIsXG4gICAgeGNhcDogODg5OCxcbiAgICB4Y3VwOiA4ODk5LFxuICAgIHhtYXA6IDEwMjM2LFxuICAgIHhuaXM6IDg5NTUsXG4gICAgeG9wZjogMTIwMTY5LFxuICAgIHhzY3I6IDEyMDAxMyxcbiAgICB4dmVlOiA4ODk3LFxuICAgIHlhY3k6IDExMDMsXG4gICAgeWljeTogMTExMSxcbiAgICB5b3BmOiAxMjAxNzAsXG4gICAgeXNjcjogMTIwMDE0LFxuICAgIHl1Y3k6IDExMDIsXG4gICAgeXVtbDogMjU1LFxuICAgIHpkb3Q6IDM4MCxcbiAgICB6ZXRhOiA5NTAsXG4gICAgemhjeTogMTA3OCxcbiAgICB6b3BmOiAxMjAxNzEsXG4gICAgenNjcjogMTIwMDE1LFxuICAgIHp3bmo6IDgyMDQsXG4gICAgQU1QOiAzOCxcbiAgICBBY3k6IDEwNDAsXG4gICAgQWZyOiAxMjAwNjgsXG4gICAgQW5kOiAxMDgzNSxcbiAgICBCY3k6IDEwNDEsXG4gICAgQmZyOiAxMjAwNjksXG4gICAgQ2FwOiA4OTE0LFxuICAgIENmcjogODQ5MyxcbiAgICBDaGk6IDkzNSxcbiAgICBDdXA6IDg5MTUsXG4gICAgRGN5OiAxMDQ0LFxuICAgIERlbDogODcxMSxcbiAgICBEZnI6IDEyMDA3MSxcbiAgICBEb3Q6IDE2OCxcbiAgICBFTkc6IDMzMCxcbiAgICBFVEg6IDIwOCxcbiAgICBFY3k6IDEwNjksXG4gICAgRWZyOiAxMjAwNzIsXG4gICAgRXRhOiA5MTksXG4gICAgRmN5OiAxMDYwLFxuICAgIEZmcjogMTIwMDczLFxuICAgIEdjeTogMTA0MyxcbiAgICBHZnI6IDEyMDA3NCxcbiAgICBIYXQ6IDk0LFxuICAgIEhmcjogODQ2MCxcbiAgICBJY3k6IDEwNDgsXG4gICAgSWZyOiA4NDY1LFxuICAgIEludDogODc0OCxcbiAgICBKY3k6IDEwNDksXG4gICAgSmZyOiAxMjAwNzcsXG4gICAgS2N5OiAxMDUwLFxuICAgIEtmcjogMTIwMDc4LFxuICAgIExjeTogMTA1MSxcbiAgICBMZnI6IDEyMDA3OSxcbiAgICBMc2g6IDg2MjQsXG4gICAgTWFwOiAxMDUwMSxcbiAgICBNY3k6IDEwNTIsXG4gICAgTWZyOiAxMjAwODAsXG4gICAgTmN5OiAxMDUzLFxuICAgIE5mcjogMTIwMDgxLFxuICAgIE5vdDogMTA5ODgsXG4gICAgT2N5OiAxMDU0LFxuICAgIE9mcjogMTIwMDgyLFxuICAgIFBjeTogMTA1NSxcbiAgICBQZnI6IDEyMDA4MyxcbiAgICBQaGk6IDkzNCxcbiAgICBQc2k6IDkzNixcbiAgICBRZnI6IDEyMDA4NCxcbiAgICBSRUc6IDE3NCxcbiAgICBSY3k6IDEwNTYsXG4gICAgUmZyOiA4NDc2LFxuICAgIFJobzogOTI5LFxuICAgIFJzaDogODYyNSxcbiAgICBTY3k6IDEwNTcsXG4gICAgU2ZyOiAxMjAwODYsXG4gICAgU3ViOiA4OTEyLFxuICAgIFN1bTogODcyMSxcbiAgICBTdXA6IDg5MTMsXG4gICAgVGFiOiA5LFxuICAgIFRhdTogOTMyLFxuICAgIFRjeTogMTA1OCxcbiAgICBUZnI6IDEyMDA4NyxcbiAgICBVY3k6IDEwNTksXG4gICAgVWZyOiAxMjAwODgsXG4gICAgVmN5OiAxMDQyLFxuICAgIFZlZTogODg5NyxcbiAgICBWZnI6IDEyMDA4OSxcbiAgICBXZnI6IDEyMDA5MCxcbiAgICBYZnI6IDEyMDA5MSxcbiAgICBZY3k6IDEwNjcsXG4gICAgWWZyOiAxMjAwOTIsXG4gICAgWmN5OiAxMDQ3LFxuICAgIFpmcjogODQ4OCxcbiAgICBhY2Q6IDg3NjcsXG4gICAgYWN5OiAxMDcyLFxuICAgIGFmcjogMTIwMDk0LFxuICAgIGFtcDogMzgsXG4gICAgYW5kOiA4NzQzLFxuICAgIGFuZzogODczNixcbiAgICBhcEU6IDEwODY0LFxuICAgIGFwZTogODc3OCxcbiAgICBhc3Q6IDQyLFxuICAgIGJjeTogMTA3MyxcbiAgICBiZnI6IDEyMDA5NSxcbiAgICBib3Q6IDg4NjksXG4gICAgY2FwOiA4NzQ1LFxuICAgIGNmcjogMTIwMDk2LFxuICAgIGNoaTogOTY3LFxuICAgIGNpcjogOTY3NSxcbiAgICBjdXA6IDg3NDYsXG4gICAgZGN5OiAxMDc2LFxuICAgIGRlZzogMTc2LFxuICAgIGRmcjogMTIwMDk3LFxuICAgIGRpZTogMTY4LFxuICAgIGRpdjogMjQ3LFxuICAgIGRvdDogNzI5LFxuICAgIGVjeTogMTEwMSxcbiAgICBlZnI6IDEyMDA5OCxcbiAgICBlZ3M6IDEwOTAyLFxuICAgIGVsbDogODQ2NyxcbiAgICBlbHM6IDEwOTAxLFxuICAgIGVuZzogMzMxLFxuICAgIGV0YTogOTUxLFxuICAgIGV0aDogMjQwLFxuICAgIGZjeTogMTA5MixcbiAgICBmZnI6IDEyMDA5OSxcbiAgICBnRWw6IDEwODkyLFxuICAgIGdhcDogMTA4ODYsXG4gICAgZ2N5OiAxMDc1LFxuICAgIGdlbDogODkyMyxcbiAgICBnZXE6IDg4MDUsXG4gICAgZ2VzOiAxMDg3OCxcbiAgICBnZnI6IDEyMDEwMCxcbiAgICBnZ2c6IDg5MjEsXG4gICAgZ2xFOiAxMDg5OCxcbiAgICBnbGE6IDEwOTE3LFxuICAgIGdsajogMTA5MTYsXG4gICAgZ25FOiA4ODA5LFxuICAgIGduZTogMTA4ODgsXG4gICAgaGZyOiAxMjAxMDEsXG4gICAgaWN5OiAxMDgwLFxuICAgIGlmZjogODY2MCxcbiAgICBpZnI6IDEyMDEwMixcbiAgICBpbnQ6IDg3NDcsXG4gICAgamN5OiAxMDgxLFxuICAgIGpmcjogMTIwMTAzLFxuICAgIGtjeTogMTA4MixcbiAgICBrZnI6IDEyMDEwNCxcbiAgICBsRWc6IDEwODkxLFxuICAgIGxhcDogMTA4ODUsXG4gICAgbGF0OiAxMDkyMyxcbiAgICBsY3k6IDEwODMsXG4gICAgbGVnOiA4OTIyLFxuICAgIGxlcTogODgwNCxcbiAgICBsZXM6IDEwODc3LFxuICAgIGxmcjogMTIwMTA1LFxuICAgIGxnRTogMTA4OTcsXG4gICAgbG5FOiA4ODA4LFxuICAgIGxuZTogMTA4ODcsXG4gICAgbG96OiA5Njc0LFxuICAgIGxybTogODIwNixcbiAgICBsc2g6IDg2MjQsXG4gICAgbWFwOiA4NjE0LFxuICAgIG1jeTogMTA4NCxcbiAgICBtZnI6IDEyMDEwNixcbiAgICBtaG86IDg0ODcsXG4gICAgbWlkOiA4NzM5LFxuICAgIG5hcDogODc3NyxcbiAgICBuY3k6IDEwODUsXG4gICAgbmZyOiAxMjAxMDcsXG4gICAgbmdlOiA4ODE3LFxuICAgIG5ndDogODgxNSxcbiAgICBuaXM6IDg5NTYsXG4gICAgbml2OiA4NzE1LFxuICAgIG5sZTogODgxNixcbiAgICBubHQ6IDg4MTQsXG4gICAgbm90OiAxNzIsXG4gICAgbnByOiA4ODMyLFxuICAgIG5zYzogODgzMyxcbiAgICBudW06IDM1LFxuICAgIG9jeTogMTA4NixcbiAgICBvZnI6IDEyMDEwOCxcbiAgICBvZ3Q6IDEwNjg5LFxuICAgIG9obTogODQ4NixcbiAgICBvbHQ6IDEwNjg4LFxuICAgIG9yZDogMTA4NDUsXG4gICAgb3J2OiAxMDg0MyxcbiAgICBwYXI6IDg3NDEsXG4gICAgcGN5OiAxMDg3LFxuICAgIHBmcjogMTIwMTA5LFxuICAgIHBoaTogOTY2LFxuICAgIHBpdjogOTgyLFxuICAgIHByRTogMTA5MzEsXG4gICAgcHJlOiAxMDkyNyxcbiAgICBwc2k6IDk2OCxcbiAgICBxZnI6IDEyMDExMCxcbiAgICByY3k6IDEwODgsXG4gICAgcmVnOiAxNzQsXG4gICAgcmZyOiAxMjAxMTEsXG4gICAgcmhvOiA5NjEsXG4gICAgcmxtOiA4MjA3LFxuICAgIHJzaDogODYyNSxcbiAgICBzY0U6IDEwOTMyLFxuICAgIHNjZTogMTA5MjgsXG4gICAgc2N5OiAxMDg5LFxuICAgIHNmcjogMTIwMTEyLFxuICAgIHNoeTogMTczLFxuICAgIHNpbTogODc2NCxcbiAgICBzbXQ6IDEwOTIyLFxuICAgIHNvbDogNDcsXG4gICAgc3F1OiA5NjMzLFxuICAgIHN1YjogODgzNCxcbiAgICBzdW06IDg3MjEsXG4gICAgc3VwOiA4ODM1LFxuICAgIHRhdTogOTY0LFxuICAgIHRjeTogMTA5MCxcbiAgICB0ZnI6IDEyMDExMyxcbiAgICB0b3A6IDg4NjgsXG4gICAgdWN5OiAxMDkxLFxuICAgIHVmcjogMTIwMTE0LFxuICAgIHVtbDogMTY4LFxuICAgIHZjeTogMTA3NCxcbiAgICB2ZWU6IDg3NDQsXG4gICAgdmZyOiAxMjAxMTUsXG4gICAgd2ZyOiAxMjAxMTYsXG4gICAgeGZyOiAxMjAxMTcsXG4gICAgeWN5OiAxMDk5LFxuICAgIHllbjogMTY1LFxuICAgIHlmcjogMTIwMTE4LFxuICAgIHpjeTogMTA3OSxcbiAgICB6ZnI6IDEyMDExOSxcbiAgICB6d2o6IDgyMDUsXG4gICAgREQ6IDg1MTcsXG4gICAgR1Q6IDYyLFxuICAgIEdnOiA4OTIxLFxuICAgIEd0OiA4ODExLFxuICAgIEltOiA4NDY1LFxuICAgIExUOiA2MCxcbiAgICBMbDogODkyMCxcbiAgICBMdDogODgxMCxcbiAgICBNdTogOTI0LFxuICAgIE51OiA5MjUsXG4gICAgT3I6IDEwODM2LFxuICAgIFBpOiA5MjgsXG4gICAgUHI6IDEwOTM5LFxuICAgIFJlOiA4NDc2LFxuICAgIFNjOiAxMDk0MCxcbiAgICBYaTogOTI2LFxuICAgIGFjOiA4NzY2LFxuICAgIGFmOiA4Mjg5LFxuICAgIGFwOiA4Nzc2LFxuICAgIGRkOiA4NTE4LFxuICAgIGVlOiA4NTE5LFxuICAgIGVnOiAxMDkwNixcbiAgICBlbDogMTA5MDUsXG4gICAgZ0U6IDg4MDcsXG4gICAgZ2U6IDg4MDUsXG4gICAgZ2c6IDg4MTEsXG4gICAgZ2w6IDg4MjMsXG4gICAgZ3Q6IDYyLFxuICAgIGljOiA4MjkxLFxuICAgIGlpOiA4NTIwLFxuICAgIFwiaW5cIjogODcxMixcbiAgICBpdDogODI5MCxcbiAgICBsRTogODgwNixcbiAgICBsZTogODgwNCxcbiAgICBsZzogODgyMixcbiAgICBsbDogODgxMCxcbiAgICBsdDogNjAsXG4gICAgbXA6IDg3MjMsXG4gICAgbXU6IDk1NixcbiAgICBuZTogODgwMCxcbiAgICBuaTogODcxNSxcbiAgICBudTogOTU3LFxuICAgIG9TOiA5NDE2LFxuICAgIG9yOiA4NzQ0LFxuICAgIHBpOiA5NjAsXG4gICAgcG06IDE3NyxcbiAgICBwcjogODgyNixcbiAgICByeDogODQ3OCxcbiAgICBzYzogODgyNyxcbiAgICB3cDogODQ3MixcbiAgICB3cjogODc2OCxcbiAgICB4aTogOTU4XG59O1xuXG52YXIgd2luZG93czEyNTIgPSBbXG4gICAgODM2NCxcbiAgICAxMjksXG4gICAgODIxOCxcbiAgICA0MDIsXG4gICAgODIyMixcbiAgICA4MjMwLFxuICAgIDgyMjQsXG4gICAgODIyNSxcbiAgICA3MTAsXG4gICAgODI0MCxcbiAgICAzNTIsXG4gICAgODI0OSxcbiAgICAzMzgsXG4gICAgMTQxLFxuICAgIDM4MSxcbiAgICAxNDMsXG4gICAgMTQ0LFxuICAgIDgyMTYsXG4gICAgODIxNyxcbiAgICA4MjIwLFxuICAgIDgyMjEsXG4gICAgODIyNixcbiAgICA4MjExLFxuICAgIDgyMTIsXG4gICAgNzMyLFxuICAgIDg0ODIsXG4gICAgMzUzLFxuICAgIDgyNTAsXG4gICAgMzM5LFxuICAgIDE1NyxcbiAgICAzODIsXG4gICAgMzc2LFxuXTtcbnZhciBlbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cChcIiYoIz8oPzp4W1xcXFx3XFxcXGRdK3xcXFxcZCt8XCIgKyBPYmplY3Qua2V5cyhodG1sRW50aXRpZXMpLmpvaW4oJ3wnKSArIFwiKSk7P1wiLCAnZycpO1xuZnVuY3Rpb24gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyhodG1sKSB7XG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZShlbnRpdHlQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gsIGVudGl0eSkge1xuICAgICAgICB2YXIgY29kZTtcbiAgICAgICAgLy8gSGFuZGxlIG5hbWVkIGVudGl0aWVzXG4gICAgICAgIGlmIChlbnRpdHlbMF0gIT09ICcjJykge1xuICAgICAgICAgICAgY29kZSA9IGh0bWxFbnRpdGllc1tlbnRpdHldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudGl0eVsxXSA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBjb2RlID0gcGFyc2VJbnQoZW50aXR5LnN1YnN0cmluZygyKSwgMTYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZSA9IHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMSksIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21Db2RlUG9pbnQodmFsaWRhdGVDb2RlKGNvZGUpKTtcbiAgICB9KTtcbn1cbnZhciBOVUwgPSAwO1xuLy8gc29tZSBjb2RlIHBvaW50cyBhcmUgdmVyYm90ZW4uIElmIHdlIHdlcmUgaW5zZXJ0aW5nIEhUTUwsIHRoZSBicm93c2VyIHdvdWxkIHJlcGxhY2UgdGhlIGlsbGVnYWxcbi8vIGNvZGUgcG9pbnRzIHdpdGggYWx0ZXJuYXRpdmVzIGluIHNvbWUgY2FzZXMgLSBzaW5jZSB3ZSdyZSBieXBhc3NpbmcgdGhhdCBtZWNoYW5pc20sIHdlIG5lZWRcbi8vIHRvIHJlcGxhY2UgdGhlbSBvdXJzZWx2ZXNcbi8vXG4vLyBTb3VyY2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcmFjdGVyX2VuY29kaW5nc19pbl9IVE1MI0lsbGVnYWxfY2hhcmFjdGVyc1xuZnVuY3Rpb24gdmFsaWRhdGVDb2RlKGNvZGUpIHtcbiAgICAvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2VcbiAgICBpZiAoY29kZSA9PT0gMTApIHtcbiAgICAgICAgcmV0dXJuIDMyO1xuICAgIH1cbiAgICAvLyBBU0NJSSByYW5nZS4gKFdoeSBzb21lb25lIHdvdWxkIHVzZSBIVE1MIGVudGl0aWVzIGZvciBBU0NJSSBjaGFyYWN0ZXJzIEkgZG9uJ3Qga25vdywgYnV0Li4uKVxuICAgIGlmIChjb2RlIDwgMTI4KSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICAvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG4gICAgLy8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cbiAgICBpZiAoY29kZSA8PSAxNTkpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvd3MxMjUyW2NvZGUgLSAxMjhdO1xuICAgIH1cbiAgICAvLyBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcbiAgICBpZiAoY29kZSA8IDU1Mjk2KSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICAvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuICAgIGlmIChjb2RlIDw9IDU3MzQzKSB7XG4gICAgICAgIHJldHVybiBOVUw7XG4gICAgfVxuICAgIC8vIHJlc3Qgb2YgdGhlIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuICAgIGlmIChjb2RlIDw9IDY1NTM1KSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICAvLyBzdXBwbGVtZW50YXJ5IG11bHRpbGluZ3VhbCBwbGFuZSAweDEwMDAwIC0gMHgxZmZmZlxuICAgIGlmIChjb2RlID49IDY1NTM2ICYmIGNvZGUgPD0gMTMxMDcxKSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICAvLyBzdXBwbGVtZW50YXJ5IGlkZW9ncmFwaGljIHBsYW5lIDB4MjAwMDAgLSAweDJmZmZmXG4gICAgaWYgKGNvZGUgPj0gMTMxMDcyICYmIGNvZGUgPD0gMTk2NjA3KSB7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gTlVMO1xufVxuXG52YXIgdm9pZEVsZW1lbnROYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC87XG5mdW5jdGlvbiBpc1ZvaWRFbGVtZW50TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHZvaWRFbGVtZW50TmFtZXMudGVzdChuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbnZhciB2YWxpZFRhZ05hbWUgPSAvXlxcIT9bYS16QS1aXXsxLH06P1thLXpBLVowLTlcXC1dKi87XG52YXIgU0VMRiA9ICc6U2VsZic7XG52YXIgQ09NUE9ORU5UID0gJzpDb21wb25lbnQnO1xudmFyIG1ldGFUYWdzID0gbmV3IFNldChbXG4gICAgJzpXaW5kb3cnLFxuICAgICc6SGVhZCdcbl0pO1xudmFyIHNwZWNpYWxzID0gbmV3IE1hcChbXG4gICAgW1xuICAgICAgICAnc2NyaXB0JyxcbiAgICAgICAge1xuICAgICAgICAgICAgcmVhZDogcmVhZFNjcmlwdCxcbiAgICAgICAgICAgIHByb3BlcnR5OiAnanMnXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBbXG4gICAgICAgICdzdHlsZScsXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlYWQ6IHJlYWRTdHlsZSxcbiAgICAgICAgICAgIHByb3BlcnR5OiAnY3NzJ1xuICAgICAgICB9LFxuICAgIF0sXG5dKTtcbi8vIGJhc2VkIG9uIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LXRhZy1vbWlzc2lvblxudmFyIGRpc2FsbG93ZWRDb250ZW50cyA9IG5ldyBNYXAoW1xuICAgIFsnbGknLCBuZXcgU2V0KFsnbGknXSldLFxuICAgIFsnZHQnLCBuZXcgU2V0KFsnZHQnLCAnZGQnXSldLFxuICAgIFsnZGQnLCBuZXcgU2V0KFsnZHQnLCAnZGQnXSldLFxuICAgIFtcbiAgICAgICAgJ3AnLFxuICAgICAgICBuZXcgU2V0KCdhZGRyZXNzIGFydGljbGUgYXNpZGUgYmxvY2txdW90ZSBkaXYgZGwgZmllbGRzZXQgZm9vdGVyIGZvcm0gaDEgaDIgaDMgaDQgaDUgaDYgaGVhZGVyIGhncm91cCBociBtYWluIG1lbnUgbmF2IG9sIHAgcHJlIHNlY3Rpb24gdGFibGUgdWwnLnNwbGl0KCcgJykpLFxuICAgIF0sXG4gICAgWydydCcsIG5ldyBTZXQoWydydCcsICdycCddKV0sXG4gICAgWydycCcsIG5ldyBTZXQoWydydCcsICdycCddKV0sXG4gICAgWydvcHRncm91cCcsIG5ldyBTZXQoWydvcHRncm91cCddKV0sXG4gICAgWydvcHRpb24nLCBuZXcgU2V0KFsnb3B0aW9uJywgJ29wdGdyb3VwJ10pXSxcbiAgICBbJ3RoZWFkJywgbmV3IFNldChbJ3Rib2R5JywgJ3Rmb290J10pXSxcbiAgICBbJ3Rib2R5JywgbmV3IFNldChbJ3Rib2R5JywgJ3Rmb290J10pXSxcbiAgICBbJ3Rmb290JywgbmV3IFNldChbJ3Rib2R5J10pXSxcbiAgICBbJ3RyJywgbmV3IFNldChbJ3RyJywgJ3Rib2R5J10pXSxcbiAgICBbJ3RkJywgbmV3IFNldChbJ3RkJywgJ3RoJywgJ3RyJ10pXSxcbiAgICBbJ3RoJywgbmV3IFNldChbJ3RkJywgJ3RoJywgJ3RyJ10pXSxcbl0pO1xuZnVuY3Rpb24gdGFnKHBhcnNlcikge1xuICAgIHZhciBzdGFydCA9IHBhcnNlci5pbmRleCsrO1xuICAgIHZhciBwYXJlbnQgPSBwYXJzZXIuY3VycmVudCgpO1xuICAgIGlmIChwYXJzZXIuZWF0KCchLS0nKSkge1xuICAgICAgICB2YXIgZGF0YSA9IHBhcnNlci5yZWFkVW50aWwoLy0tPi8pO1xuICAgICAgICBwYXJzZXIuZWF0KCctLT4nKTtcbiAgICAgICAgcGFyc2VyLmN1cnJlbnQoKS5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogcGFyc2VyLmluZGV4LFxuICAgICAgICAgICAgdHlwZTogJ0NvbW1lbnQnLFxuICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaXNDbG9zaW5nVGFnID0gcGFyc2VyLmVhdCgnLycpO1xuICAgIHZhciBuYW1lID0gcmVhZFRhZ05hbWUocGFyc2VyKTtcbiAgICBpZiAobWV0YVRhZ3MuaGFzKG5hbWUpKSB7XG4gICAgICAgIGlmIChpc0Nsb3NpbmdUYWcpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnOldpbmRvdycgJiYgcGFyc2VyLmN1cnJlbnQoKS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyb3IoXCI8OldpbmRvdz4gY2Fubm90IGhhdmUgY2hpbGRyZW5cIiwgcGFyc2VyLmN1cnJlbnQoKS5jaGlsZHJlblswXS5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmFtZSBpbiBwYXJzZXIubWV0YVRhZ3MpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyb3IoXCJBIGNvbXBvbmVudCBjYW4gb25seSBoYXZlIG9uZSA8XCIgKyBuYW1lICsgXCI+IHRhZ1wiLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VyLnN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwYXJzZXIuc3RhY2spO1xuICAgICAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIjxcIiArIG5hbWUgKyBcIj4gdGFncyBjYW5ub3QgYmUgaW5zaWRlIGVsZW1lbnRzIG9yIGJsb2Nrc1wiLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIubWV0YVRhZ3NbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgdHlwZTogJ0VsZW1lbnQnLFxuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcbiAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgaWYgKGlzQ2xvc2luZ1RhZykge1xuICAgICAgICBpZiAoaXNWb2lkRWxlbWVudE5hbWUobmFtZSkpIHtcbiAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIjxcIiArIG5hbWUgKyBcIj4gaXMgYSB2b2lkIGVsZW1lbnQgYW5kIGNhbm5vdCBoYXZlIGNoaWxkcmVuLCBvciBhIGNsb3NpbmcgdGFnXCIsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcnNlci5lYXQoJz4nKSlcbiAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIkV4cGVjdGVkICc+J1wiKTtcbiAgICAgICAgLy8gY2xvc2UgYW55IGVsZW1lbnRzIHRoYXQgZG9uJ3QgaGF2ZSB0aGVpciBvd24gY2xvc2luZyB0YWdzLCBlLmcuIDxkaXY+PHA+PC9kaXY+XG4gICAgICAgIHdoaWxlIChwYXJlbnQubmFtZSAhPT0gbmFtZSkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlICE9PSAnRWxlbWVudCcpXG4gICAgICAgICAgICAgICAgcGFyc2VyLmVycm9yKFwiPC9cIiArIG5hbWUgKyBcIj4gYXR0ZW1wdGVkIHRvIGNsb3NlIGFuIGVsZW1lbnQgdGhhdCB3YXMgbm90IG9wZW5cIiwgc3RhcnQpO1xuICAgICAgICAgICAgcGFyZW50LmVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgcGFyc2VyLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyc2VyLmN1cnJlbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnQuZW5kID0gcGFyc2VyLmluZGV4O1xuICAgICAgICBwYXJzZXIuc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGlzYWxsb3dlZENvbnRlbnRzLmhhcyhwYXJlbnQubmFtZSkpIHtcbiAgICAgICAgLy8gY2FuIHRoaXMgYmUgYSBjaGlsZCBvZiB0aGUgcGFyZW50IGVsZW1lbnQsIG9yIGRvZXMgaXQgaW1wbGljaXRseVxuICAgICAgICAvLyBjbG9zZSBpdCwgbGlrZSBgPGxpPm9uZTxsaT50d29gP1xuICAgICAgICBpZiAoZGlzYWxsb3dlZENvbnRlbnRzLmdldChwYXJlbnQubmFtZSkuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBwYXJlbnQuZW5kID0gc3RhcnQ7XG4gICAgICAgICAgICBwYXJzZXIuc3RhY2sucG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdzbG90Jykge1xuICAgICAgICB2YXIgaSA9IHBhcnNlci5zdGFjay5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gcGFyc2VyLnN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ0VhY2hCbG9jaycpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyb3IoXCI8c2xvdD4gY2Fubm90IGJlIGEgY2hpbGQgb2YgYW4gZWFjaC1ibG9ja1wiLCBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5hbWUgPT09IENPTVBPTkVOVCkge1xuICAgICAgICBwYXJzZXIuZWF0KCd7JywgdHJ1ZSk7XG4gICAgICAgIGVsZW1lbnQuZXhwcmVzc2lvbiA9IHJlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gICAgICAgIHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmVhdCgnfScsIHRydWUpO1xuICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgfVxuICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlO1xuICAgIHdoaWxlICgoYXR0cmlidXRlID0gcmVhZEF0dHJpYnV0ZShwYXJzZXIsIHVuaXF1ZU5hbWVzKSkpIHtcbiAgICAgICAgZWxlbWVudC5hdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgIH1cbiAgICAvLyBzcGVjaWFsIGNhc2VzIOKAkyB0b3AtbGV2ZWwgPHNjcmlwdD4gYW5kIDxzdHlsZT5cbiAgICBpZiAoc3BlY2lhbHMuaGFzKG5hbWUpICYmIHBhcnNlci5zdGFjay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIHNwZWNpYWwgPSBzcGVjaWFscy5nZXQobmFtZSk7XG4gICAgICAgIGlmIChwYXJzZXJbc3BlY2lhbC5wcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgIHBhcnNlci5pbmRleCA9IHN0YXJ0O1xuICAgICAgICAgICAgcGFyc2VyLmVycm9yKFwiWW91IGNhbiBvbmx5IGhhdmUgb25lIHRvcC1sZXZlbCA8XCIgKyBuYW1lICsgXCI+IHRhZyBwZXIgY29tcG9uZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5lYXQoJz4nLCB0cnVlKTtcbiAgICAgICAgcGFyc2VyW3NwZWNpYWwucHJvcGVydHldID0gc3BlY2lhbC5yZWFkKHBhcnNlciwgc3RhcnQsIGVsZW1lbnQuYXR0cmlidXRlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGFyc2VyLmN1cnJlbnQoKS5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgIHZhciBzZWxmQ2xvc2luZyA9IHBhcnNlci5lYXQoJy8nKSB8fCBpc1ZvaWRFbGVtZW50TmFtZShuYW1lKTtcbiAgICBwYXJzZXIuZWF0KCc+JywgdHJ1ZSk7XG4gICAgaWYgKHNlbGZDbG9zaW5nKSB7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gcGFyc2VyLmluZGV4O1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgIC8vIHNwZWNpYWwgY2FzZVxuICAgICAgICBlbGVtZW50LmNoaWxkcmVuID0gcmVhZFNlcXVlbmNlKHBhcnNlciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci50ZW1wbGF0ZS5zbGljZShwYXJzZXIuaW5kZXgsIHBhcnNlci5pbmRleCArIDExKSA9PT0gJzwvdGV4dGFyZWE+JztcbiAgICAgICAgfSk7XG4gICAgICAgIHBhcnNlci5yZWFkKC88XFwvdGV4dGFyZWE+Lyk7XG4gICAgICAgIGVsZW1lbnQuZW5kID0gcGFyc2VyLmluZGV4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gZG9uJ3QgcHVzaCBzZWxmLWNsb3NpbmcgZWxlbWVudHMgb250byB0aGUgc3RhY2tcbiAgICAgICAgcGFyc2VyLnN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVhZFRhZ05hbWUocGFyc2VyKSB7XG4gICAgdmFyIHN0YXJ0ID0gcGFyc2VyLmluZGV4O1xuICAgIGlmIChwYXJzZXIuZWF0KFNFTEYpKSB7XG4gICAgICAgIC8vIGNoZWNrIHdlJ3JlIGluc2lkZSBhIGJsb2NrLCBvdGhlcndpc2UgdGhpc1xuICAgICAgICAvLyB3aWxsIGNhdXNlIGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICB2YXIgaSA9IHBhcnNlci5zdGFjay5sZW5ndGg7XG4gICAgICAgIHZhciBsZWdhbCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBwYXJzZXIuc3RhY2tbaV07XG4gICAgICAgICAgICBpZiAoZnJhZ21lbnQudHlwZSA9PT0gJ0lmQmxvY2snIHx8IGZyYWdtZW50LnR5cGUgPT09ICdFYWNoQmxvY2snKSB7XG4gICAgICAgICAgICAgICAgbGVnYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbGVnYWwpIHtcbiAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIjxcIiArIFNFTEYgKyBcIj4gY29tcG9uZW50cyBjYW4gb25seSBleGlzdCBpbnNpZGUgaWYtYmxvY2tzIG9yIGVhY2gtYmxvY2tzXCIsIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU0VMRjtcbiAgICB9XG4gICAgaWYgKHBhcnNlci5lYXQoQ09NUE9ORU5UKSlcbiAgICAgICAgcmV0dXJuIENPTVBPTkVOVDtcbiAgICB2YXIgbmFtZSA9IHBhcnNlci5yZWFkVW50aWwoLyhcXHN8XFwvfD4pLyk7XG4gICAgaWYgKG1ldGFUYWdzLmhhcyhuYW1lKSlcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgaWYgKCF2YWxpZFRhZ05hbWUudGVzdChuYW1lKSkge1xuICAgICAgICBwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCB2YWxpZCB0YWcgbmFtZVwiLCBzdGFydCk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZnVuY3Rpb24gcmVhZEF0dHJpYnV0ZShwYXJzZXIsIHVuaXF1ZU5hbWVzKSB7XG4gICAgdmFyIHN0YXJ0ID0gcGFyc2VyLmluZGV4O1xuICAgIHZhciBuYW1lID0gcGFyc2VyLnJlYWRVbnRpbCgvKFxcc3w9fFxcL3w+KS8pO1xuICAgIGlmICghbmFtZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHVuaXF1ZU5hbWVzLmhhcyhuYW1lKSkge1xuICAgICAgICBwYXJzZXIuZXJyb3IoJ0F0dHJpYnV0ZXMgbmVlZCB0byBiZSB1bmlxdWUnLCBzdGFydCk7XG4gICAgfVxuICAgIHVuaXF1ZU5hbWVzLmFkZChuYW1lKTtcbiAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgaWYgKC9eb246Ly50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiByZWFkRXZlbnRIYW5kbGVyRGlyZWN0aXZlKHBhcnNlciwgc3RhcnQsIG5hbWUuc2xpY2UoMyksIHBhcnNlci5lYXQoJz0nKSk7XG4gICAgfVxuICAgIGlmICgvXmJpbmQ6Ly50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiByZWFkQmluZGluZ0RpcmVjdGl2ZShwYXJzZXIsIHN0YXJ0LCBuYW1lLnNsaWNlKDUpKTtcbiAgICB9XG4gICAgaWYgKC9ecmVmOi8udGVzdChuYW1lKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwYXJzZXIuaW5kZXgsXG4gICAgICAgICAgICB0eXBlOiAnUmVmJyxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUuc2xpY2UoNClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIG1hdGNoID0gL14oaW58b3V0fHRyYW5zaXRpb24pOi8uZXhlYyhuYW1lKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRUcmFuc2l0aW9uRGlyZWN0aXZlKHBhcnNlciwgc3RhcnQsIG5hbWUuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKSwgbWF0Y2hbMV0pO1xuICAgIH1cbiAgICB2YXIgdmFsdWU7XG4gICAgLy8gOmZvbyBpcyBzaG9ydGhhbmQgZm9yIGZvbz0ne3tmb299fSdcbiAgICBpZiAoL146XFx3KyQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIHZhbHVlID0gZ2V0U2hvcnRoYW5kVmFsdWUoc3RhcnQgKyAxLCBuYW1lKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhbHVlID0gcGFyc2VyLmVhdCgnPScpID8gcmVhZEF0dHJpYnV0ZVZhbHVlKHBhcnNlcikgOiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogcGFyc2VyLmluZGV4LFxuICAgICAgICB0eXBlOiAnQXR0cmlidXRlJyxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlYWRBdHRyaWJ1dGVWYWx1ZShwYXJzZXIpIHtcbiAgICB2YXIgcXVvdGVNYXJrID0gcGFyc2VyLmVhdChcIidcIikgPyBcIidcIiA6IHBhcnNlci5lYXQoXCJcXFwiXCIpID8gXCJcXFwiXCIgOiBudWxsO1xuICAgIHZhciByZWdleCA9IHF1b3RlTWFyayA9PT0gXCInXCJcbiAgICAgICAgPyAvJy9cbiAgICAgICAgOiBxdW90ZU1hcmsgPT09IFwiXFxcIlwiID8gL1wiLyA6IC9bXFxzXCInPTw+XFwvYF0vO1xuICAgIHZhciB2YWx1ZSA9IHJlYWRTZXF1ZW5jZShwYXJzZXIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QocGFyc2VyLnRlbXBsYXRlW3BhcnNlci5pbmRleF0pO1xuICAgIH0pO1xuICAgIGlmIChxdW90ZU1hcmspXG4gICAgICAgIHBhcnNlci5pbmRleCArPSAxO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGdldFNob3J0aGFuZFZhbHVlKHN0YXJ0LCBuYW1lKSB7XG4gICAgdmFyIGVuZCA9IHN0YXJ0ICsgbmFtZS5sZW5ndGg7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ0F0dHJpYnV0ZVNob3J0aGFuZCcsXG4gICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGVuZCxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnSWRlbnRpZmllcicsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogZW5kLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBdO1xufVxuZnVuY3Rpb24gcmVhZFNlcXVlbmNlKHBhcnNlciwgZG9uZSkge1xuICAgIHZhciBjdXJyZW50Q2h1bmsgPSB7XG4gICAgICAgIHN0YXJ0OiBwYXJzZXIuaW5kZXgsXG4gICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgdHlwZTogJ1RleHQnLFxuICAgICAgICBkYXRhOiAnJ1xuICAgIH07XG4gICAgdmFyIGNodW5rcyA9IFtdO1xuICAgIHdoaWxlIChwYXJzZXIuaW5kZXggPCBwYXJzZXIudGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHBhcnNlci5pbmRleDtcbiAgICAgICAgaWYgKGRvbmUoKSkge1xuICAgICAgICAgICAgY3VycmVudENodW5rLmVuZCA9IHBhcnNlci5pbmRleDtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2h1bmsuZGF0YSlcbiAgICAgICAgICAgICAgICBjaHVua3MucHVzaChjdXJyZW50Q2h1bmspO1xuICAgICAgICAgICAgY2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09ICdUZXh0JylcbiAgICAgICAgICAgICAgICAgICAgY2h1bmsuZGF0YSA9IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoY2h1bmsuZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjaHVua3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VyLmVhdCgne3snKSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDaHVuay5kYXRhKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENodW5rLmVuZCA9IGluZGV4O1xuICAgICAgICAgICAgICAgIGNodW5rcy5wdXNoKGN1cnJlbnRDaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gICAgICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlci5lYXQoJ319JykpIHtcbiAgICAgICAgICAgICAgICBwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCB9fVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogaW5kZXgsXG4gICAgICAgICAgICAgICAgZW5kOiBwYXJzZXIuaW5kZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogJ011c3RhY2hlVGFnJyxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnJlbnRDaHVuayA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogcGFyc2VyLmluZGV4LFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnVGV4dCcsXG4gICAgICAgICAgICAgICAgZGF0YTogJydcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50Q2h1bmsuZGF0YSArPSBwYXJzZXIudGVtcGxhdGVbcGFyc2VyLmluZGV4KytdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlci5lcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpO1xufVxuXG52YXIgd2hpdGVzcGFjZSA9IC9bIFxcdFxcclxcbl0vO1xuXG5mdW5jdGlvbiB0cmltU3RhcnQoc3RyKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICh3aGl0ZXNwYWNlLnRlc3Qoc3RyW2ldKSlcbiAgICAgICAgaSArPSAxO1xuICAgIHJldHVybiBzdHIuc2xpY2UoaSk7XG59XG5mdW5jdGlvbiB0cmltRW5kKHN0cikge1xuICAgIHZhciBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAod2hpdGVzcGFjZS50ZXN0KHN0cltpIC0gMV0pKVxuICAgICAgICBpIC09IDE7XG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCBpKTtcbn1cblxuZnVuY3Rpb24gdHJpbVdoaXRlc3BhY2UoYmxvY2ssIHRyaW1CZWZvcmUsIHRyaW1BZnRlcikge1xuICAgIGlmICghYmxvY2suY2hpbGRyZW4pXG4gICAgICAgIHJldHVybjsgLy8gQXdhaXRCbG9ja1xuICAgIHZhciBmaXJzdENoaWxkID0gYmxvY2suY2hpbGRyZW5bMF07XG4gICAgdmFyIGxhc3RDaGlsZCA9IGJsb2NrLmNoaWxkcmVuW2Jsb2NrLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgIGlmIChmaXJzdENoaWxkLnR5cGUgPT09ICdUZXh0JyAmJiB0cmltQmVmb3JlKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuZGF0YSA9IHRyaW1TdGFydChmaXJzdENoaWxkLmRhdGEpO1xuICAgICAgICBpZiAoIWZpcnN0Q2hpbGQuZGF0YSlcbiAgICAgICAgICAgIGJsb2NrLmNoaWxkcmVuLnNoaWZ0KCk7XG4gICAgfVxuICAgIGlmIChsYXN0Q2hpbGQudHlwZSA9PT0gJ1RleHQnICYmIHRyaW1BZnRlcikge1xuICAgICAgICBsYXN0Q2hpbGQuZGF0YSA9IHRyaW1FbmQobGFzdENoaWxkLmRhdGEpO1xuICAgICAgICBpZiAoIWxhc3RDaGlsZC5kYXRhKVxuICAgICAgICAgICAgYmxvY2suY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICAgIGlmIChibG9ja1tcImVsc2VcIl0pIHtcbiAgICAgICAgdHJpbVdoaXRlc3BhY2UoYmxvY2tbXCJlbHNlXCJdLCB0cmltQmVmb3JlLCB0cmltQWZ0ZXIpO1xuICAgIH1cbiAgICBpZiAoZmlyc3RDaGlsZC5lbHNlaWYpIHtcbiAgICAgICAgdHJpbVdoaXRlc3BhY2UoZmlyc3RDaGlsZCwgdHJpbUJlZm9yZSwgdHJpbUFmdGVyKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtdXN0YWNoZShwYXJzZXIpIHtcbiAgICB2YXIgc3RhcnQgPSBwYXJzZXIuaW5kZXg7XG4gICAgcGFyc2VyLmluZGV4ICs9IDI7XG4gICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgIC8vIHt7L2lmfX0gb3Ige3svZWFjaH19XG4gICAgaWYgKHBhcnNlci5lYXQoJy8nKSkge1xuICAgICAgICB2YXIgYmxvY2sgPSBwYXJzZXIuY3VycmVudCgpO1xuICAgICAgICB2YXIgZXhwZWN0ZWQgPSB2b2lkIDA7XG4gICAgICAgIGlmIChibG9jay50eXBlID09PSAnRWxzZUJsb2NrJyB8fCBibG9jay50eXBlID09PSAnUGVuZGluZ0Jsb2NrJyB8fCBibG9jay50eXBlID09PSAnVGhlbkJsb2NrJyB8fCBibG9jay50eXBlID09PSAnQ2F0Y2hCbG9jaycpIHtcbiAgICAgICAgICAgIGJsb2NrLmVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgcGFyc2VyLnN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYmxvY2sgPSBwYXJzZXIuY3VycmVudCgpO1xuICAgICAgICAgICAgZXhwZWN0ZWQgPSAnYXdhaXQnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibG9jay50eXBlID09PSAnSWZCbG9jaycpIHtcbiAgICAgICAgICAgIGV4cGVjdGVkID0gJ2lmJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9jay50eXBlID09PSAnRWFjaEJsb2NrJykge1xuICAgICAgICAgICAgZXhwZWN0ZWQgPSAnZWFjaCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2sudHlwZSA9PT0gJ0F3YWl0QmxvY2snKSB7XG4gICAgICAgICAgICBleHBlY3RlZCA9ICdhd2FpdCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZXIuZXJyb3IoXCJVbmV4cGVjdGVkIGJsb2NrIGNsb3NpbmcgdGFnXCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5lYXQoZXhwZWN0ZWQsIHRydWUpO1xuICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5lYXQoJ319JywgdHJ1ZSk7XG4gICAgICAgIHdoaWxlIChibG9jay5lbHNlaWYpIHtcbiAgICAgICAgICAgIGJsb2NrLmVuZCA9IHBhcnNlci5pbmRleDtcbiAgICAgICAgICAgIHBhcnNlci5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJsb2NrID0gcGFyc2VyLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIGlmIChibG9ja1tcImVsc2VcIl0pIHtcbiAgICAgICAgICAgICAgICBibG9ja1tcImVsc2VcIl0uZW5kID0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyaXAgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlIGFzIG5lY2Vzc2FyeVxuICAgICAgICBpZiAoYmxvY2suY2hpbGRyZW4gJiYgIWJsb2NrLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIkVtcHR5IGJsb2NrXCIsIGJsb2NrLnN0YXJ0KTtcbiAgICAgICAgdmFyIGNoYXJCZWZvcmUgPSBwYXJzZXIudGVtcGxhdGVbYmxvY2suc3RhcnQgLSAxXTtcbiAgICAgICAgdmFyIGNoYXJBZnRlciA9IHBhcnNlci50ZW1wbGF0ZVtwYXJzZXIuaW5kZXhdO1xuICAgICAgICB2YXIgdHJpbUJlZm9yZSA9ICFjaGFyQmVmb3JlIHx8IHdoaXRlc3BhY2UudGVzdChjaGFyQmVmb3JlKTtcbiAgICAgICAgdmFyIHRyaW1BZnRlciA9ICFjaGFyQWZ0ZXIgfHwgd2hpdGVzcGFjZS50ZXN0KGNoYXJBZnRlcik7XG4gICAgICAgIHRyaW1XaGl0ZXNwYWNlKGJsb2NrLCB0cmltQmVmb3JlLCB0cmltQWZ0ZXIpO1xuICAgICAgICBibG9jay5lbmQgPSBwYXJzZXIuaW5kZXg7XG4gICAgICAgIHBhcnNlci5zdGFjay5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyc2VyLmVhdCgnZWxzZWlmJykpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gcGFyc2VyLmN1cnJlbnQoKTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgIT09ICdJZkJsb2NrJylcbiAgICAgICAgICAgIHBhcnNlci5lcnJvcignQ2Fubm90IGhhdmUgYW4ge3tlbHNlaWYgLi4ufX0gYmxvY2sgb3V0c2lkZSBhbiB7eyNpZiAuLi59fSBibG9jaycpO1xuICAgICAgICBwYXJzZXIucmVxdWlyZVdoaXRlc3BhY2UoKTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSByZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5lYXQoJ319JywgdHJ1ZSk7XG4gICAgICAgIGJsb2NrW1wiZWxzZVwiXSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBwYXJzZXIuaW5kZXgsXG4gICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiAnRWxzZUJsb2NrJyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogcGFyc2VyLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdJZkJsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgZWxzZWlmOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgICBwYXJzZXIuc3RhY2sucHVzaChibG9ja1tcImVsc2VcIl0uY2hpbGRyZW5bMF0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZXIuZWF0KCdlbHNlJykpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gcGFyc2VyLmN1cnJlbnQoKTtcbiAgICAgICAgaWYgKGJsb2NrLnR5cGUgIT09ICdJZkJsb2NrJyAmJiBibG9jay50eXBlICE9PSAnRWFjaEJsb2NrJykge1xuICAgICAgICAgICAgcGFyc2VyLmVycm9yKCdDYW5ub3QgaGF2ZSBhbiB7e2Vsc2V9fSBibG9jayBvdXRzaWRlIGFuIHt7I2lmIC4uLn19IG9yIHt7I2VhY2ggLi4ufX0gYmxvY2snKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5lYXQoJ319JywgdHJ1ZSk7XG4gICAgICAgIGJsb2NrW1wiZWxzZVwiXSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBwYXJzZXIuaW5kZXgsXG4gICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiAnRWxzZUJsb2NrJyxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9O1xuICAgICAgICBwYXJzZXIuc3RhY2sucHVzaChibG9ja1tcImVsc2VcIl0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZXIuZWF0KCd0aGVuJykpIHtcbiAgICAgICAgLy8gVE9ETyBEUlkgb3V0IHRoaXMgYW5kIHRoZSBuZXh0IHNlY3Rpb25cbiAgICAgICAgdmFyIHBlbmRpbmdCbG9jayA9IHBhcnNlci5jdXJyZW50KCk7XG4gICAgICAgIGlmIChwZW5kaW5nQmxvY2sudHlwZSA9PT0gJ1BlbmRpbmdCbG9jaycpIHtcbiAgICAgICAgICAgIHBlbmRpbmdCbG9jay5lbmQgPSBzdGFydDtcbiAgICAgICAgICAgIHBhcnNlci5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHZhciBhd2FpdEJsb2NrID0gcGFyc2VyLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHBhcnNlci5yZXF1aXJlV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgYXdhaXRCbG9jay52YWx1ZSA9IHBhcnNlci5yZWFkSWRlbnRpZmllcigpO1xuICAgICAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgcGFyc2VyLmVhdCgnfX0nLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB0aGVuQmxvY2sgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICB0eXBlOiAnVGhlbkJsb2NrJyxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhd2FpdEJsb2NrLnRoZW4gPSB0aGVuQmxvY2s7XG4gICAgICAgICAgICBwYXJzZXIuc3RhY2sucHVzaCh0aGVuQmxvY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcnNlci5lYXQoJ2NhdGNoJykpIHtcbiAgICAgICAgdmFyIHRoZW5CbG9jayA9IHBhcnNlci5jdXJyZW50KCk7XG4gICAgICAgIGlmICh0aGVuQmxvY2sudHlwZSA9PT0gJ1RoZW5CbG9jaycpIHtcbiAgICAgICAgICAgIHRoZW5CbG9jay5lbmQgPSBzdGFydDtcbiAgICAgICAgICAgIHBhcnNlci5zdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHZhciBhd2FpdEJsb2NrID0gcGFyc2VyLmN1cnJlbnQoKTtcbiAgICAgICAgICAgIHBhcnNlci5yZXF1aXJlV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgYXdhaXRCbG9jay5lcnJvciA9IHBhcnNlci5yZWFkSWRlbnRpZmllcigpO1xuICAgICAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgcGFyc2VyLmVhdCgnfX0nLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciBjYXRjaEJsb2NrID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdHlwZTogJ0NhdGNoQmxvY2snLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF3YWl0QmxvY2tbXCJjYXRjaFwiXSA9IGNhdGNoQmxvY2s7XG4gICAgICAgICAgICBwYXJzZXIuc3RhY2sucHVzaChjYXRjaEJsb2NrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChwYXJzZXIuZWF0KCcjJykpIHtcbiAgICAgICAgLy8ge3sjaWYgZm9vfX0gb3Ige3sjZWFjaCBmb299fVxuICAgICAgICB2YXIgdHlwZSA9IHZvaWQgMDtcbiAgICAgICAgaWYgKHBhcnNlci5lYXQoJ2lmJykpIHtcbiAgICAgICAgICAgIHR5cGUgPSAnSWZCbG9jayc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VyLmVhdCgnZWFjaCcpKSB7XG4gICAgICAgICAgICB0eXBlID0gJ0VhY2hCbG9jayc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyc2VyLmVhdCgnYXdhaXQnKSkge1xuICAgICAgICAgICAgdHlwZSA9ICdBd2FpdEJsb2NrJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIGlmLCBlYWNoIG9yIGF3YWl0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5yZXF1aXJlV2hpdGVzcGFjZSgpO1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHJlYWRFeHByZXNzaW9uKHBhcnNlcik7XG4gICAgICAgIHZhciBibG9jayA9IHR5cGUgPT09ICdBd2FpdEJsb2NrJyA/XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgcGVuZGluZzoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnUGVuZGluZ0Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0aGVuOiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdUaGVuQmxvY2snLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFwiY2F0Y2hcIjoge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ2F0Y2hCbG9jaycsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgICBlbmQ6IG51bGwsXG4gICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBleHByZXNzaW9uLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICAvLyB7eyNlYWNofX0gYmxvY2tzIG11c3QgZGVjbGFyZSBhIGNvbnRleHQg4oCTIHt7I2VhY2ggbGlzdCBhcyBpdGVtfX1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdFYWNoQmxvY2snKSB7XG4gICAgICAgICAgICBwYXJzZXIuZWF0KCdhcycsIHRydWUpO1xuICAgICAgICAgICAgcGFyc2VyLnJlcXVpcmVXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICBpZiAocGFyc2VyLmVhdCgnWycpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmRlc3RydWN0dXJlZENvbnRleHRzID0gW107XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZXN0cnVjdHVyZWRDb250ZXh0ID0gcGFyc2VyLnJlYWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzdHJ1Y3R1cmVkQ29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmRlc3RydWN0dXJlZENvbnRleHRzLnB1c2goZGVzdHJ1Y3R1cmVkQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgICAgICAgICAgICAgICB9IHdoaWxlIChwYXJzZXIuZWF0KCcsJykpO1xuICAgICAgICAgICAgICAgIGlmICghYmxvY2suZGVzdHJ1Y3R1cmVkQ29udGV4dHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBwYXJzZXIuZXJyb3IoXCJFeHBlY3RlZCBuYW1lXCIpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmNvbnRleHQgPSBibG9jay5kZXN0cnVjdHVyZWRDb250ZXh0cy5qb2luKCdfJyk7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlci5lYXQoJ10nLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2NrLmNvbnRleHQgPSBwYXJzZXIucmVhZElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWJsb2NrLmNvbnRleHQpXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIG5hbWVcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICBpZiAocGFyc2VyLmVhdCgnLCcpKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmluZGV4ID0gcGFyc2VyLnJlYWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLmVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyc2VyLmVhdCgnQCcpKSB7XG4gICAgICAgICAgICAgICAgYmxvY2sua2V5ID0gcGFyc2VyLnJlYWRJZGVudGlmaWVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFibG9jay5rZXkpXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlci5lcnJvcihcIkV4cGVjdGVkIG5hbWVcIik7XG4gICAgICAgICAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhd2FpdEJsb2NrU2hvcnRoYW5kID0gdHlwZSA9PT0gJ0F3YWl0QmxvY2snICYmIHBhcnNlci5lYXQoJ3RoZW4nKTtcbiAgICAgICAgaWYgKGF3YWl0QmxvY2tTaG9ydGhhbmQpIHtcbiAgICAgICAgICAgIHBhcnNlci5yZXF1aXJlV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgYmxvY2sudmFsdWUgPSBwYXJzZXIucmVhZElkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZXIuZWF0KCd9fScsIHRydWUpO1xuICAgICAgICBwYXJzZXIuY3VycmVudCgpLmNoaWxkcmVuLnB1c2goYmxvY2spO1xuICAgICAgICBwYXJzZXIuc3RhY2sucHVzaChibG9jayk7XG4gICAgICAgIGlmICh0eXBlID09PSAnQXdhaXRCbG9jaycpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEJsb2NrID0gYXdhaXRCbG9ja1Nob3J0aGFuZCA/IGJsb2NrLnRoZW4gOiBibG9jay5wZW5kaW5nO1xuICAgICAgICAgICAgY2hpbGRCbG9jay5zdGFydCA9IHBhcnNlci5pbmRleDtcbiAgICAgICAgICAgIHBhcnNlci5zdGFjay5wdXNoKGNoaWxkQmxvY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcnNlci5lYXQoJ3lpZWxkJykpIHtcbiAgICAgICAgLy8ge3t5aWVsZH19XG4gICAgICAgIC8vIFRPRE8gZGVwcmVjYXRlXG4gICAgICAgIHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcbiAgICAgICAgcGFyc2VyLmVhdCgnfX0nLCB0cnVlKTtcbiAgICAgICAgcGFyc2VyLmN1cnJlbnQoKS5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgIGVuZDogcGFyc2VyLmluZGV4LFxuICAgICAgICAgICAgdHlwZTogJ0VsZW1lbnQnLFxuICAgICAgICAgICAgbmFtZTogJ3Nsb3QnLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBhcnNlci5lYXQoJ3snKSkge1xuICAgICAgICAvLyB7e3tyYXd9fX0gbXVzdGFjaGVcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSByZWFkRXhwcmVzc2lvbihwYXJzZXIpO1xuICAgICAgICBwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgICAgIHBhcnNlci5lYXQoJ319fScsIHRydWUpO1xuICAgICAgICBwYXJzZXIuY3VycmVudCgpLmNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwYXJzZXIuaW5kZXgsXG4gICAgICAgICAgICB0eXBlOiAnUmF3TXVzdGFjaGVUYWcnLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBleHByZXNzaW9uID0gcmVhZEV4cHJlc3Npb24ocGFyc2VyKTtcbiAgICAgICAgcGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuICAgICAgICBwYXJzZXIuZWF0KCd9fScsIHRydWUpO1xuICAgICAgICBwYXJzZXIuY3VycmVudCgpLmNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwYXJzZXIuaW5kZXgsXG4gICAgICAgICAgICB0eXBlOiAnTXVzdGFjaGVUYWcnLFxuICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRleHQocGFyc2VyKSB7XG4gICAgdmFyIHN0YXJ0ID0gcGFyc2VyLmluZGV4O1xuICAgIHZhciBkYXRhID0gJyc7XG4gICAgd2hpbGUgKHBhcnNlci5pbmRleCA8IHBhcnNlci50ZW1wbGF0ZS5sZW5ndGggJiZcbiAgICAgICAgIXBhcnNlci5tYXRjaCgnPCcpICYmXG4gICAgICAgICFwYXJzZXIubWF0Y2goJ3t7JykpIHtcbiAgICAgICAgZGF0YSArPSBwYXJzZXIudGVtcGxhdGVbcGFyc2VyLmluZGV4KytdO1xuICAgIH1cbiAgICBwYXJzZXIuY3VycmVudCgpLmNoaWxkcmVuLnB1c2goe1xuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogcGFyc2VyLmluZGV4LFxuICAgICAgICB0eXBlOiAnVGV4dCcsXG4gICAgICAgIGRhdGE6IGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoZGF0YSlcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZnJhZ21lbnQocGFyc2VyKSB7XG4gICAgaWYgKHBhcnNlci5tYXRjaCgnPCcpKSB7XG4gICAgICAgIHJldHVybiB0YWc7XG4gICAgfVxuICAgIGlmIChwYXJzZXIubWF0Y2goJ3t7JykpIHtcbiAgICAgICAgcmV0dXJuIG11c3RhY2hlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbn1cblxudmFyIHJlc2VydmVkTmFtZXMgPSBuZXcgU2V0KFtcbiAgICAnYXJndW1lbnRzJyxcbiAgICAnYXdhaXQnLFxuICAgICdicmVhaycsXG4gICAgJ2Nhc2UnLFxuICAgICdjYXRjaCcsXG4gICAgJ2NsYXNzJyxcbiAgICAnY29uc3QnLFxuICAgICdjb250aW51ZScsXG4gICAgJ2RlYnVnZ2VyJyxcbiAgICAnZGVmYXVsdCcsXG4gICAgJ2RlbGV0ZScsXG4gICAgJ2RvJyxcbiAgICAnZWxzZScsXG4gICAgJ2VudW0nLFxuICAgICdldmFsJyxcbiAgICAnZXhwb3J0JyxcbiAgICAnZXh0ZW5kcycsXG4gICAgJ2ZhbHNlJyxcbiAgICAnZmluYWxseScsXG4gICAgJ2ZvcicsXG4gICAgJ2Z1bmN0aW9uJyxcbiAgICAnaWYnLFxuICAgICdpbXBsZW1lbnRzJyxcbiAgICAnaW1wb3J0JyxcbiAgICAnaW4nLFxuICAgICdpbnN0YW5jZW9mJyxcbiAgICAnaW50ZXJmYWNlJyxcbiAgICAnbGV0JyxcbiAgICAnbmV3JyxcbiAgICAnbnVsbCcsXG4gICAgJ3BhY2thZ2UnLFxuICAgICdwcml2YXRlJyxcbiAgICAncHJvdGVjdGVkJyxcbiAgICAncHVibGljJyxcbiAgICAncmV0dXJuJyxcbiAgICAnc3RhdGljJyxcbiAgICAnc3VwZXInLFxuICAgICdzd2l0Y2gnLFxuICAgICd0aGlzJyxcbiAgICAndGhyb3cnLFxuICAgICd0cnVlJyxcbiAgICAndHJ5JyxcbiAgICAndHlwZW9mJyxcbiAgICAndmFyJyxcbiAgICAndm9pZCcsXG4gICAgJ3doaWxlJyxcbiAgICAnd2l0aCcsXG4gICAgJ3lpZWxkJyxcbl0pO1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZGFya3NreWFwcC9zdHJpbmctaGFzaC9ibG9iL21hc3Rlci9pbmRleC5qc1xuZnVuY3Rpb24gaGFzaChzdHIpIHtcbiAgICB2YXIgaGFzaCA9IDUzODE7XG4gICAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pXG4gICAgICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSBeIHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBoYXNoID4+PiAwO1xufVxuXG5mdW5jdGlvbiBnZXRMb2NhdG9yKHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIG9mZnNldExpbmUgPSBvcHRpb25zLm9mZnNldExpbmUgfHwgMDtcbiAgICB2YXIgb2Zmc2V0Q29sdW1uID0gb3B0aW9ucy5vZmZzZXRDb2x1bW4gfHwgMDtcbiAgICB2YXIgb3JpZ2luYWxMaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICB2YXIgbGluZVJhbmdlcyA9IG9yaWdpbmFsTGluZXMubWFwKGZ1bmN0aW9uIChsaW5lLCBpKSB7XG4gICAgICAgIHZhciBlbmQgPSBzdGFydCArIGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgdmFyIHJhbmdlID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBsaW5lOiBpIH07XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZ1bmN0aW9uIHJhbmdlQ29udGFpbnMocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiByYW5nZS5zdGFydCA8PSBpbmRleCAmJiBpbmRleCA8IHJhbmdlLmVuZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0TG9jYXRpb24ocmFuZ2UsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiB7IGxpbmU6IG9mZnNldExpbmUgKyByYW5nZS5saW5lLCBjb2x1bW46IG9mZnNldENvbHVtbiArIGluZGV4IC0gcmFuZ2Uuc3RhcnQsIGNoYXJhY3RlcjogaW5kZXggfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9jYXRlKHNlYXJjaCwgc3RhcnRJbmRleCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHNlYXJjaCA9IHNvdXJjZS5pbmRleE9mKHNlYXJjaCwgc3RhcnRJbmRleCB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSBsaW5lUmFuZ2VzW2ldO1xuICAgICAgICB2YXIgZCA9IHNlYXJjaCA+PSByYW5nZS5lbmQgPyAxIDogLTE7XG4gICAgICAgIHdoaWxlIChyYW5nZSkge1xuICAgICAgICAgICAgaWYgKHJhbmdlQ29udGFpbnMocmFuZ2UsIHNlYXJjaCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldExvY2F0aW9uKHJhbmdlLCBzZWFyY2gpO1xuICAgICAgICAgICAgaSArPSBkO1xuICAgICAgICAgICAgcmFuZ2UgPSBsaW5lUmFuZ2VzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBsb2NhdGU7XG59XG5mdW5jdGlvbiBsb2NhdGUoc291cmNlLCBzZWFyY2gsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbG9jYXRlIHRha2VzIGEgeyBzdGFydEluZGV4LCBvZmZzZXRMaW5lLCBvZmZzZXRDb2x1bW4gfSBvYmplY3QgYXMgdGhlIHRoaXJkIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIHJldHVybiBnZXRMb2NhdG9yKHNvdXJjZSwgb3B0aW9ucykoc2VhcmNoLCBvcHRpb25zICYmIG9wdGlvbnMuc3RhcnRJbmRleCk7XG59XG5cbmZ1bmN0aW9uIHRhYnNUb1NwYWNlcyhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHQrLywgZnVuY3Rpb24gKG1hdGNoKSB7IHJldHVybiBtYXRjaC5zcGxpdCgnXFx0Jykuam9pbignICAnKTsgfSk7XG59XG5mdW5jdGlvbiBnZXRDb2RlRnJhbWUoc291cmNlLCBsaW5lLCBjb2x1bW4pIHtcbiAgICB2YXIgbGluZXMgPSBzb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgIHZhciBmcmFtZVN0YXJ0ID0gTWF0aC5tYXgoMCwgbGluZSAtIDIpO1xuICAgIHZhciBmcmFtZUVuZCA9IE1hdGgubWluKGxpbmUgKyAzLCBsaW5lcy5sZW5ndGgpO1xuICAgIHZhciBkaWdpdHMgPSBTdHJpbmcoZnJhbWVFbmQgKyAxKS5sZW5ndGg7XG4gICAgcmV0dXJuIGxpbmVzXG4gICAgICAgIC5zbGljZShmcmFtZVN0YXJ0LCBmcmFtZUVuZClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc3RyLCBpKSB7XG4gICAgICAgIHZhciBpc0Vycm9yTGluZSA9IGZyYW1lU3RhcnQgKyBpID09PSBsaW5lO1xuICAgICAgICB2YXIgbGluZU51bSA9IFN0cmluZyhpICsgZnJhbWVTdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAobGluZU51bS5sZW5ndGggPCBkaWdpdHMpXG4gICAgICAgICAgICBsaW5lTnVtID0gXCIgXCIgKyBsaW5lTnVtO1xuICAgICAgICBpZiAoaXNFcnJvckxpbmUpIHtcbiAgICAgICAgICAgIHZhciBpbmRpY2F0b3IgPSByZXBlYXQoJyAnLCBkaWdpdHMgKyAyICsgdGFic1RvU3BhY2VzKHN0ci5zbGljZSgwLCBjb2x1bW4pKS5sZW5ndGgpICsgJ14nO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVOdW0gKyBcIjogXCIgKyB0YWJzVG9TcGFjZXMoc3RyKSArIFwiXFxuXCIgKyBpbmRpY2F0b3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmVOdW0gKyBcIjogXCIgKyB0YWJzVG9TcGFjZXMoc3RyKTtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG59XG5cbnZhciBDb21waWxlRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBpbGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21waWxlRXJyb3IobWVzc2FnZSwgdGVtcGxhdGUsIGluZGV4LCBmaWxlbmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5tZXNzYWdlICsgXCIgKFwiICsgX3RoaXMubG9jLmxpbmUgKyBcIjpcIiArIF90aGlzLmxvYy5jb2x1bW4gKyBcIilcXG5cIiArIF90aGlzXG4gICAgICAgICAgICAgICAgLmZyYW1lO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2EgPSBsb2NhdGUodGVtcGxhdGUsIGluZGV4KSwgbGluZSA9IF9hLmxpbmUsIGNvbHVtbiA9IF9hLmNvbHVtbjtcbiAgICAgICAgX3RoaXMubG9jID0geyBsaW5lOiBsaW5lICsgMSwgY29sdW1uOiBjb2x1bW4gfTtcbiAgICAgICAgX3RoaXMucG9zID0gaW5kZXg7XG4gICAgICAgIF90aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIF90aGlzLmZyYW1lID0gZ2V0Q29kZUZyYW1lKHRlbXBsYXRlLCBsaW5lLCBjb2x1bW4pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21waWxlRXJyb3I7XG59KEVycm9yKSk7XG5cbnZhciBQYXJzZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQYXJzZUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBhcnNlRXJyb3IobWVzc2FnZSwgdGVtcGxhdGUsIGluZGV4LCBmaWxlbmFtZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlLCB0ZW1wbGF0ZSwgaW5kZXgsIGZpbGVuYW1lKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBQYXJzZUVycm9yO1xufShDb21waWxlRXJyb3IpKTtcbnZhciBQYXJzZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUZW1wbGF0ZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5tZXRhVGFncyA9IHt9O1xuICAgICAgICB0aGlzLmh0bWwgPSB7XG4gICAgICAgICAgICBzdGFydDogbnVsbCxcbiAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgIHR5cGU6ICdGcmFnbWVudCcsXG4gICAgICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jc3MgPSBudWxsO1xuICAgICAgICB0aGlzLmpzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaHRtbCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IGZyYWdtZW50O1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudGVtcGxhdGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHN0YXRlKHRoaXMpIHx8IGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50KCk7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGN1cnJlbnQudHlwZSA9PT0gJ0VsZW1lbnQnID8gXCI8XCIgKyBjdXJyZW50Lm5hbWUgKyBcIj5cIiA6ICdCbG9jayc7XG4gICAgICAgICAgICB0aGlzLmVycm9yKHR5cGUgKyBcIiB3YXMgbGVmdCBvcGVuXCIsIGN1cnJlbnQuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaHRtbC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuaHRtbC5jaGlsZHJlblswXSAmJiB0aGlzLmh0bWwuY2hpbGRyZW5bMF0uc3RhcnQ7XG4gICAgICAgICAgICB3aGlsZSAoL1xccy8udGVzdCh0ZW1wbGF0ZVtzdGFydF0pKVxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IDE7XG4gICAgICAgICAgICB2YXIgZW5kID0gdGhpcy5odG1sLmNoaWxkcmVuW3RoaXMuaHRtbC5jaGlsZHJlbi5sZW5ndGggLSAxXSAmJiB0aGlzLmh0bWwuY2hpbGRyZW5bdGhpcy5odG1sLmNoaWxkcmVuLmxlbmd0aCAtIDFdLmVuZDtcbiAgICAgICAgICAgIHdoaWxlICgvXFxzLy50ZXN0KHRlbXBsYXRlW2VuZCAtIDFdKSlcbiAgICAgICAgICAgICAgICBlbmQgLT0gMTtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5zdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5odG1sLmVuZCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaHRtbC5zdGFydCA9IHRoaXMuaHRtbC5lbmQgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBhcnNlci5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuYWNvcm5FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdGhpcy5lcnJvcihlcnIubWVzc2FnZS5yZXBsYWNlKC8gXFwoXFxkKzpcXGQrXFwpJC8sICcnKSwgZXJyLnBvcyk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA9PT0gdm9pZCAwKSB7IGluZGV4ID0gdGhpcy5pbmRleDsgfVxuICAgICAgICB0aHJvdyBuZXcgUGFyc2VFcnJvcihtZXNzYWdlLCB0aGlzLnRlbXBsYXRlLCBpbmRleCwgdGhpcy5maWxlbmFtZSk7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLmVhdCA9IGZ1bmN0aW9uIChzdHIsIHJlcXVpcmVkKSB7XG4gICAgICAgIGlmICh0aGlzLm1hdGNoKHN0cikpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggKz0gc3RyLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXF1aXJlZCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIkV4cGVjdGVkIFwiICsgc3RyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZS5zbGljZSh0aGlzLmluZGV4LCB0aGlzLmluZGV4ICsgc3RyLmxlbmd0aCkgPT09IHN0cjtcbiAgICB9O1xuICAgIFBhcnNlci5wcm90b3R5cGUuYWxsb3dXaGl0ZXNwYWNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5pbmRleCA8IHRoaXMudGVtcGxhdGUubGVuZ3RoICYmXG4gICAgICAgICAgICB3aGl0ZXNwYWNlLnRlc3QodGhpcy50ZW1wbGF0ZVt0aGlzLmluZGV4XSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHBhdHRlcm4pIHtcbiAgICAgICAgdmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHRoaXMudGVtcGxhdGUuc2xpY2UodGhpcy5pbmRleCkpO1xuICAgICAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMuaW5kZXggKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgfTtcbiAgICBQYXJzZXIucHJvdG90eXBlLnJlYWRJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLmluZGV4O1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMucmVhZCgvW2EtekEtWl8kXVthLXpBLVowLTlfJF0qLyk7XG4gICAgICAgIGlmIChyZXNlcnZlZE5hbWVzLmhhcyhpZGVudGlmaWVyKSkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcihcIidcIiArIGlkZW50aWZpZXIgKyBcIicgaXMgYSByZXNlcnZlZCB3b3JkIGluIEphdmFTY3JpcHQgYW5kIGNhbm5vdCBiZSB1c2VkIGhlcmVcIiwgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpZGVudGlmaWVyO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZWFkVW50aWwgPSBmdW5jdGlvbiAocGF0dGVybikge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA+PSB0aGlzLnRlbXBsYXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHZhciBtYXRjaCA9IHBhdHRlcm4uZXhlYyh0aGlzLnRlbXBsYXRlLnNsaWNlKHN0YXJ0KSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0XzEgPSB0aGlzLmluZGV4O1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHN0YXJ0XzEgKyBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlLnNsaWNlKHN0YXJ0XzEsIHRoaXMuaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLnRlbXBsYXRlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVtcGxhdGUuc2xpY2Uoc3RhcnQpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRlbXBsYXRlLnNsaWNlKHRoaXMuaW5kZXgpO1xuICAgIH07XG4gICAgUGFyc2VyLnByb3RvdHlwZS5yZXF1aXJlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF3aGl0ZXNwYWNlLnRlc3QodGhpcy50ZW1wbGF0ZVt0aGlzLmluZGV4XSkpIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoXCJFeHBlY3RlZCB3aGl0ZXNwYWNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb3dXaGl0ZXNwYWNlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyc2VyO1xufSgpKTtcbmZ1bmN0aW9uIHBhcnNlKHRlbXBsYXRlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcih0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaDogaGFzaChwYXJzZXIudGVtcGxhdGUpLFxuICAgICAgICBodG1sOiBwYXJzZXIuaHRtbCxcbiAgICAgICAgY3NzOiBwYXJzZXIuY3NzLFxuICAgICAgICBqczogcGFyc2VyLmpzXG4gICAgfTtcbn1cblxudmFyIGRpc2FsbG93ZWQgPSBuZXcgU2V0KFsnTGl0ZXJhbCcsICdPYmplY3RFeHByZXNzaW9uJywgJ0FycmF5RXhwcmVzc2lvbiddKTtcbmZ1bmN0aW9uIGRhdGEodmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgd2hpbGUgKHByb3AudHlwZSA9PT0gJ1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uJylcbiAgICAgICAgcHJvcCA9IHByb3AuZXhwcmVzc2lvbjtcbiAgICAvLyBUT0RPIHNob3VsZCB3ZSBkaXNhbGxvdyByZWZlcmVuY2VzIGFuZCBleHByZXNzaW9ucyBhcyB3ZWxsP1xuICAgIGlmIChkaXNhbGxvd2VkLmhhcyhwcm9wLnZhbHVlLnR5cGUpKSB7XG4gICAgICAgIHZhbGlkYXRvci5lcnJvcihcIidkYXRhJyBtdXN0IGJlIGEgZnVuY3Rpb25cIiwgcHJvcC52YWx1ZS5zdGFydCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZXRob2ROYW1lKG5vZGUpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAnSWRlbnRpZmllcicpXG4gICAgICAgIHJldHVybiBub2RlLm5hbWU7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0xpdGVyYWwnKVxuICAgICAgICByZXR1cm4gU3RyaW5nKG5vZGUudmFsdWUpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckR1cGVzKHZhbGlkYXRvciwgcHJvcGVydGllcykge1xuICAgIHZhciBzZWVuID0gbmV3IFNldCgpO1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldE1ldGhvZE5hbWUocHJvcC5rZXkpO1xuICAgICAgICBpZiAoc2Vlbi5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIkR1cGxpY2F0ZSBwcm9wZXJ0eSAnXCIgKyBuYW1lICsgXCInXCIsIHByb3Auc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKG5hbWUpO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvckNvbXB1dGVkS2V5cyh2YWxpZGF0b3IsIHByb3BlcnRpZXMpIHtcbiAgICBwcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgaWYgKHByb3Aua2V5LmNvbXB1dGVkKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCJDYW5ub3QgdXNlIGNvbXB1dGVkIGtleXNcIiwgcHJvcC5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gbmV3IFNldChbXG4gICAgJ0Z1bmN0aW9uRXhwcmVzc2lvbicsXG4gICAgJ0Fycm93RnVuY3Rpb25FeHByZXNzaW9uJyxcbl0pO1xuZnVuY3Rpb24gY29tcHV0ZWQodmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgaWYgKHByb3AudmFsdWUudHlwZSAhPT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XG4gICAgICAgIHZhbGlkYXRvci5lcnJvcihcIlRoZSAnY29tcHV0ZWQnIHByb3BlcnR5IG11c3QgYmUgYW4gb2JqZWN0IGxpdGVyYWxcIiwgcHJvcC5zdGFydCk7XG4gICAgfVxuICAgIGNoZWNrRm9yRHVwZXModmFsaWRhdG9yLCBwcm9wLnZhbHVlLnByb3BlcnRpZXMpO1xuICAgIGNoZWNrRm9yQ29tcHV0ZWRLZXlzKHZhbGlkYXRvciwgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICBwcm9wLnZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoY29tcHV0YXRpb24pIHtcbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uRXhwcmVzc2lvbi5oYXMoY29tcHV0YXRpb24udmFsdWUudHlwZSkpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIkNvbXB1dGVkIHByb3BlcnRpZXMgY2FuIGJlIGZ1bmN0aW9uIGV4cHJlc3Npb25zIG9yIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb25zXCIsIGNvbXB1dGF0aW9uLnZhbHVlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyYW1zID0gY29tcHV0YXRpb24udmFsdWUucGFyYW1zO1xuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiQSBjb21wdXRlZCB2YWx1ZSBtdXN0IGRlcGVuZCBvbiBhdCBsZWFzdCBvbmUgcHJvcGVydHlcIiwgY29tcHV0YXRpb24udmFsdWUuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkID0gcGFyYW0udHlwZSA9PT0gJ0lkZW50aWZpZXInIHx8XG4gICAgICAgICAgICAgICAgKHBhcmFtLnR5cGUgPT09ICdBc3NpZ25tZW50UGF0dGVybicgJiZcbiAgICAgICAgICAgICAgICAgICAgcGFyYW0ubGVmdC50eXBlID09PSAnSWRlbnRpZmllcicpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIkNvbXB1dGVkIHByb3BlcnRpZXMgY2Fubm90IHVzZSBkZXN0cnVjdHVyaW5nIGluIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIiwgcGFyYW0uc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaXNSZWZlcmVuY2Uobm9kZSwgcGFyZW50KSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICAgIHJldHVybiAhbm9kZS5jb21wdXRlZCAmJiBpc1JlZmVyZW5jZShub2RlLm9iamVjdCwgbm9kZSk7XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICAvLyB0aGUgb25seSB0aW1lIHdlIGNvdWxkIGhhdmUgYW4gaWRlbnRpZmllciBub2RlIHdpdGhvdXQgYSBwYXJlbnQgaXNcbiAgICAgICAgLy8gaWYgaXQncyB0aGUgZW50aXJlIGJvZHkgb2YgYSBmdW5jdGlvbiB3aXRob3V0IGEgYmxvY2sgc3RhdGVtZW50IOKAk1xuICAgICAgICAvLyBpLmUuIGFuIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb24gbGlrZSBgYSA9PiBhYFxuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAvLyBUT0RPIGlzIHRoaXMgcmlnaHQ/XG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nIHx8XG4gICAgICAgICAgICBwYXJlbnQudHlwZSA9PT0gJ01ldGhvZERlZmluaXRpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNvbXB1dGVkIHx8IG5vZGUgPT09IHBhcmVudC5vYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzcmVnYXJkIHRoZSBgYmFyYCBpbiBgeyBiYXI6IGZvbyB9YCwgYnV0IGtlZXAgaXQgaW4gYHsgW2Jhcl06IGZvbyB9YFxuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdQcm9wZXJ0eScpXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNvbXB1dGVkIHx8IG5vZGUgPT09IHBhcmVudC52YWx1ZTtcbiAgICAgICAgLy8gZGlzcmVnYXJkIHRoZSBgYmFyYCBpbiBgY2xhc3MgRm9vIHsgYmFyICgpIHsuLi59IH1gXG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ01ldGhvZERlZmluaXRpb24nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBkaXNyZWdhcmQgdGhlIGBiYXJgIGluIGBleHBvcnQgeyBmb28gYXMgYmFyIH1gXG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ0V4cG9ydFNwZWNpZmllcicgJiYgbm9kZSAhPT0gcGFyZW50LmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVzZXNUaGlzT3JBcmd1bWVudHMobm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICB3YWxrKG5vZGUsIHtcbiAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgfHxcbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPT09ICdGdW5jdGlvbkV4cHJlc3Npb24nIHx8XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID09PSAnRnVuY3Rpb25EZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5za2lwKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgICAgICAgICAgIGlzUmVmZXJlbmNlKG5vZGUsIHBhcmVudCkgJiZcbiAgICAgICAgICAgICAgICBub2RlLm5hbWUgPT09ICdhcmd1bWVudHMnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG9uY3JlYXRlKHZhbGlkYXRvciwgcHJvcCkge1xuICAgIGlmIChwcm9wLnZhbHVlLnR5cGUgPT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICAgICAgaWYgKHVzZXNUaGlzT3JBcmd1bWVudHMocHJvcC52YWx1ZS5ib2R5KSkge1xuICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiJ29uY3JlYXRlJyBzaG91bGQgYmUgYSBmdW5jdGlvbiBleHByZXNzaW9uLCBub3QgYW4gYXJyb3cgZnVuY3Rpb24gZXhwcmVzc2lvblwiLCBwcm9wLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gb25kZXN0cm95KHZhbGlkYXRvciwgcHJvcCkge1xuICAgIGlmIChwcm9wLnZhbHVlLnR5cGUgPT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICAgICAgaWYgKHVzZXNUaGlzT3JBcmd1bWVudHMocHJvcC52YWx1ZS5ib2R5KSkge1xuICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiJ29uZGVzdHJveScgc2hvdWxkIGJlIGEgZnVuY3Rpb24gZXhwcmVzc2lvbiwgbm90IGFuIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb25cIiwgcHJvcC5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG9ucmVuZGVyKHZhbGlkYXRvciwgcHJvcCkge1xuICAgIHZhbGlkYXRvci53YXJuKFwiJ29ucmVuZGVyJyBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm91ciBvZiAnb25jcmVhdGUnLCBhbmQgd2lsbCBjYXVzZSBhbiBlcnJvciBpbiBTdmVsdGUgMi54XCIsIHByb3Auc3RhcnQpO1xuICAgIG9uY3JlYXRlKHZhbGlkYXRvciwgcHJvcCk7XG59XG5cbmZ1bmN0aW9uIG9udGVhcmRvd24odmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgdmFsaWRhdG9yLndhcm4oXCInb250ZWFyZG93bicgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2YgJ29uZGVzdHJveScsIGFuZCB3aWxsIGNhdXNlIGFuIGVycm9yIGluIFN2ZWx0ZSAyLnhcIiwgcHJvcC5zdGFydCk7XG4gICAgb25kZXN0cm95KHZhbGlkYXRvciwgcHJvcCk7XG59XG5cbmZ1bmN0aW9uIGhlbHBlcnModmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgaWYgKHByb3AudmFsdWUudHlwZSAhPT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XG4gICAgICAgIHZhbGlkYXRvci5lcnJvcihcIlRoZSAnaGVscGVycycgcHJvcGVydHkgbXVzdCBiZSBhbiBvYmplY3QgbGl0ZXJhbFwiLCBwcm9wLnN0YXJ0KTtcbiAgICB9XG4gICAgY2hlY2tGb3JEdXBlcyh2YWxpZGF0b3IsIHByb3AudmFsdWUucHJvcGVydGllcyk7XG4gICAgY2hlY2tGb3JDb21wdXRlZEtleXModmFsaWRhdG9yLCBwcm9wLnZhbHVlLnByb3BlcnRpZXMpO1xuICAgIHByb3AudmFsdWUucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIGlmICghL0Z1bmN0aW9uRXhwcmVzc2lvbi8udGVzdChwcm9wLnZhbHVlLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbGV4aWNhbERlcHRoID0gMDtcbiAgICAgICAgdmFyIHVzZXNBcmd1bWVudHMgPSBmYWxzZTtcbiAgICAgICAgd2Fsayhwcm9wLnZhbHVlLmJvZHksIHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICgvXkZ1bmN0aW9uLy50ZXN0KG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV4aWNhbERlcHRoICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxleGljYWxEZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIHRoYXQncyBjYXVzZWQgc29tZSBwZW9wbGUgY29uZnVzaW9uIOKAlCB1c2luZyBgdGhpcy5nZXQoLi4uKWAgaW5zdGVhZCBvZiBwYXNzaW5nIGFyZ3VtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gZG8gdGhlIHNhbWUgdGhpbmcgZm9yIGNvbXB1dGVkIHZhbHVlcz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0NhbGxFeHByZXNzaW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jYWxsZWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNhbGxlZS5vYmplY3QudHlwZSA9PT0gJ1RoaXNFeHByZXNzaW9uJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jYWxsZWUucHJvcGVydHkubmFtZSA9PT0gJ2dldCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFub2RlLmNhbGxlZS5wcm9wZXJ0eS5jb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiQ2Fubm90IHVzZSB0aGlzLmdldCguLi4pIFxcdTIwMTQgaXQgbXVzdCBiZSBwYXNzZWQgaW50byB0aGUgaGVscGVyIGZ1bmN0aW9uIGFzIGFuIGFyZ3VtZW50XCIsIG5vZGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdUaGlzRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIkhlbHBlcnMgc2hvdWxkIGJlIHB1cmUgZnVuY3Rpb25zIFxcdTIwMTQgdGhleSBkbyBub3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSBhbmQgY2Fubm90IHVzZSAndGhpcycuIERpZCB5b3UgbWVhbiB0byBwdXQgdGhpcyBpbiAnbWV0aG9kcyc/XCIsIG5vZGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIG5vZGUubmFtZSA9PT0gJ2FyZ3VtZW50cycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXNBcmd1bWVudHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICgvXkZ1bmN0aW9uLy50ZXN0KG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV4aWNhbERlcHRoIC09IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByb3AudmFsdWUucGFyYW1zLmxlbmd0aCA9PT0gMCAmJiAhdXNlc0FyZ3VtZW50cykge1xuICAgICAgICAgICAgdmFsaWRhdG9yLndhcm4oXCJIZWxwZXJzIHNob3VsZCBiZSBwdXJlIGZ1bmN0aW9ucywgd2l0aCBhdCBsZWFzdCBvbmUgYXJndW1lbnRcIiwgcHJvcC5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JBY2Nlc3NvcnModmFsaWRhdG9yLCBwcm9wZXJ0aWVzLCBsYWJlbCkge1xuICAgIHByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBpZiAocHJvcC5raW5kICE9PSAnaW5pdCcpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihsYWJlbCArIFwiIGNhbm5vdCB1c2UgZ2V0dGVycyBhbmQgc2V0dGVyc1wiLCBwcm9wLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG52YXIgYnVpbHRpbiA9IG5ldyBTZXQoWydzZXQnLCAnZ2V0JywgJ29uJywgJ2ZpcmUnLCAnb2JzZXJ2ZScsICdkZXN0cm95J10pO1xuZnVuY3Rpb24gbWV0aG9kcyh2YWxpZGF0b3IsIHByb3ApIHtcbiAgICBpZiAocHJvcC52YWx1ZS50eXBlICE9PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiVGhlICdtZXRob2RzJyBwcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdCBsaXRlcmFsXCIsIHByb3Auc3RhcnQpO1xuICAgIH1cbiAgICBjaGVja0ZvckFjY2Vzc29ycyh2YWxpZGF0b3IsIHByb3AudmFsdWUucHJvcGVydGllcywgJ01ldGhvZHMnKTtcbiAgICBjaGVja0ZvckR1cGVzKHZhbGlkYXRvciwgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICBjaGVja0ZvckNvbXB1dGVkS2V5cyh2YWxpZGF0b3IsIHByb3AudmFsdWUucHJvcGVydGllcyk7XG4gICAgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgdmFyIG5hbWUgPSBnZXRNZXRob2ROYW1lKHByb3Aua2V5KTtcbiAgICAgICAgaWYgKGJ1aWx0aW4uaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCJDYW5ub3Qgb3ZlcndyaXRlIGJ1aWx0LWluIG1ldGhvZCAnXCIgKyBuYW1lICsgXCInXCIsIHByb3Auc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wLnZhbHVlLnR5cGUgPT09ICdBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgIGlmICh1c2VzVGhpc09yQXJndW1lbnRzKHByb3AudmFsdWUuYm9keSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCJNZXRob2QgJ1wiICsgcHJvcC5rZXlcbiAgICAgICAgICAgICAgICAgICAgLm5hbWUgKyBcIicgc2hvdWxkIGJlIGEgZnVuY3Rpb24gZXhwcmVzc2lvbiwgbm90IGFuIGFycm93IGZ1bmN0aW9uIGV4cHJlc3Npb25cIiwgcHJvcC5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcG9uZW50cyh2YWxpZGF0b3IsIHByb3ApIHtcbiAgICBpZiAocHJvcC52YWx1ZS50eXBlICE9PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiVGhlICdjb21wb25lbnRzJyBwcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdCBsaXRlcmFsXCIsIHByb3Auc3RhcnQpO1xuICAgIH1cbiAgICBjaGVja0ZvckR1cGVzKHZhbGlkYXRvciwgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICBjaGVja0ZvckNvbXB1dGVkS2V5cyh2YWxpZGF0b3IsIHByb3AudmFsdWUucHJvcGVydGllcyk7XG4gICAgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICB2YXIgbmFtZSA9IGdldE1ldGhvZE5hbWUoY29tcG9uZW50LmtleSk7XG4gICAgICAgIGlmIChuYW1lID09PSAnc3RhdGUnKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCJDb21wb25lbnQgY29uc3RydWN0b3JzIGNhbm5vdCBiZSBjYWxsZWQgJ3N0YXRlJyBkdWUgdG8gdGVjaG5pY2FsIGxpbWl0YXRpb25zXCIsIGNvbXBvbmVudC5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvXltBLVpdLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iud2FybihcIkNvbXBvbmVudCBuYW1lcyBzaG91bGQgYmUgY2FwaXRhbGlzZWRcIiwgY29tcG9uZW50LnN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBldmVudHModmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgaWYgKHByb3AudmFsdWUudHlwZSAhPT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XG4gICAgICAgIHZhbGlkYXRvci5lcnJvcihcIlRoZSAnZXZlbnRzJyBwcm9wZXJ0eSBtdXN0IGJlIGFuIG9iamVjdCBsaXRlcmFsXCIsIHByb3Auc3RhcnQpO1xuICAgIH1cbiAgICBjaGVja0ZvckR1cGVzKHZhbGlkYXRvciwgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICBjaGVja0ZvckNvbXB1dGVkS2V5cyh2YWxpZGF0b3IsIHByb3AudmFsdWUucHJvcGVydGllcyk7XG59XG5cbnZhciBodG1sID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIG1hdGhtbCA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBzdmcgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xudmFyIHhsaW5rID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xudmFyIHhtbCA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnO1xudmFyIHhtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMnO1xudmFyIHZhbGlkTmFtZXNwYWNlcyA9IFtcbiAgICAnaHRtbCcsXG4gICAgJ21hdGhtbCcsXG4gICAgJ3N2ZycsXG4gICAgJ3hsaW5rJyxcbiAgICAneG1sJyxcbiAgICAneG1sbnMnLFxuICAgIGh0bWwsXG4gICAgbWF0aG1sLFxuICAgIHN2ZyxcbiAgICB4bGluayxcbiAgICB4bWwsXG4gICAgeG1sbnMsXG5dO1xudmFyIG5hbWVzcGFjZXMgPSB7IGh0bWw6IGh0bWwsIG1hdGhtbDogbWF0aG1sLCBzdmc6IHN2ZywgeGxpbms6IHhsaW5rLCB4bWw6IHhtbCwgeG1sbnM6IHhtbG5zIH07XG5cbi8vIGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR2xlbmNoL2Z1enp5c2V0LmpzL2Jsb2IvbWFzdGVyL2xpYi9mdXp6eXNldC5qc1xuLy8gQlNEIExpY2Vuc2VkXG52YXIgR1JBTV9TSVpFX0xPV0VSID0gMjtcbnZhciBHUkFNX1NJWkVfVVBQRVIgPSAzO1xuLy8gcmV0dXJuIGFuIGVkaXQgZGlzdGFuY2UgZnJvbSAwIHRvIDFcbmZ1bmN0aW9uIF9kaXN0YW5jZShzdHIxLCBzdHIyKSB7XG4gICAgaWYgKHN0cjEgPT09IG51bGwgJiYgc3RyMiA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgJ1RyeWluZyB0byBjb21wYXJlIHR3byBudWxsIHZhbHVlcyc7XG4gICAgaWYgKHN0cjEgPT09IG51bGwgfHwgc3RyMiA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgc3RyMSA9IFN0cmluZyhzdHIxKTtcbiAgICBzdHIyID0gU3RyaW5nKHN0cjIpO1xuICAgIHZhciBkaXN0YW5jZSA9IGxldmVuc2h0ZWluKHN0cjEsIHN0cjIpO1xuICAgIGlmIChzdHIxLmxlbmd0aCA+IHN0cjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAxIC0gZGlzdGFuY2UgLyBzdHIxLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxIC0gZGlzdGFuY2UgLyBzdHIyLmxlbmd0aDtcbiAgICB9XG59XG4vLyBoZWxwZXIgZnVuY3Rpb25zXG5mdW5jdGlvbiBsZXZlbnNodGVpbihzdHIxLCBzdHIyKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBbXTtcbiAgICB2YXIgcHJldjtcbiAgICB2YXIgdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc3RyMi5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBzdHIxLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaSAmJiBqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cjEuY2hhckF0KGogLSAxKSA9PT0gc3RyMi5jaGFyQXQoaSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcHJldjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5taW4oY3VycmVudFtqXSwgY3VycmVudFtqIC0gMV0sIHByZXYpICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGkgKyBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldiA9IGN1cnJlbnRbal07XG4gICAgICAgICAgICBjdXJyZW50W2pdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQucG9wKCk7XG59XG52YXIgX25vbldvcmRSZSA9IC9bXlxcdywgXSsvO1xuZnVuY3Rpb24gX2l0ZXJhdGVHcmFtcyh2YWx1ZSwgZ3JhbVNpemUpIHtcbiAgICBncmFtU2l6ZSA9IGdyYW1TaXplIHx8IDI7XG4gICAgdmFyIHNpbXBsaWZpZWQgPSAnLScgKyB2YWx1ZS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoX25vbldvcmRSZSwgJycpICsgJy0nO1xuICAgIHZhciBsZW5EaWZmID0gZ3JhbVNpemUgLSBzaW1wbGlmaWVkLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChsZW5EaWZmID4gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbkRpZmY7ICsraSkge1xuICAgICAgICAgICAgdmFsdWUgKz0gJy0nO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2ltcGxpZmllZC5sZW5ndGggLSBncmFtU2l6ZSArIDE7ICsraSkge1xuICAgICAgICByZXN1bHRzLnB1c2goc2ltcGxpZmllZC5zbGljZShpLCBpICsgZ3JhbVNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBfZ3JhbUNvdW50ZXIodmFsdWUsIGdyYW1TaXplKSB7XG4gICAgLy8gcmV0dXJuIGFuIG9iamVjdCB3aGVyZSBrZXk9Z3JhbSwgdmFsdWU9bnVtYmVyIG9mIG9jY3VycmVuY2VzXG4gICAgZ3JhbVNpemUgPSBncmFtU2l6ZSB8fCAyO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgZ3JhbXMgPSBfaXRlcmF0ZUdyYW1zKHZhbHVlLCBncmFtU2l6ZSk7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoaTsgaSA8IGdyYW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChncmFtc1tpXSBpbiByZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtncmFtc1tpXV0gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdFtncmFtc1tpXV0gPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzb3J0RGVzY2VuZGluZyhhLCBiKSB7XG4gICAgcmV0dXJuIGJbMF0gLSBhWzBdO1xufVxudmFyIEZ1enp5U2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZ1enp5U2V0KGFycikge1xuICAgICAgICAvLyBkZWZpbmUgYWxsIHRoZSBvYmplY3QgZnVuY3Rpb25zIGFuZCBhdHRyaWJ1dGVzXG4gICAgICAgIHRoaXMuZXhhY3RTZXQgPSB7fTtcbiAgICAgICAgdGhpcy5tYXRjaERpY3QgPSB7fTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IHt9O1xuICAgICAgICAvLyBpbml0aWFsaXphdGlvblxuICAgICAgICBmb3IgKHZhciBpID0gR1JBTV9TSVpFX0xPV0VSOyBpIDwgR1JBTV9TSVpFX1VQUEVSICsgMTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLml0ZW1zW2ldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGFsbCB0aGUgaXRlbXMgdG8gdGhlIHNldFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdGhpcy5hZGQoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBGdXp6eVNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAobm9ybWFsaXplZFZhbHVlIGluIHRoaXMuZXhhY3RTZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaSA9IEdSQU1fU0laRV9MT1dFUjtcbiAgICAgICAgZm9yIChpOyBpIDwgR1JBTV9TSVpFX1VQUEVSICsgMTsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGQodmFsdWUsIGkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGdXp6eVNldC5wcm90b3R5cGUuX2FkZCA9IGZ1bmN0aW9uICh2YWx1ZSwgZ3JhbVNpemUpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXNbZ3JhbVNpemVdIHx8IFtdO1xuICAgICAgICB2YXIgaW5kZXggPSBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGl0ZW1zLnB1c2goMCk7XG4gICAgICAgIHZhciBncmFtQ291bnRzID0gX2dyYW1Db3VudGVyKG5vcm1hbGl6ZWRWYWx1ZSwgZ3JhbVNpemUpO1xuICAgICAgICB2YXIgc3VtT2ZTcXVhcmVHcmFtQ291bnRzID0gMDtcbiAgICAgICAgdmFyIGdyYW07XG4gICAgICAgIHZhciBncmFtQ291bnQ7XG4gICAgICAgIGZvciAoZ3JhbSBpbiBncmFtQ291bnRzKSB7XG4gICAgICAgICAgICBncmFtQ291bnQgPSBncmFtQ291bnRzW2dyYW1dO1xuICAgICAgICAgICAgc3VtT2ZTcXVhcmVHcmFtQ291bnRzICs9IE1hdGgucG93KGdyYW1Db3VudCwgMik7XG4gICAgICAgICAgICBpZiAoZ3JhbSBpbiB0aGlzLm1hdGNoRGljdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hEaWN0W2dyYW1dLnB1c2goW2luZGV4LCBncmFtQ291bnRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2hEaWN0W2dyYW1dID0gW1tpbmRleCwgZ3JhbUNvdW50XV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlY3Rvck5vcm1hbCA9IE1hdGguc3FydChzdW1PZlNxdWFyZUdyYW1Db3VudHMpO1xuICAgICAgICBpdGVtc1tpbmRleF0gPSBbdmVjdG9yTm9ybWFsLCBub3JtYWxpemVkVmFsdWVdO1xuICAgICAgICB0aGlzLml0ZW1zW2dyYW1TaXplXSA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmV4YWN0U2V0W25vcm1hbGl6ZWRWYWx1ZV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIFxuICAgIEZ1enp5U2V0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZSA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmV4YWN0U2V0W25vcm1hbGl6ZWRWYWx1ZV07XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBbWzEsIHJlc3VsdF1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIC8vIHN0YXJ0IHdpdGggaGlnaCBncmFtIHNpemUgYW5kIGlmIHRoZXJlIGFyZSBubyByZXN1bHRzLCBnbyB0byBsb3dlciBncmFtIHNpemVzXG4gICAgICAgIGZvciAodmFyIGdyYW1TaXplID0gR1JBTV9TSVpFX1VQUEVSOyBncmFtU2l6ZSA+PSBHUkFNX1NJWkVfTE9XRVI7IC0tZ3JhbVNpemUpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLl9fZ2V0KHZhbHVlLCBncmFtU2l6ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0cykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRnV6enlTZXQucHJvdG90eXBlLl9fZ2V0ID0gZnVuY3Rpb24gKHZhbHVlLCBncmFtU2l6ZSkge1xuICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSB7fTtcbiAgICAgICAgdmFyIGdyYW1Db3VudHMgPSBfZ3JhbUNvdW50ZXIobm9ybWFsaXplZFZhbHVlLCBncmFtU2l6ZSk7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXNbZ3JhbVNpemVdO1xuICAgICAgICB2YXIgc3VtT2ZTcXVhcmVHcmFtQ291bnRzID0gMDtcbiAgICAgICAgdmFyIGdyYW07XG4gICAgICAgIHZhciBncmFtQ291bnQ7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBvdGhlckdyYW1Db3VudDtcbiAgICAgICAgZm9yIChncmFtIGluIGdyYW1Db3VudHMpIHtcbiAgICAgICAgICAgIGdyYW1Db3VudCA9IGdyYW1Db3VudHNbZ3JhbV07XG4gICAgICAgICAgICBzdW1PZlNxdWFyZUdyYW1Db3VudHMgKz0gTWF0aC5wb3coZ3JhbUNvdW50LCAyKTtcbiAgICAgICAgICAgIGlmIChncmFtIGluIHRoaXMubWF0Y2hEaWN0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubWF0Y2hEaWN0W2dyYW1dLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5tYXRjaERpY3RbZ3JhbV1baV1bMF07XG4gICAgICAgICAgICAgICAgICAgIG90aGVyR3JhbUNvdW50ID0gdGhpcy5tYXRjaERpY3RbZ3JhbV1baV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCBpbiBtYXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzW2luZGV4XSArPSBncmFtQ291bnQgKiBvdGhlckdyYW1Db3VudDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNbaW5kZXhdID0gZ3JhbUNvdW50ICogb3RoZXJHcmFtQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlY3Rvck5vcm1hbCA9IE1hdGguc3FydChzdW1PZlNxdWFyZUdyYW1Db3VudHMpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgbWF0Y2hTY29yZTtcbiAgICAgICAgLy8gYnVpbGQgYSByZXN1bHRzIGxpc3Qgb2YgW3Njb3JlLCBzdHJdXG4gICAgICAgIGZvciAodmFyIG1hdGNoSW5kZXggaW4gbWF0Y2hlcykge1xuICAgICAgICAgICAgbWF0Y2hTY29yZSA9IG1hdGNoZXNbbWF0Y2hJbmRleF07XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goW1xuICAgICAgICAgICAgICAgIG1hdGNoU2NvcmUgLyAodmVjdG9yTm9ybWFsICogaXRlbXNbbWF0Y2hJbmRleF1bMF0pLFxuICAgICAgICAgICAgICAgIGl0ZW1zW21hdGNoSW5kZXhdWzFdLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cy5zb3J0KHNvcnREZXNjZW5kaW5nKTtcbiAgICAgICAgdmFyIG5ld1Jlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIGVuZEluZGV4ID0gTWF0aC5taW4oNTAsIHJlc3VsdHMubGVuZ3RoKTtcbiAgICAgICAgLy8gdHJ1bmNhdGUgc29tZXdoYXQgYXJiaXRyYXJpbHkgdG8gNTBcbiAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgZW5kSW5kZXg7ICsraV8xKSB7XG4gICAgICAgICAgICBuZXdSZXN1bHRzLnB1c2goW1xuICAgICAgICAgICAgICAgIF9kaXN0YW5jZShyZXN1bHRzW2lfMV1bMV0sIG5vcm1hbGl6ZWRWYWx1ZSksXG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpXzFdWzFdLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cyA9IG5ld1Jlc3VsdHM7XG4gICAgICAgIHJlc3VsdHMuc29ydChzb3J0RGVzY2VuZGluZyk7XG4gICAgICAgIG5ld1Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaV8yID0gMDsgaV8yIDwgcmVzdWx0cy5sZW5ndGg7ICsraV8yKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0c1tpXzJdWzBdID09IHJlc3VsdHNbMF1bMF0pIHtcbiAgICAgICAgICAgICAgICBuZXdSZXN1bHRzLnB1c2goW3Jlc3VsdHNbaV8yXVswXSwgdGhpcy5leGFjdFNldFtyZXN1bHRzW2lfMl1bMV1dXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1Jlc3VsdHM7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gRnV6enlTZXQ7XG59KCkpO1xuXG5mdW5jdGlvbiBmdXp6eW1hdGNoKG5hbWUsIG5hbWVzKSB7XG4gICAgdmFyIHNldCA9IG5ldyBGdXp6eVNldChuYW1lcyk7XG4gICAgdmFyIG1hdGNoZXMgPSBzZXQuZ2V0KG5hbWUpO1xuICAgIHJldHVybiBtYXRjaGVzICYmIG1hdGNoZXNbMF0gJiYgbWF0Y2hlc1swXVswXSA+IDAuNyA/IG1hdGNoZXNbMF1bMV0gOiBudWxsO1xufVxuXG52YXIgdmFsaWQgPSBuZXcgU2V0KHZhbGlkTmFtZXNwYWNlcyk7XG5mdW5jdGlvbiBuYW1lc3BhY2UodmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgdmFyIG5zID0gcHJvcC52YWx1ZS52YWx1ZTtcbiAgICBpZiAocHJvcC52YWx1ZS50eXBlICE9PSAnTGl0ZXJhbCcgfHwgdHlwZW9mIG5zICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCJUaGUgJ25hbWVzcGFjZScgcHJvcGVydHkgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsIHJlcHJlc2VudGluZyBhIHZhbGlkIG5hbWVzcGFjZVwiLCBwcm9wLnN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZC5oYXMobnMpKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1enp5bWF0Y2gobnMsIHZhbGlkTmFtZXNwYWNlcyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiSW52YWxpZCBuYW1lc3BhY2UgJ1wiICsgbnMgKyBcIicgKGRpZCB5b3UgbWVhbiAnXCIgKyBtYXRjaCArIFwiJz8pXCIsIHByb3Auc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiSW52YWxpZCBuYW1lc3BhY2UgJ1wiICsgbnMgKyBcIidcIiwgcHJvcC5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWQodmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgLy8gbm90IHN1cmUgdGhlcmUncyBhbnl0aGluZyB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUuLi5cbn1cblxuZnVuY3Rpb24gcHJvcHModmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgaWYgKHByb3AudmFsdWUudHlwZSAhPT0gJ0FycmF5RXhwcmVzc2lvbicpIHtcbiAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiJ3Byb3BzJyBtdXN0IGJlIGFuIGFycmF5IGV4cHJlc3Npb24sIGlmIHNwZWNpZmllZFwiLCBwcm9wLnZhbHVlLnN0YXJ0KTtcbiAgICB9XG4gICAgcHJvcC52YWx1ZS5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50LnR5cGUgIT09ICdMaXRlcmFsJyB8fCB0eXBlb2YgZWxlbWVudC52YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIidwcm9wcycgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmcgbGl0ZXJhbHNcIiwgZWxlbWVudC5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdGFnJDEodmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgaWYgKHByb3AudmFsdWUudHlwZSAhPT0gJ0xpdGVyYWwnIHx8IHR5cGVvZiBwcm9wLnZhbHVlLnZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCIndGFnJyBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWxcIiwgcHJvcC52YWx1ZS5zdGFydCk7XG4gICAgfVxuICAgIHZhciB0YWcgPSBwcm9wLnZhbHVlLnZhbHVlO1xuICAgIGlmICghL15bYS16QS1aXVthLXpBLVowLTldKi1bYS16QS1aMC05LV0rJC8udGVzdCh0YWcpKSB7XG4gICAgICAgIHZhbGlkYXRvci5lcnJvcihcInRhZyBuYW1lIG11c3QgYmUgdHdvIG9yIG1vcmUgd29yZHMgam9pbmVkIGJ5IHRoZSAnLScgY2hhcmFjdGVyXCIsIHByb3AudmFsdWUuc3RhcnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdHJhbnNpdGlvbnModmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgaWYgKHByb3AudmFsdWUudHlwZSAhPT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XG4gICAgICAgIHZhbGlkYXRvci5lcnJvcihcIlRoZSAndHJhbnNpdGlvbnMnIHByb3BlcnR5IG11c3QgYmUgYW4gb2JqZWN0IGxpdGVyYWxcIiwgcHJvcC5zdGFydCk7XG4gICAgfVxuICAgIGNoZWNrRm9yRHVwZXModmFsaWRhdG9yLCBwcm9wLnZhbHVlLnByb3BlcnRpZXMpO1xuICAgIGNoZWNrRm9yQ29tcHV0ZWRLZXlzKHZhbGlkYXRvciwgcHJvcC52YWx1ZS5wcm9wZXJ0aWVzKTtcbiAgICBwcm9wLnZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE8gcHJvYmFibHkgc29tZSB2YWxpZGF0aW9uIHRoYXQgY2FuIGhhcHBlbiBoZXJlLi4uXG4gICAgICAgIC8vIGNoZWNraW5nIGZvciB1c2Ugb2YgYHRoaXNgIGV0Yz9cbiAgICB9KTtcbn1cblxudmFyIGRpc2FsbG93ZWQkMSA9IG5ldyBTZXQoWydMaXRlcmFsJywgJ09iamVjdEV4cHJlc3Npb24nLCAnQXJyYXlFeHByZXNzaW9uJ10pO1xuZnVuY3Rpb24gc2V0dXAodmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgd2hpbGUgKHByb3AudHlwZSA9PT0gJ1BhcmVudGhlc2l6ZWRFeHByZXNzaW9uJylcbiAgICAgICAgcHJvcCA9IHByb3AuZXhwcmVzc2lvbjtcbiAgICBpZiAoZGlzYWxsb3dlZCQxLmhhcyhwcm9wLnZhbHVlLnR5cGUpKSB7XG4gICAgICAgIHZhbGlkYXRvci5lcnJvcihcIidzZXR1cCcgbXVzdCBiZSBhIGZ1bmN0aW9uXCIsIHByb3AudmFsdWUuc3RhcnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc3RvcmUodmFsaWRhdG9yLCBwcm9wKSB7XG4gICAgLy8gbm90IHN1cmUgdGhlcmUncyBhbnl0aGluZyB3ZSBuZWVkIHRvIGNoZWNrIGhlcmUuLi5cbn1cblxudmFyIHByb3BWYWxpZGF0b3JzID0ge1xuICAgIGRhdGE6IGRhdGEsXG4gICAgY29tcHV0ZWQ6IGNvbXB1dGVkLFxuICAgIG9uY3JlYXRlOiBvbmNyZWF0ZSxcbiAgICBvbmRlc3Ryb3k6IG9uZGVzdHJveSxcbiAgICBvbnJlbmRlcjogb25yZW5kZXIsXG4gICAgb250ZWFyZG93bjogb250ZWFyZG93bixcbiAgICBoZWxwZXJzOiBoZWxwZXJzLFxuICAgIG1ldGhvZHM6IG1ldGhvZHMsXG4gICAgY29tcG9uZW50czogY29tcG9uZW50cyxcbiAgICBldmVudHM6IGV2ZW50cyxcbiAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcbiAgICBwcmVsb2FkOiBwcmVsb2FkLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICB0YWc6IHRhZyQxLFxuICAgIHRyYW5zaXRpb25zOiB0cmFuc2l0aW9ucyxcbiAgICBzZXR1cDogc2V0dXAsXG4gICAgc3RvcmU6IHN0b3JlXG59O1xuXG52YXIgdmFsaWRQcm9wTGlzdCA9IE9iamVjdC5rZXlzKHByb3BWYWxpZGF0b3JzKTtcbmZ1bmN0aW9uIHZhbGlkYXRlSnModmFsaWRhdG9yLCBqcykge1xuICAgIGpzLmNvbnRlbnQuYm9keS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIGNoZWNrIHRoZXJlIGFyZSBubyBuYW1lZCBleHBvcnRzXG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdFeHBvcnROYW1lZERlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiQSBjb21wb25lbnQgY2FuIG9ubHkgaGF2ZSBhIGRlZmF1bHQgZXhwb3J0XCIsIG5vZGUuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdFeHBvcnREZWZhdWx0RGVjbGFyYXRpb24nKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kZWNsYXJhdGlvbi50eXBlICE9PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsaWRhdG9yLmVycm9yKFwiRGVmYXVsdCBleHBvcnQgbXVzdCBiZSBhbiBvYmplY3QgbGl0ZXJhbFwiLCBub2RlLmRlY2xhcmF0aW9uLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrRm9yQ29tcHV0ZWRLZXlzKHZhbGlkYXRvciwgbm9kZS5kZWNsYXJhdGlvbi5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGNoZWNrRm9yRHVwZXModmFsaWRhdG9yLCBub2RlLmRlY2xhcmF0aW9uLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgdmFyIHByb3BzXzEgPSB2YWxpZGF0b3IucHJvcGVydGllcztcbiAgICAgICAgICAgIG5vZGUuZGVjbGFyYXRpb24ucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgcHJvcHNfMS5zZXQoZ2V0TWV0aG9kTmFtZShwcm9wLmtleSksIHByb3ApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlc2UgY2hlY2tzIGluIHZlcnNpb24gMlxuICAgICAgICAgICAgaWYgKHByb3BzXzEuaGFzKCdvbmNyZWF0ZScpICYmIHByb3BzXzEuaGFzKCdvbnJlbmRlcicpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKCdDYW5ub3QgaGF2ZSBib3RoIG9uY3JlYXRlIGFuZCBvbnJlbmRlcicsIHByb3BzXzEuZ2V0KCdvbnJlbmRlcicpLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wc18xLmhhcygnb25kZXN0cm95JykgJiYgcHJvcHNfMS5oYXMoJ29udGVhcmRvd24nKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcignQ2Fubm90IGhhdmUgYm90aCBvbmRlc3Ryb3kgYW5kIG9udGVhcmRvd24nLCBwcm9wc18xLmdldCgnb250ZWFyZG93bicpLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVuc3VyZSBhbGwgZXhwb3J0ZWQgcHJvcHMgYXJlIHZhbGlkXG4gICAgICAgICAgICBub2RlLmRlY2xhcmF0aW9uLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0TWV0aG9kTmFtZShwcm9wLmtleSk7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BWYWxpZGF0b3IgPSBwcm9wVmFsaWRhdG9yc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcFZhbGlkYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsaWRhdG9yKHZhbGlkYXRvciwgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBmdXp6eW1hdGNoKG5hbWUsIHZhbGlkUHJvcExpc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIlVuZXhwZWN0ZWQgcHJvcGVydHkgJ1wiICsgbmFtZSArIFwiJyAoZGlkIHlvdSBtZWFuICdcIiArIG1hdGNoICsgXCInPylcIiwgcHJvcC5zdGFydCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoL0Z1bmN0aW9uRXhwcmVzc2lvbi8udGVzdChwcm9wLnZhbHVlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCJVbmV4cGVjdGVkIHByb3BlcnR5ICdcIiArIG5hbWUgKyBcIicgKGRpZCB5b3UgbWVhbiB0byBpbmNsdWRlIGl0IGluICdtZXRob2RzJz8pXCIsIHByb3Auc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiVW5leHBlY3RlZCBwcm9wZXJ0eSAnXCIgKyBuYW1lICsgXCInXCIsIHByb3Auc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocHJvcHNfMS5oYXMoJ25hbWVzcGFjZScpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5zID0gcHJvcHNfMS5nZXQoJ25hbWVzcGFjZScpLnZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzW25zXSB8fCBucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbGlkYXRvci5kZWZhdWx0RXhwb3J0ID0gbm9kZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFsnY29tcG9uZW50cycsICdtZXRob2RzJywgJ2hlbHBlcnMnLCAndHJhbnNpdGlvbnMnXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRvci5wcm9wZXJ0aWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3IucHJvcGVydGllcy5nZXQoa2V5KS52YWx1ZS5wcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3Jba2V5XS5zZXQoZ2V0TWV0aG9kTmFtZShwcm9wLmtleSksIHByb3AudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlbihub2RlKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgdmFyIHByb3BFbmQgPSBub2RlLmVuZDtcbiAgICB3aGlsZSAobm9kZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgICAgaWYgKG5vZGUuY29tcHV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcGFydHMudW5zaGlmdChub2RlLnByb3BlcnR5Lm5hbWUpO1xuICAgICAgICBub2RlID0gbm9kZS5vYmplY3Q7XG4gICAgfVxuICAgIHZhciBwcm9wU3RhcnQgPSBub2RlLmVuZDtcbiAgICB2YXIgbmFtZSA9IG5vZGUudHlwZSA9PT0gJ0lkZW50aWZpZXInXG4gICAgICAgID8gbm9kZS5uYW1lXG4gICAgICAgIDogbm9kZS50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nID8gJ3RoaXMnIDogbnVsbDtcbiAgICBpZiAoIW5hbWUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHBhcnRzLnVuc2hpZnQobmFtZSk7XG4gICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgcGFydHM6IHBhcnRzLCBrZXlwYXRoOiBuYW1lICsgXCJbXFx1MjcwMlwiICsgcHJvcFN0YXJ0ICsgXCItXCIgKyBwcm9wRW5kICsgXCJcXHUyNzAyXVwiIH07XG59XG5cbmZ1bmN0aW9uIGxpc3QkMihpdGVtcywgY29uanVuY3Rpb24pIHtcbiAgICBpZiAoY29uanVuY3Rpb24gPT09IHZvaWQgMCkgeyBjb25qdW5jdGlvbiA9ICdvcic7IH1cbiAgICBpZiAoaXRlbXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gaXRlbXNbMF07XG4gICAgcmV0dXJuIGl0ZW1zLnNsaWNlKDAsIC0xKS5qb2luKCcsICcpICsgXCIgXCIgKyBjb25qdW5jdGlvbiArIFwiIFwiICsgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG59XG5cbnZhciB2YWxpZENhbGxlZU9iamVjdHMgPSBuZXcgU2V0KFsndGhpcycsICdldmVudCcsICdjb25zb2xlJ10pO1xuXG52YXIgdmFsaWRCdWlsdGlucyA9IG5ldyBTZXQoWydzZXQnLCAnZmlyZScsICdkZXN0cm95J10pO1xuZnVuY3Rpb24gdmFsaWRhdGVFdmVudEhhbmRsZXJDYWxsZWUodmFsaWRhdG9yLCBhdHRyaWJ1dGUsIHJlZkNhbGxlZXMpIHtcbiAgICBpZiAoIWF0dHJpYnV0ZS5leHByZXNzaW9uKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIF9hID0gYXR0cmlidXRlLmV4cHJlc3Npb24sIGNhbGxlZSA9IF9hLmNhbGxlZSwgc3RhcnQgPSBfYS5zdGFydCwgdHlwZSA9IF9hLnR5cGU7XG4gICAgaWYgKHR5cGUgIT09ICdDYWxsRXhwcmVzc2lvbicpIHtcbiAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiRXhwZWN0ZWQgYSBjYWxsIGV4cHJlc3Npb25cIiwgc3RhcnQpO1xuICAgIH1cbiAgICB2YXIgbmFtZSA9IGZsYXR0ZW4oY2FsbGVlKS5uYW1lO1xuICAgIGlmICh2YWxpZENhbGxlZU9iamVjdHMuaGFzKG5hbWUpIHx8IG5hbWUgPT09ICdvcHRpb25zJylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChuYW1lID09PSAncmVmcycpIHtcbiAgICAgICAgcmVmQ2FsbGVlcy5wdXNoKGNhbGxlZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdzdG9yZScgJiYgYXR0cmlidXRlLmV4cHJlc3Npb24uY2FsbGVlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICBpZiAoIXZhbGlkYXRvci5vcHRpb25zLnN0b3JlKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iud2FybignY29tcGlsZSB3aXRoIGBzdG9yZTogdHJ1ZWAgaW4gb3JkZXIgdG8gY2FsbCBzdG9yZSBtZXRob2RzJywgYXR0cmlidXRlLmV4cHJlc3Npb24uc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKChjYWxsZWUudHlwZSA9PT0gJ0lkZW50aWZpZXInICYmIHZhbGlkQnVpbHRpbnMuaGFzKGNhbGxlZS5uYW1lKSkgfHxcbiAgICAgICAgdmFsaWRhdG9yLm1ldGhvZHMuaGFzKGNhbGxlZS5uYW1lKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZhciB2YWxpZENhbGxlZXMgPSBbJ3RoaXMuKicsICdldmVudC4qJywgJ29wdGlvbnMuKicsICdjb25zb2xlLionXS5jb25jYXQodmFsaWRhdG9yLm9wdGlvbnMuc3RvcmUgPyAnc3RvcmUuKicgOiBbXSwgQXJyYXkuZnJvbSh2YWxpZEJ1aWx0aW5zKSwgQXJyYXkuZnJvbSh2YWxpZGF0b3IubWV0aG9kcy5rZXlzKCkpKTtcbiAgICB2YXIgbWVzc2FnZSA9IFwiJ1wiICsgdmFsaWRhdG9yLnNvdXJjZS5zbGljZShjYWxsZWUuc3RhcnQsIGNhbGxlZS5lbmQpICsgXCInIGlzIGFuIGludmFsaWQgY2FsbGVlIChzaG91bGQgYmUgb25lIG9mIFwiICsgbGlzdCQyKHZhbGlkQ2FsbGVlcykgKyBcIilcIjtcbiAgICBpZiAoY2FsbGVlLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiB2YWxpZGF0b3IuaGVscGVycy5oYXMoY2FsbGVlLm5hbWUpKSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gXCIuICdcIiArIGNhbGxlZS5uYW1lICsgXCInIGV4aXN0cyBvbiAnaGVscGVycycsIGRpZCB5b3UgcHV0IGl0IGluIHRoZSB3cm9uZyBwbGFjZT9cIjtcbiAgICB9XG4gICAgdmFsaWRhdG9yLndhcm4obWVzc2FnZSwgc3RhcnQpO1xufVxuXG52YXIgc3ZnJDEgPSAvXig/OmFsdEdseXBofGFsdEdseXBoRGVmfGFsdEdseXBoSXRlbXxhbmltYXRlfGFuaW1hdGVDb2xvcnxhbmltYXRlTW90aW9ufGFuaW1hdGVUcmFuc2Zvcm18Y2lyY2xlfGNsaXBQYXRofGNvbG9yLXByb2ZpbGV8Y3Vyc29yfGRlZnN8ZGVzY3xkaXNjYXJkfGVsbGlwc2V8ZmVCbGVuZHxmZUNvbG9yTWF0cml4fGZlQ29tcG9uZW50VHJhbnNmZXJ8ZmVDb21wb3NpdGV8ZmVDb252b2x2ZU1hdHJpeHxmZURpZmZ1c2VMaWdodGluZ3xmZURpc3BsYWNlbWVudE1hcHxmZURpc3RhbnRMaWdodHxmZURyb3BTaGFkb3d8ZmVGbG9vZHxmZUZ1bmNBfGZlRnVuY0J8ZmVGdW5jR3xmZUZ1bmNSfGZlR2F1c3NpYW5CbHVyfGZlSW1hZ2V8ZmVNZXJnZXxmZU1lcmdlTm9kZXxmZU1vcnBob2xvZ3l8ZmVPZmZzZXR8ZmVQb2ludExpZ2h0fGZlU3BlY3VsYXJMaWdodGluZ3xmZVNwb3RMaWdodHxmZVRpbGV8ZmVUdXJidWxlbmNlfGZpbHRlcnxmb250fGZvbnQtZmFjZXxmb250LWZhY2UtZm9ybWF0fGZvbnQtZmFjZS1uYW1lfGZvbnQtZmFjZS1zcmN8Zm9udC1mYWNlLXVyaXxmb3JlaWduT2JqZWN0fGd8Z2x5cGh8Z2x5cGhSZWZ8aGF0Y2h8aGF0Y2hwYXRofGhrZXJufGltYWdlfGxpbmV8bGluZWFyR3JhZGllbnR8bWFya2VyfG1hc2t8bWVzaHxtZXNoZ3JhZGllbnR8bWVzaHBhdGNofG1lc2hyb3d8bWV0YWRhdGF8bWlzc2luZy1nbHlwaHxtcGF0aHxwYXRofHBhdHRlcm58cG9seWdvbnxwb2x5bGluZXxyYWRpYWxHcmFkaWVudHxyZWN0fHNldHxzb2xpZGNvbG9yfHN0b3B8c3dpdGNofHN5bWJvbHx0ZXh0fHRleHRQYXRofHRpdGxlfHRyZWZ8dHNwYW58dW5rbm93bnx1c2V8dmlld3x2a2VybikkLztcbmZ1bmN0aW9uIHZhbGlkYXRlRWxlbWVudCh2YWxpZGF0b3IsIG5vZGUsIHJlZnMsIHJlZkNhbGxlZXMsIHN0YWNrLCBlbGVtZW50U3RhY2spIHtcbiAgICB2YXIgaXNDb21wb25lbnQgPSBub2RlLm5hbWUgPT09ICc6U2VsZicgfHwgbm9kZS5uYW1lID09PSAnOkNvbXBvbmVudCcgfHwgdmFsaWRhdG9yLmNvbXBvbmVudHMuaGFzKG5vZGUubmFtZSk7XG4gICAgaWYgKCFpc0NvbXBvbmVudCAmJiAvXltBLVpdLy50ZXN0KG5vZGUubmFtZVswXSkpIHtcbiAgICAgICAgLy8gVE9ETyB1cGdyYWRlIHRvIHZhbGlkYXRvci5lcnJvciBpbiB2MlxuICAgICAgICB2YWxpZGF0b3Iud2Fybihub2RlLm5hbWUgKyBcIiBjb21wb25lbnQgaXMgbm90IGRlZmluZWRcIiwgbm9kZS5zdGFydCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50U3RhY2subGVuZ3RoID09PSAwICYmIHZhbGlkYXRvci5uYW1lc3BhY2UgIT09IHN2ZyAmJiBzdmckMS50ZXN0KG5vZGUubmFtZSkpIHtcbiAgICAgICAgdmFsaWRhdG9yLndhcm4oXCI8XCIgKyBub2RlLm5hbWUgKyBcIj4gaXMgYW4gU1ZHIGVsZW1lbnQgXFx1MjAxMyBkaWQgeW91IGZvcmdldCB0byBhZGQgeyBuYW1lc3BhY2U6ICdzdmcnIH0gP1wiLCBub2RlLnN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgIHZhciBuYW1lQXR0cmlidXRlID0gbm9kZS5hdHRyaWJ1dGVzLmZpbmQoZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyByZXR1cm4gYXR0cmlidXRlLm5hbWUgPT09ICduYW1lJzsgfSk7XG4gICAgICAgIGlmIChuYW1lQXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpZiAobmFtZUF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggIT09IDEgfHwgbmFtZUF0dHJpYnV0ZS52YWx1ZVswXS50eXBlICE9PSAnVGV4dCcpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCI8c2xvdD4gbmFtZSBjYW5ub3QgYmUgZHluYW1pY1wiLCBuYW1lQXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzbG90TmFtZSA9IG5hbWVBdHRyaWJ1dGUudmFsdWVbMF0uZGF0YTtcbiAgICAgICAgICAgIGlmIChzbG90TmFtZSA9PT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiZGVmYXVsdCBpcyBhIHJlc2VydmVkIHdvcmQgXFx1MjAxNCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIHNsb3QgbmFtZVwiLCBuYW1lQXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE8gc2hvdWxkIGR1cGxpY2F0ZSBzbG90cyBiZSBkaXNhbGxvd2VkPyBGZWVscyBsaWtlIGl0J3MgbW9yZSBsaWtlbHkgdG8gYmUgYVxuICAgICAgICAgICAgLy8gYnVnIHRoYW4gYW55dGhpbmcuIFBlcmhhcHMgaXQgc2hvdWxkIGJlIGEgd2FybmluZ1xuICAgICAgICAgICAgLy8gaWYgKHZhbGlkYXRvci5zbG90cy5oYXMoc2xvdE5hbWUpKSB7XG4gICAgICAgICAgICAvLyBcdHZhbGlkYXRvci5lcnJvcihgZHVwbGljYXRlICcke3Nsb3ROYW1lfScgPHNsb3Q+IGVsZW1lbnRgLCBuYW1lQXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIHZhbGlkYXRvci5zbG90cy5hZGQoc2xvdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgKHZhbGlkYXRvci5zbG90cy5oYXMoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgLy8gXHR2YWxpZGF0b3IuZXJyb3IoYGR1cGxpY2F0ZSBkZWZhdWx0IDxzbG90PiBlbGVtZW50YCwgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyB2YWxpZGF0b3Iuc2xvdHMuYWRkKCdkZWZhdWx0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGhhc0ludHJvO1xuICAgIHZhciBoYXNPdXRybztcbiAgICB2YXIgaGFzVHJhbnNpdGlvbjtcbiAgICBub2RlLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ1JlZicpIHtcbiAgICAgICAgICAgIGlmICghcmVmcy5oYXMoYXR0cmlidXRlLm5hbWUpKVxuICAgICAgICAgICAgICAgIHJlZnMuc2V0KGF0dHJpYnV0ZS5uYW1lLCBbXSk7XG4gICAgICAgICAgICByZWZzLmdldChhdHRyaWJ1dGUubmFtZSkucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQ29tcG9uZW50ICYmIGF0dHJpYnV0ZS50eXBlID09PSAnQmluZGluZycpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgIT09ICdpbnB1dCcgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lICE9PSAndGV4dGFyZWEnICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiJ3ZhbHVlJyBpcyBub3QgYSB2YWxpZCBiaW5kaW5nIG9uIDxcIiArIG5vZGUubmFtZSArIFwiPiBlbGVtZW50c1wiLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGVja1R5cGVBdHRyaWJ1dGUodmFsaWRhdG9yLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdjaGVja2VkJyB8fCBuYW1lID09PSAnaW5kZXRlcm1pbmF0ZScpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lICE9PSAnaW5wdXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIidcIiArIG5hbWUgKyBcIicgaXMgbm90IGEgdmFsaWQgYmluZGluZyBvbiA8XCIgKyBub2RlLm5hbWUgKyBcIj4gZWxlbWVudHNcIiwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVHlwZUF0dHJpYnV0ZSh2YWxpZGF0b3IsIG5vZGUpICE9PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIidcIiArIG5hbWUgKyBcIicgYmluZGluZyBjYW4gb25seSBiZSB1c2VkIHdpdGggPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIj5cIiwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSAhPT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCInZ3JvdXAnIGlzIG5vdCBhIHZhbGlkIGJpbmRpbmcgb24gPFwiICsgbm9kZS5uYW1lICsgXCI+IGVsZW1lbnRzXCIsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gY2hlY2tUeXBlQXR0cmlidXRlKHZhbGlkYXRvciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgIT09ICdjaGVja2JveCcgJiYgdHlwZSAhPT0gJ3JhZGlvJykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCInY2hlY2tlZCcgYmluZGluZyBjYW4gb25seSBiZSB1c2VkIHdpdGggPGlucHV0IHR5cGU9XFxcImNoZWNrYm94XFxcIj4gb3IgPGlucHV0IHR5cGU9XFxcInJhZGlvXFxcIj5cIiwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnY3VycmVudFRpbWUnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2R1cmF0aW9uJyB8fFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdwYXVzZWQnIHx8XG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2J1ZmZlcmVkJyB8fFxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdzZWVrYWJsZScgfHxcbiAgICAgICAgICAgICAgICBuYW1lID09PSAncGxheWVkJykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgIT09ICdhdWRpbycgJiYgbm9kZS5uYW1lICE9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIidcIiArIG5hbWUgKyBcIicgYmluZGluZyBjYW4gb25seSBiZSB1c2VkIHdpdGggPGF1ZGlvPiBvciA8dmlkZW8+XCIsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiJ1wiICsgYXR0cmlidXRlLm5hbWUgKyBcIicgaXMgbm90IGEgdmFsaWQgYmluZGluZ1wiLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnRXZlbnRIYW5kbGVyJykge1xuICAgICAgICAgICAgdmFsaWRhdGVFdmVudEhhbmRsZXJDYWxsZWUodmFsaWRhdG9yLCBhdHRyaWJ1dGUsIHJlZkNhbGxlZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnVHJhbnNpdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChpc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIlRyYW5zaXRpb25zIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gRE9NIGVsZW1lbnRzLCBub3QgY29tcG9uZW50c1wiLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJpZGkgPSBhdHRyaWJ1dGUuaW50cm8gJiYgYXR0cmlidXRlLm91dHJvO1xuICAgICAgICAgICAgaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoYmlkaSlcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiQW4gZWxlbWVudCBjYW4gb25seSBoYXZlIG9uZSAndHJhbnNpdGlvbicgZGlyZWN0aXZlXCIsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiQW4gZWxlbWVudCBjYW5ub3QgaGF2ZSBib3RoIGEgJ3RyYW5zaXRpb24nIGRpcmVjdGl2ZSBhbmQgYW4gJ1wiICsgKGF0dHJpYnV0ZS5pbnRyb1xuICAgICAgICAgICAgICAgICAgICA/ICdpbidcbiAgICAgICAgICAgICAgICAgICAgOiAnb3V0JykgKyBcIicgZGlyZWN0aXZlXCIsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKGhhc0ludHJvICYmIGF0dHJpYnV0ZS5pbnRybykgfHwgKGhhc091dHJvICYmIGF0dHJpYnV0ZS5vdXRybykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYmlkaSlcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiQW4gZWxlbWVudCBjYW5ub3QgaGF2ZSBib3RoIGFuICdcIiArIChoYXNJbnRyb1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnaW4nXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICdvdXQnKSArIFwiJyBkaXJlY3RpdmUgYW5kIGEgJ3RyYW5zaXRpb24nIGRpcmVjdGl2ZVwiLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIkFuIGVsZW1lbnQgY2FuIG9ubHkgaGF2ZSBvbmUgJ1wiICsgKGhhc0ludHJvID8gJ2luJyA6ICdvdXQnKSArIFwiJyBkaXJlY3RpdmVcIiwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuaW50cm8pXG4gICAgICAgICAgICAgICAgaGFzSW50cm8gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5vdXRybylcbiAgICAgICAgICAgICAgICBoYXNPdXRybyA9IHRydWU7XG4gICAgICAgICAgICBpZiAoYmlkaSlcbiAgICAgICAgICAgICAgICBoYXNUcmFuc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdG9yLnRyYW5zaXRpb25zLmhhcyhhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCJNaXNzaW5nIHRyYW5zaXRpb24gJ1wiICsgYXR0cmlidXRlLm5hbWUgKyBcIidcIiwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ0F0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUubmFtZSA9PT0gJ3ZhbHVlJyAmJiBub2RlLm5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwiQSA8dGV4dGFyZWE+IGNhbiBoYXZlIGVpdGhlciBhIHZhbHVlIGF0dHJpYnV0ZSBvciAoZXF1aXZhbGVudGx5KSBjaGlsZCBjb250ZW50LCBidXQgbm90IGJvdGhcIiwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlLm5hbWUgPT09ICdzbG90JyAmJiAhaXNDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGVja1Nsb3RBdHRyaWJ1dGUodmFsaWRhdG9yLCBub2RlLCBhdHRyaWJ1dGUsIHN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hlY2tUeXBlQXR0cmlidXRlKHZhbGlkYXRvciwgbm9kZSkge1xuICAgIHZhciBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXMuZmluZChmdW5jdGlvbiAoYXR0cmlidXRlKSB7IHJldHVybiBhdHRyaWJ1dGUubmFtZSA9PT0gJ3R5cGUnOyB9KTtcbiAgICBpZiAoIWF0dHJpYnV0ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCIndHlwZScgYXR0cmlidXRlIG11c3QgYmUgc3BlY2lmaWVkXCIsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgfVxuICAgIGlmIChpc0R5bmFtaWMoYXR0cmlidXRlKSkge1xuICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCIndHlwZScgYXR0cmlidXRlIGNhbm5vdCBiZSBkeW5hbWljIGlmIGlucHV0IHVzZXMgdHdvLXdheSBiaW5kaW5nXCIsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgfVxuICAgIHJldHVybiBhdHRyaWJ1dGUudmFsdWVbMF0uZGF0YTtcbn1cbmZ1bmN0aW9uIGNoZWNrU2xvdEF0dHJpYnV0ZSh2YWxpZGF0b3IsIG5vZGUsIGF0dHJpYnV0ZSwgc3RhY2spIHtcbiAgICBpZiAoaXNEeW5hbWljKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdmFsaWRhdG9yLmVycm9yKFwic2xvdCBhdHRyaWJ1dGUgY2Fubm90IGhhdmUgYSBkeW5hbWljIHZhbHVlXCIsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgfVxuICAgIHZhciBpID0gc3RhY2subGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdFbGVtZW50Jykge1xuICAgICAgICAgICAgLy8gaWYgd2UncmUgaW5zaWRlIGEgY29tcG9uZW50IG9yIGEgY3VzdG9tIGVsZW1lbnQsIGdyYXZ5XG4gICAgICAgICAgICBpZiAocGFyZW50Lm5hbWUgPT09ICc6U2VsZicgfHwgcGFyZW50Lm5hbWUgPT09ICc6Q29tcG9uZW50JyB8fCB2YWxpZGF0b3IuY29tcG9uZW50cy5oYXMocGFyZW50Lm5hbWUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICgvLS8udGVzdChwYXJlbnQubmFtZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJlbnQudHlwZSA9PT0gJ0lmQmxvY2snIHx8IHBhcmVudC50eXBlID09PSAnRWFjaEJsb2NrJykge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkNhbm5vdCBwbGFjZSBzbG90dGVkIGVsZW1lbnRzIGluc2lkZSBhbiBcIiArIChwYXJlbnQudHlwZSA9PT0gJ0lmQmxvY2snID8gJ2lmJyA6ICdlYWNoJykgKyBcIi1ibG9ja1wiO1xuICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKG1lc3NhZ2UsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdG9yLmVycm9yKFwiRWxlbWVudCB3aXRoIGEgc2xvdD0nLi4uJyBhdHRyaWJ1dGUgbXVzdCBiZSBhIGRlc2NlbmRhbnQgb2YgYSBjb21wb25lbnQgb3IgY3VzdG9tIGVsZW1lbnRcIiwgYXR0cmlidXRlLnN0YXJ0KTtcbn1cbmZ1bmN0aW9uIGlzRHluYW1pYyhhdHRyaWJ1dGUpIHtcbiAgICByZXR1cm4gYXR0cmlidXRlLnZhbHVlLmxlbmd0aCA+IDEgfHwgYXR0cmlidXRlLnZhbHVlWzBdLnR5cGUgIT09ICdUZXh0Jztcbn1cblxudmFyIHZhbGlkQmluZGluZ3MgPSBbXG4gICAgJ2lubmVyV2lkdGgnLFxuICAgICdpbm5lckhlaWdodCcsXG4gICAgJ291dGVyV2lkdGgnLFxuICAgICdvdXRlckhlaWdodCcsXG4gICAgJ3Njcm9sbFgnLFxuICAgICdzY3JvbGxZJyxcbiAgICAnb25saW5lJ1xuXTtcbmZ1bmN0aW9uIHZhbGlkYXRlV2luZG93KHZhbGlkYXRvciwgbm9kZSwgcmVmcywgcmVmQ2FsbGVlcykge1xuICAgIG5vZGUuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnQmluZGluZycpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gZmxhdHRlbihhdHRyaWJ1dGUudmFsdWUpLnBhcnRzO1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIkJpbmRpbmdzIG9uIDw6V2luZG93Lz4gbXVzdCBiZSB0byB0b3AtbGV2ZWwgcHJvcGVydGllcywgZS5nLiAnXCIgKyBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSArIFwiJyByYXRoZXIgdGhhbiAnXCIgKyBwYXJ0cy5qb2luKCcuJykgKyBcIidcIiwgYXR0cmlidXRlLnZhbHVlLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghfnZhbGlkQmluZGluZ3MuaW5kZXhPZihhdHRyaWJ1dGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBhdHRyaWJ1dGUubmFtZSA9PT0gJ3dpZHRoJ1xuICAgICAgICAgICAgICAgICAgICA/ICdpbm5lcldpZHRoJ1xuICAgICAgICAgICAgICAgICAgICA6IGF0dHJpYnV0ZS5uYW1lID09PSAnaGVpZ2h0J1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAnaW5uZXJIZWlnaHQnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZ1enp5bWF0Y2goYXR0cmlidXRlLm5hbWUsIHZhbGlkQmluZGluZ3MpO1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCInXCIgKyBhdHRyaWJ1dGUubmFtZSArIFwiJyBpcyBub3QgYSB2YWxpZCBiaW5kaW5nIG9uIDw6V2luZG93PlwiO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IobWVzc2FnZSArIFwiIChkaWQgeW91IG1lYW4gJ1wiICsgbWF0Y2ggKyBcIic/KVwiLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKG1lc3NhZ2UgKyBcIiBcXHUyMDE0IHZhbGlkIGJpbmRpbmdzIGFyZSBcIiArIGxpc3QkMih2YWxpZEJpbmRpbmdzKSwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXR0cmlidXRlLnR5cGUgPT09ICdFdmVudEhhbmRsZXInKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV2ZW50SGFuZGxlckNhbGxlZSh2YWxpZGF0b3IsIGF0dHJpYnV0ZSwgcmVmQ2FsbGVlcyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVIZWFkKHZhbGlkYXRvciwgbm9kZSwgcmVmcywgcmVmQ2FsbGVlcykge1xuICAgIGlmIChub2RlLmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICAgIHZhbGlkYXRvci5lcnJvcihcIjw6SGVhZD4gc2hvdWxkIG5vdCBoYXZlIGFueSBhdHRyaWJ1dGVzIG9yIGRpcmVjdGl2ZXNcIiwgbm9kZS5zdGFydCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGF0aWNBdHRyaWJ1dGVWYWx1ZShub2RlLCBuYW1lKSB7XG4gICAgdmFyIGF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlcy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZTsgfSk7XG4gICAgaWYgKCFhdHRyaWJ1dGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgPT09IHRydWUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggPT09IDEgJiYgYXR0cmlidXRlLnZhbHVlWzBdLnR5cGUgPT09ICdUZXh0Jykge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlLnZhbHVlWzBdLmRhdGE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG52YXIgYXJpYUF0dHJpYnV0ZXMgPSAnYWN0aXZlZGVzY2VuZGFudCBhdG9taWMgYXV0b2NvbXBsZXRlIGJ1c3kgY2hlY2tlZCBjb250cm9scyBjdXJyZW50IGRlc2NyaWJlZGJ5IGRpc2FibGVkIGRyb3BlZmZlY3QgZXhwYW5kZWQgZmxvd3RvIGdyYWJiZWQgaGFzcG9wdXAgaGlkZGVuIGludmFsaWQgbGFiZWwgbGFiZWxsZWRieSBsZXZlbCBsaXZlIG11bHRpbGluZSBtdWx0aXNlbGVjdGFibGUgb3JpZW50YXRpb24gb3ducyBwb3NpbnNldCBwcmVzc2VkIHJlYWRvbmx5IHJlbGV2YW50IHJlcXVpcmVkIHNlbGVjdGVkIHNldHNpemUgc29ydCB2YWx1ZW1heCB2YWx1ZW1pbiB2YWx1ZW5vdyB2YWx1ZXRleHQnLnNwbGl0KCcgJyk7XG52YXIgYXJpYUF0dHJpYnV0ZVNldCA9IG5ldyBTZXQoYXJpYUF0dHJpYnV0ZXMpO1xudmFyIGFyaWFSb2xlcyA9ICdhbGVydCBhbGVydGRpYWxvZyBhcHBsaWNhdGlvbiBhcnRpY2xlIGJhbm5lciBidXR0b24gY2hlY2tib3ggY29sdW1uaGVhZGVyIGNvbWJvYm94IGNvbW1hbmQgY29tcGxlbWVudGFyeSBjb21wb3NpdGUgY29udGVudGluZm8gZGVmaW5pdGlvbiBkaWFsb2cgZGlyZWN0b3J5IGRvY3VtZW50IGZvcm0gZ3JpZCBncmlkY2VsbCBncm91cCBoZWFkaW5nIGltZyBpbnB1dCBsYW5kbWFyayBsaW5rIGxpc3QgbGlzdGJveCBsaXN0aXRlbSBsb2cgbWFpbiBtYXJxdWVlIG1hdGggbWVudSBtZW51YmFyIG1lbnVpdGVtIG1lbnVpdGVtY2hlY2tib3ggbWVudWl0ZW1yYWRpbyBuYXZpZ2F0aW9uIG5vdGUgb3B0aW9uIHByZXNlbnRhdGlvbiBwcm9ncmVzc2JhciByYWRpbyByYWRpb2dyb3VwIHJhbmdlIHJlZ2lvbiByb2xldHlwZSByb3cgcm93Z3JvdXAgcm93aGVhZGVyIHNjcm9sbGJhciBzZWFyY2ggc2VjdGlvbiBzZWN0aW9uaGVhZCBzZWxlY3Qgc2VwYXJhdG9yIHNsaWRlciBzcGluYnV0dG9uIHN0YXR1cyBzdHJ1Y3R1cmUgdGFiIHRhYmxpc3QgdGFicGFuZWwgdGV4dGJveCB0aW1lciB0b29sYmFyIHRvb2x0aXAgdHJlZSB0cmVlZ3JpZCB0cmVlaXRlbSB3aWRnZXQgd2luZG93Jy5zcGxpdCgnICcpO1xudmFyIGFyaWFSb2xlU2V0ID0gbmV3IFNldChhcmlhUm9sZXMpO1xudmFyIGludmlzaWJsZUVsZW1lbnRzID0gbmV3IFNldChbJ21ldGEnLCAnaHRtbCcsICdzY3JpcHQnLCAnc3R5bGUnXSk7XG5mdW5jdGlvbiBhMTF5KHZhbGlkYXRvciwgbm9kZSwgZWxlbWVudFN0YWNrKSB7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ1RleHQnKSB7XG4gICAgICAgIC8vIGFjY2Vzc2libGUtZW1vamlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlICE9PSAnRWxlbWVudCcpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgYXR0cmlidXRlTWFwID0gbmV3IE1hcCgpO1xuICAgIG5vZGUuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGUubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBhcmlhLXByb3BzXG4gICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2FyaWEtJykpIHtcbiAgICAgICAgICAgIGlmIChpbnZpc2libGVFbGVtZW50cy5oYXMobm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIGFyaWEtdW5zdXBwb3J0ZWQtZWxlbWVudHNcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3Iud2FybihcIkExMXk6IDxcIiArIG5vZGUubmFtZSArIFwiPiBzaG91bGQgbm90IGhhdmUgYXJpYS0qIGF0dHJpYnV0ZXNcIiwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0eXBlID0gbmFtZS5zbGljZSg1KTtcbiAgICAgICAgICAgIGlmICghYXJpYUF0dHJpYnV0ZVNldC5oYXModHlwZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBmdXp6eW1hdGNoKHR5cGUsIGFyaWFBdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiQTExeTogVW5rbm93biBhcmlhIGF0dHJpYnV0ZSAnYXJpYS1cIiArIHR5cGUgKyBcIidcIjtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKGRpZCB5b3UgbWVhbiAnXCIgKyBtYXRjaCArIFwiJz8pXCI7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLndhcm4obWVzc2FnZSwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhcmlhLXJvbGVcbiAgICAgICAgaWYgKG5hbWUgPT09ICdyb2xlJykge1xuICAgICAgICAgICAgaWYgKGludmlzaWJsZUVsZW1lbnRzLmhhcyhub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gYXJpYS11bnN1cHBvcnRlZC1lbGVtZW50c1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci53YXJuKFwiQTExeTogPFwiICsgbm9kZS5uYW1lICsgXCI+IHNob3VsZCBub3QgaGF2ZSByb2xlIGF0dHJpYnV0ZVwiLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUobm9kZSwgJ3JvbGUnKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhYXJpYVJvbGVTZXQuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IGZ1enp5bWF0Y2godmFsdWUsIGFyaWFSb2xlcyk7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkExMXk6IFVua25vd24gcm9sZSAnXCIgKyB2YWx1ZSArIFwiJ1wiO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaClcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoZGlkIHlvdSBtZWFuICdcIiArIG1hdGNoICsgXCInPylcIjtcbiAgICAgICAgICAgICAgICB2YWxpZGF0b3Iud2FybihtZXNzYWdlLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG5vLWFjY2Vzcy1rZXlcbiAgICAgICAgaWYgKG5hbWUgPT09ICdhY2Nlc3NrZXknKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iud2FybihcIkExMXk6IEF2b2lkIHVzaW5nIGFjY2Vzc2tleVwiLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vLWF1dG9mb2N1c1xuICAgICAgICBpZiAobmFtZSA9PT0gJ2F1dG9mb2N1cycpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvci53YXJuKFwiQTExeTogQXZvaWQgdXNpbmcgYXV0b2ZvY3VzXCIsIGF0dHJpYnV0ZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2NvcGVcbiAgICAgICAgaWYgKG5hbWUgPT09ICdzY29wZScgJiYgbm9kZS5uYW1lICE9PSAndGgnKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iud2FybihcIkExMXk6IFRoZSBzY29wZSBhdHRyaWJ1dGUgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aXRoIDx0aD4gZWxlbWVudHNcIiwgYXR0cmlidXRlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0YWJpbmRleC1uby1wb3NpdGl2ZVxuICAgICAgICBpZiAobmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUobm9kZSwgJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHZhbHVlKSAmJiArdmFsdWUgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLndhcm4oXCJBMTF5OiBhdm9pZCB0YWJpbmRleCB2YWx1ZXMgYWJvdmUgemVyb1wiLCBhdHRyaWJ1dGUuc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGF0dHJpYnV0ZU1hcC5zZXQoYXR0cmlidXRlLm5hbWUsIGF0dHJpYnV0ZSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gc2hvdWxkSGF2ZUF0dHJpYnV0ZShhdHRyaWJ1dGVzLCBuYW1lKSB7XG4gICAgICAgIGlmIChuYW1lID09PSB2b2lkIDApIHsgbmFtZSA9IG5vZGUubmFtZTsgfVxuICAgICAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggPT09IDAgfHwgIWF0dHJpYnV0ZXMuc29tZShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gYXR0cmlidXRlTWFwLmhhcyhuYW1lKTsgfSkpIHtcbiAgICAgICAgICAgIHZhciBhcnRpY2xlID0gL15bYWVpb3VdLy50ZXN0KGF0dHJpYnV0ZXNbMF0pID8gJ2FuJyA6ICdhJztcbiAgICAgICAgICAgIHZhciBzZXF1ZW5jZSA9IGF0dHJpYnV0ZXMubGVuZ3RoID4gMSA/XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zbGljZSgwLCAtMSkuam9pbignLCAnKSArIChcIiBvciBcIiArIGF0dHJpYnV0ZXNbYXR0cmlidXRlcy5sZW5ndGggLSAxXSkgOlxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNbMF07XG4gICAgICAgICAgICB2YWxpZGF0b3Iud2FybihcIkExMXk6IDxcIiArIG5hbWUgKyBcIj4gZWxlbWVudCBzaG91bGQgaGF2ZSBcIiArIGFydGljbGUgKyBcIiBcIiArIHNlcXVlbmNlICsgXCIgYXR0cmlidXRlXCIsIG5vZGUuc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNob3VsZEhhdmVDb250ZW50KCkge1xuICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhbGlkYXRvci53YXJuKFwiQTExeTogPFwiICsgbm9kZS5uYW1lICsgXCI+IGVsZW1lbnQgc2hvdWxkIGhhdmUgY2hpbGQgY29udGVudFwiLCBub2RlLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5uYW1lID09PSAnYScpIHtcbiAgICAgICAgLy8gYW5jaG9yLWlzLXZhbGlkXG4gICAgICAgIHZhciBocmVmID0gYXR0cmlidXRlTWFwLmdldCgnaHJlZicpO1xuICAgICAgICBpZiAoYXR0cmlidXRlTWFwLmhhcygnaHJlZicpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRTdGF0aWNBdHRyaWJ1dGVWYWx1ZShub2RlLCAnaHJlZicpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLndhcm4oXCJBMTF5OiAnXCIgKyB2YWx1ZSArIFwiJyBpcyBub3QgYSB2YWxpZCBocmVmIGF0dHJpYnV0ZVwiLCBocmVmLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRvci53YXJuKFwiQTExeTogPGE+IGVsZW1lbnQgc2hvdWxkIGhhdmUgYW4gaHJlZiBhdHRyaWJ1dGVcIiwgbm9kZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYW5jaG9yLWhhcy1jb250ZW50XG4gICAgICAgIHNob3VsZEhhdmVDb250ZW50KCk7XG4gICAgfVxuICAgIGlmIChub2RlLm5hbWUgPT09ICdpbWcnKVxuICAgICAgICBzaG91bGRIYXZlQXR0cmlidXRlKFsnYWx0J10pO1xuICAgIGlmIChub2RlLm5hbWUgPT09ICdhcmVhJylcbiAgICAgICAgc2hvdWxkSGF2ZUF0dHJpYnV0ZShbJ2FsdCcsICdhcmlhLWxhYmVsJywgJ2FyaWEtbGFiZWxsZWRieSddKTtcbiAgICBpZiAobm9kZS5uYW1lID09PSAnb2JqZWN0JylcbiAgICAgICAgc2hvdWxkSGF2ZUF0dHJpYnV0ZShbJ3RpdGxlJywgJ2FyaWEtbGFiZWwnLCAnYXJpYS1sYWJlbGxlZGJ5J10pO1xuICAgIGlmIChub2RlLm5hbWUgPT09ICdpbnB1dCcgJiYgZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUobm9kZSwgJ3R5cGUnKSA9PT0gJ2ltYWdlJykge1xuICAgICAgICBzaG91bGRIYXZlQXR0cmlidXRlKFsnYWx0JywgJ2FyaWEtbGFiZWwnLCAnYXJpYS1sYWJlbGxlZGJ5J10sICdpbnB1dCB0eXBlPVwiaW1hZ2VcIicpO1xuICAgIH1cbiAgICAvLyBoZWFkaW5nLWhhcy1jb250ZW50XG4gICAgaWYgKC9eaFsxLTZdJC8udGVzdChub2RlLm5hbWUpKSB7XG4gICAgICAgIHNob3VsZEhhdmVDb250ZW50KCk7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVNYXAuaGFzKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgICAgICB2YWxpZGF0b3Iud2FybihcIkExMXk6IDxcIiArIG5vZGUubmFtZSArIFwiPiBlbGVtZW50IHNob3VsZCBub3QgYmUgaGlkZGVuXCIsIGF0dHJpYnV0ZU1hcC5nZXQoJ2FyaWEtaGlkZGVuJykuc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGlmcmFtZS1oYXMtdGl0bGVcbiAgICBpZiAobm9kZS5uYW1lID09PSAnaWZyYW1lJykge1xuICAgICAgICBzaG91bGRIYXZlQXR0cmlidXRlKFsndGl0bGUnXSk7XG4gICAgfVxuICAgIC8vIGh0bWwtaGFzLWxhbmdcbiAgICBpZiAobm9kZS5uYW1lID09PSAnaHRtbCcpIHtcbiAgICAgICAgc2hvdWxkSGF2ZUF0dHJpYnV0ZShbJ2xhbmcnXSk7XG4gICAgfVxuICAgIC8vIG5vLWRpc3RyYWN0aW5nLWVsZW1lbnRzXG4gICAgaWYgKG5vZGUubmFtZSA9PT0gJ21hcnF1ZWUnIHx8IG5vZGUubmFtZSA9PT0gJ2JsaW5rJykge1xuICAgICAgICB2YWxpZGF0b3Iud2FybihcIkExMXk6IEF2b2lkIDxcIiArIG5vZGUubmFtZSArIFwiPiBlbGVtZW50c1wiLCBub2RlLnN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKG5vZGUubmFtZSA9PT0gJ2ZpZ2NhcHRpb24nKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50U3RhY2tbZWxlbWVudFN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICBpZiAocGFyZW50Lm5hbWUgIT09ICdmaWd1cmUnKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLndhcm4oXCJBMTF5OiA8ZmlnY2FwdGlvbj4gbXVzdCBiZSBhbiBpbW1lZGlhdGUgY2hpbGQgb2YgPGZpZ3VyZT5cIiwgbm9kZS5zdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdDb21tZW50JylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1RleHQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC9cXFMvLnRlc3Qobm9kZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gY2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IDAgJiYgaW5kZXggIT09IGNoaWxkcmVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdG9yLndhcm4oXCJBMTF5OiA8ZmlnY2FwdGlvbj4gbXVzdCBiZSBmaXJzdCBvciBsYXN0IGNoaWxkIG9mIDxmaWd1cmU+XCIsIG5vZGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxudmFyIG1ldGEgPSBuZXcgTWFwKFtcbiAgICBbJzpXaW5kb3cnLCB2YWxpZGF0ZVdpbmRvd10sXG4gICAgWyc6SGVhZCcsIHZhbGlkYXRlSGVhZF1cbl0pO1xuZnVuY3Rpb24gdmFsaWRhdGVIdG1sKHZhbGlkYXRvciwgaHRtbCkge1xuICAgIHZhciByZWZzID0gbmV3IE1hcCgpO1xuICAgIHZhciByZWZDYWxsZWVzID0gW107XG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgdmFyIGVsZW1lbnRTdGFjayA9IFtdO1xuICAgIGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICAgICAgYTExeSh2YWxpZGF0b3IsIG5vZGUsIGVsZW1lbnRTdGFjayk7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdFbGVtZW50Jykge1xuICAgICAgICAgICAgaWYgKG1ldGEuaGFzKG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWV0YS5nZXQobm9kZS5uYW1lKSh2YWxpZGF0b3IsIG5vZGUsIHJlZnMsIHJlZkNhbGxlZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsaWRhdGVFbGVtZW50KHZhbGlkYXRvciwgbm9kZSwgcmVmcywgcmVmQ2FsbGVlcywgc3RhY2ssIGVsZW1lbnRTdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnRWFjaEJsb2NrJykge1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRvci5oZWxwZXJzLmhhcyhub2RlLmNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBub2RlLmV4cHJlc3Npb24uZW5kO1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgc3RhcnQgb2YgY29udGV4dFxuICAgICAgICAgICAgICAgIHdoaWxlICgvXFxzLy50ZXN0KHZhbGlkYXRvci5zb3VyY2VbY10pKVxuICAgICAgICAgICAgICAgICAgICBjICs9IDE7XG4gICAgICAgICAgICAgICAgYyArPSAyO1xuICAgICAgICAgICAgICAgIHdoaWxlICgvXFxzLy50ZXN0KHZhbGlkYXRvci5zb3VyY2VbY10pKVxuICAgICAgICAgICAgICAgICAgICBjICs9IDE7XG4gICAgICAgICAgICAgICAgdmFsaWRhdG9yLndhcm4oXCJDb250ZXh0IGNsYXNoZXMgd2l0aCBhIGhlbHBlci4gUmVuYW1lIG9uZSBvciB0aGUgb3RoZXIgdG8gZWxpbWluYXRlIGFueSBhbWJpZ3VpdHlcIiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdFbGVtZW50JylcbiAgICAgICAgICAgICAgICBlbGVtZW50U3RhY2sucHVzaChub2RlKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2godmlzaXQpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnRWxlbWVudCcpXG4gICAgICAgICAgICAgICAgZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlW1wiZWxzZVwiXSkge1xuICAgICAgICAgICAgdmlzaXQobm9kZVtcImVsc2VcIl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGh0bWwuY2hpbGRyZW4uZm9yRWFjaCh2aXNpdCk7XG4gICAgcmVmQ2FsbGVlcy5mb3JFYWNoKGZ1bmN0aW9uIChjYWxsZWUpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gZmxhdHRlbihjYWxsZWUpLnBhcnRzO1xuICAgICAgICB2YXIgcmVmID0gcGFydHNbMV07XG4gICAgICAgIGlmIChyZWZzLmhhcyhyZWYpKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIG1ldGhvZCBpcyB2YWxpZCwgZS5nLiBgYXVkaW8uc3RvcCgpYCBzaG91bGQgYmUgYGF1ZGlvLnBhdXNlKClgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBmdXp6eW1hdGNoKHJlZiwgQXJyYXkuZnJvbShyZWZzLmtleXMoKSkpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIidyZWZzLlwiICsgcmVmICsgXCInIGRvZXMgbm90IGV4aXN0XCI7XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoZGlkIHlvdSBtZWFuICdyZWZzLlwiICsgbWF0Y2ggKyBcIic/KVwiO1xuICAgICAgICAgICAgdmFsaWRhdG9yLmVycm9yKG1lc3NhZ2UsIGNhbGxlZS5zdGFydCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxudmFyIFZhbGlkYXRpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFsaWRhdGlvbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZhbGlkYXRpb25FcnJvcihtZXNzYWdlLCB0ZW1wbGF0ZSwgaW5kZXgsIGZpbGVuYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UsIHRlbXBsYXRlLCBpbmRleCwgZmlsZW5hbWUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yO1xufShDb21waWxlRXJyb3IpKTtcbnZhciBWYWxpZGF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFsaWRhdG9yKHBhcnNlZCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICAgICAgdGhpcy5vbndhcm4gPSBvcHRpb25zLm9ud2FybjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBudWxsO1xuICAgICAgICB0aGlzLmRlZmF1bHRFeHBvcnQgPSBudWxsO1xuICAgICAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5tZXRob2RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2xvdHMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIFZhbGlkYXRvci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSwgcG9zKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWxpZGF0aW9uRXJyb3IobWVzc2FnZSwgdGhpcy5zb3VyY2UsIHBvcywgdGhpcy5maWxlbmFtZSk7XG4gICAgfTtcbiAgICBWYWxpZGF0b3IucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSwgcG9zKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2NhdG9yKVxuICAgICAgICAgICAgdGhpcy5sb2NhdG9yID0gZ2V0TG9jYXRvcih0aGlzLnNvdXJjZSk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMubG9jYXRvcihwb3MpLCBsaW5lID0gX2EubGluZSwgY29sdW1uID0gX2EuY29sdW1uO1xuICAgICAgICB2YXIgZnJhbWUgPSBnZXRDb2RlRnJhbWUodGhpcy5zb3VyY2UsIGxpbmUsIGNvbHVtbik7XG4gICAgICAgIHRoaXMub253YXJuKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICBmcmFtZTogZnJhbWUsXG4gICAgICAgICAgICBsb2M6IHsgbGluZTogbGluZSArIDEsIGNvbHVtbjogY29sdW1uIH0sXG4gICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgIGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lLFxuICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2UgKyBcIiAoXCIgKyAobGluZSArIDEpICsgXCI6XCIgKyBjb2x1bW4gKyBcIilcXG5cIiArIGZyYW1lOyB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFZhbGlkYXRvcjtcbn0oKSk7XG5mdW5jdGlvbiB2YWxpZGF0ZShwYXJzZWQsIHNvdXJjZSwgc3R5bGVzaGVldCwgb3B0aW9ucykge1xuICAgIHZhciBvbndhcm4gPSBvcHRpb25zLm9ud2Fybiwgb25lcnJvciA9IG9wdGlvbnMub25lcnJvciwgbmFtZSA9IG9wdGlvbnMubmFtZSwgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lLCBzdG9yZSA9IG9wdGlvbnMuc3RvcmU7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKG5hbWUgJiYgIS9eW2EtekEtWl8kXVthLXpBLVpfJDAtOV0qJC8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwib3B0aW9ucy5uYW1lIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyIChnb3QgJ1wiICsgbmFtZSArIFwiJylcIik7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZSAmJiAhL15bQS1aXS8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VfMSA9IFwib3B0aW9ucy5uYW1lIHNob3VsZCBiZSBjYXBpdGFsaXNlZFwiO1xuICAgICAgICAgICAgb253YXJuKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlXzEsXG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtZXNzYWdlXzE7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHBhcnNlZCwgc291cmNlLCB7XG4gICAgICAgICAgICBvbndhcm46IG9ud2FybixcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWUsXG4gICAgICAgICAgICBzdG9yZTogc3RvcmVcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwYXJzZWQuanMpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlSnModmFsaWRhdG9yLCBwYXJzZWQuanMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQuY3NzKSB7XG4gICAgICAgICAgICBzdHlsZXNoZWV0LnZhbGlkYXRlKHZhbGlkYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZC5odG1sKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUh0bWwodmFsaWRhdG9yLCBwYXJzZWQuaHRtbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAob25lcnJvcikge1xuICAgICAgICAgICAgb25lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxufVxuXG52YXIgY2hhclRvSW50ZWdlciA9IHt9O1xudmFyIGludGVnZXJUb0NoYXIgPSB7fTtcblxuJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89Jy5zcGxpdCggJycgKS5mb3JFYWNoKCBmdW5jdGlvbiAoIGNoYXIsIGkgKSB7XG5cdGNoYXJUb0ludGVnZXJbIGNoYXIgXSA9IGk7XG5cdGludGVnZXJUb0NoYXJbIGkgXSA9IGNoYXI7XG59KTtcblxuXG5cbmZ1bmN0aW9uIGVuY29kZSAoIHZhbHVlICkge1xuXHR2YXIgcmVzdWx0O1xuXG5cdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblx0XHRyZXN1bHQgPSBlbmNvZGVJbnRlZ2VyKCB2YWx1ZSApO1xuXHR9IGVsc2Uge1xuXHRcdHJlc3VsdCA9ICcnO1xuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0cmVzdWx0ICs9IGVuY29kZUludGVnZXIoIHZhbHVlW2ldICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZW5jb2RlSW50ZWdlciAoIG51bSApIHtcblx0dmFyIHJlc3VsdCA9ICcnO1xuXG5cdGlmICggbnVtIDwgMCApIHtcblx0XHRudW0gPSAoIC1udW0gPDwgMSApIHwgMTtcblx0fSBlbHNlIHtcblx0XHRudW0gPDw9IDE7XG5cdH1cblxuXHRkbyB7XG5cdFx0dmFyIGNsYW1wZWQgPSBudW0gJiAzMTtcblx0XHRudW0gPj49IDU7XG5cblx0XHRpZiAoIG51bSA+IDAgKSB7XG5cdFx0XHRjbGFtcGVkIHw9IDMyO1xuXHRcdH1cblxuXHRcdHJlc3VsdCArPSBpbnRlZ2VyVG9DaGFyWyBjbGFtcGVkIF07XG5cdH0gd2hpbGUgKCBudW0gPiAwICk7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gQ2h1bmsgKCBzdGFydCwgZW5kLCBjb250ZW50ICkge1xuXHR0aGlzLnN0YXJ0ID0gc3RhcnQ7XG5cdHRoaXMuZW5kID0gZW5kO1xuXHR0aGlzLm9yaWdpbmFsID0gY29udGVudDtcblxuXHR0aGlzLmludHJvID0gJyc7XG5cdHRoaXMub3V0cm8gPSAnJztcblxuXHR0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuXHR0aGlzLnN0b3JlTmFtZSA9IGZhbHNlO1xuXHR0aGlzLmVkaXRlZCA9IGZhbHNlO1xuXG5cdC8vIHdlIG1ha2UgdGhlc2Ugbm9uLWVudW1lcmFibGUsIGZvciBzYW5pdHkgd2hpbGUgZGVidWdnaW5nXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG5cdFx0cHJldmlvdXM6IHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBudWxsIH0sXG5cdFx0bmV4dDogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG51bGwgfVxuXHR9KTtcbn1cblxuQ2h1bmsucHJvdG90eXBlID0ge1xuXHRhcHBlbmRMZWZ0OiBmdW5jdGlvbiBhcHBlbmRMZWZ0ICggY29udGVudCApIHtcblx0XHR0aGlzLm91dHJvICs9IGNvbnRlbnQ7XG5cdH0sXG5cblx0YXBwZW5kUmlnaHQ6IGZ1bmN0aW9uIGFwcGVuZFJpZ2h0ICggY29udGVudCApIHtcblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRybyArIGNvbnRlbnQ7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uIGNsb25lICgpIHtcblx0XHR2YXIgY2h1bmsgPSBuZXcgQ2h1bmsoIHRoaXMuc3RhcnQsIHRoaXMuZW5kLCB0aGlzLm9yaWdpbmFsICk7XG5cblx0XHRjaHVuay5pbnRybyA9IHRoaXMuaW50cm87XG5cdFx0Y2h1bmsub3V0cm8gPSB0aGlzLm91dHJvO1xuXHRcdGNodW5rLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQ7XG5cdFx0Y2h1bmsuc3RvcmVOYW1lID0gdGhpcy5zdG9yZU5hbWU7XG5cdFx0Y2h1bmsuZWRpdGVkID0gdGhpcy5lZGl0ZWQ7XG5cblx0XHRyZXR1cm4gY2h1bms7XG5cdH0sXG5cblx0Y29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zICggaW5kZXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuc3RhcnQgPCBpbmRleCAmJiBpbmRleCA8IHRoaXMuZW5kO1xuXHR9LFxuXG5cdGVhY2hOZXh0OiBmdW5jdGlvbiBlYWNoTmV4dCAoIGZuICkge1xuXHRcdHZhciBjaHVuayA9IHRoaXM7XG5cdFx0d2hpbGUgKCBjaHVuayApIHtcblx0XHRcdGZuKCBjaHVuayApO1xuXHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdH1cblx0fSxcblxuXHRlYWNoUHJldmlvdXM6IGZ1bmN0aW9uIGVhY2hQcmV2aW91cyAoIGZuICkge1xuXHRcdHZhciBjaHVuayA9IHRoaXM7XG5cdFx0d2hpbGUgKCBjaHVuayApIHtcblx0XHRcdGZuKCBjaHVuayApO1xuXHRcdFx0Y2h1bmsgPSBjaHVuay5wcmV2aW91cztcblx0XHR9XG5cdH0sXG5cblx0ZWRpdDogZnVuY3Rpb24gZWRpdCAoIGNvbnRlbnQsIHN0b3JlTmFtZSwgY29udGVudE9ubHkgKSB7XG5cdFx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0XHRpZiAoICFjb250ZW50T25seSApIHtcblx0XHRcdHRoaXMuaW50cm8gPSAnJztcblx0XHRcdHRoaXMub3V0cm8gPSAnJztcblx0XHR9XG5cdFx0dGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XG5cblx0XHR0aGlzLmVkaXRlZCA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVwZW5kTGVmdDogZnVuY3Rpb24gcHJlcGVuZExlZnQgKCBjb250ZW50ICkge1xuXHRcdHRoaXMub3V0cm8gPSBjb250ZW50ICsgdGhpcy5vdXRybztcblx0fSxcblxuXHRwcmVwZW5kUmlnaHQ6IGZ1bmN0aW9uIHByZXBlbmRSaWdodCAoIGNvbnRlbnQgKSB7XG5cdFx0dGhpcy5pbnRybyA9IGNvbnRlbnQgKyB0aGlzLmludHJvO1xuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbiBzcGxpdCAoIGluZGV4ICkge1xuXHRcdHZhciBzbGljZUluZGV4ID0gaW5kZXggLSB0aGlzLnN0YXJ0O1xuXG5cdFx0dmFyIG9yaWdpbmFsQmVmb3JlID0gdGhpcy5vcmlnaW5hbC5zbGljZSggMCwgc2xpY2VJbmRleCApO1xuXHRcdHZhciBvcmlnaW5hbEFmdGVyID0gdGhpcy5vcmlnaW5hbC5zbGljZSggc2xpY2VJbmRleCApO1xuXG5cdFx0dGhpcy5vcmlnaW5hbCA9IG9yaWdpbmFsQmVmb3JlO1xuXG5cdFx0dmFyIG5ld0NodW5rID0gbmV3IENodW5rKCBpbmRleCwgdGhpcy5lbmQsIG9yaWdpbmFsQWZ0ZXIgKTtcblx0XHRuZXdDaHVuay5vdXRybyA9IHRoaXMub3V0cm87XG5cdFx0dGhpcy5vdXRybyA9ICcnO1xuXG5cdFx0dGhpcy5lbmQgPSBpbmRleDtcblxuXHRcdGlmICggdGhpcy5lZGl0ZWQgKSB7XG5cdFx0XHQvLyBUT0RPIGlzIHRoaXMgYmxvY2sgbmVjZXNzYXJ5Py4uLlxuXHRcdFx0bmV3Q2h1bmsuZWRpdCggJycsIGZhbHNlICk7XG5cdFx0XHR0aGlzLmNvbnRlbnQgPSAnJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jb250ZW50ID0gb3JpZ2luYWxCZWZvcmU7XG5cdFx0fVxuXG5cdFx0bmV3Q2h1bmsubmV4dCA9IHRoaXMubmV4dDtcblx0XHRpZiAoIG5ld0NodW5rLm5leHQgKSB7IG5ld0NodW5rLm5leHQucHJldmlvdXMgPSBuZXdDaHVuazsgfVxuXHRcdG5ld0NodW5rLnByZXZpb3VzID0gdGhpcztcblx0XHR0aGlzLm5leHQgPSBuZXdDaHVuaztcblxuXHRcdHJldHVybiBuZXdDaHVuaztcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuXHRcdHJldHVybiB0aGlzLmludHJvICsgdGhpcy5jb250ZW50ICsgdGhpcy5vdXRybztcblx0fSxcblxuXHR0cmltRW5kOiBmdW5jdGlvbiB0cmltRW5kICggcnggKSB7XG5cdFx0dGhpcy5vdXRybyA9IHRoaXMub3V0cm8ucmVwbGFjZSggcngsICcnICk7XG5cdFx0aWYgKCB0aGlzLm91dHJvLmxlbmd0aCApIHsgcmV0dXJuIHRydWU7IH1cblxuXHRcdHZhciB0cmltbWVkID0gdGhpcy5jb250ZW50LnJlcGxhY2UoIHJ4LCAnJyApO1xuXG5cdFx0aWYgKCB0cmltbWVkLmxlbmd0aCApIHtcblx0XHRcdGlmICggdHJpbW1lZCAhPT0gdGhpcy5jb250ZW50ICkge1xuXHRcdFx0XHR0aGlzLnNwbGl0KCB0aGlzLnN0YXJ0ICsgdHJpbW1lZC5sZW5ndGggKS5lZGl0KCAnJywgZmFsc2UgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWRpdCggJycsIGZhbHNlICk7XG5cblx0XHRcdHRoaXMuaW50cm8gPSB0aGlzLmludHJvLnJlcGxhY2UoIHJ4LCAnJyApO1xuXHRcdFx0aWYgKCB0aGlzLmludHJvLmxlbmd0aCApIHsgcmV0dXJuIHRydWU7IH1cblx0XHR9XG5cdH0sXG5cblx0dHJpbVN0YXJ0OiBmdW5jdGlvbiB0cmltU3RhcnQgKCByeCApIHtcblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKCByeCwgJycgKTtcblx0XHRpZiAoIHRoaXMuaW50cm8ubGVuZ3RoICkgeyByZXR1cm4gdHJ1ZTsgfVxuXG5cdFx0dmFyIHRyaW1tZWQgPSB0aGlzLmNvbnRlbnQucmVwbGFjZSggcngsICcnICk7XG5cblx0XHRpZiAoIHRyaW1tZWQubGVuZ3RoICkge1xuXHRcdFx0aWYgKCB0cmltbWVkICE9PSB0aGlzLmNvbnRlbnQgKSB7XG5cdFx0XHRcdHRoaXMuc3BsaXQoIHRoaXMuZW5kIC0gdHJpbW1lZC5sZW5ndGggKTtcblx0XHRcdFx0dGhpcy5lZGl0KCAnJywgZmFsc2UgKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuZWRpdCggJycsIGZhbHNlICk7XG5cblx0XHRcdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UoIHJ4LCAnJyApO1xuXHRcdFx0aWYgKCB0aGlzLm91dHJvLmxlbmd0aCApIHsgcmV0dXJuIHRydWU7IH1cblx0XHR9XG5cdH1cbn07XG5cbnZhciBfYnRvYTtcblxuaWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmJ0b2EgPT09ICdmdW5jdGlvbicgKSB7XG5cdF9idG9hID0gd2luZG93LmJ0b2E7XG59IGVsc2UgaWYgKCB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nICkge1xuXHRfYnRvYSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIG5ldyBCdWZmZXIoIHN0ciApLnRvU3RyaW5nKCAnYmFzZTY0JyApOyB9O1xufSBlbHNlIHtcblx0X2J0b2EgPSBmdW5jdGlvbiAoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCAnVW5zdXBwb3J0ZWQgZW52aXJvbm1lbnQ6IGB3aW5kb3cuYnRvYWAgb3IgYEJ1ZmZlcmAgc2hvdWxkIGJlIHN1cHBvcnRlZC4nICk7XG5cdH07XG59XG5cbnZhciBidG9hID0gX2J0b2E7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcCAoIHByb3BlcnRpZXMgKSB7XG5cdHRoaXMudmVyc2lvbiA9IDM7XG5cblx0dGhpcy5maWxlICAgICAgICAgICA9IHByb3BlcnRpZXMuZmlsZTtcblx0dGhpcy5zb3VyY2VzICAgICAgICA9IHByb3BlcnRpZXMuc291cmNlcztcblx0dGhpcy5zb3VyY2VzQ29udGVudCA9IHByb3BlcnRpZXMuc291cmNlc0NvbnRlbnQ7XG5cdHRoaXMubmFtZXMgICAgICAgICAgPSBwcm9wZXJ0aWVzLm5hbWVzO1xuXHR0aGlzLm1hcHBpbmdzICAgICAgID0gcHJvcGVydGllcy5tYXBwaW5ncztcbn1cblxuU291cmNlTWFwLnByb3RvdHlwZSA9IHtcblx0dG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoIHRoaXMgKTtcblx0fSxcblxuXHR0b1VybDogZnVuY3Rpb24gdG9VcmwgKCkge1xuXHRcdHJldHVybiAnZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBidG9hKCB0aGlzLnRvU3RyaW5nKCkgKTtcblx0fVxufTtcblxuZnVuY3Rpb24gZ3Vlc3NJbmRlbnQgKCBjb2RlICkge1xuXHR2YXIgbGluZXMgPSBjb2RlLnNwbGl0KCAnXFxuJyApO1xuXG5cdHZhciB0YWJiZWQgPSBsaW5lcy5maWx0ZXIoIGZ1bmN0aW9uIChsaW5lKSB7IHJldHVybiAvXlxcdCsvLnRlc3QoIGxpbmUgKTsgfSApO1xuXHR2YXIgc3BhY2VkID0gbGluZXMuZmlsdGVyKCBmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gL14gezIsfS8udGVzdCggbGluZSApOyB9ICk7XG5cblx0aWYgKCB0YWJiZWQubGVuZ3RoID09PSAwICYmIHNwYWNlZC5sZW5ndGggPT09IDAgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBNb3JlIGxpbmVzIHRhYmJlZCB0aGFuIHNwYWNlZD8gQXNzdW1lIHRhYnMsIGFuZFxuXHQvLyBkZWZhdWx0IHRvIHRhYnMgaW4gdGhlIGNhc2Ugb2YgYSB0aWUgKG9yIG5vdGhpbmdcblx0Ly8gdG8gZ28gb24pXG5cdGlmICggdGFiYmVkLmxlbmd0aCA+PSBzcGFjZWQubGVuZ3RoICkge1xuXHRcdHJldHVybiAnXFx0Jztcblx0fVxuXG5cdC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byBndWVzcyB0aGUgbXVsdGlwbGVcblx0dmFyIG1pbiA9IHNwYWNlZC5yZWR1Y2UoIGZ1bmN0aW9uICggcHJldmlvdXMsIGN1cnJlbnQgKSB7XG5cdFx0dmFyIG51bVNwYWNlcyA9IC9eICsvLmV4ZWMoIGN1cnJlbnQgKVswXS5sZW5ndGg7XG5cdFx0cmV0dXJuIE1hdGgubWluKCBudW1TcGFjZXMsIHByZXZpb3VzICk7XG5cdH0sIEluZmluaXR5ICk7XG5cblx0cmV0dXJuIG5ldyBBcnJheSggbWluICsgMSApLmpvaW4oICcgJyApO1xufVxuXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVBhdGggKCBmcm9tLCB0byApIHtcblx0dmFyIGZyb21QYXJ0cyA9IGZyb20uc3BsaXQoIC9bXFwvXFxcXF0vICk7XG5cdHZhciB0b1BhcnRzID0gdG8uc3BsaXQoIC9bXFwvXFxcXF0vICk7XG5cblx0ZnJvbVBhcnRzLnBvcCgpOyAvLyBnZXQgZGlybmFtZVxuXG5cdHdoaWxlICggZnJvbVBhcnRzWzBdID09PSB0b1BhcnRzWzBdICkge1xuXHRcdGZyb21QYXJ0cy5zaGlmdCgpO1xuXHRcdHRvUGFydHMuc2hpZnQoKTtcblx0fVxuXG5cdGlmICggZnJvbVBhcnRzLmxlbmd0aCApIHtcblx0XHR2YXIgaSA9IGZyb21QYXJ0cy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7IGZyb21QYXJ0c1tpXSA9ICcuLic7IH1cblx0fVxuXG5cdHJldHVybiBmcm9tUGFydHMuY29uY2F0KCB0b1BhcnRzICkuam9pbiggJy8nICk7XG59XG5cbnZhciB0b1N0cmluZyQxJDEgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5mdW5jdGlvbiBpc09iamVjdCAoIHRoaW5nICkge1xuXHRyZXR1cm4gdG9TdHJpbmckMSQxLmNhbGwoIHRoaW5nICkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBnZXRMb2NhdG9yJDEgKCBzb3VyY2UgKSB7XG5cdHZhciBvcmlnaW5hbExpbmVzID0gc291cmNlLnNwbGl0KCAnXFxuJyApO1xuXG5cdHZhciBzdGFydCA9IDA7XG5cdHZhciBsaW5lUmFuZ2VzID0gb3JpZ2luYWxMaW5lcy5tYXAoIGZ1bmN0aW9uICggbGluZSwgaSApIHtcblx0XHR2YXIgZW5kID0gc3RhcnQgKyBsaW5lLmxlbmd0aCArIDE7XG5cdFx0dmFyIHJhbmdlID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBsaW5lOiBpIH07XG5cblx0XHRzdGFydCA9IGVuZDtcblx0XHRyZXR1cm4gcmFuZ2U7XG5cdH0pO1xuXG5cdHZhciBpID0gMDtcblxuXHRmdW5jdGlvbiByYW5nZUNvbnRhaW5zICggcmFuZ2UsIGluZGV4ICkge1xuXHRcdHJldHVybiByYW5nZS5zdGFydCA8PSBpbmRleCAmJiBpbmRleCA8IHJhbmdlLmVuZDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldExvY2F0aW9uICggcmFuZ2UsIGluZGV4ICkge1xuXHRcdHJldHVybiB7IGxpbmU6IHJhbmdlLmxpbmUsIGNvbHVtbjogaW5kZXggLSByYW5nZS5zdGFydCB9O1xuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGxvY2F0ZSAoIGluZGV4ICkge1xuXHRcdHZhciByYW5nZSA9IGxpbmVSYW5nZXNbaV07XG5cblx0XHR2YXIgZCA9IGluZGV4ID49IHJhbmdlLmVuZCA/IDEgOiAtMTtcblxuXHRcdHdoaWxlICggcmFuZ2UgKSB7XG5cdFx0XHRpZiAoIHJhbmdlQ29udGFpbnMoIHJhbmdlLCBpbmRleCApICkgeyByZXR1cm4gZ2V0TG9jYXRpb24oIHJhbmdlLCBpbmRleCApOyB9XG5cblx0XHRcdGkgKz0gZDtcblx0XHRcdHJhbmdlID0gbGluZVJhbmdlc1tpXTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIE1hcHBpbmdzICggaGlyZXMgKSB7XG5cdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdHZhciBvZmZzZXRzID0ge1xuXHRcdGdlbmVyYXRlZENvZGVDb2x1bW46IDAsXG5cdFx0c291cmNlSW5kZXg6IDAsXG5cdFx0c291cmNlQ29kZUxpbmU6IDAsXG5cdFx0c291cmNlQ29kZUNvbHVtbjogMCxcblx0XHRzb3VyY2VDb2RlTmFtZTogMFxuXHR9O1xuXG5cdHZhciBnZW5lcmF0ZWRDb2RlTGluZSA9IDA7XG5cdHZhciBnZW5lcmF0ZWRDb2RlQ29sdW1uID0gMDtcblxuXHR0aGlzLnJhdyA9IFtdO1xuXHR2YXIgcmF3U2VnbWVudHMgPSB0aGlzLnJhd1sgZ2VuZXJhdGVkQ29kZUxpbmUgXSA9IFtdO1xuXG5cdHZhciBwZW5kaW5nID0gbnVsbDtcblxuXHR0aGlzLmFkZEVkaXQgPSBmdW5jdGlvbiAoIHNvdXJjZUluZGV4LCBjb250ZW50LCBvcmlnaW5hbCwgbG9jLCBuYW1lSW5kZXggKSB7XG5cdFx0aWYgKCBjb250ZW50Lmxlbmd0aCApIHtcblx0XHRcdHJhd1NlZ21lbnRzLnB1c2goW1xuXHRcdFx0XHRnZW5lcmF0ZWRDb2RlQ29sdW1uLFxuXHRcdFx0XHRzb3VyY2VJbmRleCxcblx0XHRcdFx0bG9jLmxpbmUsXG5cdFx0XHRcdGxvYy5jb2x1bW4sXG5cdFx0XHRcdG5hbWVJbmRleCBdKTtcblx0XHR9IGVsc2UgaWYgKCBwZW5kaW5nICkge1xuXHRcdFx0cmF3U2VnbWVudHMucHVzaCggcGVuZGluZyApO1xuXHRcdH1cblxuXHRcdHRoaXMkMS5hZHZhbmNlKCBjb250ZW50ICk7XG5cdFx0cGVuZGluZyA9IG51bGw7XG5cdH07XG5cblx0dGhpcy5hZGRVbmVkaXRlZENodW5rID0gZnVuY3Rpb24gKCBzb3VyY2VJbmRleCwgY2h1bmssIG9yaWdpbmFsLCBsb2MsIHNvdXJjZW1hcExvY2F0aW9ucyApIHtcblx0XHR2YXIgb3JpZ2luYWxDaGFySW5kZXggPSBjaHVuay5zdGFydDtcblx0XHR2YXIgZmlyc3QgPSB0cnVlO1xuXG5cdFx0d2hpbGUgKCBvcmlnaW5hbENoYXJJbmRleCA8IGNodW5rLmVuZCApIHtcblx0XHRcdGlmICggaGlyZXMgfHwgZmlyc3QgfHwgc291cmNlbWFwTG9jYXRpb25zWyBvcmlnaW5hbENoYXJJbmRleCBdICkge1xuXHRcdFx0XHRyYXdTZWdtZW50cy5wdXNoKFtcblx0XHRcdFx0XHRnZW5lcmF0ZWRDb2RlQ29sdW1uLFxuXHRcdFx0XHRcdHNvdXJjZUluZGV4LFxuXHRcdFx0XHRcdGxvYy5saW5lLFxuXHRcdFx0XHRcdGxvYy5jb2x1bW4sXG5cdFx0XHRcdFx0LTFcblx0XHRcdFx0XSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggb3JpZ2luYWxbIG9yaWdpbmFsQ2hhckluZGV4IF0gPT09ICdcXG4nICkge1xuXHRcdFx0XHRsb2MubGluZSArPSAxO1xuXHRcdFx0XHRsb2MuY29sdW1uID0gMDtcblx0XHRcdFx0Z2VuZXJhdGVkQ29kZUxpbmUgKz0gMTtcblx0XHRcdFx0dGhpcyQxLnJhd1sgZ2VuZXJhdGVkQ29kZUxpbmUgXSA9IHJhd1NlZ21lbnRzID0gW107XG5cdFx0XHRcdGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bG9jLmNvbHVtbiArPSAxO1xuXHRcdFx0XHRnZW5lcmF0ZWRDb2RlQ29sdW1uICs9IDE7XG5cdFx0XHR9XG5cblx0XHRcdG9yaWdpbmFsQ2hhckluZGV4ICs9IDE7XG5cdFx0XHRmaXJzdCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHBlbmRpbmcgPSBbXG5cdFx0XHRnZW5lcmF0ZWRDb2RlQ29sdW1uLFxuXHRcdFx0c291cmNlSW5kZXgsXG5cdFx0XHRsb2MubGluZSxcblx0XHRcdGxvYy5jb2x1bW4sXG5cdFx0XHQtMSBdO1xuXHR9O1xuXG5cdHRoaXMuYWR2YW5jZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0XHRpZiAoICFzdHIgKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGxpbmVzID0gc3RyLnNwbGl0KCAnXFxuJyApO1xuXHRcdHZhciBsYXN0TGluZSA9IGxpbmVzLnBvcCgpO1xuXG5cdFx0aWYgKCBsaW5lcy5sZW5ndGggKSB7XG5cdFx0XHRnZW5lcmF0ZWRDb2RlTGluZSArPSBsaW5lcy5sZW5ndGg7XG5cdFx0XHR0aGlzJDEucmF3WyBnZW5lcmF0ZWRDb2RlTGluZSBdID0gcmF3U2VnbWVudHMgPSBbXTtcblx0XHRcdGdlbmVyYXRlZENvZGVDb2x1bW4gPSBsYXN0TGluZS5sZW5ndGg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdlbmVyYXRlZENvZGVDb2x1bW4gKz0gbGFzdExpbmUubGVuZ3RoO1xuXHRcdH1cblx0fTtcblxuXHR0aGlzLmVuY29kZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcyQxLnJhdy5tYXAoIGZ1bmN0aW9uIChzZWdtZW50cykge1xuXHRcdFx0dmFyIGdlbmVyYXRlZENvZGVDb2x1bW4gPSAwO1xuXG5cdFx0XHRyZXR1cm4gc2VnbWVudHMubWFwKCBmdW5jdGlvbiAoc2VnbWVudCkge1xuXHRcdFx0XHR2YXIgYXJyID0gW1xuXHRcdFx0XHRcdHNlZ21lbnRbMF0gLSBnZW5lcmF0ZWRDb2RlQ29sdW1uLFxuXHRcdFx0XHRcdHNlZ21lbnRbMV0gLSBvZmZzZXRzLnNvdXJjZUluZGV4LFxuXHRcdFx0XHRcdHNlZ21lbnRbMl0gLSBvZmZzZXRzLnNvdXJjZUNvZGVMaW5lLFxuXHRcdFx0XHRcdHNlZ21lbnRbM10gLSBvZmZzZXRzLnNvdXJjZUNvZGVDb2x1bW5cblx0XHRcdFx0XTtcblxuXHRcdFx0XHRnZW5lcmF0ZWRDb2RlQ29sdW1uID0gc2VnbWVudFswXTtcblx0XHRcdFx0b2Zmc2V0cy5zb3VyY2VJbmRleCA9IHNlZ21lbnRbMV07XG5cdFx0XHRcdG9mZnNldHMuc291cmNlQ29kZUxpbmUgPSBzZWdtZW50WzJdO1xuXHRcdFx0XHRvZmZzZXRzLnNvdXJjZUNvZGVDb2x1bW4gPSBzZWdtZW50WzNdO1xuXG5cdFx0XHRcdGlmICggfnNlZ21lbnRbNF0gKSB7XG5cdFx0XHRcdFx0YXJyLnB1c2goIHNlZ21lbnRbNF0gLSBvZmZzZXRzLnNvdXJjZUNvZGVOYW1lICk7XG5cdFx0XHRcdFx0b2Zmc2V0cy5zb3VyY2VDb2RlTmFtZSA9IHNlZ21lbnRbNF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5jb2RlKCBhcnIgKTtcblx0XHRcdH0pLmpvaW4oICcsJyApO1xuXHRcdH0pLmpvaW4oICc7JyApO1xuXHR9O1xufVxuXG52YXIgU3RhdHMgPSBmdW5jdGlvbiBTdGF0cyAoKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XG5cdFx0c3RhcnRUaW1lczogeyB2YWx1ZToge30gfVxuXHR9KTtcbn07XG5cblN0YXRzLnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24gdGltZSAoIGxhYmVsICkge1xuXHR0aGlzLnN0YXJ0VGltZXNbIGxhYmVsIF0gPSBwcm9jZXNzLmhydGltZSgpO1xufTtcblxuU3RhdHMucHJvdG90eXBlLnRpbWVFbmQgPSBmdW5jdGlvbiB0aW1lRW5kICggbGFiZWwgKSB7XG5cdHZhciBlbGFwc2VkID0gcHJvY2Vzcy5ocnRpbWUoIHRoaXMuc3RhcnRUaW1lc1sgbGFiZWwgXSApO1xuXG5cdGlmICggIXRoaXNbIGxhYmVsIF0gKSB7IHRoaXNbIGxhYmVsIF0gPSAwOyB9XG5cdHRoaXNbIGxhYmVsIF0gKz0gZWxhcHNlZFswXSAqIDFlMyArIGVsYXBzZWRbMV0gKiAxZS02O1xufTtcblxudmFyIHdhcm5lZCA9IHtcblx0aW5zZXJ0TGVmdDogZmFsc2UsXG5cdGluc2VydFJpZ2h0OiBmYWxzZSxcblx0c3RvcmVOYW1lOiBmYWxzZVxufTtcblxuZnVuY3Rpb24gTWFnaWNTdHJpbmckMSAoIHN0cmluZywgb3B0aW9ucyApIHtcblx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKSBvcHRpb25zID0ge307XG5cblx0dmFyIGNodW5rID0gbmV3IENodW5rKCAwLCBzdHJpbmcubGVuZ3RoLCBzdHJpbmcgKTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xuXHRcdG9yaWdpbmFsOiAgICAgICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHN0cmluZyB9LFxuXHRcdG91dHJvOiAgICAgICAgICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6ICcnIH0sXG5cdFx0aW50cm86ICAgICAgICAgICAgICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogJycgfSxcblx0XHRmaXJzdENodW5rOiAgICAgICAgICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiBjaHVuayB9LFxuXHRcdGxhc3RDaHVuazogICAgICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGNodW5rIH0sXG5cdFx0bGFzdFNlYXJjaGVkQ2h1bms6ICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogY2h1bmsgfSxcblx0XHRieVN0YXJ0OiAgICAgICAgICAgICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuXHRcdGJ5RW5kOiAgICAgICAgICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHt9IH0sXG5cdFx0ZmlsZW5hbWU6ICAgICAgICAgICAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogb3B0aW9ucy5maWxlbmFtZSB9LFxuXHRcdGluZGVudEV4Y2x1c2lvblJhbmdlczogeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IG9wdGlvbnMuaW5kZW50RXhjbHVzaW9uUmFuZ2VzIH0sXG5cdFx0c291cmNlbWFwTG9jYXRpb25zOiAgICB7IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZToge30gfSxcblx0XHRzdG9yZWROYW1lczogICAgICAgICAgIHsgd3JpdGFibGU6IHRydWUsIHZhbHVlOiB7fSB9LFxuXHRcdGluZGVudFN0cjogICAgICAgICAgICAgeyB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IGd1ZXNzSW5kZW50KCBzdHJpbmcgKSB9XG5cdH0pO1xuXG5cdHRoaXMuYnlTdGFydFsgMCBdID0gY2h1bms7XG5cdHRoaXMuYnlFbmRbIHN0cmluZy5sZW5ndGggXSA9IGNodW5rO1xufVxuXG5NYWdpY1N0cmluZyQxLnByb3RvdHlwZSA9IHtcblx0YWRkU291cmNlbWFwTG9jYXRpb246IGZ1bmN0aW9uIGFkZFNvdXJjZW1hcExvY2F0aW9uICggY2hhciApIHtcblx0XHR0aGlzLnNvdXJjZW1hcExvY2F0aW9uc1sgY2hhciBdID0gdHJ1ZTtcblx0fSxcblxuXHRhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZCAoIGNvbnRlbnQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycgKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoICdvdXRybyBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnICk7IH1cblxuXHRcdHRoaXMub3V0cm8gKz0gY29udGVudDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhcHBlbmRMZWZ0OiBmdW5jdGlvbiBhcHBlbmRMZWZ0ICggaW5kZXgsIGNvbnRlbnQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycgKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoICdpbnNlcnRlZCBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnICk7IH1cblxuXHRcdHRoaXMuX3NwbGl0KCBpbmRleCApO1xuXG5cdFx0dmFyIGNodW5rID0gdGhpcy5ieUVuZFsgaW5kZXggXTtcblxuXHRcdGlmICggY2h1bmsgKSB7XG5cdFx0XHRjaHVuay5hcHBlbmRMZWZ0KCBjb250ZW50ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW50cm8gKz0gY29udGVudDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhcHBlbmRSaWdodDogZnVuY3Rpb24gYXBwZW5kUmlnaHQgKCBpbmRleCwgY29udGVudCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJyApIHsgdGhyb3cgbmV3IFR5cGVFcnJvciggJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycgKTsgfVxuXG5cdFx0dGhpcy5fc3BsaXQoIGluZGV4ICk7XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLmJ5U3RhcnRbIGluZGV4IF07XG5cblx0XHRpZiAoIGNodW5rICkge1xuXHRcdFx0Y2h1bmsuYXBwZW5kUmlnaHQoIGNvbnRlbnQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vdXRybyArPSBjb250ZW50O1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiBjbG9uZSAoKSB7XG5cdFx0dmFyIGNsb25lZCA9IG5ldyBNYWdpY1N0cmluZyQxKCB0aGlzLm9yaWdpbmFsLCB7IGZpbGVuYW1lOiB0aGlzLmZpbGVuYW1lIH0pO1xuXG5cdFx0dmFyIG9yaWdpbmFsQ2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cdFx0dmFyIGNsb25lZENodW5rID0gY2xvbmVkLmZpcnN0Q2h1bmsgPSBjbG9uZWQubGFzdFNlYXJjaGVkQ2h1bmsgPSBvcmlnaW5hbENodW5rLmNsb25lKCk7XG5cblx0XHR3aGlsZSAoIG9yaWdpbmFsQ2h1bmsgKSB7XG5cdFx0XHRjbG9uZWQuYnlTdGFydFsgY2xvbmVkQ2h1bmsuc3RhcnQgXSA9IGNsb25lZENodW5rO1xuXHRcdFx0Y2xvbmVkLmJ5RW5kWyBjbG9uZWRDaHVuay5lbmQgXSA9IGNsb25lZENodW5rO1xuXG5cdFx0XHR2YXIgbmV4dE9yaWdpbmFsQ2h1bmsgPSBvcmlnaW5hbENodW5rLm5leHQ7XG5cdFx0XHR2YXIgbmV4dENsb25lZENodW5rID0gbmV4dE9yaWdpbmFsQ2h1bmsgJiYgbmV4dE9yaWdpbmFsQ2h1bmsuY2xvbmUoKTtcblxuXHRcdFx0aWYgKCBuZXh0Q2xvbmVkQ2h1bmsgKSB7XG5cdFx0XHRcdGNsb25lZENodW5rLm5leHQgPSBuZXh0Q2xvbmVkQ2h1bms7XG5cdFx0XHRcdG5leHRDbG9uZWRDaHVuay5wcmV2aW91cyA9IGNsb25lZENodW5rO1xuXG5cdFx0XHRcdGNsb25lZENodW5rID0gbmV4dENsb25lZENodW5rO1xuXHRcdFx0fVxuXG5cdFx0XHRvcmlnaW5hbENodW5rID0gbmV4dE9yaWdpbmFsQ2h1bms7XG5cdFx0fVxuXG5cdFx0Y2xvbmVkLmxhc3RDaHVuayA9IGNsb25lZENodW5rO1xuXG5cdFx0aWYgKCB0aGlzLmluZGVudEV4Y2x1c2lvblJhbmdlcyApIHtcblx0XHRcdGNsb25lZC5pbmRlbnRFeGNsdXNpb25SYW5nZXMgPSB0aGlzLmluZGVudEV4Y2x1c2lvblJhbmdlcy5zbGljZSgpO1xuXHRcdH1cblxuXHRcdE9iamVjdC5rZXlzKCB0aGlzLnNvdXJjZW1hcExvY2F0aW9ucyApLmZvckVhY2goIGZ1bmN0aW9uIChsb2MpIHtcblx0XHRcdGNsb25lZC5zb3VyY2VtYXBMb2NhdGlvbnNbIGxvYyBdID0gdHJ1ZTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBjbG9uZWQ7XG5cdH0sXG5cblx0Z2VuZXJhdGVNYXA6IGZ1bmN0aW9uIGdlbmVyYXRlTWFwICggb3B0aW9ucyApIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHNvdXJjZUluZGV4ID0gMDtcblx0XHR2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyggdGhpcy5zdG9yZWROYW1lcyApO1xuXHRcdHZhciBtYXBwaW5ncyA9IG5ldyBNYXBwaW5ncyggb3B0aW9ucy5oaXJlcyApO1xuXG5cdFx0dmFyIGxvY2F0ZSA9IGdldExvY2F0b3IkMSggdGhpcy5vcmlnaW5hbCApO1xuXG5cdFx0aWYgKCB0aGlzLmludHJvICkge1xuXHRcdFx0bWFwcGluZ3MuYWR2YW5jZSggdGhpcy5pbnRybyApO1xuXHRcdH1cblxuXHRcdHRoaXMuZmlyc3RDaHVuay5lYWNoTmV4dCggZnVuY3Rpb24gKGNodW5rKSB7XG5cdFx0XHR2YXIgbG9jID0gbG9jYXRlKCBjaHVuay5zdGFydCApO1xuXG5cdFx0XHRpZiAoIGNodW5rLmludHJvLmxlbmd0aCApIHsgbWFwcGluZ3MuYWR2YW5jZSggY2h1bmsuaW50cm8gKTsgfVxuXG5cdFx0XHRpZiAoIGNodW5rLmVkaXRlZCApIHtcblx0XHRcdFx0bWFwcGluZ3MuYWRkRWRpdCggc291cmNlSW5kZXgsIGNodW5rLmNvbnRlbnQsIGNodW5rLm9yaWdpbmFsLCBsb2MsIGNodW5rLnN0b3JlTmFtZSA/IG5hbWVzLmluZGV4T2YoIGNodW5rLm9yaWdpbmFsICkgOiAtMSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWFwcGluZ3MuYWRkVW5lZGl0ZWRDaHVuayggc291cmNlSW5kZXgsIGNodW5rLCB0aGlzJDEub3JpZ2luYWwsIGxvYywgdGhpcyQxLnNvdXJjZW1hcExvY2F0aW9ucyApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGNodW5rLm91dHJvLmxlbmd0aCApIHsgbWFwcGluZ3MuYWR2YW5jZSggY2h1bmsub3V0cm8gKTsgfVxuXHRcdH0pO1xuXG5cdFx0dmFyIG1hcCA9IG5ldyBTb3VyY2VNYXAoe1xuXHRcdFx0ZmlsZTogKCBvcHRpb25zLmZpbGUgPyBvcHRpb25zLmZpbGUuc3BsaXQoIC9bXFwvXFxcXF0vICkucG9wKCkgOiBudWxsICksXG5cdFx0XHRzb3VyY2VzOiBbIG9wdGlvbnMuc291cmNlID8gZ2V0UmVsYXRpdmVQYXRoKCBvcHRpb25zLmZpbGUgfHwgJycsIG9wdGlvbnMuc291cmNlICkgOiBudWxsIF0sXG5cdFx0XHRzb3VyY2VzQ29udGVudDogb3B0aW9ucy5pbmNsdWRlQ29udGVudCA/IFsgdGhpcy5vcmlnaW5hbCBdIDogWyBudWxsIF0sXG5cdFx0XHRuYW1lczogbmFtZXMsXG5cdFx0XHRtYXBwaW5nczogbWFwcGluZ3MuZW5jb2RlKClcblx0XHR9KTtcblx0XHRyZXR1cm4gbWFwO1xuXHR9LFxuXG5cdGdldEluZGVudFN0cmluZzogZnVuY3Rpb24gZ2V0SW5kZW50U3RyaW5nICgpIHtcblx0XHRyZXR1cm4gdGhpcy5pbmRlbnRTdHIgPT09IG51bGwgPyAnXFx0JyA6IHRoaXMuaW5kZW50U3RyO1xuXHR9LFxuXG5cdGluZGVudDogZnVuY3Rpb24gaW5kZW50ICggaW5kZW50U3RyLCBvcHRpb25zICkge1xuXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdFx0dmFyIHBhdHRlcm4gPSAvXlteXFxyXFxuXS9nbTtcblxuXHRcdGlmICggaXNPYmplY3QoIGluZGVudFN0ciApICkge1xuXHRcdFx0b3B0aW9ucyA9IGluZGVudFN0cjtcblx0XHRcdGluZGVudFN0ciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpbmRlbnRTdHIgPSBpbmRlbnRTdHIgIT09IHVuZGVmaW5lZCA/IGluZGVudFN0ciA6ICggdGhpcy5pbmRlbnRTdHIgfHwgJ1xcdCcgKTtcblxuXHRcdGlmICggaW5kZW50U3RyID09PSAnJyApIHsgcmV0dXJuIHRoaXM7IH0gLy8gbm9vcFxuXG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBQcm9jZXNzIGV4Y2x1c2lvbiByYW5nZXNcblx0XHR2YXIgaXNFeGNsdWRlZCA9IHt9O1xuXG5cdFx0aWYgKCBvcHRpb25zLmV4Y2x1ZGUgKSB7XG5cdFx0XHR2YXIgZXhjbHVzaW9ucyA9IHR5cGVvZiBvcHRpb25zLmV4Y2x1ZGVbMF0gPT09ICdudW1iZXInID8gWyBvcHRpb25zLmV4Y2x1ZGUgXSA6IG9wdGlvbnMuZXhjbHVkZTtcblx0XHRcdGV4Y2x1c2lvbnMuZm9yRWFjaCggZnVuY3Rpb24gKGV4Y2x1c2lvbikge1xuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IGV4Y2x1c2lvblswXTsgaSA8IGV4Y2x1c2lvblsxXTsgaSArPSAxICkge1xuXHRcdFx0XHRcdGlzRXhjbHVkZWRbaV0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2YXIgc2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IG9wdGlvbnMuaW5kZW50U3RhcnQgIT09IGZhbHNlO1xuXHRcdHZhciByZXBsYWNlciA9IGZ1bmN0aW9uIChtYXRjaCkge1xuXHRcdFx0aWYgKCBzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyICkgeyByZXR1cm4gKFwiXCIgKyBpbmRlbnRTdHIgKyBtYXRjaCk7IH1cblx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH07XG5cblx0XHR0aGlzLmludHJvID0gdGhpcy5pbnRyby5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlciApO1xuXG5cdFx0dmFyIGNoYXJJbmRleCA9IDA7XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLmZpcnN0Q2h1bms7XG5cblx0XHR3aGlsZSAoIGNodW5rICkge1xuXHRcdFx0dmFyIGVuZCA9IGNodW5rLmVuZDtcblxuXHRcdFx0aWYgKCBjaHVuay5lZGl0ZWQgKSB7XG5cdFx0XHRcdGlmICggIWlzRXhjbHVkZWRbIGNoYXJJbmRleCBdICkge1xuXHRcdFx0XHRcdGNodW5rLmNvbnRlbnQgPSBjaHVuay5jb250ZW50LnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2VyICk7XG5cblx0XHRcdFx0XHRpZiAoIGNodW5rLmNvbnRlbnQubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0c2hvdWxkSW5kZW50TmV4dENoYXJhY3RlciA9IGNodW5rLmNvbnRlbnRbIGNodW5rLmNvbnRlbnQubGVuZ3RoIC0gMSBdID09PSAnXFxuJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNoYXJJbmRleCA9IGNodW5rLnN0YXJ0O1xuXG5cdFx0XHRcdHdoaWxlICggY2hhckluZGV4IDwgZW5kICkge1xuXHRcdFx0XHRcdGlmICggIWlzRXhjbHVkZWRbIGNoYXJJbmRleCBdICkge1xuXHRcdFx0XHRcdFx0dmFyIGNoYXIgPSB0aGlzJDEub3JpZ2luYWxbIGNoYXJJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRpZiAoIGNoYXIgPT09ICdcXG4nICkge1xuXHRcdFx0XHRcdFx0XHRzaG91bGRJbmRlbnROZXh0Q2hhcmFjdGVyID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGNoYXIgIT09ICdcXHInICYmIHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHNob3VsZEluZGVudE5leHRDaGFyYWN0ZXIgPSBmYWxzZTtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIGNoYXJJbmRleCA9PT0gY2h1bmsuc3RhcnQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KCBpbmRlbnRTdHIgKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzJDEuX3NwbGl0Q2h1bmsoIGNodW5rLCBjaGFySW5kZXggKTtcblx0XHRcdFx0XHRcdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0XHRcdFx0XHRcdFx0Y2h1bmsucHJlcGVuZFJpZ2h0KCBpbmRlbnRTdHIgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNoYXJJbmRleCArPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGNoYXJJbmRleCA9IGNodW5rLmVuZDtcblx0XHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0XHR9XG5cblx0XHR0aGlzLm91dHJvID0gdGhpcy5vdXRyby5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlciApO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0aW5zZXJ0OiBmdW5jdGlvbiBpbnNlcnQgKCkge1xuXHRcdHRocm93IG5ldyBFcnJvciggJ21hZ2ljU3RyaW5nLmluc2VydCguLi4pIGlzIGRlcHJlY2F0ZWQuIFVzZSBwcmVwZW5kUmlnaHQoLi4uKSBvciBhcHBlbmRMZWZ0KC4uLiknICk7XG5cdH0sXG5cblx0aW5zZXJ0TGVmdDogZnVuY3Rpb24gaW5zZXJ0TGVmdCAoIGluZGV4LCBjb250ZW50ICkge1xuXHRcdGlmICggIXdhcm5lZC5pbnNlcnRMZWZ0ICkge1xuXHRcdFx0Y29uc29sZS53YXJuKCAnbWFnaWNTdHJpbmcuaW5zZXJ0TGVmdCguLi4pIGlzIGRlcHJlY2F0ZWQuIFVzZSBtYWdpY1N0cmluZy5hcHBlbmRMZWZ0KC4uLikgaW5zdGVhZCcgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0XHR3YXJuZWQuaW5zZXJ0TGVmdCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuYXBwZW5kTGVmdCggaW5kZXgsIGNvbnRlbnQgKTtcblx0fSxcblxuXHRpbnNlcnRSaWdodDogZnVuY3Rpb24gaW5zZXJ0UmlnaHQgKCBpbmRleCwgY29udGVudCApIHtcblx0XHRpZiAoICF3YXJuZWQuaW5zZXJ0UmlnaHQgKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oICdtYWdpY1N0cmluZy5pbnNlcnRSaWdodCguLi4pIGlzIGRlcHJlY2F0ZWQuIFVzZSBtYWdpY1N0cmluZy5wcmVwZW5kUmlnaHQoLi4uKSBpbnN0ZWFkJyApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblx0XHRcdHdhcm5lZC5pbnNlcnRSaWdodCA9IHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHJlcGVuZFJpZ2h0KCBpbmRleCwgY29udGVudCApO1xuXHR9LFxuXG5cdG1vdmU6IGZ1bmN0aW9uIG1vdmUgKCBzdGFydCwgZW5kLCBpbmRleCApIHtcblx0XHRpZiAoIGluZGV4ID49IHN0YXJ0ICYmIGluZGV4IDw9IGVuZCApIHsgdGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IG1vdmUgYSBzZWxlY3Rpb24gaW5zaWRlIGl0c2VsZicgKTsgfVxuXG5cdFx0dGhpcy5fc3BsaXQoIHN0YXJ0ICk7XG5cdFx0dGhpcy5fc3BsaXQoIGVuZCApO1xuXHRcdHRoaXMuX3NwbGl0KCBpbmRleCApO1xuXG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5ieVN0YXJ0WyBzdGFydCBdO1xuXHRcdHZhciBsYXN0ID0gdGhpcy5ieUVuZFsgZW5kIF07XG5cblx0XHR2YXIgb2xkTGVmdCA9IGZpcnN0LnByZXZpb3VzO1xuXHRcdHZhciBvbGRSaWdodCA9IGxhc3QubmV4dDtcblxuXHRcdHZhciBuZXdSaWdodCA9IHRoaXMuYnlTdGFydFsgaW5kZXggXTtcblx0XHRpZiAoICFuZXdSaWdodCAmJiBsYXN0ID09PSB0aGlzLmxhc3RDaHVuayApIHsgcmV0dXJuIHRoaXM7IH1cblx0XHR2YXIgbmV3TGVmdCA9IG5ld1JpZ2h0ID8gbmV3UmlnaHQucHJldmlvdXMgOiB0aGlzLmxhc3RDaHVuaztcblxuXHRcdGlmICggb2xkTGVmdCApIHsgb2xkTGVmdC5uZXh0ID0gb2xkUmlnaHQ7IH1cblx0XHRpZiAoIG9sZFJpZ2h0ICkgeyBvbGRSaWdodC5wcmV2aW91cyA9IG9sZExlZnQ7IH1cblxuXHRcdGlmICggbmV3TGVmdCApIHsgbmV3TGVmdC5uZXh0ID0gZmlyc3Q7IH1cblx0XHRpZiAoIG5ld1JpZ2h0ICkgeyBuZXdSaWdodC5wcmV2aW91cyA9IGxhc3Q7IH1cblxuXHRcdGlmICggIWZpcnN0LnByZXZpb3VzICkgeyB0aGlzLmZpcnN0Q2h1bmsgPSBsYXN0Lm5leHQ7IH1cblx0XHRpZiAoICFsYXN0Lm5leHQgKSB7XG5cdFx0XHR0aGlzLmxhc3RDaHVuayA9IGZpcnN0LnByZXZpb3VzO1xuXHRcdFx0dGhpcy5sYXN0Q2h1bmsubmV4dCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Zmlyc3QucHJldmlvdXMgPSBuZXdMZWZ0O1xuXHRcdGxhc3QubmV4dCA9IG5ld1JpZ2h0IHx8IG51bGw7XG5cblx0XHRpZiAoICFuZXdMZWZ0ICkgeyB0aGlzLmZpcnN0Q2h1bmsgPSBmaXJzdDsgfVxuXHRcdGlmICggIW5ld1JpZ2h0ICkgeyB0aGlzLmxhc3RDaHVuayA9IGxhc3Q7IH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG92ZXJ3cml0ZTogZnVuY3Rpb24gb3ZlcndyaXRlICggc3RhcnQsIGVuZCwgY29udGVudCwgb3B0aW9ucyApIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdGlmICggdHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnICkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCAncmVwbGFjZW1lbnQgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyApOyB9XG5cblx0XHR3aGlsZSAoIHN0YXJ0IDwgMCApIHsgc3RhcnQgKz0gdGhpcyQxLm9yaWdpbmFsLmxlbmd0aDsgfVxuXHRcdHdoaWxlICggZW5kIDwgMCApIHsgZW5kICs9IHRoaXMkMS5vcmlnaW5hbC5sZW5ndGg7IH1cblxuXHRcdGlmICggZW5kID4gdGhpcy5vcmlnaW5hbC5sZW5ndGggKSB7IHRocm93IG5ldyBFcnJvciggJ2VuZCBpcyBvdXQgb2YgYm91bmRzJyApOyB9XG5cdFx0aWYgKCBzdGFydCA9PT0gZW5kICkgeyB0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3Qgb3ZlcndyaXRlIGEgemVyby1sZW5ndGggcmFuZ2Ug4oCTIHVzZSBhcHBlbmRMZWZ0IG9yIHByZXBlbmRSaWdodCBpbnN0ZWFkJyApOyB9XG5cblx0XHR0aGlzLl9zcGxpdCggc3RhcnQgKTtcblx0XHR0aGlzLl9zcGxpdCggZW5kICk7XG5cblx0XHRpZiAoIG9wdGlvbnMgPT09IHRydWUgKSB7XG5cdFx0XHRpZiAoICF3YXJuZWQuc3RvcmVOYW1lICkge1xuXHRcdFx0XHRjb25zb2xlLndhcm4oICdUaGUgZmluYWwgYXJndW1lbnQgdG8gbWFnaWNTdHJpbmcub3ZlcndyaXRlKC4uLikgc2hvdWxkIGJlIGFuIG9wdGlvbnMgb2JqZWN0LiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JpY2gtaGFycmlzL21hZ2ljLXN0cmluZycgKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cdFx0XHRcdHdhcm5lZC5zdG9yZU5hbWUgPSB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRvcHRpb25zID0geyBzdG9yZU5hbWU6IHRydWUgfTtcblx0XHR9XG5cdFx0dmFyIHN0b3JlTmFtZSA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuc3RvcmVOYW1lIDogZmFsc2U7XG5cdFx0dmFyIGNvbnRlbnRPbmx5ID0gb3B0aW9ucyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jb250ZW50T25seSA6IGZhbHNlO1xuXG5cdFx0aWYgKCBzdG9yZU5hbWUgKSB7XG5cdFx0XHR2YXIgb3JpZ2luYWwgPSB0aGlzLm9yaWdpbmFsLnNsaWNlKCBzdGFydCwgZW5kICk7XG5cdFx0XHR0aGlzLnN0b3JlZE5hbWVzWyBvcmlnaW5hbCBdID0gdHJ1ZTtcblx0XHR9XG5cblx0XHR2YXIgZmlyc3QgPSB0aGlzLmJ5U3RhcnRbIHN0YXJ0IF07XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmJ5RW5kWyBlbmQgXTtcblxuXHRcdGlmICggZmlyc3QgKSB7XG5cdFx0XHRpZiAoIGVuZCA+IGZpcnN0LmVuZCAmJiBmaXJzdC5uZXh0ICE9PSB0aGlzLmJ5U3RhcnRbIGZpcnN0LmVuZCBdICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3Qgb3ZlcndyaXRlIGFjcm9zcyBhIHNwbGl0IHBvaW50JyApO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJzdC5lZGl0KCBjb250ZW50LCBzdG9yZU5hbWUsIGNvbnRlbnRPbmx5ICk7XG5cblx0XHRcdGlmICggZmlyc3QgIT09IGxhc3QgKSB7XG5cdFx0XHRcdHZhciBjaHVuayA9IGZpcnN0Lm5leHQ7XG5cdFx0XHRcdHdoaWxlICggY2h1bmsgIT09IGxhc3QgKSB7XG5cdFx0XHRcdFx0Y2h1bmsuZWRpdCggJycsIGZhbHNlICk7XG5cdFx0XHRcdFx0Y2h1bmsgPSBjaHVuay5uZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2h1bmsuZWRpdCggJycsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBtdXN0IGJlIGluc2VydGluZyBhdCB0aGUgZW5kXG5cdFx0XHR2YXIgbmV3Q2h1bmsgPSBuZXcgQ2h1bmsoIHN0YXJ0LCBlbmQsICcnICkuZWRpdCggY29udGVudCwgc3RvcmVOYW1lICk7XG5cblx0XHRcdC8vIFRPRE8gbGFzdCBjaHVuayBpbiB0aGUgYXJyYXkgbWF5IG5vdCBiZSB0aGUgbGFzdCBjaHVuaywgaWYgaXQncyBtb3ZlZC4uLlxuXHRcdFx0bGFzdC5uZXh0ID0gbmV3Q2h1bms7XG5cdFx0XHRuZXdDaHVuay5wcmV2aW91cyA9IGxhc3Q7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZCAoIGNvbnRlbnQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGVudCAhPT0gJ3N0cmluZycgKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoICdvdXRybyBjb250ZW50IG11c3QgYmUgYSBzdHJpbmcnICk7IH1cblxuXHRcdHRoaXMuaW50cm8gPSBjb250ZW50ICsgdGhpcy5pbnRybztcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVwZW5kTGVmdDogZnVuY3Rpb24gcHJlcGVuZExlZnQgKCBpbmRleCwgY29udGVudCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZW50ICE9PSAnc3RyaW5nJyApIHsgdGhyb3cgbmV3IFR5cGVFcnJvciggJ2luc2VydGVkIGNvbnRlbnQgbXVzdCBiZSBhIHN0cmluZycgKTsgfVxuXG5cdFx0dGhpcy5fc3BsaXQoIGluZGV4ICk7XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLmJ5RW5kWyBpbmRleCBdO1xuXG5cdFx0aWYgKCBjaHVuayApIHtcblx0XHRcdGNodW5rLnByZXBlbmRMZWZ0KCBjb250ZW50ICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaW50cm8gPSBjb250ZW50ICsgdGhpcy5pbnRybztcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVwZW5kUmlnaHQ6IGZ1bmN0aW9uIHByZXBlbmRSaWdodCAoIGluZGV4LCBjb250ZW50ICkge1xuXHRcdGlmICggdHlwZW9mIGNvbnRlbnQgIT09ICdzdHJpbmcnICkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCAnaW5zZXJ0ZWQgY29udGVudCBtdXN0IGJlIGEgc3RyaW5nJyApOyB9XG5cblx0XHR0aGlzLl9zcGxpdCggaW5kZXggKTtcblxuXHRcdHZhciBjaHVuayA9IHRoaXMuYnlTdGFydFsgaW5kZXggXTtcblxuXHRcdGlmICggY2h1bmsgKSB7XG5cdFx0XHRjaHVuay5wcmVwZW5kUmlnaHQoIGNvbnRlbnQgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vdXRybyA9IGNvbnRlbnQgKyB0aGlzLm91dHJvO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlICggc3RhcnQsIGVuZCApIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdHdoaWxlICggc3RhcnQgPCAwICkgeyBzdGFydCArPSB0aGlzJDEub3JpZ2luYWwubGVuZ3RoOyB9XG5cdFx0d2hpbGUgKCBlbmQgPCAwICkgeyBlbmQgKz0gdGhpcyQxLm9yaWdpbmFsLmxlbmd0aDsgfVxuXG5cdFx0aWYgKCBzdGFydCA9PT0gZW5kICkgeyByZXR1cm4gdGhpczsgfVxuXG5cdFx0aWYgKCBzdGFydCA8IDAgfHwgZW5kID4gdGhpcy5vcmlnaW5hbC5sZW5ndGggKSB7IHRocm93IG5ldyBFcnJvciggJ0NoYXJhY3RlciBpcyBvdXQgb2YgYm91bmRzJyApOyB9XG5cdFx0aWYgKCBzdGFydCA+IGVuZCApIHsgdGhyb3cgbmV3IEVycm9yKCAnZW5kIG11c3QgYmUgZ3JlYXRlciB0aGFuIHN0YXJ0JyApOyB9XG5cblx0XHR0aGlzLl9zcGxpdCggc3RhcnQgKTtcblx0XHR0aGlzLl9zcGxpdCggZW5kICk7XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLmJ5U3RhcnRbIHN0YXJ0IF07XG5cblx0XHR3aGlsZSAoIGNodW5rICkge1xuXHRcdFx0Y2h1bmsuaW50cm8gPSAnJztcblx0XHRcdGNodW5rLm91dHJvID0gJyc7XG5cdFx0XHRjaHVuay5lZGl0KCAnJyApO1xuXG5cdFx0XHRjaHVuayA9IGVuZCA+IGNodW5rLmVuZCA/IHRoaXMkMS5ieVN0YXJ0WyBjaHVuay5lbmQgXSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2xpY2U6IGZ1bmN0aW9uIHNsaWNlICggc3RhcnQsIGVuZCApIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblx0XHRpZiAoIHN0YXJ0ID09PSB2b2lkIDAgKSBzdGFydCA9IDA7XG5cdFx0aWYgKCBlbmQgPT09IHZvaWQgMCApIGVuZCA9IHRoaXMub3JpZ2luYWwubGVuZ3RoO1xuXG5cdFx0d2hpbGUgKCBzdGFydCA8IDAgKSB7IHN0YXJ0ICs9IHRoaXMkMS5vcmlnaW5hbC5sZW5ndGg7IH1cblx0XHR3aGlsZSAoIGVuZCA8IDAgKSB7IGVuZCArPSB0aGlzJDEub3JpZ2luYWwubGVuZ3RoOyB9XG5cblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cblx0XHQvLyBmaW5kIHN0YXJ0IGNodW5rXG5cdFx0dmFyIGNodW5rID0gdGhpcy5maXJzdENodW5rO1xuXHRcdHdoaWxlICggY2h1bmsgJiYgKCBjaHVuay5zdGFydCA+IHN0YXJ0IHx8IGNodW5rLmVuZCA8PSBzdGFydCApICkge1xuXG5cdFx0XHQvLyBmb3VuZCBlbmQgY2h1bmsgYmVmb3JlIHN0YXJ0XG5cdFx0XHRpZiAoIGNodW5rLnN0YXJ0IDwgZW5kICYmIGNodW5rLmVuZCA+PSBlbmQgKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cblx0XHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0XHR9XG5cblx0XHRpZiAoIGNodW5rICYmIGNodW5rLmVkaXRlZCAmJiBjaHVuay5zdGFydCAhPT0gc3RhcnQgKSB7IHRocm93IG5ldyBFcnJvcigoXCJDYW5ub3QgdXNlIHJlcGxhY2VkIGNoYXJhY3RlciBcIiArIHN0YXJ0ICsgXCIgYXMgc2xpY2Ugc3RhcnQgYW5jaG9yLlwiKSk7IH1cblxuXHRcdHZhciBzdGFydENodW5rID0gY2h1bms7XG5cdFx0d2hpbGUgKCBjaHVuayApIHtcblx0XHRcdGlmICggY2h1bmsuaW50cm8gJiYgKCBzdGFydENodW5rICE9PSBjaHVuayB8fCBjaHVuay5zdGFydCA9PT0gc3RhcnQgKSApIHtcblx0XHRcdFx0cmVzdWx0ICs9IGNodW5rLmludHJvO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29udGFpbnNFbmQgPSBjaHVuay5zdGFydCA8IGVuZCAmJiBjaHVuay5lbmQgPj0gZW5kO1xuXHRcdFx0aWYgKCBjb250YWluc0VuZCAmJiBjaHVuay5lZGl0ZWQgJiYgY2h1bmsuZW5kICE9PSBlbmQgKSB7IHRocm93IG5ldyBFcnJvcigoXCJDYW5ub3QgdXNlIHJlcGxhY2VkIGNoYXJhY3RlciBcIiArIGVuZCArIFwiIGFzIHNsaWNlIGVuZCBhbmNob3IuXCIpKTsgfVxuXG5cdFx0XHR2YXIgc2xpY2VTdGFydCA9IHN0YXJ0Q2h1bmsgPT09IGNodW5rID8gc3RhcnQgLSBjaHVuay5zdGFydCA6IDA7XG5cdFx0XHR2YXIgc2xpY2VFbmQgPSBjb250YWluc0VuZCA/IGNodW5rLmNvbnRlbnQubGVuZ3RoICsgZW5kIC0gY2h1bmsuZW5kIDogY2h1bmsuY29udGVudC5sZW5ndGg7XG5cblx0XHRcdHJlc3VsdCArPSBjaHVuay5jb250ZW50LnNsaWNlKCBzbGljZVN0YXJ0LCBzbGljZUVuZCApO1xuXG5cdFx0XHRpZiAoIGNodW5rLm91dHJvICYmICggIWNvbnRhaW5zRW5kIHx8IGNodW5rLmVuZCA9PT0gZW5kICkgKSB7XG5cdFx0XHRcdHJlc3VsdCArPSBjaHVuay5vdXRybztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBjb250YWluc0VuZCApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGNodW5rID0gY2h1bmsubmV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8vIFRPRE8gZGVwcmVjYXRlIHRoaXM/IG5vdCByZWFsbHkgdmVyeSB1c2VmdWxcblx0c25pcDogZnVuY3Rpb24gc25pcCAoIHN0YXJ0LCBlbmQgKSB7XG5cdFx0dmFyIGNsb25lID0gdGhpcy5jbG9uZSgpO1xuXHRcdGNsb25lLnJlbW92ZSggMCwgc3RhcnQgKTtcblx0XHRjbG9uZS5yZW1vdmUoIGVuZCwgY2xvbmUub3JpZ2luYWwubGVuZ3RoICk7XG5cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0X3NwbGl0OiBmdW5jdGlvbiBfc3BsaXQgKCBpbmRleCApIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdGlmICggdGhpcy5ieVN0YXJ0WyBpbmRleCBdIHx8IHRoaXMuYnlFbmRbIGluZGV4IF0gKSB7IHJldHVybjsgfVxuXG5cdFx0dmFyIGNodW5rID0gdGhpcy5sYXN0U2VhcmNoZWRDaHVuaztcblx0XHR2YXIgc2VhcmNoRm9yd2FyZCA9IGluZGV4ID4gY2h1bmsuZW5kO1xuXG5cdFx0d2hpbGUgKCB0cnVlICkge1xuXHRcdFx0aWYgKCBjaHVuay5jb250YWlucyggaW5kZXggKSApIHsgcmV0dXJuIHRoaXMkMS5fc3BsaXRDaHVuayggY2h1bmssIGluZGV4ICk7IH1cblxuXHRcdFx0Y2h1bmsgPSBzZWFyY2hGb3J3YXJkID9cblx0XHRcdFx0dGhpcyQxLmJ5U3RhcnRbIGNodW5rLmVuZCBdIDpcblx0XHRcdFx0dGhpcyQxLmJ5RW5kWyBjaHVuay5zdGFydCBdO1xuXHRcdH1cblx0fSxcblxuXHRfc3BsaXRDaHVuazogZnVuY3Rpb24gX3NwbGl0Q2h1bmsgKCBjaHVuaywgaW5kZXggKSB7XG5cdFx0aWYgKCBjaHVuay5lZGl0ZWQgJiYgY2h1bmsuY29udGVudC5sZW5ndGggKSB7IC8vIHplcm8tbGVuZ3RoIGVkaXRlZCBjaHVua3MgYXJlIGEgc3BlY2lhbCBjYXNlIChvdmVybGFwcGluZyByZXBsYWNlbWVudHMpXG5cdFx0XHR2YXIgbG9jID0gZ2V0TG9jYXRvciQxKCB0aGlzLm9yaWdpbmFsICkoIGluZGV4ICk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoIChcIkNhbm5vdCBzcGxpdCBhIGNodW5rIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBlZGl0ZWQgKFwiICsgKGxvYy5saW5lKSArIFwiOlwiICsgKGxvYy5jb2x1bW4pICsgXCIg4oCTIFxcXCJcIiArIChjaHVuay5vcmlnaW5hbCkgKyBcIlxcXCIpXCIpICk7XG5cdFx0fVxuXG5cdFx0dmFyIG5ld0NodW5rID0gY2h1bmsuc3BsaXQoIGluZGV4ICk7XG5cblx0XHR0aGlzLmJ5RW5kWyBpbmRleCBdID0gY2h1bms7XG5cdFx0dGhpcy5ieVN0YXJ0WyBpbmRleCBdID0gbmV3Q2h1bms7XG5cdFx0dGhpcy5ieUVuZFsgbmV3Q2h1bmsuZW5kIF0gPSBuZXdDaHVuaztcblxuXHRcdGlmICggY2h1bmsgPT09IHRoaXMubGFzdENodW5rICkgeyB0aGlzLmxhc3RDaHVuayA9IG5ld0NodW5rOyB9XG5cblx0XHR0aGlzLmxhc3RTZWFyY2hlZENodW5rID0gY2h1bms7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcblx0XHR2YXIgc3RyID0gdGhpcy5pbnRybztcblxuXHRcdHZhciBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblx0XHR3aGlsZSAoIGNodW5rICkge1xuXHRcdFx0c3RyICs9IGNodW5rLnRvU3RyaW5nKCk7XG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0ciArIHRoaXMub3V0cm87XG5cdH0sXG5cblx0dHJpbUxpbmVzOiBmdW5jdGlvbiB0cmltTGluZXMgKCkge1xuXHRcdHJldHVybiB0aGlzLnRyaW0oJ1tcXFxcclxcXFxuXScpO1xuXHR9LFxuXG5cdHRyaW06IGZ1bmN0aW9uIHRyaW0gKCBjaGFyVHlwZSApIHtcblx0XHRyZXR1cm4gdGhpcy50cmltU3RhcnQoIGNoYXJUeXBlICkudHJpbUVuZCggY2hhclR5cGUgKTtcblx0fSxcblxuXHR0cmltRW5kOiBmdW5jdGlvbiB0cmltRW5kICggY2hhclR5cGUgKSB7XG5cdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHR2YXIgcnggPSBuZXcgUmVnRXhwKCAoIGNoYXJUeXBlIHx8ICdcXFxccycgKSArICcrJCcgKTtcblxuXHRcdHRoaXMub3V0cm8gPSB0aGlzLm91dHJvLnJlcGxhY2UoIHJ4LCAnJyApO1xuXHRcdGlmICggdGhpcy5vdXRyby5sZW5ndGggKSB7IHJldHVybiB0aGlzOyB9XG5cblx0XHR2YXIgY2h1bmsgPSB0aGlzLmxhc3RDaHVuaztcblxuXHRcdGRvIHtcblx0XHRcdHZhciBlbmQgPSBjaHVuay5lbmQ7XG5cdFx0XHR2YXIgYWJvcnRlZCA9IGNodW5rLnRyaW1FbmQoIHJ4ICk7XG5cblx0XHRcdC8vIGlmIGNodW5rIHdhcyB0cmltbWVkLCB3ZSBoYXZlIGEgbmV3IGxhc3RDaHVua1xuXHRcdFx0aWYgKCBjaHVuay5lbmQgIT09IGVuZCApIHtcblx0XHRcdFx0aWYgKCB0aGlzJDEubGFzdENodW5rID09PSBjaHVuayApIHtcblx0XHRcdFx0XHR0aGlzJDEubGFzdENodW5rID0gY2h1bmsubmV4dDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXMkMS5ieUVuZFsgY2h1bmsuZW5kIF0gPSBjaHVuaztcblx0XHRcdFx0dGhpcyQxLmJ5U3RhcnRbIGNodW5rLm5leHQuc3RhcnQgXSA9IGNodW5rLm5leHQ7XG5cdFx0XHRcdHRoaXMkMS5ieUVuZFsgY2h1bmsubmV4dC5lbmQgXSA9IGNodW5rLm5leHQ7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYWJvcnRlZCApIHsgcmV0dXJuIHRoaXMkMTsgfVxuXHRcdFx0Y2h1bmsgPSBjaHVuay5wcmV2aW91cztcblx0XHR9IHdoaWxlICggY2h1bmsgKTtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRyaW1TdGFydDogZnVuY3Rpb24gdHJpbVN0YXJ0ICggY2hhclR5cGUgKSB7XG5cdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHR2YXIgcnggPSBuZXcgUmVnRXhwKCAnXicgKyAoIGNoYXJUeXBlIHx8ICdcXFxccycgKSArICcrJyApO1xuXG5cdFx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZSggcngsICcnICk7XG5cdFx0aWYgKCB0aGlzLmludHJvLmxlbmd0aCApIHsgcmV0dXJuIHRoaXM7IH1cblxuXHRcdHZhciBjaHVuayA9IHRoaXMuZmlyc3RDaHVuaztcblxuXHRcdGRvIHtcblx0XHRcdHZhciBlbmQgPSBjaHVuay5lbmQ7XG5cdFx0XHR2YXIgYWJvcnRlZCA9IGNodW5rLnRyaW1TdGFydCggcnggKTtcblxuXHRcdFx0aWYgKCBjaHVuay5lbmQgIT09IGVuZCApIHtcblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlLi4uXG5cdFx0XHRcdGlmICggY2h1bmsgPT09IHRoaXMkMS5sYXN0Q2h1bmsgKSB7IHRoaXMkMS5sYXN0Q2h1bmsgPSBjaHVuay5uZXh0OyB9XG5cblx0XHRcdFx0dGhpcyQxLmJ5RW5kWyBjaHVuay5lbmQgXSA9IGNodW5rO1xuXHRcdFx0XHR0aGlzJDEuYnlTdGFydFsgY2h1bmsubmV4dC5zdGFydCBdID0gY2h1bmsubmV4dDtcblx0XHRcdFx0dGhpcyQxLmJ5RW5kWyBjaHVuay5uZXh0LmVuZCBdID0gY2h1bmsubmV4dDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBhYm9ydGVkICkgeyByZXR1cm4gdGhpcyQxOyB9XG5cdFx0XHRjaHVuayA9IGNodW5rLm5leHQ7XG5cdFx0fSB3aGlsZSAoIGNodW5rICk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxudmFyIGhhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBCdW5kbGUgKCBvcHRpb25zICkge1xuXHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHR0aGlzLmludHJvID0gb3B0aW9ucy5pbnRybyB8fCAnJztcblx0dGhpcy5zZXBhcmF0b3IgPSBvcHRpb25zLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zZXBhcmF0b3IgOiAnXFxuJztcblxuXHR0aGlzLnNvdXJjZXMgPSBbXTtcblxuXHR0aGlzLnVuaXF1ZVNvdXJjZXMgPSBbXTtcblx0dGhpcy51bmlxdWVTb3VyY2VJbmRleEJ5RmlsZW5hbWUgPSB7fTtcbn1cblxuQnVuZGxlLnByb3RvdHlwZSA9IHtcblx0YWRkU291cmNlOiBmdW5jdGlvbiBhZGRTb3VyY2UgKCBzb3VyY2UgKSB7XG5cdFx0aWYgKCBzb3VyY2UgaW5zdGFuY2VvZiBNYWdpY1N0cmluZyQxICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkU291cmNlKHtcblx0XHRcdFx0Y29udGVudDogc291cmNlLFxuXHRcdFx0XHRmaWxlbmFtZTogc291cmNlLmZpbGVuYW1lLFxuXHRcdFx0XHRzZXBhcmF0b3I6IHRoaXMuc2VwYXJhdG9yXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZiAoICFpc09iamVjdCggc291cmNlICkgfHwgIXNvdXJjZS5jb250ZW50ICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnYnVuZGxlLmFkZFNvdXJjZSgpIHRha2VzIGFuIG9iamVjdCB3aXRoIGEgYGNvbnRlbnRgIHByb3BlcnR5LCB3aGljaCBzaG91bGQgYmUgYW4gaW5zdGFuY2Ugb2YgTWFnaWNTdHJpbmcsIGFuZCBhbiBvcHRpb25hbCBgZmlsZW5hbWVgJyApO1xuXHRcdH1cblxuXHRcdFsgJ2ZpbGVuYW1lJywgJ2luZGVudEV4Y2x1c2lvblJhbmdlcycsICdzZXBhcmF0b3InIF0uZm9yRWFjaCggZnVuY3Rpb24gKG9wdGlvbikge1xuXHRcdFx0aWYgKCAhaGFzT3duUHJvcC5jYWxsKCBzb3VyY2UsIG9wdGlvbiApICkgeyBzb3VyY2VbIG9wdGlvbiBdID0gc291cmNlLmNvbnRlbnRbIG9wdGlvbiBdOyB9XG5cdFx0fSk7XG5cblx0XHRpZiAoIHNvdXJjZS5zZXBhcmF0b3IgPT09IHVuZGVmaW5lZCApIHsgLy8gVE9ETyB0aGVyZSdzIGEgYnVuY2ggb2YgdGhpcyBzb3J0IG9mIHRoaW5nLCBuZWVkcyBjbGVhbmluZyB1cFxuXHRcdFx0c291cmNlLnNlcGFyYXRvciA9IHRoaXMuc2VwYXJhdG9yO1xuXHRcdH1cblxuXHRcdGlmICggc291cmNlLmZpbGVuYW1lICkge1xuXHRcdFx0aWYgKCAhaGFzT3duUHJvcC5jYWxsKCB0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZSwgc291cmNlLmZpbGVuYW1lICkgKSB7XG5cdFx0XHRcdHRoaXMudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lWyBzb3VyY2UuZmlsZW5hbWUgXSA9IHRoaXMudW5pcXVlU291cmNlcy5sZW5ndGg7XG5cdFx0XHRcdHRoaXMudW5pcXVlU291cmNlcy5wdXNoKHsgZmlsZW5hbWU6IHNvdXJjZS5maWxlbmFtZSwgY29udGVudDogc291cmNlLmNvbnRlbnQub3JpZ2luYWwgfSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgdW5pcXVlU291cmNlID0gdGhpcy51bmlxdWVTb3VyY2VzWyB0aGlzLnVuaXF1ZVNvdXJjZUluZGV4QnlGaWxlbmFtZVsgc291cmNlLmZpbGVuYW1lIF0gXTtcblx0XHRcdFx0aWYgKCBzb3VyY2UuY29udGVudC5vcmlnaW5hbCAhPT0gdW5pcXVlU291cmNlLmNvbnRlbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAoXCJJbGxlZ2FsIHNvdXJjZTogc2FtZSBmaWxlbmFtZSAoXCIgKyAoc291cmNlLmZpbGVuYW1lKSArIFwiKSwgZGlmZmVyZW50IGNvbnRlbnRzXCIpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnNvdXJjZXMucHVzaCggc291cmNlICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbiBhcHBlbmQgKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0dGhpcy5hZGRTb3VyY2Uoe1xuXHRcdFx0Y29udGVudDogbmV3IE1hZ2ljU3RyaW5nJDEoIHN0ciApLFxuXHRcdFx0c2VwYXJhdG9yOiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5zZXBhcmF0b3IgKSB8fCAnJ1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uIGNsb25lICgpIHtcblx0XHR2YXIgYnVuZGxlID0gbmV3IEJ1bmRsZSh7XG5cdFx0XHRpbnRybzogdGhpcy5pbnRybyxcblx0XHRcdHNlcGFyYXRvcjogdGhpcy5zZXBhcmF0b3Jcblx0XHR9KTtcblxuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKCBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRidW5kbGUuYWRkU291cmNlKHtcblx0XHRcdFx0ZmlsZW5hbWU6IHNvdXJjZS5maWxlbmFtZSxcblx0XHRcdFx0Y29udGVudDogc291cmNlLmNvbnRlbnQuY2xvbmUoKSxcblx0XHRcdFx0c2VwYXJhdG9yOiBzb3VyY2Uuc2VwYXJhdG9yXG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBidW5kbGU7XG5cdH0sXG5cblx0Z2VuZXJhdGVNYXA6IGZ1bmN0aW9uIGdlbmVyYXRlTWFwICggb3B0aW9ucyApIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuXHRcdHZhciBuYW1lcyA9IFtdO1xuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKCBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRPYmplY3Qua2V5cyggc291cmNlLmNvbnRlbnQuc3RvcmVkTmFtZXMgKS5mb3JFYWNoKCBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRpZiAoICF+bmFtZXMuaW5kZXhPZiggbmFtZSApICkgeyBuYW1lcy5wdXNoKCBuYW1lICk7IH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dmFyIG1hcHBpbmdzID0gbmV3IE1hcHBpbmdzKCBvcHRpb25zLmhpcmVzICk7XG5cblx0XHRpZiAoIHRoaXMuaW50cm8gKSB7XG5cdFx0XHRtYXBwaW5ncy5hZHZhbmNlKCB0aGlzLmludHJvICk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zb3VyY2VzLmZvckVhY2goIGZ1bmN0aW9uICggc291cmNlLCBpICkge1xuXHRcdFx0aWYgKCBpID4gMCApIHtcblx0XHRcdFx0bWFwcGluZ3MuYWR2YW5jZSggdGhpcyQxLnNlcGFyYXRvciApO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc291cmNlSW5kZXggPSBzb3VyY2UuZmlsZW5hbWUgPyB0aGlzJDEudW5pcXVlU291cmNlSW5kZXhCeUZpbGVuYW1lWyBzb3VyY2UuZmlsZW5hbWUgXSA6IC0xO1xuXHRcdFx0dmFyIG1hZ2ljU3RyaW5nID0gc291cmNlLmNvbnRlbnQ7XG5cdFx0XHR2YXIgbG9jYXRlID0gZ2V0TG9jYXRvciQxKCBtYWdpY1N0cmluZy5vcmlnaW5hbCApO1xuXG5cdFx0XHRpZiAoIG1hZ2ljU3RyaW5nLmludHJvICkge1xuXHRcdFx0XHRtYXBwaW5ncy5hZHZhbmNlKCBtYWdpY1N0cmluZy5pbnRybyApO1xuXHRcdFx0fVxuXG5cdFx0XHRtYWdpY1N0cmluZy5maXJzdENodW5rLmVhY2hOZXh0KCBmdW5jdGlvbiAoY2h1bmspIHtcblx0XHRcdFx0dmFyIGxvYyA9IGxvY2F0ZSggY2h1bmsuc3RhcnQgKTtcblxuXHRcdFx0XHRpZiAoIGNodW5rLmludHJvLmxlbmd0aCApIHsgbWFwcGluZ3MuYWR2YW5jZSggY2h1bmsuaW50cm8gKTsgfVxuXG5cdFx0XHRcdGlmICggc291cmNlLmZpbGVuYW1lICkge1xuXHRcdFx0XHRcdGlmICggY2h1bmsuZWRpdGVkICkge1xuXHRcdFx0XHRcdFx0bWFwcGluZ3MuYWRkRWRpdCggc291cmNlSW5kZXgsIGNodW5rLmNvbnRlbnQsIGNodW5rLm9yaWdpbmFsLCBsb2MsIGNodW5rLnN0b3JlTmFtZSA/IG5hbWVzLmluZGV4T2YoIGNodW5rLm9yaWdpbmFsICkgOiAtMSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRtYXBwaW5ncy5hZGRVbmVkaXRlZENodW5rKCBzb3VyY2VJbmRleCwgY2h1bmssIG1hZ2ljU3RyaW5nLm9yaWdpbmFsLCBsb2MsIG1hZ2ljU3RyaW5nLnNvdXJjZW1hcExvY2F0aW9ucyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdG1hcHBpbmdzLmFkdmFuY2UoIGNodW5rLmNvbnRlbnQgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY2h1bmsub3V0cm8ubGVuZ3RoICkgeyBtYXBwaW5ncy5hZHZhbmNlKCBjaHVuay5vdXRybyApOyB9XG5cdFx0XHR9KTtcblxuXHRcdFx0aWYgKCBtYWdpY1N0cmluZy5vdXRybyApIHtcblx0XHRcdFx0bWFwcGluZ3MuYWR2YW5jZSggbWFnaWNTdHJpbmcub3V0cm8gKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBuZXcgU291cmNlTWFwKHtcblx0XHRcdGZpbGU6ICggb3B0aW9ucy5maWxlID8gb3B0aW9ucy5maWxlLnNwbGl0KCAvW1xcL1xcXFxdLyApLnBvcCgpIDogbnVsbCApLFxuXHRcdFx0c291cmNlczogdGhpcy51bmlxdWVTb3VyY2VzLm1hcCggZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucy5maWxlID8gZ2V0UmVsYXRpdmVQYXRoKCBvcHRpb25zLmZpbGUsIHNvdXJjZS5maWxlbmFtZSApIDogc291cmNlLmZpbGVuYW1lO1xuXHRcdFx0fSksXG5cdFx0XHRzb3VyY2VzQ29udGVudDogdGhpcy51bmlxdWVTb3VyY2VzLm1hcCggZnVuY3Rpb24gKHNvdXJjZSkge1xuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucy5pbmNsdWRlQ29udGVudCA/IHNvdXJjZS5jb250ZW50IDogbnVsbDtcblx0XHRcdH0pLFxuXHRcdFx0bmFtZXM6IG5hbWVzLFxuXHRcdFx0bWFwcGluZ3M6IG1hcHBpbmdzLmVuY29kZSgpXG5cdFx0fSk7XG5cdH0sXG5cblx0Z2V0SW5kZW50U3RyaW5nOiBmdW5jdGlvbiBnZXRJbmRlbnRTdHJpbmcgKCkge1xuXHRcdHZhciBpbmRlbnRTdHJpbmdDb3VudHMgPSB7fTtcblxuXHRcdHRoaXMuc291cmNlcy5mb3JFYWNoKCBmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHR2YXIgaW5kZW50U3RyID0gc291cmNlLmNvbnRlbnQuaW5kZW50U3RyO1xuXG5cdFx0XHRpZiAoIGluZGVudFN0ciA9PT0gbnVsbCApIHsgcmV0dXJuOyB9XG5cblx0XHRcdGlmICggIWluZGVudFN0cmluZ0NvdW50c1sgaW5kZW50U3RyIF0gKSB7IGluZGVudFN0cmluZ0NvdW50c1sgaW5kZW50U3RyIF0gPSAwOyB9XG5cdFx0XHRpbmRlbnRTdHJpbmdDb3VudHNbIGluZGVudFN0ciBdICs9IDE7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gKCBPYmplY3Qua2V5cyggaW5kZW50U3RyaW5nQ291bnRzICkuc29ydCggZnVuY3Rpb24gKCBhLCBiICkge1xuXHRcdFx0cmV0dXJuIGluZGVudFN0cmluZ0NvdW50c1thXSAtIGluZGVudFN0cmluZ0NvdW50c1tiXTtcblx0XHR9KVswXSApIHx8ICdcXHQnO1xuXHR9LFxuXG5cdGluZGVudDogZnVuY3Rpb24gaW5kZW50ICggaW5kZW50U3RyICkge1xuXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGluZGVudFN0ciA9IHRoaXMuZ2V0SW5kZW50U3RyaW5nKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpbmRlbnRTdHIgPT09ICcnICkgeyByZXR1cm4gdGhpczsgfSAvLyBub29wXG5cblx0XHR2YXIgdHJhaWxpbmdOZXdsaW5lID0gIXRoaXMuaW50cm8gfHwgdGhpcy5pbnRyby5zbGljZSggLTEgKSA9PT0gJ1xcbic7XG5cblx0XHR0aGlzLnNvdXJjZXMuZm9yRWFjaCggZnVuY3Rpb24gKCBzb3VyY2UsIGkgKSB7XG5cdFx0XHR2YXIgc2VwYXJhdG9yID0gc291cmNlLnNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gc291cmNlLnNlcGFyYXRvciA6IHRoaXMkMS5zZXBhcmF0b3I7XG5cdFx0XHR2YXIgaW5kZW50U3RhcnQgPSB0cmFpbGluZ05ld2xpbmUgfHwgKCBpID4gMCAmJiAvXFxyP1xcbiQvLnRlc3QoIHNlcGFyYXRvciApICk7XG5cblx0XHRcdHNvdXJjZS5jb250ZW50LmluZGVudCggaW5kZW50U3RyLCB7XG5cdFx0XHRcdGV4Y2x1ZGU6IHNvdXJjZS5pbmRlbnRFeGNsdXNpb25SYW5nZXMsXG5cdFx0XHRcdGluZGVudFN0YXJ0OiBpbmRlbnRTdGFydC8vOiB0cmFpbGluZ05ld2xpbmUgfHwgL1xccj9cXG4kLy50ZXN0KCBzZXBhcmF0b3IgKSAgLy90cnVlLy8vXFxyP1xcbi8udGVzdCggc2VwYXJhdG9yIClcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBUT0RPIHRoaXMgaXMgYSB2ZXJ5IHNsb3cgd2F5IHRvIGRldGVybWluZSB0aGlzXG5cdFx0XHR0cmFpbGluZ05ld2xpbmUgPSBzb3VyY2UuY29udGVudC50b1N0cmluZygpLnNsaWNlKCAwLCAtMSApID09PSAnXFxuJztcblx0XHR9KTtcblxuXHRcdGlmICggdGhpcy5pbnRybyApIHtcblx0XHRcdHRoaXMuaW50cm8gPSBpbmRlbnRTdHIgKyB0aGlzLmludHJvLnJlcGxhY2UoIC9eW15cXG5dL2dtLCBmdW5jdGlvbiAoIG1hdGNoLCBpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIGluZGV4ID4gMCA/IGluZGVudFN0ciArIG1hdGNoIDogbWF0Y2g7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRwcmVwZW5kOiBmdW5jdGlvbiBwcmVwZW5kICggc3RyICkge1xuXHRcdHRoaXMuaW50cm8gPSBzdHIgKyB0aGlzLmludHJvO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG5cdFx0dmFyIHRoaXMkMSA9IHRoaXM7XG5cblx0XHR2YXIgYm9keSA9IHRoaXMuc291cmNlcy5tYXAoIGZ1bmN0aW9uICggc291cmNlLCBpICkge1xuXHRcdFx0dmFyIHNlcGFyYXRvciA9IHNvdXJjZS5zZXBhcmF0b3IgIT09IHVuZGVmaW5lZCA/IHNvdXJjZS5zZXBhcmF0b3IgOiB0aGlzJDEuc2VwYXJhdG9yO1xuXHRcdFx0dmFyIHN0ciA9ICggaSA+IDAgPyBzZXBhcmF0b3IgOiAnJyApICsgc291cmNlLmNvbnRlbnQudG9TdHJpbmcoKTtcblxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9KS5qb2luKCAnJyApO1xuXG5cdFx0cmV0dXJuIHRoaXMuaW50cm8gKyBib2R5O1xuXHR9LFxuXG5cdHRyaW1MaW5lczogZnVuY3Rpb24gdHJpbUxpbmVzICgpIHtcblx0XHRyZXR1cm4gdGhpcy50cmltKCdbXFxcXHJcXFxcbl0nKTtcblx0fSxcblxuXHR0cmltOiBmdW5jdGlvbiB0cmltICggY2hhclR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJpbVN0YXJ0KCBjaGFyVHlwZSApLnRyaW1FbmQoIGNoYXJUeXBlICk7XG5cdH0sXG5cblx0dHJpbVN0YXJ0OiBmdW5jdGlvbiB0cmltU3RhcnQgKCBjaGFyVHlwZSApIHtcblx0XHR2YXIgdGhpcyQxID0gdGhpcztcblxuXHRcdHZhciByeCA9IG5ldyBSZWdFeHAoICdeJyArICggY2hhclR5cGUgfHwgJ1xcXFxzJyApICsgJysnICk7XG5cdFx0dGhpcy5pbnRybyA9IHRoaXMuaW50cm8ucmVwbGFjZSggcngsICcnICk7XG5cblx0XHRpZiAoICF0aGlzLmludHJvICkge1xuXHRcdFx0dmFyIHNvdXJjZTtcblx0XHRcdHZhciBpID0gMDtcblxuXHRcdFx0ZG8ge1xuXHRcdFx0XHRzb3VyY2UgPSB0aGlzJDEuc291cmNlc1tpXTtcblxuXHRcdFx0XHRpZiAoICFzb3VyY2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzb3VyY2UuY29udGVudC50cmltU3RhcnQoIGNoYXJUeXBlICk7XG5cdFx0XHRcdGkgKz0gMTtcblx0XHRcdH0gd2hpbGUgKCBzb3VyY2UuY29udGVudC50b1N0cmluZygpID09PSAnJyApOyAvLyBUT0RPIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIG5vbi1lbXB0eSBzb3VyY2U/XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dHJpbUVuZDogZnVuY3Rpb24gdHJpbUVuZCAoIGNoYXJUeXBlICkge1xuXHRcdHZhciB0aGlzJDEgPSB0aGlzO1xuXG5cdFx0dmFyIHJ4ID0gbmV3IFJlZ0V4cCggKCBjaGFyVHlwZSB8fCAnXFxcXHMnICkgKyAnKyQnICk7XG5cblx0XHR2YXIgc291cmNlO1xuXHRcdHZhciBpID0gdGhpcy5zb3VyY2VzLmxlbmd0aCAtIDE7XG5cblx0XHRkbyB7XG5cdFx0XHRzb3VyY2UgPSB0aGlzJDEuc291cmNlc1tpXTtcblxuXHRcdFx0aWYgKCAhc291cmNlICkge1xuXHRcdFx0XHR0aGlzJDEuaW50cm8gPSB0aGlzJDEuaW50cm8ucmVwbGFjZSggcngsICcnICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRzb3VyY2UuY29udGVudC50cmltRW5kKCBjaGFyVHlwZSApO1xuXHRcdFx0aSAtPSAxO1xuXHRcdH0gd2hpbGUgKCBzb3VyY2UuY29udGVudC50b1N0cmluZygpID09PSAnJyApOyAvLyBUT0RPIGZhc3RlciB3YXkgdG8gZGV0ZXJtaW5lIG5vbi1lbXB0eSBzb3VyY2U/XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufTtcblxuZnVuY3Rpb24gYW5ub3RhdGVXaXRoU2NvcGVzKGV4cHJlc3Npb24pIHtcbiAgICB2YXIgc2NvcGUgPSBuZXcgU2NvcGUobnVsbCwgZmFsc2UpO1xuICAgIHdhbGsoZXhwcmVzc2lvbiwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICgvRnVuY3Rpb24vLnRlc3Qobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdGdW5jdGlvbkRlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBzY29wZS5kZWNsYXJhdGlvbnMuYWRkKG5vZGUuaWQubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9zY29wZSA9IHNjb3BlID0gbmV3IFNjb3BlKHNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUuZGVjbGFyYXRpb25zLmFkZChub2RlLmlkLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnBhcmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYWN0TmFtZXMocGFyYW0pLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLmRlY2xhcmF0aW9ucy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL0Zvcig/OklufE9mKVN0YXRlbWVudC8udGVzdChub2RlLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5fc2NvcGUgPSBzY29wZSA9IG5ldyBTY29wZShzY29wZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdCbG9ja1N0YXRlbWVudCcpIHtcbiAgICAgICAgICAgICAgICBub2RlLl9zY29wZSA9IHNjb3BlID0gbmV3IFNjb3BlKHNjb3BlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC8oRnVuY3Rpb258Q2xhc3N8VmFyaWFibGUpRGVjbGFyYXRpb24vLnRlc3Qobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgIHNjb3BlLmFkZERlY2xhcmF0aW9uKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLl9zY29wZSkge1xuICAgICAgICAgICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNjb3BlO1xufVxudmFyIFNjb3BlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNjb3BlKHBhcmVudCwgYmxvY2spIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9jaztcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIFNjb3BlLnByb3RvdHlwZS5hZGREZWNsYXJhdGlvbiA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChub2RlLmtpbmQgPT09ICd2YXInICYmICF0aGlzLmJsb2NrICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5hZGREZWNsYXJhdGlvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnR5cGUgPT09ICdWYXJpYWJsZURlY2xhcmF0aW9uJykge1xuICAgICAgICAgICAgbm9kZS5kZWNsYXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVjbGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGV4dHJhY3ROYW1lcyhkZWNsYXJhdG9yLmlkKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRlY2xhcmF0aW9ucy5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyYXRpb25zLmFkZChub2RlLmlkLm5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTY29wZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmRlY2xhcmF0aW9ucy5oYXMobmFtZSkgfHwgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmhhcyhuYW1lKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFNjb3BlO1xufSgpKTtcbmZ1bmN0aW9uIGV4dHJhY3ROYW1lcyhwYXJhbSkge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGV4dHJhY3RvcnNbcGFyYW0udHlwZV0obmFtZXMsIHBhcmFtKTtcbiAgICByZXR1cm4gbmFtZXM7XG59XG52YXIgZXh0cmFjdG9ycyA9IHtcbiAgICBJZGVudGlmaWVyOiBmdW5jdGlvbiAobmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIG5hbWVzLnB1c2gocGFyYW0ubmFtZSk7XG4gICAgfSxcbiAgICBPYmplY3RQYXR0ZXJuOiBmdW5jdGlvbiAobmFtZXMsIHBhcmFtKSB7XG4gICAgICAgIHBhcmFtLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgZXh0cmFjdG9yc1twcm9wLnZhbHVlLnR5cGVdKG5hbWVzLCBwcm9wLnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBBcnJheVBhdHRlcm46IGZ1bmN0aW9uIChuYW1lcywgcGFyYW0pIHtcbiAgICAgICAgcGFyYW0uZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgZXh0cmFjdG9yc1tlbGVtZW50LnR5cGVdKG5hbWVzLCBlbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBSZXN0RWxlbWVudDogZnVuY3Rpb24gKG5hbWVzLCBwYXJhbSkge1xuICAgICAgICBleHRyYWN0b3JzW3BhcmFtLmFyZ3VtZW50LnR5cGVdKG5hbWVzLCBwYXJhbS5hcmd1bWVudCk7XG4gICAgfSxcbiAgICBBc3NpZ25tZW50UGF0dGVybjogZnVuY3Rpb24gKG5hbWVzLCBwYXJhbSkge1xuICAgICAgICBleHRyYWN0b3JzW3BhcmFtLmxlZnQudHlwZV0obmFtZXMsIHBhcmFtLmxlZnQpO1xuICAgIH1cbn07XG5cbnZhciBzdGFydCA9IC9cXG4oXFx0KykvO1xuZnVuY3Rpb24gZGVpbmRlbnQoc3RyaW5ncykge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBpbmRlbnRhdGlvbiA9IHN0YXJ0LmV4ZWMoc3RyaW5nc1swXSlbMV07XG4gICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKFwiXlwiICsgaW5kZW50YXRpb24sICdnbScpO1xuICAgIHZhciByZXN1bHQgPSBzdHJpbmdzWzBdLnJlcGxhY2Uoc3RhcnQsICcnKS5yZXBsYWNlKHBhdHRlcm4sICcnKTtcbiAgICB2YXIgdHJhaWxpbmdJbmRlbnRhdGlvbiA9IGdldFRyYWlsaW5nSW5kZW50YXRpb24ocmVzdWx0KTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB2YWx1ZXNbaSAtIDFdO1xuICAgICAgICB2YXIgc3RyaW5nID0gc3RyaW5nc1tpXS5yZXBsYWNlKHBhdHRlcm4sICcnKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXhwcmVzc2lvbikpIHtcbiAgICAgICAgICAgIGV4cHJlc3Npb24gPSBleHByZXNzaW9uLmxlbmd0aCA/IGV4cHJlc3Npb24uam9pbignXFxuJykgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHByZXNzaW9uIHx8IGV4cHJlc3Npb24gPT09ICcnKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBTdHJpbmcoZXhwcmVzc2lvbikucmVwbGFjZSgvXFxuL2csIFwiXFxuXCIgKyB0cmFpbGluZ0luZGVudGF0aW9uKTtcbiAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZSArIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjID0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgvXFxzLy50ZXN0KHJlc3VsdFtjIC0gMV0pKVxuICAgICAgICAgICAgICAgIGMgLT0gMTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCBjKSArIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICB0cmFpbGluZ0luZGVudGF0aW9uID0gZ2V0VHJhaWxpbmdJbmRlbnRhdGlvbihyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnRyaW0oKS5yZXBsYWNlKC9cXHQrJC9nbSwgJycpO1xufVxuZnVuY3Rpb24gZ2V0VHJhaWxpbmdJbmRlbnRhdGlvbihzdHIpIHtcbiAgICB2YXIgaSA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKHN0cltpIC0gMV0gPT09ICcgJyB8fCBzdHJbaSAtIDFdID09PSAnXFx0JylcbiAgICAgICAgaSAtPSAxO1xuICAgIHJldHVybiBzdHIuc2xpY2UoaSwgc3RyLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeShkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZXNjYXBlKGRhdGEsIG9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIGVzY2FwZShkYXRhLCBfYSkge1xuICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkub25seUVzY2FwZUF0U3ltYm9sLCBvbmx5RXNjYXBlQXRTeW1ib2wgPSBfYiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYjtcbiAgICByZXR1cm4gZGF0YS5yZXBsYWNlKG9ubHlFc2NhcGVBdFN5bWJvbCA/IC8oJSt8QCspL2cgOiAvKCUrfEArfCMrKS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoICsgbWF0Y2hbMF07XG4gICAgfSk7XG59XG5cbnZhciBDaHVua1R5cGU7XG4oZnVuY3Rpb24gKENodW5rVHlwZSkge1xuICAgIENodW5rVHlwZVtDaHVua1R5cGVbXCJMaW5lXCJdID0gMF0gPSBcIkxpbmVcIjtcbiAgICBDaHVua1R5cGVbQ2h1bmtUeXBlW1wiQmxvY2tcIl0gPSAxXSA9IFwiQmxvY2tcIjtcbn0pKENodW5rVHlwZSB8fCAoQ2h1bmtUeXBlID0ge30pKTtcbnZhciBDb2RlQnVpbGRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb2RlQnVpbGRlcihzdHIpIHtcbiAgICAgICAgaWYgKHN0ciA9PT0gdm9pZCAwKSB7IHN0ciA9ICcnOyB9XG4gICAgICAgIHRoaXMucmVzdWx0ID0gc3RyO1xuICAgICAgICB2YXIgaW5pdGlhbCA9IHN0clxuICAgICAgICAgICAgPyAvXFxuLy50ZXN0KHN0cikgPyBDaHVua1R5cGUuQmxvY2sgOiBDaHVua1R5cGUuTGluZVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB0aGlzLmZpcnN0ID0gaW5pdGlhbDtcbiAgICAgICAgdGhpcy5sYXN0ID0gaW5pdGlhbDtcbiAgICAgICAgdGhpcy5sYXN0Q29uZGl0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmluZGVudCA9ICcnO1xuICAgIH1cbiAgICBDb2RlQnVpbGRlci5wcm90b3R5cGUuYWRkQ29uZGl0aW9uYWwgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBib2R5KSB7XG4gICAgICAgIHRoaXMucmVpZnlDb25kaXRpb25zKCk7XG4gICAgICAgIGJvZHkgPSBib2R5LnJlcGxhY2UoL14vZ20sIHRoaXMuaW5kZW50ICsgXCJcXHRcIik7XG4gICAgICAgIGlmIChjb25kaXRpb24gPT09IHRoaXMubGFzdENvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gXCJcXG5cIiArIGJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0Q29uZGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gXCJcXG5cIiArIHRoaXMuaW5kZW50ICsgXCJ9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBcIlwiICsgKHRoaXMubGFzdCA9PT0gQ2h1bmtUeXBlLkJsb2NrID8gJ1xcblxcbicgOiAnXFxuJykgKyB0aGlzLmluZGVudCArIFwiaWYgKFwiICsgY29uZGl0aW9uICsgXCIpIHtcXG5cIiArIGJvZHk7XG4gICAgICAgICAgICB0aGlzLmxhc3RDb25kaXRpb24gPSBjb25kaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0ID0gQ2h1bmtUeXBlLkJsb2NrO1xuICAgIH07XG4gICAgQ29kZUJ1aWxkZXIucHJvdG90eXBlLmFkZExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB0aGlzLnJlaWZ5Q29uZGl0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5sYXN0Q29uZGl0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBcIlxcblwiICsgdGhpcy5pbmRlbnQgKyBcIn1cIjtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbmRpdGlvbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGFzdCA9PT0gQ2h1bmtUeXBlLkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBcIlxcblxcblwiICsgdGhpcy5pbmRlbnQgKyBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGFzdCA9PT0gQ2h1bmtUeXBlLkxpbmUpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IFwiXFxuXCIgKyB0aGlzLmluZGVudCArIGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdCA9IENodW5rVHlwZS5MaW5lO1xuICAgICAgICBpZiAoIXRoaXMuZmlyc3QpXG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gQ2h1bmtUeXBlLkxpbmU7XG4gICAgfTtcbiAgICBDb2RlQnVpbGRlci5wcm90b3R5cGUuYWRkTGluZUF0U3RhcnQgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB0aGlzLnJlaWZ5Q29uZGl0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5maXJzdCA9PT0gQ2h1bmtUeXBlLkJsb2NrKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IGxpbmUgKyBcIlxcblxcblwiICsgdGhpcy5pbmRlbnQgKyB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmZpcnN0ID09PSBDaHVua1R5cGUuTGluZSkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBsaW5lICsgXCJcXG5cIiArIHRoaXMuaW5kZW50ICsgdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyc3QgPSBDaHVua1R5cGUuTGluZTtcbiAgICAgICAgaWYgKCF0aGlzLmxhc3QpXG4gICAgICAgICAgICB0aGlzLmxhc3QgPSBDaHVua1R5cGUuTGluZTtcbiAgICB9O1xuICAgIENvZGVCdWlsZGVyLnByb3RvdHlwZS5hZGRCbG9jayA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB0aGlzLnJlaWZ5Q29uZGl0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5pbmRlbnQpXG4gICAgICAgICAgICBibG9jayA9IGJsb2NrLnJlcGxhY2UoL14vZ20sIFwiXCIgKyB0aGlzLmluZGVudCk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RDb25kaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IFwiXFxuXCIgKyB0aGlzLmluZGVudCArIFwifVwiO1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29uZGl0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IFwiXFxuXFxuXCIgKyB0aGlzLmluZGVudCArIGJsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gYmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0ID0gQ2h1bmtUeXBlLkJsb2NrO1xuICAgICAgICBpZiAoIXRoaXMuZmlyc3QpXG4gICAgICAgICAgICB0aGlzLmZpcnN0ID0gQ2h1bmtUeXBlLkJsb2NrO1xuICAgIH07XG4gICAgQ29kZUJ1aWxkZXIucHJvdG90eXBlLmFkZEJsb2NrQXRTdGFydCA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB0aGlzLnJlaWZ5Q29uZGl0aW9ucygpO1xuICAgICAgICBpZiAodGhpcy5yZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ID0gYmxvY2sgKyBcIlxcblxcblwiICsgdGhpcy5pbmRlbnQgKyB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0ICs9IGJsb2NrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlyc3QgPSBDaHVua1R5cGUuQmxvY2s7XG4gICAgICAgIGlmICghdGhpcy5sYXN0KVxuICAgICAgICAgICAgdGhpcy5sYXN0ID0gQ2h1bmtUeXBlLkJsb2NrO1xuICAgIH07XG4gICAgQ29kZUJ1aWxkZXIucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdCA9PT0gJyc7XG4gICAgfTtcbiAgICBDb2RlQnVpbGRlci5wcm90b3R5cGUucHVzaENvbmRpdGlvbiA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKHsgY29uZGl0aW9uOiBjb25kaXRpb24sIHVzZWQ6IGZhbHNlIH0pO1xuICAgIH07XG4gICAgQ29kZUJ1aWxkZXIucHJvdG90eXBlLnBvcENvbmRpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVzZWQgPSB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpLnVzZWQ7XG4gICAgICAgIHRoaXMuaW5kZW50ID0gcmVwZWF0KCdcXHQnLCB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCk7XG4gICAgICAgIGlmICh1c2VkKVxuICAgICAgICAgICAgdGhpcy5hZGRMaW5lKCd9Jyk7XG4gICAgfTtcbiAgICBDb2RlQnVpbGRlci5wcm90b3R5cGUucmVpZnlDb25kaXRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSB0aGlzLmNvbmRpdGlvblN0YWNrW2ldO1xuICAgICAgICAgICAgaWYgKCFjb25kaXRpb24udXNlZCkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gXCJpZiAoXCIgKyBjb25kaXRpb24uY29uZGl0aW9uICsgXCIpIHtcIjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXN0ID09PSBDaHVua1R5cGUuQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gXCJcXG5cXG5cIiArIHRoaXMuaW5kZW50ICsgbGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sYXN0ID09PSBDaHVua1R5cGUuTGluZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCArPSBcIlxcblwiICsgdGhpcy5pbmRlbnQgKyBsaW5lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgKz0gbGluZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ID0gQ2h1bmtUeXBlLkxpbmU7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmZpcnN0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0ID0gQ2h1bmtUeXBlLkxpbmU7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRlbnQgPSByZXBlYXQoJ1xcdCcsIHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25kaXRpb24udXNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvZGVCdWlsZGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0LnRyaW0oKSArICh0aGlzLmxhc3RDb25kaXRpb24gPyBcIlxcbn1cIiA6IFwiXCIpO1xuICAgIH07XG4gICAgcmV0dXJuIENvZGVCdWlsZGVyO1xufSgpKTtcblxudmFyIGdsb2JhbFdoaXRlbGlzdCA9IG5ldyBTZXQoW1xuICAgICdBcnJheScsXG4gICAgJ0Jvb2xlYW4nLFxuICAgICdjb25zb2xlJyxcbiAgICAnRGF0ZScsXG4gICAgJ2RlY29kZVVSSScsXG4gICAgJ2RlY29kZVVSSUNvbXBvbmVudCcsXG4gICAgJ2VuY29kZVVSSScsXG4gICAgJ2VuY29kZVVSSUNvbXBvbmVudCcsXG4gICAgJ0luZmluaXR5JyxcbiAgICAnSW50bCcsXG4gICAgJ2lzRmluaXRlJyxcbiAgICAnaXNOYU4nLFxuICAgICdKU09OJyxcbiAgICAnTWFwJyxcbiAgICAnTWF0aCcsXG4gICAgJ05hTicsXG4gICAgJ051bWJlcicsXG4gICAgJ09iamVjdCcsXG4gICAgJ3BhcnNlRmxvYXQnLFxuICAgICdwYXJzZUludCcsXG4gICAgJ1JlZ0V4cCcsXG4gICAgJ1NldCcsXG4gICAgJ1N0cmluZycsXG4gICAgJ3VuZGVmaW5lZCcsXG5dKTtcblxuLy8gdGhpcyBmaWxlIGlzIGF1dG8tZ2VuZXJhdGVkLCBkbyBub3QgZWRpdCBpdFxudmFyIHNoYXJlZCA9IHtcbiAgICBcImFwcGVuZE5vZGVcIjogXCJmdW5jdGlvbiBhcHBlbmROb2RlKG5vZGUsIHRhcmdldCkge1xcblxcdHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcXG59XCIsXG4gICAgXCJpbnNlcnROb2RlXCI6IFwiZnVuY3Rpb24gaW5zZXJ0Tm9kZShub2RlLCB0YXJnZXQsIGFuY2hvcikge1xcblxcdHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yKTtcXG59XCIsXG4gICAgXCJkZXRhY2hOb2RlXCI6IFwiZnVuY3Rpb24gZGV0YWNoTm9kZShub2RlKSB7XFxuXFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xcbn1cIixcbiAgICBcImRldGFjaEJldHdlZW5cIjogXCJmdW5jdGlvbiBkZXRhY2hCZXR3ZWVuKGJlZm9yZSwgYWZ0ZXIpIHtcXG5cXHR3aGlsZSAoYmVmb3JlLm5leHRTaWJsaW5nICYmIGJlZm9yZS5uZXh0U2libGluZyAhPT0gYWZ0ZXIpIHtcXG5cXHRcXHRiZWZvcmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiZWZvcmUubmV4dFNpYmxpbmcpO1xcblxcdH1cXG59XCIsXG4gICAgXCJkZXRhY2hCZWZvcmVcIjogXCJmdW5jdGlvbiBkZXRhY2hCZWZvcmUoYWZ0ZXIpIHtcXG5cXHR3aGlsZSAoYWZ0ZXIucHJldmlvdXNTaWJsaW5nKSB7XFxuXFx0XFx0YWZ0ZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xcblxcdH1cXG59XCIsXG4gICAgXCJkZXRhY2hBZnRlclwiOiBcImZ1bmN0aW9uIGRldGFjaEFmdGVyKGJlZm9yZSkge1xcblxcdHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHtcXG5cXHRcXHRiZWZvcmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiZWZvcmUubmV4dFNpYmxpbmcpO1xcblxcdH1cXG59XCIsXG4gICAgXCJyZWluc2VydEJldHdlZW5cIjogXCJmdW5jdGlvbiByZWluc2VydEJldHdlZW4oYmVmb3JlLCBhZnRlciwgdGFyZ2V0KSB7XFxuXFx0d2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XFxuXFx0XFx0dGFyZ2V0LmFwcGVuZENoaWxkKGJlZm9yZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJlZm9yZS5uZXh0U2libGluZykpO1xcblxcdH1cXG59XCIsXG4gICAgXCJyZWluc2VydENoaWxkcmVuXCI6IFwiZnVuY3Rpb24gcmVpbnNlcnRDaGlsZHJlbihwYXJlbnQsIHRhcmdldCkge1xcblxcdHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCkgdGFyZ2V0LmFwcGVuZENoaWxkKHBhcmVudC5maXJzdENoaWxkKTtcXG59XCIsXG4gICAgXCJyZWluc2VydEFmdGVyXCI6IFwiZnVuY3Rpb24gcmVpbnNlcnRBZnRlcihiZWZvcmUsIHRhcmdldCkge1xcblxcdHdoaWxlIChiZWZvcmUubmV4dFNpYmxpbmcpIHRhcmdldC5hcHBlbmRDaGlsZChiZWZvcmUubmV4dFNpYmxpbmcpO1xcbn1cIixcbiAgICBcInJlaW5zZXJ0QmVmb3JlXCI6IFwiZnVuY3Rpb24gcmVpbnNlcnRCZWZvcmUoYWZ0ZXIsIHRhcmdldCkge1xcblxcdHZhciBwYXJlbnQgPSBhZnRlci5wYXJlbnROb2RlO1xcblxcdHdoaWxlIChwYXJlbnQuZmlyc3RDaGlsZCAhPT0gYWZ0ZXIpIHRhcmdldC5hcHBlbmRDaGlsZChwYXJlbnQuZmlyc3RDaGlsZCk7XFxufVwiLFxuICAgIFwiZGVzdHJveUVhY2hcIjogXCJmdW5jdGlvbiBkZXN0cm95RWFjaChpdGVyYXRpb25zKSB7XFxuXFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYXRpb25zLmxlbmd0aDsgaSArPSAxKSB7XFxuXFx0XFx0aWYgKGl0ZXJhdGlvbnNbaV0pIGl0ZXJhdGlvbnNbaV0uZCgpO1xcblxcdH1cXG59XCIsXG4gICAgXCJjcmVhdGVGcmFnbWVudFwiOiBcImZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50KCkge1xcblxcdHJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XFxufVwiLFxuICAgIFwiY3JlYXRlRWxlbWVudFwiOiBcImZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobmFtZSkge1xcblxcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xcbn1cIixcbiAgICBcImNyZWF0ZVN2Z0VsZW1lbnRcIjogXCJmdW5jdGlvbiBjcmVhdGVTdmdFbGVtZW50KG5hbWUpIHtcXG5cXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xcbn1cIixcbiAgICBcImNyZWF0ZVRleHRcIjogXCJmdW5jdGlvbiBjcmVhdGVUZXh0KGRhdGEpIHtcXG5cXHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSk7XFxufVwiLFxuICAgIFwiY3JlYXRlQ29tbWVudFwiOiBcImZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQoKSB7XFxuXFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJycpO1xcbn1cIixcbiAgICBcImFkZExpc3RlbmVyXCI6IFwiZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgZXZlbnQsIGhhbmRsZXIpIHtcXG5cXHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIsIGZhbHNlKTtcXG59XCIsXG4gICAgXCJyZW1vdmVMaXN0ZW5lclwiOiBcImZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKG5vZGUsIGV2ZW50LCBoYW5kbGVyKSB7XFxuXFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XFxufVwiLFxuICAgIFwic2V0QXR0cmlidXRlXCI6IFwiZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcXG5cXHRub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcXG59XCIsXG4gICAgXCJzZXRYbGlua0F0dHJpYnV0ZVwiOiBcImZ1bmN0aW9uIHNldFhsaW5rQXR0cmlidXRlKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcXG5cXHRub2RlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgYXR0cmlidXRlLCB2YWx1ZSk7XFxufVwiLFxuICAgIFwiZ2V0QmluZGluZ0dyb3VwVmFsdWVcIjogXCJmdW5jdGlvbiBnZXRCaW5kaW5nR3JvdXBWYWx1ZShncm91cCkge1xcblxcdHZhciB2YWx1ZSA9IFtdO1xcblxcdGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHRcXHRpZiAoZ3JvdXBbaV0uY2hlY2tlZCkgdmFsdWUucHVzaChncm91cFtpXS5fX3ZhbHVlKTtcXG5cXHR9XFxuXFx0cmV0dXJuIHZhbHVlO1xcbn1cIixcbiAgICBcInRvTnVtYmVyXCI6IFwiZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcXG5cXHRyZXR1cm4gdmFsdWUgPT09ICcnID8gdW5kZWZpbmVkIDogK3ZhbHVlO1xcbn1cIixcbiAgICBcInRpbWVSYW5nZXNUb0FycmF5XCI6IFwiZnVuY3Rpb24gdGltZVJhbmdlc1RvQXJyYXkocmFuZ2VzKSB7XFxuXFx0dmFyIGFycmF5ID0gW107XFxuXFx0Zm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHRcXHRhcnJheS5wdXNoKHsgc3RhcnQ6IHJhbmdlcy5zdGFydChpKSwgZW5kOiByYW5nZXMuZW5kKGkpIH0pO1xcblxcdH1cXG5cXHRyZXR1cm4gYXJyYXk7XFxufVwiLFxuICAgIFwiY2hpbGRyZW5cIjogXCJmdW5jdGlvbiBjaGlsZHJlbiAoZWxlbWVudCkge1xcblxcdHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XFxufVwiLFxuICAgIFwiY2xhaW1FbGVtZW50XCI6IFwiZnVuY3Rpb24gY2xhaW1FbGVtZW50IChub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnKSB7XFxuXFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xcblxcdFxcdHZhciBub2RlID0gbm9kZXNbaV07XFxuXFx0XFx0aWYgKG5vZGUubm9kZU5hbWUgPT09IG5hbWUpIHtcXG5cXHRcXHRcXHRmb3IgKHZhciBqID0gMDsgaiA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGogKz0gMSkge1xcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XFxuXFx0XFx0XFx0XFx0aWYgKCFhdHRyaWJ1dGVzW2F0dHJpYnV0ZS5uYW1lXSkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gbm9kZXMuc3BsaWNlKGksIDEpWzBdOyAvLyBUT0RPIHN0cmlwIHVud2FudGVkIGF0dHJpYnV0ZXNcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdHJldHVybiBzdmcgPyBjcmVhdGVTdmdFbGVtZW50KG5hbWUpIDogY3JlYXRlRWxlbWVudChuYW1lKTtcXG59XCIsXG4gICAgXCJjbGFpbVRleHRcIjogXCJmdW5jdGlvbiBjbGFpbVRleHQgKG5vZGVzLCBkYXRhKSB7XFxuXFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xcblxcdFxcdHZhciBub2RlID0gbm9kZXNbaV07XFxuXFx0XFx0aWYgKG5vZGUubm9kZVR5cGUgPT09IDMpIHtcXG5cXHRcXHRcXHRub2RlLmRhdGEgPSBkYXRhO1xcblxcdFxcdFxcdHJldHVybiBub2Rlcy5zcGxpY2UoaSwgMSlbMF07XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRyZXR1cm4gY3JlYXRlVGV4dChkYXRhKTtcXG59XCIsXG4gICAgXCJzZXRJbnB1dFR5cGVcIjogXCJmdW5jdGlvbiBzZXRJbnB1dFR5cGUoaW5wdXQsIHR5cGUpIHtcXG5cXHR0cnkge1xcblxcdFxcdGlucHV0LnR5cGUgPSB0eXBlO1xcblxcdH0gY2F0Y2ggKGUpIHt9XFxufVwiLFxuICAgIFwic2V0U3R5bGVcIjogXCJmdW5jdGlvbiBzZXRTdHlsZShub2RlLCBrZXksIHZhbHVlKSB7XFxuXFx0bm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcXG59XCIsXG4gICAgXCJzZWxlY3RPcHRpb25cIjogXCJmdW5jdGlvbiBzZWxlY3RPcHRpb24oc2VsZWN0LCB2YWx1ZSkge1xcblxcdGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHRcXHR2YXIgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XFxuXFxuXFx0XFx0aWYgKG9wdGlvbi5fX3ZhbHVlID09PSB2YWx1ZSkge1xcblxcdFxcdFxcdG9wdGlvbi5zZWxlY3RlZCA9IHRydWU7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXHR9XFxufVwiLFxuICAgIFwic2VsZWN0T3B0aW9uc1wiOiBcImZ1bmN0aW9uIHNlbGVjdE9wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xcblxcdGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcXG5cXHRcXHR2YXIgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XFxuXFx0XFx0b3B0aW9uLnNlbGVjdGVkID0gfnZhbHVlLmluZGV4T2Yob3B0aW9uLl9fdmFsdWUpO1xcblxcdH1cXG59XCIsXG4gICAgXCJzZWxlY3RWYWx1ZVwiOiBcImZ1bmN0aW9uIHNlbGVjdFZhbHVlKHNlbGVjdCkge1xcblxcdHZhciBzZWxlY3RlZE9wdGlvbiA9IHNlbGVjdC5xdWVyeVNlbGVjdG9yKCc6Y2hlY2tlZCcpIHx8IHNlbGVjdC5vcHRpb25zWzBdO1xcblxcdHJldHVybiBzZWxlY3RlZE9wdGlvbiAmJiBzZWxlY3RlZE9wdGlvbi5fX3ZhbHVlO1xcbn1cIixcbiAgICBcInNlbGVjdE11bHRpcGxlVmFsdWVcIjogXCJmdW5jdGlvbiBzZWxlY3RNdWx0aXBsZVZhbHVlKHNlbGVjdCkge1xcblxcdHJldHVybiBbXS5tYXAuY2FsbChzZWxlY3QucXVlcnlTZWxlY3RvckFsbCgnOmNoZWNrZWQnKSwgZnVuY3Rpb24ob3B0aW9uKSB7XFxuXFx0XFx0cmV0dXJuIG9wdGlvbi5fX3ZhbHVlO1xcblxcdH0pO1xcbn1cIixcbiAgICBcImJsYW5rT2JqZWN0XCI6IFwiZnVuY3Rpb24gYmxhbmtPYmplY3QoKSB7XFxuXFx0cmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XFxufVwiLFxuICAgIFwiZGVzdHJveVwiOiBcImZ1bmN0aW9uIGRlc3Ryb3koZGV0YWNoKSB7XFxuXFx0dGhpcy5kZXN0cm95ID0gbm9vcDtcXG5cXHR0aGlzLmZpcmUoJ2Rlc3Ryb3knKTtcXG5cXHR0aGlzLnNldCA9IHRoaXMuZ2V0ID0gbm9vcDtcXG5cXG5cXHRpZiAoZGV0YWNoICE9PSBmYWxzZSkgdGhpcy5fZnJhZ21lbnQudSgpO1xcblxcdHRoaXMuX2ZyYWdtZW50LmQoKTtcXG5cXHR0aGlzLl9mcmFnbWVudCA9IHRoaXMuX3N0YXRlID0gbnVsbDtcXG59XCIsXG4gICAgXCJkZXN0cm95RGV2XCI6IFwiZnVuY3Rpb24gZGVzdHJveURldihkZXRhY2gpIHtcXG5cXHRkZXN0cm95LmNhbGwodGhpcywgZGV0YWNoKTtcXG5cXHR0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTtcXG5cXHR9O1xcbn1cIixcbiAgICBcImRpZmZlcnNcIjogXCJmdW5jdGlvbiBkaWZmZXJzKGEsIGIpIHtcXG5cXHRyZXR1cm4gYSAhPT0gYiB8fCAoKGEgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnKSB8fCB0eXBlb2YgYSA9PT0gJ2Z1bmN0aW9uJyk7XFxufVwiLFxuICAgIFwiZGlzcGF0Y2hPYnNlcnZlcnNcIjogXCJmdW5jdGlvbiBkaXNwYXRjaE9ic2VydmVycyhjb21wb25lbnQsIGdyb3VwLCBjaGFuZ2VkLCBuZXdTdGF0ZSwgb2xkU3RhdGUpIHtcXG5cXHRmb3IgKHZhciBrZXkgaW4gZ3JvdXApIHtcXG5cXHRcXHRpZiAoIWNoYW5nZWRba2V5XSkgY29udGludWU7XFxuXFxuXFx0XFx0dmFyIG5ld1ZhbHVlID0gbmV3U3RhdGVba2V5XTtcXG5cXHRcXHR2YXIgb2xkVmFsdWUgPSBvbGRTdGF0ZVtrZXldO1xcblxcblxcdFxcdHZhciBjYWxsYmFja3MgPSBncm91cFtrZXldO1xcblxcdFxcdGlmICghY2FsbGJhY2tzKSBjb250aW51ZTtcXG5cXG5cXHRcXHRmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkgKz0gMSkge1xcblxcdFxcdFxcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcXG5cXHRcXHRcXHRpZiAoY2FsbGJhY2suX19jYWxsaW5nKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRjYWxsYmFjay5fX2NhbGxpbmcgPSB0cnVlO1xcblxcdFxcdFxcdGNhbGxiYWNrLmNhbGwoY29tcG9uZW50LCBuZXdWYWx1ZSwgb2xkVmFsdWUpO1xcblxcdFxcdFxcdGNhbGxiYWNrLl9fY2FsbGluZyA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9XFxufVwiLFxuICAgIFwiZmlyZVwiOiBcImZ1bmN0aW9uIGZpcmUoZXZlbnROYW1lLCBkYXRhKSB7XFxuXFx0dmFyIGhhbmRsZXJzID1cXG5cXHRcXHRldmVudE5hbWUgaW4gdGhpcy5faGFuZGxlcnMgJiYgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5zbGljZSgpO1xcblxcdGlmICghaGFuZGxlcnMpIHJldHVybjtcXG5cXG5cXHRmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSArPSAxKSB7XFxuXFx0XFx0aGFuZGxlcnNbaV0uY2FsbCh0aGlzLCBkYXRhKTtcXG5cXHR9XFxufVwiLFxuICAgIFwiZ2V0XCI6IFwiZnVuY3Rpb24gZ2V0KGtleSkge1xcblxcdHJldHVybiBrZXkgPyB0aGlzLl9zdGF0ZVtrZXldIDogdGhpcy5fc3RhdGU7XFxufVwiLFxuICAgIFwiaW5pdFwiOiBcImZ1bmN0aW9uIGluaXQoY29tcG9uZW50LCBvcHRpb25zKSB7XFxuXFx0Y29tcG9uZW50Ll9vYnNlcnZlcnMgPSB7IHByZTogYmxhbmtPYmplY3QoKSwgcG9zdDogYmxhbmtPYmplY3QoKSB9O1xcblxcdGNvbXBvbmVudC5faGFuZGxlcnMgPSBibGFua09iamVjdCgpO1xcblxcdGNvbXBvbmVudC5fYmluZCA9IG9wdGlvbnMuX2JpbmQ7XFxuXFxuXFx0Y29tcG9uZW50Lm9wdGlvbnMgPSBvcHRpb25zO1xcblxcdGNvbXBvbmVudC5yb290ID0gb3B0aW9ucy5yb290IHx8IGNvbXBvbmVudDtcXG5cXHRjb21wb25lbnQuc3RvcmUgPSBjb21wb25lbnQucm9vdC5zdG9yZSB8fCBvcHRpb25zLnN0b3JlO1xcbn1cIixcbiAgICBcIm9ic2VydmVcIjogXCJmdW5jdGlvbiBvYnNlcnZlKGtleSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcXG5cXHR2YXIgZ3JvdXAgPSBvcHRpb25zICYmIG9wdGlvbnMuZGVmZXJcXG5cXHRcXHQ/IHRoaXMuX29ic2VydmVycy5wb3N0XFxuXFx0XFx0OiB0aGlzLl9vYnNlcnZlcnMucHJlO1xcblxcblxcdChncm91cFtrZXldIHx8IChncm91cFtrZXldID0gW10pKS5wdXNoKGNhbGxiYWNrKTtcXG5cXG5cXHRpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5pbml0ICE9PSBmYWxzZSkge1xcblxcdFxcdGNhbGxiYWNrLl9fY2FsbGluZyA9IHRydWU7XFxuXFx0XFx0Y2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl9zdGF0ZVtrZXldKTtcXG5cXHRcXHRjYWxsYmFjay5fX2NhbGxpbmcgPSBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHtcXG5cXHRcXHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBpbmRleCA9IGdyb3VwW2tleV0uaW5kZXhPZihjYWxsYmFjayk7XFxuXFx0XFx0XFx0aWYgKH5pbmRleCkgZ3JvdXBba2V5XS5zcGxpY2UoaW5kZXgsIDEpO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cIixcbiAgICBcIm9ic2VydmVEZXZcIjogXCJmdW5jdGlvbiBvYnNlcnZlRGV2KGtleSwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcXG5cXHR2YXIgYyA9IChrZXkgPSAnJyArIGtleSkuc2VhcmNoKC9bXlxcXFx3XS8pO1xcblxcdGlmIChjID4gLTEpIHtcXG5cXHRcXHR2YXIgbWVzc2FnZSA9XFxuXFx0XFx0XFx0J1RoZSBmaXJzdCBhcmd1bWVudCB0byBjb21wb25lbnQub2JzZXJ2ZSguLi4pIG11c3QgYmUgdGhlIG5hbWUgb2YgYSB0b3AtbGV2ZWwgcHJvcGVydHknO1xcblxcdFxcdGlmIChjID4gMClcXG5cXHRcXHRcXHRtZXNzYWdlICs9IFxcXCIsIGkuZS4gJ1xcXCIgKyBrZXkuc2xpY2UoMCwgYykgKyBcXFwiJyByYXRoZXIgdGhhbiAnXFxcIiArIGtleSArIFxcXCInXFxcIjtcXG5cXG5cXHRcXHR0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XFxuXFx0fVxcblxcblxcdHJldHVybiBvYnNlcnZlLmNhbGwodGhpcywga2V5LCBjYWxsYmFjaywgb3B0aW9ucyk7XFxufVwiLFxuICAgIFwib25cIjogXCJmdW5jdGlvbiBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcXG5cXHRpZiAoZXZlbnROYW1lID09PSAndGVhcmRvd24nKSByZXR1cm4gdGhpcy5vbignZGVzdHJveScsIGhhbmRsZXIpO1xcblxcblxcdHZhciBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gfHwgKHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0gPSBbXSk7XFxuXFx0aGFuZGxlcnMucHVzaChoYW5kbGVyKTtcXG5cXG5cXHRyZXR1cm4ge1xcblxcdFxcdGNhbmNlbDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcXG5cXHRcXHRcXHRpZiAofmluZGV4KSBoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cIixcbiAgICBcIm9uRGV2XCI6IFwiZnVuY3Rpb24gb25EZXYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XFxuXFx0aWYgKGV2ZW50TmFtZSA9PT0gJ3RlYXJkb3duJykge1xcblxcdFxcdGNvbnNvbGUud2FybihcXG5cXHRcXHRcXHRcXFwiVXNlIGNvbXBvbmVudC5vbignZGVzdHJveScsIC4uLikgaW5zdGVhZCBvZiBjb21wb25lbnQub24oJ3RlYXJkb3duJywgLi4uKSB3aGljaCBoYXMgYmVlbiBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHVuc3VwcG9ydGVkIGluIFN2ZWx0ZSAyXFxcIlxcblxcdFxcdCk7XFxuXFx0XFx0cmV0dXJuIHRoaXMub24oJ2Rlc3Ryb3knLCBoYW5kbGVyKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIG9uLmNhbGwodGhpcywgZXZlbnROYW1lLCBoYW5kbGVyKTtcXG59XCIsXG4gICAgXCJzZXRcIjogXCJmdW5jdGlvbiBzZXQobmV3U3RhdGUpIHtcXG5cXHR0aGlzLl9zZXQoYXNzaWduKHt9LCBuZXdTdGF0ZSkpO1xcblxcdGlmICh0aGlzLnJvb3QuX2xvY2spIHJldHVybjtcXG5cXHR0aGlzLnJvb3QuX2xvY2sgPSB0cnVlO1xcblxcdGNhbGxBbGwodGhpcy5yb290Ll9iZWZvcmVjcmVhdGUpO1xcblxcdGNhbGxBbGwodGhpcy5yb290Ll9vbmNyZWF0ZSk7XFxuXFx0Y2FsbEFsbCh0aGlzLnJvb3QuX2FmdGVyY3JlYXRlKTtcXG5cXHR0aGlzLnJvb3QuX2xvY2sgPSBmYWxzZTtcXG59XCIsXG4gICAgXCJfc2V0XCI6IFwiZnVuY3Rpb24gX3NldChuZXdTdGF0ZSkge1xcblxcdHZhciBvbGRTdGF0ZSA9IHRoaXMuX3N0YXRlLFxcblxcdFxcdGNoYW5nZWQgPSB7fSxcXG5cXHRcXHRkaXJ0eSA9IGZhbHNlO1xcblxcblxcdGZvciAodmFyIGtleSBpbiBuZXdTdGF0ZSkge1xcblxcdFxcdGlmIChkaWZmZXJzKG5ld1N0YXRlW2tleV0sIG9sZFN0YXRlW2tleV0pKSBjaGFuZ2VkW2tleV0gPSBkaXJ0eSA9IHRydWU7XFxuXFx0fVxcblxcdGlmICghZGlydHkpIHJldHVybjtcXG5cXG5cXHR0aGlzLl9zdGF0ZSA9IGFzc2lnbih7fSwgb2xkU3RhdGUsIG5ld1N0YXRlKTtcXG5cXHR0aGlzLl9yZWNvbXB1dGUoY2hhbmdlZCwgdGhpcy5fc3RhdGUpO1xcblxcdGlmICh0aGlzLl9iaW5kKSB0aGlzLl9iaW5kKGNoYW5nZWQsIHRoaXMuX3N0YXRlKTtcXG5cXG5cXHRpZiAodGhpcy5fZnJhZ21lbnQpIHtcXG5cXHRcXHRkaXNwYXRjaE9ic2VydmVycyh0aGlzLCB0aGlzLl9vYnNlcnZlcnMucHJlLCBjaGFuZ2VkLCB0aGlzLl9zdGF0ZSwgb2xkU3RhdGUpO1xcblxcdFxcdHRoaXMuX2ZyYWdtZW50LnAoY2hhbmdlZCwgdGhpcy5fc3RhdGUpO1xcblxcdFxcdGRpc3BhdGNoT2JzZXJ2ZXJzKHRoaXMsIHRoaXMuX29ic2VydmVycy5wb3N0LCBjaGFuZ2VkLCB0aGlzLl9zdGF0ZSwgb2xkU3RhdGUpO1xcblxcdH1cXG59XCIsXG4gICAgXCJzZXREZXZcIjogXCJmdW5jdGlvbiBzZXREZXYobmV3U3RhdGUpIHtcXG5cXHRpZiAodHlwZW9mIG5ld1N0YXRlICE9PSAnb2JqZWN0Jykge1xcblxcdFxcdHRocm93IG5ldyBFcnJvcihcXG5cXHRcXHRcXHR0aGlzLl9kZWJ1Z05hbWUgKyAnLnNldCB3YXMgY2FsbGVkIHdpdGhvdXQgYW4gb2JqZWN0IG9mIGRhdGEga2V5LXZhbHVlcyB0byB1cGRhdGUuJ1xcblxcdFxcdCk7XFxuXFx0fVxcblxcblxcdHRoaXMuX2NoZWNrUmVhZE9ubHkobmV3U3RhdGUpO1xcblxcdHNldC5jYWxsKHRoaXMsIG5ld1N0YXRlKTtcXG59XCIsXG4gICAgXCJjYWxsQWxsXCI6IFwiZnVuY3Rpb24gY2FsbEFsbChmbnMpIHtcXG5cXHR3aGlsZSAoZm5zICYmIGZucy5sZW5ndGgpIGZucy5wb3AoKSgpO1xcbn1cIixcbiAgICBcIl9tb3VudFwiOiBcImZ1bmN0aW9uIF9tb3VudCh0YXJnZXQsIGFuY2hvcikge1xcblxcdHRoaXMuX2ZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xcbn1cIixcbiAgICBcIl91bm1vdW50XCI6IFwiZnVuY3Rpb24gX3VubW91bnQoKSB7XFxuXFx0aWYgKHRoaXMuX2ZyYWdtZW50KSB0aGlzLl9mcmFnbWVudC51KCk7XFxufVwiLFxuICAgIFwiaXNQcm9taXNlXCI6IFwiZnVuY3Rpb24gaXNQcm9taXNlKHZhbHVlKSB7XFxuXFx0cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xcbn1cIixcbiAgICBcIlBFTkRJTkdcIjogXCJ7fVwiLFxuICAgIFwiU1VDQ0VTU1wiOiBcInt9XCIsXG4gICAgXCJGQUlMVVJFXCI6IFwie31cIixcbiAgICBcInJlbW92ZUZyb21TdG9yZVwiOiBcImZ1bmN0aW9uIHJlbW92ZUZyb21TdG9yZSgpIHtcXG5cXHR0aGlzLnN0b3JlLl9yZW1vdmUodGhpcyk7XFxufVwiLFxuICAgIFwicHJvdG9cIjogXCJ7XFxuXFx0ZGVzdHJveTogZGVzdHJveSxcXG5cXHRnZXQ6IGdldCxcXG5cXHRmaXJlOiBmaXJlLFxcblxcdG9ic2VydmU6IG9ic2VydmUsXFxuXFx0b246IG9uLFxcblxcdHNldDogc2V0LFxcblxcdHRlYXJkb3duOiBkZXN0cm95LFxcblxcdF9yZWNvbXB1dGU6IG5vb3AsXFxuXFx0X3NldDogX3NldCxcXG5cXHRfbW91bnQ6IF9tb3VudCxcXG5cXHRfdW5tb3VudDogX3VubW91bnRcXG59XCIsXG4gICAgXCJwcm90b0RldlwiOiBcIntcXG5cXHRkZXN0cm95OiBkZXN0cm95RGV2LFxcblxcdGdldDogZ2V0LFxcblxcdGZpcmU6IGZpcmUsXFxuXFx0b2JzZXJ2ZTogb2JzZXJ2ZURldixcXG5cXHRvbjogb25EZXYsXFxuXFx0c2V0OiBzZXREZXYsXFxuXFx0dGVhcmRvd246IGRlc3Ryb3lEZXYsXFxuXFx0X3JlY29tcHV0ZTogbm9vcCxcXG5cXHRfc2V0OiBfc2V0LFxcblxcdF9tb3VudDogX21vdW50LFxcblxcdF91bm1vdW50OiBfdW5tb3VudFxcbn1cIixcbiAgICBcImxpbmVhclwiOiBcImZ1bmN0aW9uIGxpbmVhcih0KSB7XFxuXFx0cmV0dXJuIHQ7XFxufVwiLFxuICAgIFwiZ2VuZXJhdGVSdWxlXCI6IFwiZnVuY3Rpb24gZ2VuZXJhdGVSdWxlKFxcblxcdGEsXFxuXFx0YixcXG5cXHRkZWx0YSxcXG5cXHRkdXJhdGlvbixcXG5cXHRlYXNlLFxcblxcdGZuXFxuKSB7XFxuXFx0dmFyIGtleWZyYW1lcyA9ICd7XFxcXG4nO1xcblxcblxcdGZvciAodmFyIHAgPSAwOyBwIDw9IDE7IHAgKz0gMTYuNjY2IC8gZHVyYXRpb24pIHtcXG5cXHRcXHR2YXIgdCA9IGEgKyBkZWx0YSAqIGVhc2UocCk7XFxuXFx0XFx0a2V5ZnJhbWVzICs9IHAgKiAxMDAgKyAnJXsnICsgZm4odCkgKyAnfVxcXFxuJztcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIGtleWZyYW1lcyArICcxMDAlIHsnICsgZm4oYikgKyAnfVxcXFxufSc7XFxufVwiLFxuICAgIFwiaGFzaFwiOiBcImZ1bmN0aW9uIGhhc2goc3RyKSB7XFxuXFx0dmFyIGhhc2ggPSA1MzgxO1xcblxcdHZhciBpID0gc3RyLmxlbmd0aDtcXG5cXG5cXHR3aGlsZSAoaS0tKSBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcXG5cXHRyZXR1cm4gaGFzaCA+Pj4gMDtcXG59XCIsXG4gICAgXCJ3cmFwVHJhbnNpdGlvblwiOiBcImZ1bmN0aW9uIHdyYXBUcmFuc2l0aW9uKGNvbXBvbmVudCwgbm9kZSwgZm4sIHBhcmFtcywgaW50cm8sIG91dGdyb3VwKSB7XFxuXFx0dmFyIG9iaiA9IGZuKG5vZGUsIHBhcmFtcyk7XFxuXFx0dmFyIGR1cmF0aW9uID0gb2JqLmR1cmF0aW9uIHx8IDMwMDtcXG5cXHR2YXIgZWFzZSA9IG9iai5lYXNpbmcgfHwgbGluZWFyO1xcblxcdHZhciBjc3NUZXh0O1xcblxcblxcdC8vIFRPRE8gc2hhcmUgPHN0eWxlPiB0YWcgYmV0d2VlbiBhbGwgdHJhbnNpdGlvbnM/XFxuXFx0aWYgKG9iai5jc3MgJiYgIXRyYW5zaXRpb25NYW5hZ2VyLnN0eWxlc2hlZXQpIHtcXG5cXHRcXHR2YXIgc3R5bGUgPSBjcmVhdGVFbGVtZW50KCdzdHlsZScpO1xcblxcdFxcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xcblxcdFxcdHRyYW5zaXRpb25NYW5hZ2VyLnN0eWxlc2hlZXQgPSBzdHlsZS5zaGVldDtcXG5cXHR9XFxuXFxuXFx0aWYgKGludHJvKSB7XFxuXFx0XFx0aWYgKG9iai5jc3MgJiYgb2JqLmRlbGF5KSB7XFxuXFx0XFx0XFx0Y3NzVGV4dCA9IG5vZGUuc3R5bGUuY3NzVGV4dDtcXG5cXHRcXHRcXHRub2RlLnN0eWxlLmNzc1RleHQgKz0gb2JqLmNzcygwKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKG9iai50aWNrKSBvYmoudGljaygwKTtcXG5cXHR9XFxuXFxuXFx0cmV0dXJuIHtcXG5cXHRcXHR0OiBpbnRybyA/IDAgOiAxLFxcblxcdFxcdHJ1bm5pbmc6IGZhbHNlLFxcblxcdFxcdHByb2dyYW06IG51bGwsXFxuXFx0XFx0cGVuZGluZzogbnVsbCxcXG5cXHRcXHRydW46IGZ1bmN0aW9uKGludHJvLCBjYWxsYmFjaykge1xcblxcdFxcdFxcdHZhciBwcm9ncmFtID0ge1xcblxcdFxcdFxcdFxcdHN0YXJ0OiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgKyAob2JqLmRlbGF5IHx8IDApLFxcblxcdFxcdFxcdFxcdGludHJvOiBpbnRybyxcXG5cXHRcXHRcXHRcXHRjYWxsYmFjazogY2FsbGJhY2tcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdGlmIChvYmouZGVsYXkpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnBlbmRpbmcgPSBwcm9ncmFtO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zdGFydChwcm9ncmFtKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCF0aGlzLnJ1bm5pbmcpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHRyYW5zaXRpb25NYW5hZ2VyLmFkZCh0aGlzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzdGFydDogZnVuY3Rpb24ocHJvZ3JhbSkge1xcblxcdFxcdFxcdGNvbXBvbmVudC5maXJlKHByb2dyYW0uaW50cm8gPyAnaW50cm8uc3RhcnQnIDogJ291dHJvLnN0YXJ0JywgeyBub2RlOiBub2RlIH0pO1xcblxcblxcdFxcdFxcdHByb2dyYW0uYSA9IHRoaXMudDtcXG5cXHRcXHRcXHRwcm9ncmFtLmIgPSBwcm9ncmFtLmludHJvID8gMSA6IDA7XFxuXFx0XFx0XFx0cHJvZ3JhbS5kZWx0YSA9IHByb2dyYW0uYiAtIHByb2dyYW0uYTtcXG5cXHRcXHRcXHRwcm9ncmFtLmR1cmF0aW9uID0gZHVyYXRpb24gKiBNYXRoLmFicyhwcm9ncmFtLmIgLSBwcm9ncmFtLmEpO1xcblxcdFxcdFxcdHByb2dyYW0uZW5kID0gcHJvZ3JhbS5zdGFydCArIHByb2dyYW0uZHVyYXRpb247XFxuXFxuXFx0XFx0XFx0aWYgKG9iai5jc3MpIHtcXG5cXHRcXHRcXHRcXHRpZiAob2JqLmRlbGF5KSBub2RlLnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0O1xcblxcblxcdFxcdFxcdFxcdHByb2dyYW0ucnVsZSA9IGdlbmVyYXRlUnVsZShcXG5cXHRcXHRcXHRcXHRcXHRwcm9ncmFtLmEsXFxuXFx0XFx0XFx0XFx0XFx0cHJvZ3JhbS5iLFxcblxcdFxcdFxcdFxcdFxcdHByb2dyYW0uZGVsdGEsXFxuXFx0XFx0XFx0XFx0XFx0cHJvZ3JhbS5kdXJhdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRlYXNlLFxcblxcdFxcdFxcdFxcdFxcdG9iai5jc3NcXG5cXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdHRyYW5zaXRpb25NYW5hZ2VyLmFkZFJ1bGUocHJvZ3JhbS5ydWxlLCBwcm9ncmFtLm5hbWUgPSAnX19zdmVsdGVfJyArIGhhc2gocHJvZ3JhbS5ydWxlKSk7XFxuXFxuXFx0XFx0XFx0XFx0bm9kZS5zdHlsZS5hbmltYXRpb24gPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpXFxuXFx0XFx0XFx0XFx0XFx0LnNwbGl0KCcsICcpXFxuXFx0XFx0XFx0XFx0XFx0LmZpbHRlcihmdW5jdGlvbihhbmltKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gd2hlbiBpbnRyb2luZywgZGlzY2FyZCBvbGQgYW5pbWF0aW9ucyBpZiB0aGVyZSBhcmUgYW55XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGFuaW0gJiYgKHByb2dyYW0uZGVsdGEgPCAwIHx8ICEvX19zdmVsdGUvLnRlc3QoYW5pbSkpO1xcblxcdFxcdFxcdFxcdFxcdH0pXFxuXFx0XFx0XFx0XFx0XFx0LmNvbmNhdChwcm9ncmFtLm5hbWUgKyAnICcgKyBkdXJhdGlvbiArICdtcyBsaW5lYXIgMSBmb3J3YXJkcycpXFxuXFx0XFx0XFx0XFx0XFx0LmpvaW4oJywgJyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XFxuXFx0XFx0XFx0dGhpcy5wZW5kaW5nID0gbnVsbDtcXG5cXHRcXHR9LFxcblxcdFxcdHVwZGF0ZTogZnVuY3Rpb24obm93KSB7XFxuXFx0XFx0XFx0dmFyIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XFxuXFx0XFx0XFx0aWYgKCFwcm9ncmFtKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0dmFyIHAgPSBub3cgLSBwcm9ncmFtLnN0YXJ0O1xcblxcdFxcdFxcdHRoaXMudCA9IHByb2dyYW0uYSArIHByb2dyYW0uZGVsdGEgKiBlYXNlKHAgLyBwcm9ncmFtLmR1cmF0aW9uKTtcXG5cXHRcXHRcXHRpZiAob2JqLnRpY2spIG9iai50aWNrKHRoaXMudCk7XFxuXFx0XFx0fSxcXG5cXHRcXHRkb25lOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbTtcXG5cXHRcXHRcXHR0aGlzLnQgPSBwcm9ncmFtLmI7XFxuXFx0XFx0XFx0aWYgKG9iai50aWNrKSBvYmoudGljayh0aGlzLnQpO1xcblxcdFxcdFxcdGlmIChvYmouY3NzKSB0cmFuc2l0aW9uTWFuYWdlci5kZWxldGVSdWxlKG5vZGUsIHByb2dyYW0ubmFtZSk7XFxuXFx0XFx0XFx0cHJvZ3JhbS5jYWxsYmFjaygpO1xcblxcdFxcdFxcdHByb2dyYW0gPSBudWxsO1xcblxcdFxcdFxcdHRoaXMucnVubmluZyA9ICEhdGhpcy5wZW5kaW5nO1xcblxcdFxcdH0sXFxuXFx0XFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmIChvYmoudGljaykgb2JqLnRpY2soMSk7XFxuXFx0XFx0XFx0aWYgKG9iai5jc3MpIHRyYW5zaXRpb25NYW5hZ2VyLmRlbGV0ZVJ1bGUobm9kZSwgdGhpcy5wcm9ncmFtLm5hbWUpO1xcblxcdFxcdFxcdHRoaXMucHJvZ3JhbSA9IHRoaXMucGVuZGluZyA9IG51bGw7XFxuXFx0XFx0XFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XFxuXFx0XFx0fVxcblxcdH07XFxufVwiLFxuICAgIFwidHJhbnNpdGlvbk1hbmFnZXJcIjogXCJ7XFxuXFx0cnVubmluZzogZmFsc2UsXFxuXFx0dHJhbnNpdGlvbnM6IFtdLFxcblxcdGJvdW5kOiBudWxsLFxcblxcdHN0eWxlc2hlZXQ6IG51bGwsXFxuXFx0YWN0aXZlUnVsZXM6IHt9LFxcblxcblxcdGFkZDogZnVuY3Rpb24odHJhbnNpdGlvbikge1xcblxcdFxcdHRoaXMudHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcXG5cXG5cXHRcXHRpZiAoIXRoaXMucnVubmluZykge1xcblxcdFxcdFxcdHRoaXMucnVubmluZyA9IHRydWU7XFxuXFx0XFx0XFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYm91bmQgfHwgKHRoaXMuYm91bmQgPSB0aGlzLm5leHQuYmluZCh0aGlzKSkpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdGFkZFJ1bGU6IGZ1bmN0aW9uKHJ1bGUsIG5hbWUpIHtcXG5cXHRcXHRpZiAoIXRoaXMuYWN0aXZlUnVsZXNbbmFtZV0pIHtcXG5cXHRcXHRcXHR0aGlzLmFjdGl2ZVJ1bGVzW25hbWVdID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLnN0eWxlc2hlZXQuaW5zZXJ0UnVsZSgnQGtleWZyYW1lcyAnICsgbmFtZSArICcgJyArIHJ1bGUsIHRoaXMuc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xcblxcdFxcdH1cXG5cXHR9LFxcblxcblxcdG5leHQ6IGZ1bmN0aW9uKCkge1xcblxcdFxcdHRoaXMucnVubmluZyA9IGZhbHNlO1xcblxcblxcdFxcdHZhciBub3cgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCk7XFxuXFx0XFx0dmFyIGkgPSB0aGlzLnRyYW5zaXRpb25zLmxlbmd0aDtcXG5cXG5cXHRcXHR3aGlsZSAoaS0tKSB7XFxuXFx0XFx0XFx0dmFyIHRyYW5zaXRpb24gPSB0aGlzLnRyYW5zaXRpb25zW2ldO1xcblxcblxcdFxcdFxcdGlmICh0cmFuc2l0aW9uLnByb2dyYW0gJiYgbm93ID49IHRyYW5zaXRpb24ucHJvZ3JhbS5lbmQpIHtcXG5cXHRcXHRcXHRcXHR0cmFuc2l0aW9uLmRvbmUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHRyYW5zaXRpb24ucGVuZGluZyAmJiBub3cgPj0gdHJhbnNpdGlvbi5wZW5kaW5nLnN0YXJ0KSB7XFxuXFx0XFx0XFx0XFx0dHJhbnNpdGlvbi5zdGFydCh0cmFuc2l0aW9uLnBlbmRpbmcpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAodHJhbnNpdGlvbi5ydW5uaW5nKSB7XFxuXFx0XFx0XFx0XFx0dHJhbnNpdGlvbi51cGRhdGUobm93KTtcXG5cXHRcXHRcXHRcXHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoIXRyYW5zaXRpb24ucGVuZGluZykge1xcblxcdFxcdFxcdFxcdHRoaXMudHJhbnNpdGlvbnMuc3BsaWNlKGksIDEpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMucnVubmluZykge1xcblxcdFxcdFxcdHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmJvdW5kKTtcXG5cXHRcXHR9IGVsc2UgaWYgKHRoaXMuc3R5bGVzaGVldCkge1xcblxcdFxcdFxcdHZhciBpID0gdGhpcy5zdHlsZXNoZWV0LmNzc1J1bGVzLmxlbmd0aDtcXG5cXHRcXHRcXHR3aGlsZSAoaS0tKSB0aGlzLnN0eWxlc2hlZXQuZGVsZXRlUnVsZShpKTtcXG5cXHRcXHRcXHR0aGlzLmFjdGl2ZVJ1bGVzID0ge307XFxuXFx0XFx0fVxcblxcdH0sXFxuXFxuXFx0ZGVsZXRlUnVsZTogZnVuY3Rpb24obm9kZSwgbmFtZSkge1xcblxcdFxcdG5vZGUuc3R5bGUuYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb25cXG5cXHRcXHRcXHQuc3BsaXQoJywgJylcXG5cXHRcXHRcXHQuZmlsdGVyKGZ1bmN0aW9uKGFuaW0pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYW5pbS5zbGljZSgwLCBuYW1lLmxlbmd0aCkgIT09IG5hbWU7XFxuXFx0XFx0XFx0fSlcXG5cXHRcXHRcXHQuam9pbignLCAnKTtcXG5cXHR9XFxufVwiLFxuICAgIFwibm9vcFwiOiBcImZ1bmN0aW9uIG5vb3AoKSB7fVwiLFxuICAgIFwiYXNzaWduXCI6IFwiZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xcblxcdHZhciBrLFxcblxcdFxcdHNvdXJjZSxcXG5cXHRcXHRpID0gMSxcXG5cXHRcXHRsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xcblxcdGZvciAoOyBpIDwgbGVuOyBpKyspIHtcXG5cXHRcXHRzb3VyY2UgPSBhcmd1bWVudHNbaV07XFxuXFx0XFx0Zm9yIChrIGluIHNvdXJjZSkgdGFyZ2V0W2tdID0gc291cmNlW2tdO1xcblxcdH1cXG5cXG5cXHRyZXR1cm4gdGFyZ2V0O1xcbn1cIlxufTtcblxudmFyIGtleXMgPSB7XG4gICAgT2JqZWN0RXhwcmVzc2lvbjogJ3Byb3BlcnRpZXMnLFxuICAgIFByb2dyYW06ICdib2R5J1xufTtcbnZhciBvZmZzZXRzID0ge1xuICAgIE9iamVjdEV4cHJlc3Npb246IFsxLCAtMV0sXG4gICAgUHJvZ3JhbTogWzAsIDBdXG59O1xuZnVuY3Rpb24gcmVtb3ZlTm9kZShjb2RlLCBwYXJlbnQsIG5vZGUpIHtcbiAgICB2YXIga2V5ID0ga2V5c1twYXJlbnQudHlwZV07XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldHNbcGFyZW50LnR5cGVdO1xuICAgIGlmICgha2V5IHx8ICFvZmZzZXQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZDogXCIgKyBwYXJlbnQudHlwZSk7XG4gICAgdmFyIGxpc3QgPSBwYXJlbnRba2V5XTtcbiAgICB2YXIgaSA9IGxpc3QuaW5kZXhPZihub2RlKTtcbiAgICBpZiAoaSA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm9kZSBub3QgaW4gbGlzdCcpO1xuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAvLyByZW1vdmUgZXZlcnl0aGluZywgbGVhdmUge31cbiAgICAgICAgYSA9IHBhcmVudC5zdGFydCArIG9mZnNldFswXTtcbiAgICAgICAgYiA9IHBhcmVudC5lbmQgKyBvZmZzZXRbMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgLy8gcmVtb3ZlIGV2ZXJ5dGhpbmcgYmVmb3JlIHNlY29uZCBub2RlLCBpbmNsdWRpbmcgY29tbWVudHNcbiAgICAgICAgYSA9IHBhcmVudC5zdGFydCArIG9mZnNldFswXTtcbiAgICAgICAgd2hpbGUgKC9cXHMvLnRlc3QoY29kZS5vcmlnaW5hbFthXSkpXG4gICAgICAgICAgICBhICs9IDE7XG4gICAgICAgIGIgPSBsaXN0W2ldLmVuZDtcbiAgICAgICAgd2hpbGUgKC9bXFxzLF0vLnRlc3QoY29kZS5vcmlnaW5hbFtiXSkpXG4gICAgICAgICAgICBiICs9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyByZW1vdmUgdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgbm9kZSB0byB0aGUgZW5kIG9mIHRoaXMgb25lXG4gICAgICAgIGEgPSBsaXN0W2kgLSAxXS5lbmQ7XG4gICAgICAgIGIgPSBub2RlLmVuZDtcbiAgICB9XG4gICAgY29kZS5yZW1vdmUoYSwgYik7XG4gICAgbGlzdC5zcGxpY2UoaSwgMSk7XG4gICAgcmV0dXJuO1xufVxuXG52YXIgd3JhcHBlcnMgPSB7IGVzOiBlcywgYW1kOiBhbWQsIGNqczogY2pzLCBpaWZlOiBpaWZlLCB1bWQ6IHVtZCwgZXZhbDogZXhwciB9O1xuZnVuY3Rpb24gd3JhcE1vZHVsZShjb2RlLCBmb3JtYXQsIG5hbWUsIG9wdGlvbnMsIGJhbm5lciwgc2hhcmVkUGF0aCwgaGVscGVycywgaW1wb3J0cywgc291cmNlKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gJ2VzJylcbiAgICAgICAgcmV0dXJuIGVzKGNvZGUsIG5hbWUsIG9wdGlvbnMsIGJhbm5lciwgc2hhcmVkUGF0aCwgaGVscGVycywgaW1wb3J0cywgc291cmNlKTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gaW1wb3J0cy5tYXAoZnVuY3Rpb24gKGRlY2xhcmF0aW9uLCBpKSB7XG4gICAgICAgIHZhciBkZWZhdWx0SW1wb3J0ID0gZGVjbGFyYXRpb24uc3BlY2lmaWVycy5maW5kKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geC50eXBlID09PSAnSW1wb3J0RGVmYXVsdFNwZWNpZmllcicgfHxcbiAgICAgICAgICAgICAgICAoeC50eXBlID09PSAnSW1wb3J0U3BlY2lmaWVyJyAmJiB4LmltcG9ydGVkLm5hbWUgPT09ICdkZWZhdWx0Jyk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmFtZXNwYWNlSW1wb3J0ID0gZGVjbGFyYXRpb24uc3BlY2lmaWVycy5maW5kKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LnR5cGUgPT09ICdJbXBvcnROYW1lc3BhY2VTcGVjaWZpZXInOyB9KTtcbiAgICAgICAgdmFyIG5hbWVkSW1wb3J0cyA9IGRlY2xhcmF0aW9uLnNwZWNpZmllcnMuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geC50eXBlID09PSAnSW1wb3J0U3BlY2lmaWVyJyAmJiB4LmltcG9ydGVkLm5hbWUgIT09ICdkZWZhdWx0JztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBuYW1lID0gZGVmYXVsdEltcG9ydCB8fCBuYW1lc3BhY2VJbXBvcnRcbiAgICAgICAgICAgID8gKGRlZmF1bHRJbXBvcnQgfHwgbmFtZXNwYWNlSW1wb3J0KS5sb2NhbC5uYW1lXG4gICAgICAgICAgICA6IFwiX19pbXBvcnRcIiArIGk7XG4gICAgICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgICAgIG5hbWVkSW1wb3J0cy5mb3JFYWNoKGZ1bmN0aW9uIChzcGVjaWZpZXIpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChcInZhciBcIiArIHNwZWNpZmllci5sb2NhbC5uYW1lICsgXCIgPSBcIiArIG5hbWUgKyBcIi5cIiArIHNwZWNpZmllci5pbXBvcnRlZC5uYW1lICsgXCI7XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlZmF1bHRJbXBvcnQpIHtcbiAgICAgICAgICAgIHN0YXRlbWVudHMucHVzaChuYW1lICsgXCIgPSAoXCIgKyBuYW1lICsgXCIgJiYgXCIgKyBuYW1lICsgXCIuX19lc01vZHVsZSkgPyBcIiArIG5hbWUgKyBcIltcXFwiZGVmYXVsdFxcXCJdIDogXCIgKyBuYW1lICsgXCI7XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHN0YXRlbWVudHM6IHN0YXRlbWVudHMsIHNvdXJjZTogZGVjbGFyYXRpb24uc291cmNlLnZhbHVlIH07XG4gICAgfSk7XG4gICAgaWYgKGZvcm1hdCA9PT0gJ2FtZCcpXG4gICAgICAgIHJldHVybiBhbWQoY29kZSwgbmFtZSwgb3B0aW9ucywgYmFubmVyLCBkZXBlbmRlbmNpZXMpO1xuICAgIGlmIChmb3JtYXQgPT09ICdjanMnKVxuICAgICAgICByZXR1cm4gY2pzKGNvZGUsIG5hbWUsIG9wdGlvbnMsIGJhbm5lciwgc2hhcmVkUGF0aCwgaGVscGVycywgZGVwZW5kZW5jaWVzKTtcbiAgICBpZiAoZm9ybWF0ID09PSAnaWlmZScpXG4gICAgICAgIHJldHVybiBpaWZlKGNvZGUsIG5hbWUsIG9wdGlvbnMsIGJhbm5lciwgZGVwZW5kZW5jaWVzKTtcbiAgICBpZiAoZm9ybWF0ID09PSAndW1kJylcbiAgICAgICAgcmV0dXJuIHVtZChjb2RlLCBuYW1lLCBvcHRpb25zLCBiYW5uZXIsIGRlcGVuZGVuY2llcyk7XG4gICAgaWYgKGZvcm1hdCA9PT0gJ2V2YWwnKVxuICAgICAgICByZXR1cm4gZXhwcihjb2RlLCBuYW1lLCBvcHRpb25zLCBiYW5uZXIsIGRlcGVuZGVuY2llcyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5mb3JtYXQgaXMgaW52YWxpZCAobXVzdCBiZSBcIiArIGxpc3QkMihPYmplY3Qua2V5cyh3cmFwcGVycykpICsgXCIpXCIpO1xufVxuZnVuY3Rpb24gZXMoY29kZSwgbmFtZSwgb3B0aW9ucywgYmFubmVyLCBzaGFyZWRQYXRoLCBoZWxwZXJzLCBpbXBvcnRzLCBzb3VyY2UpIHtcbiAgICB2YXIgaW1wb3J0SGVscGVycyA9IGhlbHBlcnMgJiYgKFwiaW1wb3J0IHsgXCIgKyBoZWxwZXJzLm1hcChmdW5jdGlvbiAoaCkgeyByZXR1cm4gaC5uYW1lID09PSBoLmFsaWFzID8gaC5uYW1lIDogaC5uYW1lICsgXCIgYXMgXCIgKyBoLmFsaWFzOyB9KS5qb2luKCcsICcpICsgXCIgfSBmcm9tIFwiICsgSlNPTi5zdHJpbmdpZnkoc2hhcmVkUGF0aCkgKyBcIjtcIik7XG4gICAgdmFyIGltcG9ydEJsb2NrID0gaW1wb3J0cy5sZW5ndGggPiAwICYmIChpbXBvcnRzXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlY2xhcmF0aW9uKSB7IHJldHVybiBzb3VyY2Uuc2xpY2UoZGVjbGFyYXRpb24uc3RhcnQsIGRlY2xhcmF0aW9uLmVuZCk7IH0pXG4gICAgICAgIC5qb2luKCdcXG4nKSk7XG4gICAgcmV0dXJuIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkMiB8fCAodGVtcGxhdGVPYmplY3RfMSQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0ZXhwb3J0IGRlZmF1bHQgXCIsIFwiO1wiXSwgW1wiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0ZXhwb3J0IGRlZmF1bHQgXCIsIFwiO1wiXSkpLCBiYW5uZXIsIGltcG9ydEhlbHBlcnMsIGltcG9ydEJsb2NrLCBjb2RlLCBuYW1lKTtcbn1cbmZ1bmN0aW9uIGFtZChjb2RlLCBuYW1lLCBvcHRpb25zLCBiYW5uZXIsIGRlcGVuZGVuY2llcykge1xuICAgIHZhciBzb3VyY2VTdHJpbmcgPSBkZXBlbmRlbmNpZXMubGVuZ3RoXG4gICAgICAgID8gXCJbXCIgKyBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBcIlxcXCJcIiArIHJlbW92ZUV4dGVuc2lvbihkLnNvdXJjZSkgKyBcIlxcXCJcIjsgfSkuam9pbignLCAnKSArIFwiXSwgXCJcbiAgICAgICAgOiAnJztcbiAgICB2YXIgaWQgPSBvcHRpb25zLmFtZCAmJiBvcHRpb25zLmFtZC5pZDtcbiAgICByZXR1cm4gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMiQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRkZWZpbmUoXCIsIFwiXCIsIFwiZnVuY3Rpb24oXCIsIFwiKSB7IFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRyZXR1cm4gXCIsIFwiO1xcblxcdFxcdH0pO1wiXSwgW1wiXFxuXFx0XFx0ZGVmaW5lKFwiLCBcIlwiLCBcImZ1bmN0aW9uKFwiLCBcIikgeyBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFx0XFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0cmV0dXJuIFwiLCBcIjtcXG5cXHRcXHR9KTtcIl0pKSwgaWQgPyBcIlxcXCJcIiArIGlkICsgXCJcXFwiLCBcIiA6ICcnLCBzb3VyY2VTdHJpbmcsIHBhcmFtU3RyaW5nKGRlcGVuZGVuY2llcyksIGdldENvbXBhdGliaWxpdHlTdGF0ZW1lbnRzKGRlcGVuZGVuY2llcyksIGNvZGUsIG5hbWUpO1xufVxuZnVuY3Rpb24gY2pzKGNvZGUsIG5hbWUsIG9wdGlvbnMsIGJhbm5lciwgc2hhcmVkUGF0aCwgaGVscGVycywgZGVwZW5kZW5jaWVzKSB7XG4gICAgdmFyIFNIQVJFRCA9ICdfX3NoYXJlZCc7XG4gICAgdmFyIGhlbHBlckJsb2NrID0gaGVscGVycyAmJiAoXCJ2YXIgXCIgKyBTSEFSRUQgKyBcIiA9IHJlcXVpcmUoXCIgKyBKU09OLnN0cmluZ2lmeShzaGFyZWRQYXRoKSArIFwiKTtcXG5cIiArXG4gICAgICAgIGhlbHBlcnMubWFwKGZ1bmN0aW9uIChoZWxwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBcInZhciBcIiArIGhlbHBlci5hbGlhcyArIFwiID0gXCIgKyBTSEFSRUQgKyBcIi5cIiArIGhlbHBlci5uYW1lICsgXCI7XCI7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpKTtcbiAgICB2YXIgcmVxdWlyZUJsb2NrID0gZGVwZW5kZW5jaWVzLmxlbmd0aCA+IDAgJiYgKGRlcGVuZGVuY2llc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChkKSB7IHJldHVybiBcInZhciBcIiArIGQubmFtZSArIFwiID0gcmVxdWlyZShcXFwiXCIgKyBkLnNvdXJjZSArIFwiXFxcIik7XCI7IH0pXG4gICAgICAgIC5qb2luKCdcXG5cXG4nKSk7XG4gICAgcmV0dXJuIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzMkMiB8fCAodGVtcGxhdGVPYmplY3RfMyQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdFxcdFwiLCBcIlxcblxcdFxcdFwiLCBcIlxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gXCIsIFwiO1wiXSwgW1wiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdFxcdFwiLCBcIlxcblxcdFxcdFwiLCBcIlxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gXCIsIFwiO1wiXSkpLCBiYW5uZXIsIGhlbHBlckJsb2NrLCByZXF1aXJlQmxvY2ssIGdldENvbXBhdGliaWxpdHlTdGF0ZW1lbnRzKGRlcGVuZGVuY2llcyksIGNvZGUsIG5hbWUpO1xufVxuZnVuY3Rpb24gaWlmZShjb2RlLCBuYW1lLCBvcHRpb25zLCBiYW5uZXIsIGRlcGVuZGVuY2llcykge1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgJ25hbWUnIG9wdGlvbiBmb3IgSUlGRSBleHBvcnRcIik7XG4gICAgfVxuICAgIHZhciBnbG9iYWxzID0gZ2V0R2xvYmFscyhkZXBlbmRlbmNpZXMsIG9wdGlvbnMpO1xuICAgIHJldHVybiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF80JDIgfHwgKHRlbXBsYXRlT2JqZWN0XzQkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFwiLCBcIlxcblxcdFxcdHZhciBcIiwgXCIgPSAoZnVuY3Rpb24oXCIsIFwiKSB7IFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRyZXR1cm4gXCIsIFwiO1xcblxcdFxcdH0oXCIsIFwiKSk7XCJdLCBbXCJcXG5cXHRcXHRcIiwgXCJcXG5cXHRcXHR2YXIgXCIsIFwiID0gKGZ1bmN0aW9uKFwiLCBcIikgeyBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFx0XFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0cmV0dXJuIFwiLCBcIjtcXG5cXHRcXHR9KFwiLCBcIikpO1wiXSkpLCBiYW5uZXIsIG9wdGlvbnMubmFtZSwgcGFyYW1TdHJpbmcoZGVwZW5kZW5jaWVzKSwgZ2V0Q29tcGF0aWJpbGl0eVN0YXRlbWVudHMoZGVwZW5kZW5jaWVzKSwgY29kZSwgbmFtZSwgZ2xvYmFscy5qb2luKCcsICcpKTtcbn1cbmZ1bmN0aW9uIHVtZChjb2RlLCBuYW1lLCBvcHRpb25zLCBiYW5uZXIsIGRlcGVuZGVuY2llcykge1xuICAgIGlmICghb3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgJ25hbWUnIG9wdGlvbiBmb3IgVU1EIGV4cG9ydFwiKTtcbiAgICB9XG4gICAgdmFyIGFtZElkID0gb3B0aW9ucy5hbWQgJiYgb3B0aW9ucy5hbWQuaWQgPyBcIidcIiArIG9wdGlvbnMuYW1kLmlkICsgXCInLCBcIiA6ICcnO1xuICAgIHZhciBhbWREZXBzID0gZGVwZW5kZW5jaWVzLmxlbmd0aFxuICAgICAgICA/IFwiW1wiICsgZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gXCJcXFwiXCIgKyByZW1vdmVFeHRlbnNpb24oZC5zb3VyY2UpICsgXCJcXFwiXCI7IH0pLmpvaW4oJywgJykgKyBcIl0sIFwiXG4gICAgICAgIDogJyc7XG4gICAgdmFyIGNqc0RlcHMgPSBkZXBlbmRlbmNpZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gXCJyZXF1aXJlKFxcXCJcIiArIGQuc291cmNlICsgXCJcXFwiKVwiOyB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB2YXIgZ2xvYmFscyA9IGdldEdsb2JhbHMoZGVwZW5kZW5jaWVzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNSQxIHx8ICh0ZW1wbGF0ZU9iamVjdF81JDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcIiwgXCJcXG5cXHRcXHQoZnVuY3Rpb24oZ2xvYmFsLCBmYWN0b3J5KSB7XFxuXFx0XFx0XFx0dHlwZW9mIGV4cG9ydHMgPT09IFxcXCJvYmplY3RcXFwiICYmIHR5cGVvZiBtb2R1bGUgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFwiLCBcIikgOlxcblxcdFxcdFxcdHR5cGVvZiBkZWZpbmUgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShcIiwgXCJcIiwgXCJmYWN0b3J5KSA6XFxuXFx0XFx0XFx0KGdsb2JhbC5cIiwgXCIgPSBmYWN0b3J5KFwiLCBcIikpO1xcblxcdFxcdH0odGhpcywgKGZ1bmN0aW9uIChcIiwgXCIpIHsgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdHJldHVybiBcIiwgXCI7XFxuXFxuXFx0XFx0fSkpKTtcIl0sIFtcIlxcblxcdFxcdFwiLCBcIlxcblxcdFxcdChmdW5jdGlvbihnbG9iYWwsIGZhY3RvcnkpIHtcXG5cXHRcXHRcXHR0eXBlb2YgZXhwb3J0cyA9PT0gXFxcIm9iamVjdFxcXCIgJiYgdHlwZW9mIG1vZHVsZSAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXCIsIFwiKSA6XFxuXFx0XFx0XFx0dHlwZW9mIGRlZmluZSA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFwiLCBcIlwiLCBcImZhY3RvcnkpIDpcXG5cXHRcXHRcXHQoZ2xvYmFsLlwiLCBcIiA9IGZhY3RvcnkoXCIsIFwiKSk7XFxuXFx0XFx0fSh0aGlzLCAoZnVuY3Rpb24gKFwiLCBcIikgeyBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XFx0cmV0dXJuIFwiLCBcIjtcXG5cXG5cXHRcXHR9KSkpO1wiXSkpLCBiYW5uZXIsIGNqc0RlcHMsIGFtZElkLCBhbWREZXBzLCBvcHRpb25zLm5hbWUsIGdsb2JhbHMuam9pbignLCAnKSwgcGFyYW1TdHJpbmcoZGVwZW5kZW5jaWVzKSwgZ2V0Q29tcGF0aWJpbGl0eVN0YXRlbWVudHMoZGVwZW5kZW5jaWVzKSwgY29kZSwgbmFtZSk7XG59XG5mdW5jdGlvbiBleHByKGNvZGUsIG5hbWUsIG9wdGlvbnMsIGJhbm5lciwgZGVwZW5kZW5jaWVzKSB7XG4gICAgdmFyIGdsb2JhbHMgPSBnZXRHbG9iYWxzKGRlcGVuZGVuY2llcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzYkMSB8fCAodGVtcGxhdGVPYmplY3RfNiQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0KGZ1bmN0aW9uIChcIiwgXCIpIHsgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdHJldHVybiBcIiwgXCI7XFxuXFx0XFx0fShcIiwgXCIpKVwiXSwgW1wiXFxuXFx0XFx0KGZ1bmN0aW9uIChcIiwgXCIpIHsgXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdHJldHVybiBcIiwgXCI7XFxuXFx0XFx0fShcIiwgXCIpKVwiXSkpLCBwYXJhbVN0cmluZyhkZXBlbmRlbmNpZXMpLCBiYW5uZXIsIGdldENvbXBhdGliaWxpdHlTdGF0ZW1lbnRzKGRlcGVuZGVuY2llcyksIGNvZGUsIG5hbWUsIGdsb2JhbHMuam9pbignLCAnKSk7XG59XG5mdW5jdGlvbiBwYXJhbVN0cmluZyhkZXBlbmRlbmNpZXMpIHtcbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXAubmFtZTsgfSkuam9pbignLCAnKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUV4dGVuc2lvbihmaWxlKSB7XG4gICAgdmFyIGluZGV4ID0gZmlsZS5sYXN0SW5kZXhPZignLicpO1xuICAgIHJldHVybiB+aW5kZXggPyBmaWxlLnNsaWNlKDAsIGluZGV4KSA6IGZpbGU7XG59XG5mdW5jdGlvbiBnZXRDb21wYXRpYmlsaXR5U3RhdGVtZW50cyhkZXBlbmRlbmNpZXMpIHtcbiAgICBpZiAoIWRlcGVuZGVuY2llcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XG4gICAgZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgc3RhdGVtZW50cy5wdXNoLmFwcGx5KHN0YXRlbWVudHMsIGRlcGVuZGVuY3kuc3RhdGVtZW50cyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0YXRlbWVudHMuam9pbignXFxuJyk7XG59XG5mdW5jdGlvbiBnZXRHbG9iYWxzKGRlcGVuZGVuY2llcywgb3B0aW9ucykge1xuICAgIHZhciBnbG9iYWxzID0gb3B0aW9ucy5nbG9iYWxzLCBvbmVycm9yID0gb3B0aW9ucy5vbmVycm9yLCBvbndhcm4gPSBvcHRpb25zLm9ud2FybjtcbiAgICB2YXIgZ2xvYmFsRm4gPSBnZXRHbG9iYWxGbihnbG9iYWxzKTtcbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgbmFtZSA9IGdsb2JhbEZuKGQuc291cmNlKTtcbiAgICAgICAgaWYgKCFuYW1lKSB7XG4gICAgICAgICAgICBpZiAoZC5uYW1lLnN0YXJ0c1dpdGgoJ19faW1wb3J0JykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZGV0ZXJtaW5lIG5hbWUgZm9yIGltcG9ydGVkIG1vZHVsZSAnXCIgKyBkLnNvdXJjZSArIFwiJyBcXHUyMDEzIHVzZSBvcHRpb25zLmdsb2JhbHNcIik7XG4gICAgICAgICAgICAgICAgb25lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgd2FybmluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogXCJObyBuYW1lIHdhcyBzdXBwbGllZCBmb3IgaW1wb3J0ZWQgbW9kdWxlICdcIiArIGQuc291cmNlICsgXCInLiBHdWVzc2luZyAnXCIgKyBkLm5hbWUgKyBcIicsIGJ1dCB5b3Ugc2hvdWxkIHVzZSBvcHRpb25zLmdsb2JhbHNcIlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb253YXJuKHdhcm5pbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmFtZSA9IGQubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmFtZTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbEZuKGdsb2JhbHMpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbHMgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiBnbG9iYWxzO1xuICAgIGlmICh0eXBlb2YgZ2xvYmFscyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gZ2xvYmFsc1tpZF07IH07XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH07XG59XG52YXIgdGVtcGxhdGVPYmplY3RfMSQyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzIkMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF8zJDI7XG52YXIgdGVtcGxhdGVPYmplY3RfNCQyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzUkMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF82JDE7XG5cbmZ1bmN0aW9uIGNsb25lKG5vZGUpIHtcbiAgICB2YXIgY2xvbmVkID0ge307XG4gICAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbm9kZVtrZXldO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGNsb25lZFtrZXldID0gdmFsdWUubWFwKGNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjbG9uZWRba2V5XSA9IGNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsb25lZFtrZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZDtcbn1cblxudmFyIHRlc3QgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuVEVTVDtcblxudmFyIGJpbmFyeU9wZXJhdG9ycyA9IHtcbiAgICAnKionOiAxNSxcbiAgICAnKic6IDE0LFxuICAgICcvJzogMTQsXG4gICAgJyUnOiAxNCxcbiAgICAnKyc6IDEzLFxuICAgICctJzogMTMsXG4gICAgJzw8JzogMTIsXG4gICAgJz4+JzogMTIsXG4gICAgJz4+Pic6IDEyLFxuICAgICc8JzogMTEsXG4gICAgJzw9JzogMTEsXG4gICAgJz4nOiAxMSxcbiAgICAnPj0nOiAxMSxcbiAgICAnaW4nOiAxMSxcbiAgICAnaW5zdGFuY2VvZic6IDExLFxuICAgICc9PSc6IDEwLFxuICAgICchPSc6IDEwLFxuICAgICc9PT0nOiAxMCxcbiAgICAnIT09JzogMTAsXG4gICAgJyYnOiA5LFxuICAgICdeJzogOCxcbiAgICAnfCc6IDdcbn07XG52YXIgbG9naWNhbE9wZXJhdG9ycyA9IHtcbiAgICAnJiYnOiA2LFxuICAgICd8fCc6IDVcbn07XG52YXIgcHJlY2VkZW5jZSA9IHtcbiAgICBMaXRlcmFsOiBmdW5jdGlvbiAoKSB7IHJldHVybiAyMTsgfSxcbiAgICBJZGVudGlmaWVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiAyMTsgfSxcbiAgICBQYXJlbnRoZXNpemVkRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gMjA7IH0sXG4gICAgTWVtYmVyRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTk7IH0sXG4gICAgTmV3RXhwcmVzc2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTk7IH0sXG4gICAgQ2FsbEV4cHJlc3Npb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE5OyB9LFxuICAgIFVwZGF0ZUV4cHJlc3Npb246IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDE3OyB9LFxuICAgIFVuYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gMTY7IH0sXG4gICAgQmluYXJ5RXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHsgcmV0dXJuIGJpbmFyeU9wZXJhdG9yc1tleHByZXNzaW9uLm9wZXJhdG9yXTsgfSxcbiAgICBMb2dpY2FsRXhwcmVzc2lvbjogZnVuY3Rpb24gKGV4cHJlc3Npb24pIHsgcmV0dXJuIGxvZ2ljYWxPcGVyYXRvcnNbZXhwcmVzc2lvbi5vcGVyYXRvcl07IH0sXG4gICAgQ29uZGl0aW9uYWxFeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0OyB9LFxuICAgIEFzc2lnbm1lbnRFeHByZXNzaW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiAzOyB9LFxuICAgIFlpZWxkRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gMjsgfSxcbiAgICBTcHJlYWRFbGVtZW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9LFxuICAgIFNlcXVlbmNlRXhwcmVzc2lvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gMDsgfVxufTtcbmZ1bmN0aW9uIGdldEV4cHJlc3Npb25QcmVjZWRlbmNlKGV4cHJlc3Npb24pIHtcbiAgICByZXR1cm4gZXhwcmVzc2lvbi50eXBlIGluIHByZWNlZGVuY2UgPyBwcmVjZWRlbmNlW2V4cHJlc3Npb24udHlwZV0oZXhwcmVzc2lvbikgOiAwO1xufVxuXG52YXIgQXR0cmlidXRlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZShfYSkge1xuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gX2EuZ2VuZXJhdG9yLCBuYW1lID0gX2EubmFtZSwgdmFsdWUgPSBfYS52YWx1ZSwgcGFyZW50ID0gX2EucGFyZW50O1xuICAgICAgICB0aGlzLnR5cGUgPSAnQXR0cmlidXRlJztcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIEF0dHJpYnV0ZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgdmFyIHN0eWxlUHJvcHMgPSBvcHRpbWl6ZVN0eWxlKHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgaWYgKHN0eWxlUHJvcHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclN0eWxlKGJsb2NrLCBzdHlsZVByb3BzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGFkYXRhID0gbm9kZS5uYW1lc3BhY2UgPyBudWxsIDogYXR0cmlidXRlTG9va3VwW25hbWVdO1xuICAgICAgICBpZiAobWV0YWRhdGEgJiYgbWV0YWRhdGEuYXBwbGllc1RvICYmICF+bWV0YWRhdGEuYXBwbGllc1RvLmluZGV4T2Yobm9kZS5uYW1lKSlcbiAgICAgICAgICAgIG1ldGFkYXRhID0gbnVsbDtcbiAgICAgICAgdmFyIGlzSW5kaXJlY3RseUJvdW5kVmFsdWUgPSBuYW1lID09PSAndmFsdWUnICYmXG4gICAgICAgICAgICAobm9kZS5uYW1lID09PSAnb3B0aW9uJyB8fCAvLyBUT0RPIGNoZWNrIGl0J3MgYWN0dWFsbHkgYm91bmRcbiAgICAgICAgICAgICAgICAobm9kZS5uYW1lID09PSAnaW5wdXQnICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5maW5kKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGUudHlwZSA9PT0gJ0JpbmRpbmcnICYmIC9jaGVja2VkfGdyb3VwLy50ZXN0KGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGlzSW5kaXJlY3RseUJvdW5kVmFsdWVcbiAgICAgICAgICAgID8gJ19fdmFsdWUnXG4gICAgICAgICAgICA6IG1ldGFkYXRhICYmIG1ldGFkYXRhLnByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8geGxpbmsgaXMgYSBzcGVjaWFsIGNhc2UuLi4gd2UgY291bGQgbWF5YmUgZXh0ZW5kIHRoaXMgdG8gZ2VuZXJpY1xuICAgICAgICAvLyBuYW1lc3BhY2VkIGF0dHJpYnV0ZXMgYnV0IEknbSBub3Qgc3VyZSB0aGF0J3MgYXBwbGljYWJsZSBpblxuICAgICAgICAvLyBIVE1MNT9cbiAgICAgICAgdmFyIG1ldGhvZCA9IG5hbWUuc2xpY2UoMCwgNikgPT09ICd4bGluazonXG4gICAgICAgICAgICA/ICdAc2V0WGxpbmtBdHRyaWJ1dGUnXG4gICAgICAgICAgICA6ICdAc2V0QXR0cmlidXRlJztcbiAgICAgICAgdmFyIGlzRHluYW1pYyA9IHRoaXMuaXNEeW5hbWljKCk7XG4gICAgICAgIHZhciBpc0xlZ2FjeUlucHV0VHlwZSA9IHRoaXMuZ2VuZXJhdG9yLmxlZ2FjeSAmJiBuYW1lID09PSAndHlwZScgJiYgdGhpcy5wYXJlbnQubmFtZSA9PT0gJ2lucHV0JztcbiAgICAgICAgdmFyIGlzRGF0YVNldCA9IC9eZGF0YS0vLnRlc3QobmFtZSkgJiYgIXRoaXMuZ2VuZXJhdG9yLmxlZ2FjeSAmJiAhbm9kZS5uYW1lc3BhY2U7XG4gICAgICAgIHZhciBjYW1lbENhc2VOYW1lID0gaXNEYXRhU2V0ID8gbmFtZS5yZXBsYWNlKCdkYXRhLScsICcnKS5yZXBsYWNlKC8oLVxcdykvZywgZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtWzFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH0pIDogbmFtZTtcbiAgICAgICAgaWYgKGlzRHluYW1pYykge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGFsbERlcGVuZGVuY2llc18xID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdmFyIHNob3VsZENhY2hlID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIGhhc0NoYW5nZWFibGVJbmRleF8xO1xuICAgICAgICAgICAgLy8gVE9ETyBzb21lIG9mIHRoaXMgY29kZSBpcyByZXBlYXRlZCBpbiBUYWcudHMg4oCUIHdvdWxkIGJlIGdvb2QgdG9cbiAgICAgICAgICAgIC8vIERSWSBpdCBvdXQgaWYgdGhhdCdzIHBvc3NpYmxlIHdpdGhvdXQgaW50cm9kdWNpbmcgY3JhenkgaW5kaXJlY3Rpb25cbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIHNpbmdsZSB7e3RhZ319IOKAlCBtYXkgYmUgYSBub24tc3RyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGV4cHJlc3Npb24gPSB0aGlzLnZhbHVlWzBdLmV4cHJlc3Npb247XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBibG9jay5jb250ZXh0dWFsaXNlKGV4cHJlc3Npb24pLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gdGhpcy52YWx1ZVswXS5tZXRhZGF0YSwgZGVwZW5kZW5jaWVzID0gX2EuZGVwZW5kZW5jaWVzLCBzbmlwcGV0ID0gX2Euc25pcHBldDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNuaXBwZXQ7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGVwZW5kZW5jaWVzXzEuYWRkKGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGhhc0NoYW5nZWFibGVJbmRleF8xID0gQXJyYXkuZnJvbShpbmRleGVzKS5zb21lKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gYmxvY2suY2hhbmdlYWJsZUluZGV4ZXMuZ2V0KGluZGV4KTsgfSk7XG4gICAgICAgICAgICAgICAgc2hvdWxkQ2FjaGUgPSAoZXhwcmVzc2lvbi50eXBlICE9PSAnSWRlbnRpZmllcicgfHxcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suY29udGV4dHMuaGFzKGV4cHJlc3Npb24ubmFtZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgaGFzQ2hhbmdlYWJsZUluZGV4XzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gJ3t7Zm9vfX0ge3tiYXJ9fScg4oCUIHRyZWF0IGFzIHN0cmluZyBjb25jYXRlbmF0aW9uXG4gICAgICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICAodGhpcy52YWx1ZVswXS50eXBlID09PSAnVGV4dCcgPyAnJyA6IFwiXFxcIlxcXCIgKyBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09ICdUZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGNodW5rLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBibG9jay5jb250ZXh0dWFsaXNlKGNodW5rLmV4cHJlc3Npb24pLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGNodW5rLm1ldGFkYXRhLCBkZXBlbmRlbmNpZXMgPSBfYS5kZXBlbmRlbmNpZXMsIHNuaXBwZXQgPSBfYS5zbmlwcGV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuZnJvbShpbmRleGVzKS5zb21lKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gYmxvY2suY2hhbmdlYWJsZUluZGV4ZXMuZ2V0KGluZGV4KTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZWFibGVJbmRleF8xID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGVwZW5kZW5jaWVzXzEuYWRkKGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4cHJlc3Npb25QcmVjZWRlbmNlKGNodW5rLmV4cHJlc3Npb24pIDw9IDEzID8gXCIoXCIgKyBzbmlwcGV0ICsgXCIpXCIgOiBzbmlwcGV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyArICcpO1xuICAgICAgICAgICAgICAgIHNob3VsZENhY2hlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc1NlbGVjdFZhbHVlQXR0cmlidXRlID0gbmFtZSA9PT0gJ3ZhbHVlJyAmJiBub2RlLm5hbWUgPT09ICdzZWxlY3QnO1xuICAgICAgICAgICAgdmFyIGxhc3QgPSAoc2hvdWxkQ2FjaGUgfHwgaXNTZWxlY3RWYWx1ZUF0dHJpYnV0ZSkgJiYgYmxvY2suZ2V0VW5pcXVlTmFtZShub2RlW1widmFyXCJdICsgXCJfXCIgKyBuYW1lLnJlcGxhY2UoL1teYS16QS1aXyRdL2csICdfJykgKyBcIl92YWx1ZVwiKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDYWNoZSB8fCBpc1NlbGVjdFZhbHVlQXR0cmlidXRlKVxuICAgICAgICAgICAgICAgIGJsb2NrLmFkZFZhcmlhYmxlKGxhc3QpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZXIgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgaW5pdCA9IHNob3VsZENhY2hlID8gbGFzdCArIFwiID0gXCIgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzTGVnYWN5SW5wdXRUeXBlKSB7XG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaHlkcmF0ZS5hZGRMaW5lKFwiQHNldElucHV0VHlwZShcIiArIG5vZGVbXCJ2YXJcIl0gKyBcIiwgXCIgKyBpbml0ICsgXCIpO1wiKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVyID0gXCJAc2V0SW5wdXRUeXBlKFwiICsgbm9kZVtcInZhclwiXSArIFwiLCBcIiArIChzaG91bGRDYWNoZSA/IGxhc3QgOiB2YWx1ZSkgKyBcIik7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1NlbGVjdFZhbHVlQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gYW5ub3lpbmcgc3BlY2lhbCBjYXNlXG4gICAgICAgICAgICAgICAgdmFyIGlzTXVsdGlwbGVTZWxlY3QgPSBub2RlLmdldFN0YXRpY0F0dHJpYnV0ZVZhbHVlKCdtdWx0aXBsZScpO1xuICAgICAgICAgICAgICAgIHZhciBpID0gYmxvY2suZ2V0VW5pcXVlTmFtZSgnaScpO1xuICAgICAgICAgICAgICAgIHZhciBvcHRpb24gPSBibG9jay5nZXRVbmlxdWVOYW1lKCdvcHRpb24nKTtcbiAgICAgICAgICAgICAgICB2YXIgaWZTdGF0ZW1lbnQgPSBpc011bHRpcGxlU2VsZWN0XG4gICAgICAgICAgICAgICAgICAgID8gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMSQzIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuc2VsZWN0ZWQgPSB+XCIsIFwiLmluZGV4T2YoXCIsIFwiLl9fdmFsdWUpO1wiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLnNlbGVjdGVkID0gflwiLCBcIi5pbmRleE9mKFwiLCBcIi5fX3ZhbHVlKTtcIl0pKSwgb3B0aW9uLCBsYXN0LCBvcHRpb24pIDogZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMiQzIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiLl9fdmFsdWUgPT09IFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5zZWxlY3RlZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIi5fX3ZhbHVlID09PSBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuc2VsZWN0ZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cIl0pKSwgb3B0aW9uLCBsYXN0LCBvcHRpb24pO1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIgPSBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8zJDMgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdGZvciAodmFyIFwiLCBcIiA9IDA7IFwiLCBcIiA8IFwiLCBcIi5vcHRpb25zLmxlbmd0aDsgXCIsIFwiICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiLm9wdGlvbnNbXCIsIFwiXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHZhciBcIiwgXCIgPSAwOyBcIiwgXCIgPCBcIiwgXCIub3B0aW9ucy5sZW5ndGg7IFwiLCBcIiArPSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIi5vcHRpb25zW1wiLCBcIl07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFwiXSkpLCBpLCBpLCBub2RlW1widmFyXCJdLCBpLCBvcHRpb24sIG5vZGVbXCJ2YXJcIl0sIGksIGlmU3RhdGVtZW50KTtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy5oeWRyYXRlLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzQkMyB8fCAodGVtcGxhdGVPYmplY3RfNCQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiXSkpLCBsYXN0LCB2YWx1ZSwgdXBkYXRlcikpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRMaW5lKGxhc3QgKyBcIiA9IFwiICsgdmFsdWUgKyBcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy5oeWRyYXRlLmFkZExpbmUobm9kZVtcInZhclwiXSArIFwiLlwiICsgcHJvcGVydHlOYW1lICsgXCIgPSBcIiArIGluaXQgKyBcIjtcIik7XG4gICAgICAgICAgICAgICAgdXBkYXRlciA9IG5vZGVbXCJ2YXJcIl0gKyBcIi5cIiArIHByb3BlcnR5TmFtZSArIFwiID0gXCIgKyAoc2hvdWxkQ2FjaGUgfHwgaXNTZWxlY3RWYWx1ZUF0dHJpYnV0ZSA/IGxhc3QgOiB2YWx1ZSkgKyBcIjtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0YVNldCkge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmh5ZHJhdGUuYWRkTGluZShub2RlW1widmFyXCJdICsgXCIuZGF0YXNldC5cIiArIGNhbWVsQ2FzZU5hbWUgKyBcIiA9IFwiICsgaW5pdCArIFwiO1wiKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVyID0gbm9kZVtcInZhclwiXSArIFwiLmRhdGFzZXQuXCIgKyBjYW1lbENhc2VOYW1lICsgXCIgPSBcIiArIChzaG91bGRDYWNoZSB8fCBpc1NlbGVjdFZhbHVlQXR0cmlidXRlID8gbGFzdCA6IHZhbHVlKSArIFwiO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaHlkcmF0ZS5hZGRMaW5lKG1ldGhvZCArIFwiKFwiICsgbm9kZVtcInZhclwiXSArIFwiLCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIiArIGluaXQgKyBcIik7XCIpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIgPSBtZXRob2QgKyBcIihcIiArIG5vZGVbXCJ2YXJcIl0gKyBcIiwgXFxcIlwiICsgbmFtZSArIFwiXFxcIiwgXCIgKyAoc2hvdWxkQ2FjaGUgfHwgaXNTZWxlY3RWYWx1ZUF0dHJpYnV0ZSA/IGxhc3QgOiB2YWx1ZSkgKyBcIik7XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWxsRGVwZW5kZW5jaWVzXzEuc2l6ZSB8fCBoYXNDaGFuZ2VhYmxlSW5kZXhfMSB8fCBpc1NlbGVjdFZhbHVlQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IEFycmF5LmZyb20oYWxsRGVwZW5kZW5jaWVzXzEpO1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkQ2hlY2sgPSAoKGJsb2NrLmhhc091dHJvTWV0aG9kID8gXCIjb3V0cm9pbmcgfHwgXCIgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXBlbmRlbmN5KSB7IHJldHVybiBcImNoYW5nZWQuXCIgKyBkZXBlbmRlbmN5OyB9KS5qb2luKCcgfHwgJykpO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVDYWNoZWRWYWx1ZSA9IGxhc3QgKyBcIiAhPT0gKFwiICsgbGFzdCArIFwiID0gXCIgKyB2YWx1ZSArIFwiKVwiO1xuICAgICAgICAgICAgICAgIHZhciBjb25kaXRpb24gPSBzaG91bGRDYWNoZSA/XG4gICAgICAgICAgICAgICAgICAgIChkZXBlbmRlbmNpZXMubGVuZ3RoID8gXCIoXCIgKyBjaGFuZ2VkQ2hlY2sgKyBcIikgJiYgXCIgKyB1cGRhdGVDYWNoZWRWYWx1ZSA6IHVwZGF0ZUNhY2hlZFZhbHVlKSA6XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRDaGVjaztcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy51cGRhdGUuYWRkQ29uZGl0aW9uYWwoY29uZGl0aW9uLCB1cGRhdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/ICd0cnVlJ1xuICAgICAgICAgICAgICAgIDogdGhpcy52YWx1ZS5sZW5ndGggPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBcIicnXCJcbiAgICAgICAgICAgICAgICAgICAgOiBzdHJpbmdpZnkodGhpcy52YWx1ZVswXS5kYXRhKTtcbiAgICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSAoaXNMZWdhY3lJbnB1dFR5cGUgPyBcIkBzZXRJbnB1dFR5cGUoXCIgKyBub2RlW1widmFyXCJdICsgXCIsIFwiICsgdmFsdWUgKyBcIik7XCIgOlxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSA/IG5vZGVbXCJ2YXJcIl0gKyBcIi5cIiArIHByb3BlcnR5TmFtZSArIFwiID0gXCIgKyB2YWx1ZSArIFwiO1wiIDpcbiAgICAgICAgICAgICAgICAgICAgaXNEYXRhU2V0ID8gbm9kZVtcInZhclwiXSArIFwiLmRhdGFzZXQuXCIgKyBjYW1lbENhc2VOYW1lICsgXCIgPSBcIiArIHZhbHVlICsgXCI7XCIgOlxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kICsgXCIoXCIgKyBub2RlW1widmFyXCJdICsgXCIsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIFwiICsgdmFsdWUgKyBcIik7XCIpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaHlkcmF0ZS5hZGRMaW5lKHN0YXRlbWVudCk7XG4gICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ug4oCTIGF1dG9mb2N1cy4gaGFzIHRvIGJlIGhhbmRsZWQgaW4gYSBiaXQgb2YgYSB3ZWlyZCB3YXlcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID09PSB0cnVlICYmIG5hbWUgPT09ICdhdXRvZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgYmxvY2suYXV0b2ZvY3VzID0gbm9kZVtcInZhclwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNJbmRpcmVjdGx5Qm91bmRWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVZhbHVlID0gbm9kZVtcInZhclwiXSArIFwiLnZhbHVlID0gXCIgKyBub2RlW1widmFyXCJdICsgXCIuX192YWx1ZTtcIjtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmh5ZHJhdGUuYWRkTGluZSh1cGRhdGVWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoaXNEeW5hbWljKVxuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRMaW5lKHVwZGF0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXR0cmlidXRlLnByb3RvdHlwZS5yZW5kZXJTdHlsZSA9IGZ1bmN0aW9uIChibG9jaywgc3R5bGVQcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzdHlsZVByb3BzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc0R5bmFtaWMkMShwcm9wLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBhbGxEZXBlbmRlbmNpZXNfMiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2hvdWxkQ2FjaGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0NoYW5nZWFibGVJbmRleF8yO1xuICAgICAgICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgKChwcm9wLnZhbHVlLmxlbmd0aCA9PT0gMSB8fCBwcm9wLnZhbHVlWzBdLnR5cGUgPT09ICdUZXh0JykgPyAnJyA6IFwiXFxcIlxcXCIgKyBcIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09ICdUZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5naWZ5KGNodW5rLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4ZXMgPSBibG9jay5jb250ZXh0dWFsaXNlKGNodW5rLmV4cHJlc3Npb24pLmluZGV4ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGNodW5rLm1ldGFkYXRhLCBkZXBlbmRlbmNpZXMgPSBfYS5kZXBlbmRlbmNpZXMsIHNuaXBwZXQgPSBfYS5zbmlwcGV0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuZnJvbShpbmRleGVzKS5zb21lKGZ1bmN0aW9uIChpbmRleCkgeyByZXR1cm4gYmxvY2suY2hhbmdlYWJsZUluZGV4ZXMuZ2V0KGluZGV4KTsgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoYW5nZWFibGVJbmRleF8yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGVwZW5kZW5jaWVzXzIuYWRkKGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEV4cHJlc3Npb25QcmVjZWRlbmNlKGNodW5rLmV4cHJlc3Npb24pIDw9IDEzID8gXCIoIFwiICsgc25pcHBldCArIFwiIClcIiA6IHNuaXBwZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuam9pbignICsgJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbERlcGVuZGVuY2llc18yLnNpemUgfHwgaGFzQ2hhbmdlYWJsZUluZGV4XzIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IEFycmF5LmZyb20oYWxsRGVwZW5kZW5jaWVzXzIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29uZGl0aW9uID0gKChibG9jay5oYXNPdXRyb01ldGhvZCA/IFwiI291dHJvaW5nIHx8IFwiIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHsgcmV0dXJuIFwiY2hhbmdlZC5cIiArIGRlcGVuZGVuY3k7IH0pLmpvaW4oJyB8fCAnKSk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRDb25kaXRpb25hbChjb25kaXRpb24sIFwiQHNldFN0eWxlKFwiICsgX3RoaXMucGFyZW50W1widmFyXCJdICsgXCIsIFxcXCJcIiArIHByb3Aua2V5ICsgXCJcXFwiLCBcIiArIHZhbHVlICsgXCIpO1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmluZ2lmeShwcm9wLnZhbHVlWzBdLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaHlkcmF0ZS5hZGRMaW5lKFwiQHNldFN0eWxlKFwiICsgX3RoaXMucGFyZW50W1widmFyXCJdICsgXCIsIFxcXCJcIiArIHByb3Aua2V5ICsgXCJcXFwiLCBcIiArIHZhbHVlICsgXCIpO1wiKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdHRyaWJ1dGUucHJvdG90eXBlLmlzRHluYW1pYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IHRydWUgfHwgdGhpcy52YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVbMF0udHlwZSAhPT0gJ1RleHQnO1xuICAgIH07XG4gICAgcmV0dXJuIEF0dHJpYnV0ZTtcbn0oKSk7XG4vLyBzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvQXR0cmlidXRlc1xudmFyIGF0dHJpYnV0ZUxvb2t1cCA9IHtcbiAgICBhY2NlcHQ6IHsgYXBwbGllc1RvOiBbJ2Zvcm0nLCAnaW5wdXQnXSB9LFxuICAgICdhY2NlcHQtY2hhcnNldCc6IHsgcHJvcGVydHlOYW1lOiAnYWNjZXB0Q2hhcnNldCcsIGFwcGxpZXNUbzogWydmb3JtJ10gfSxcbiAgICBhY2Nlc3NrZXk6IHsgcHJvcGVydHlOYW1lOiAnYWNjZXNzS2V5JyB9LFxuICAgIGFjdGlvbjogeyBhcHBsaWVzVG86IFsnZm9ybSddIH0sXG4gICAgYWxpZ246IHtcbiAgICAgICAgYXBwbGllc1RvOiBbXG4gICAgICAgICAgICAnYXBwbGV0JyxcbiAgICAgICAgICAgICdjYXB0aW9uJyxcbiAgICAgICAgICAgICdjb2wnLFxuICAgICAgICAgICAgJ2NvbGdyb3VwJyxcbiAgICAgICAgICAgICdocicsXG4gICAgICAgICAgICAnaWZyYW1lJyxcbiAgICAgICAgICAgICdpbWcnLFxuICAgICAgICAgICAgJ3RhYmxlJyxcbiAgICAgICAgICAgICd0Ym9keScsXG4gICAgICAgICAgICAndGQnLFxuICAgICAgICAgICAgJ3Rmb290JyxcbiAgICAgICAgICAgICd0aCcsXG4gICAgICAgICAgICAndGhlYWQnLFxuICAgICAgICAgICAgJ3RyJyxcbiAgICAgICAgXVxuICAgIH0sXG4gICAgYWxsb3dmdWxsc2NyZWVuOiB7IHByb3BlcnR5TmFtZTogJ2FsbG93RnVsbHNjcmVlbicsIGFwcGxpZXNUbzogWydpZnJhbWUnXSB9LFxuICAgIGFsdDogeyBhcHBsaWVzVG86IFsnYXBwbGV0JywgJ2FyZWEnLCAnaW1nJywgJ2lucHV0J10gfSxcbiAgICBhc3luYzogeyBhcHBsaWVzVG86IFsnc2NyaXB0J10gfSxcbiAgICBhdXRvY29tcGxldGU6IHsgYXBwbGllc1RvOiBbJ2Zvcm0nLCAnaW5wdXQnXSB9LFxuICAgIGF1dG9mb2N1czogeyBhcHBsaWVzVG86IFsnYnV0dG9uJywgJ2lucHV0JywgJ2tleWdlbicsICdzZWxlY3QnLCAndGV4dGFyZWEnXSB9LFxuICAgIGF1dG9wbGF5OiB7IGFwcGxpZXNUbzogWydhdWRpbycsICd2aWRlbyddIH0sXG4gICAgYXV0b3NhdmU6IHsgYXBwbGllc1RvOiBbJ2lucHV0J10gfSxcbiAgICBiZ2NvbG9yOiB7XG4gICAgICAgIHByb3BlcnR5TmFtZTogJ2JnQ29sb3InLFxuICAgICAgICBhcHBsaWVzVG86IFtcbiAgICAgICAgICAgICdib2R5JyxcbiAgICAgICAgICAgICdjb2wnLFxuICAgICAgICAgICAgJ2NvbGdyb3VwJyxcbiAgICAgICAgICAgICdtYXJxdWVlJyxcbiAgICAgICAgICAgICd0YWJsZScsXG4gICAgICAgICAgICAndGJvZHknLFxuICAgICAgICAgICAgJ3Rmb290JyxcbiAgICAgICAgICAgICd0ZCcsXG4gICAgICAgICAgICAndGgnLFxuICAgICAgICAgICAgJ3RyJyxcbiAgICAgICAgXVxuICAgIH0sXG4gICAgYm9yZGVyOiB7IGFwcGxpZXNUbzogWydpbWcnLCAnb2JqZWN0JywgJ3RhYmxlJ10gfSxcbiAgICBidWZmZXJlZDogeyBhcHBsaWVzVG86IFsnYXVkaW8nLCAndmlkZW8nXSB9LFxuICAgIGNoYWxsZW5nZTogeyBhcHBsaWVzVG86IFsna2V5Z2VuJ10gfSxcbiAgICBjaGFyc2V0OiB7IGFwcGxpZXNUbzogWydtZXRhJywgJ3NjcmlwdCddIH0sXG4gICAgY2hlY2tlZDogeyBhcHBsaWVzVG86IFsnY29tbWFuZCcsICdpbnB1dCddIH0sXG4gICAgY2l0ZTogeyBhcHBsaWVzVG86IFsnYmxvY2txdW90ZScsICdkZWwnLCAnaW5zJywgJ3EnXSB9LFxuICAgIFwiY2xhc3NcIjogeyBwcm9wZXJ0eU5hbWU6ICdjbGFzc05hbWUnIH0sXG4gICAgY29kZTogeyBhcHBsaWVzVG86IFsnYXBwbGV0J10gfSxcbiAgICBjb2RlYmFzZTogeyBwcm9wZXJ0eU5hbWU6ICdjb2RlQmFzZScsIGFwcGxpZXNUbzogWydhcHBsZXQnXSB9LFxuICAgIGNvbG9yOiB7IGFwcGxpZXNUbzogWydiYXNlZm9udCcsICdmb250JywgJ2hyJ10gfSxcbiAgICBjb2xzOiB7IGFwcGxpZXNUbzogWyd0ZXh0YXJlYSddIH0sXG4gICAgY29sc3BhbjogeyBwcm9wZXJ0eU5hbWU6ICdjb2xTcGFuJywgYXBwbGllc1RvOiBbJ3RkJywgJ3RoJ10gfSxcbiAgICBjb250ZW50OiB7IGFwcGxpZXNUbzogWydtZXRhJ10gfSxcbiAgICBjb250ZW50ZWRpdGFibGU6IHsgcHJvcGVydHlOYW1lOiAnY29udGVudEVkaXRhYmxlJyB9LFxuICAgIGNvbnRleHRtZW51OiB7fSxcbiAgICBjb250cm9sczogeyBhcHBsaWVzVG86IFsnYXVkaW8nLCAndmlkZW8nXSB9LFxuICAgIGNvb3JkczogeyBhcHBsaWVzVG86IFsnYXJlYSddIH0sXG4gICAgZGF0YTogeyBhcHBsaWVzVG86IFsnb2JqZWN0J10gfSxcbiAgICBkYXRldGltZTogeyBwcm9wZXJ0eU5hbWU6ICdkYXRlVGltZScsIGFwcGxpZXNUbzogWydkZWwnLCAnaW5zJywgJ3RpbWUnXSB9LFxuICAgIFwiZGVmYXVsdFwiOiB7IGFwcGxpZXNUbzogWyd0cmFjayddIH0sXG4gICAgZGVmZXI6IHsgYXBwbGllc1RvOiBbJ3NjcmlwdCddIH0sXG4gICAgZGlyOiB7fSxcbiAgICBkaXJuYW1lOiB7IHByb3BlcnR5TmFtZTogJ2Rpck5hbWUnLCBhcHBsaWVzVG86IFsnaW5wdXQnLCAndGV4dGFyZWEnXSB9LFxuICAgIGRpc2FibGVkOiB7XG4gICAgICAgIGFwcGxpZXNUbzogW1xuICAgICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgICAnY29tbWFuZCcsXG4gICAgICAgICAgICAnZmllbGRzZXQnLFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgICdrZXlnZW4nLFxuICAgICAgICAgICAgJ29wdGdyb3VwJyxcbiAgICAgICAgICAgICdvcHRpb24nLFxuICAgICAgICAgICAgJ3NlbGVjdCcsXG4gICAgICAgICAgICAndGV4dGFyZWEnLFxuICAgICAgICBdXG4gICAgfSxcbiAgICBkb3dubG9hZDogeyBhcHBsaWVzVG86IFsnYScsICdhcmVhJ10gfSxcbiAgICBkcmFnZ2FibGU6IHt9LFxuICAgIGRyb3B6b25lOiB7fSxcbiAgICBlbmN0eXBlOiB7IGFwcGxpZXNUbzogWydmb3JtJ10gfSxcbiAgICBcImZvclwiOiB7IHByb3BlcnR5TmFtZTogJ2h0bWxGb3InLCBhcHBsaWVzVG86IFsnbGFiZWwnLCAnb3V0cHV0J10gfSxcbiAgICBmb3JtOiB7XG4gICAgICAgIGFwcGxpZXNUbzogW1xuICAgICAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICAgICAnZmllbGRzZXQnLFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgICdrZXlnZW4nLFxuICAgICAgICAgICAgJ2xhYmVsJyxcbiAgICAgICAgICAgICdtZXRlcicsXG4gICAgICAgICAgICAnb2JqZWN0JyxcbiAgICAgICAgICAgICdvdXRwdXQnLFxuICAgICAgICAgICAgJ3Byb2dyZXNzJyxcbiAgICAgICAgICAgICdzZWxlY3QnLFxuICAgICAgICAgICAgJ3RleHRhcmVhJyxcbiAgICAgICAgXVxuICAgIH0sXG4gICAgZm9ybWFjdGlvbjogeyBhcHBsaWVzVG86IFsnaW5wdXQnLCAnYnV0dG9uJ10gfSxcbiAgICBoZWFkZXJzOiB7IGFwcGxpZXNUbzogWyd0ZCcsICd0aCddIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIGFwcGxpZXNUbzogWydjYW52YXMnLCAnZW1iZWQnLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdvYmplY3QnLCAndmlkZW8nXVxuICAgIH0sXG4gICAgaGlkZGVuOiB7fSxcbiAgICBoaWdoOiB7IGFwcGxpZXNUbzogWydtZXRlciddIH0sXG4gICAgaHJlZjogeyBhcHBsaWVzVG86IFsnYScsICdhcmVhJywgJ2Jhc2UnLCAnbGluayddIH0sXG4gICAgaHJlZmxhbmc6IHsgYXBwbGllc1RvOiBbJ2EnLCAnYXJlYScsICdsaW5rJ10gfSxcbiAgICAnaHR0cC1lcXVpdic6IHsgcHJvcGVydHlOYW1lOiAnaHR0cEVxdWl2JywgYXBwbGllc1RvOiBbJ21ldGEnXSB9LFxuICAgIGljb246IHsgYXBwbGllc1RvOiBbJ2NvbW1hbmQnXSB9LFxuICAgIGlkOiB7fSxcbiAgICBpbmRldGVybWluYXRlOiB7IGFwcGxpZXNUbzogWydpbnB1dCddIH0sXG4gICAgaXNtYXA6IHsgcHJvcGVydHlOYW1lOiAnaXNNYXAnLCBhcHBsaWVzVG86IFsnaW1nJ10gfSxcbiAgICBpdGVtcHJvcDoge30sXG4gICAga2V5dHlwZTogeyBhcHBsaWVzVG86IFsna2V5Z2VuJ10gfSxcbiAgICBraW5kOiB7IGFwcGxpZXNUbzogWyd0cmFjayddIH0sXG4gICAgbGFiZWw6IHsgYXBwbGllc1RvOiBbJ3RyYWNrJ10gfSxcbiAgICBsYW5nOiB7fSxcbiAgICBsYW5ndWFnZTogeyBhcHBsaWVzVG86IFsnc2NyaXB0J10gfSxcbiAgICBsb29wOiB7IGFwcGxpZXNUbzogWydhdWRpbycsICdiZ3NvdW5kJywgJ21hcnF1ZWUnLCAndmlkZW8nXSB9LFxuICAgIGxvdzogeyBhcHBsaWVzVG86IFsnbWV0ZXInXSB9LFxuICAgIG1hbmlmZXN0OiB7IGFwcGxpZXNUbzogWydodG1sJ10gfSxcbiAgICBtYXg6IHsgYXBwbGllc1RvOiBbJ2lucHV0JywgJ21ldGVyJywgJ3Byb2dyZXNzJ10gfSxcbiAgICBtYXhsZW5ndGg6IHsgcHJvcGVydHlOYW1lOiAnbWF4TGVuZ3RoJywgYXBwbGllc1RvOiBbJ2lucHV0JywgJ3RleHRhcmVhJ10gfSxcbiAgICBtZWRpYTogeyBhcHBsaWVzVG86IFsnYScsICdhcmVhJywgJ2xpbmsnLCAnc291cmNlJywgJ3N0eWxlJ10gfSxcbiAgICBtZXRob2Q6IHsgYXBwbGllc1RvOiBbJ2Zvcm0nXSB9LFxuICAgIG1pbjogeyBhcHBsaWVzVG86IFsnaW5wdXQnLCAnbWV0ZXInXSB9LFxuICAgIG11bHRpcGxlOiB7IGFwcGxpZXNUbzogWydpbnB1dCcsICdzZWxlY3QnXSB9LFxuICAgIG11dGVkOiB7IGFwcGxpZXNUbzogWydhdWRpbycsICd2aWRlbyddIH0sXG4gICAgbmFtZToge1xuICAgICAgICBhcHBsaWVzVG86IFtcbiAgICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgICAgJ2Zvcm0nLFxuICAgICAgICAgICAgJ2ZpZWxkc2V0JyxcbiAgICAgICAgICAgICdpZnJhbWUnLFxuICAgICAgICAgICAgJ2lucHV0JyxcbiAgICAgICAgICAgICdrZXlnZW4nLFxuICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAnb3V0cHV0JyxcbiAgICAgICAgICAgICdzZWxlY3QnLFxuICAgICAgICAgICAgJ3RleHRhcmVhJyxcbiAgICAgICAgICAgICdtYXAnLFxuICAgICAgICAgICAgJ21ldGEnLFxuICAgICAgICAgICAgJ3BhcmFtJyxcbiAgICAgICAgXVxuICAgIH0sXG4gICAgbm92YWxpZGF0ZTogeyBwcm9wZXJ0eU5hbWU6ICdub1ZhbGlkYXRlJywgYXBwbGllc1RvOiBbJ2Zvcm0nXSB9LFxuICAgIG9wZW46IHsgYXBwbGllc1RvOiBbJ2RldGFpbHMnXSB9LFxuICAgIG9wdGltdW06IHsgYXBwbGllc1RvOiBbJ21ldGVyJ10gfSxcbiAgICBwYXR0ZXJuOiB7IGFwcGxpZXNUbzogWydpbnB1dCddIH0sXG4gICAgcGluZzogeyBhcHBsaWVzVG86IFsnYScsICdhcmVhJ10gfSxcbiAgICBwbGFjZWhvbGRlcjogeyBhcHBsaWVzVG86IFsnaW5wdXQnLCAndGV4dGFyZWEnXSB9LFxuICAgIHBvc3RlcjogeyBhcHBsaWVzVG86IFsndmlkZW8nXSB9LFxuICAgIHByZWxvYWQ6IHsgYXBwbGllc1RvOiBbJ2F1ZGlvJywgJ3ZpZGVvJ10gfSxcbiAgICByYWRpb2dyb3VwOiB7IGFwcGxpZXNUbzogWydjb21tYW5kJ10gfSxcbiAgICByZWFkb25seTogeyBwcm9wZXJ0eU5hbWU6ICdyZWFkT25seScsIGFwcGxpZXNUbzogWydpbnB1dCcsICd0ZXh0YXJlYSddIH0sXG4gICAgcmVsOiB7IGFwcGxpZXNUbzogWydhJywgJ2FyZWEnLCAnbGluayddIH0sXG4gICAgcmVxdWlyZWQ6IHsgYXBwbGllc1RvOiBbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYSddIH0sXG4gICAgcmV2ZXJzZWQ6IHsgYXBwbGllc1RvOiBbJ29sJ10gfSxcbiAgICByb3dzOiB7IGFwcGxpZXNUbzogWyd0ZXh0YXJlYSddIH0sXG4gICAgcm93c3BhbjogeyBwcm9wZXJ0eU5hbWU6ICdyb3dTcGFuJywgYXBwbGllc1RvOiBbJ3RkJywgJ3RoJ10gfSxcbiAgICBzYW5kYm94OiB7IGFwcGxpZXNUbzogWydpZnJhbWUnXSB9LFxuICAgIHNjb3BlOiB7IGFwcGxpZXNUbzogWyd0aCddIH0sXG4gICAgc2NvcGVkOiB7IGFwcGxpZXNUbzogWydzdHlsZSddIH0sXG4gICAgc2VhbWxlc3M6IHsgYXBwbGllc1RvOiBbJ2lmcmFtZSddIH0sXG4gICAgc2VsZWN0ZWQ6IHsgYXBwbGllc1RvOiBbJ29wdGlvbiddIH0sXG4gICAgc2hhcGU6IHsgYXBwbGllc1RvOiBbJ2EnLCAnYXJlYSddIH0sXG4gICAgc2l6ZTogeyBhcHBsaWVzVG86IFsnaW5wdXQnLCAnc2VsZWN0J10gfSxcbiAgICBzaXplczogeyBhcHBsaWVzVG86IFsnbGluaycsICdpbWcnLCAnc291cmNlJ10gfSxcbiAgICBzcGFuOiB7IGFwcGxpZXNUbzogWydjb2wnLCAnY29sZ3JvdXAnXSB9LFxuICAgIHNwZWxsY2hlY2s6IHt9LFxuICAgIHNyYzoge1xuICAgICAgICBhcHBsaWVzVG86IFtcbiAgICAgICAgICAgICdhdWRpbycsXG4gICAgICAgICAgICAnZW1iZWQnLFxuICAgICAgICAgICAgJ2lmcmFtZScsXG4gICAgICAgICAgICAnaW1nJyxcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICAnc2NyaXB0JyxcbiAgICAgICAgICAgICdzb3VyY2UnLFxuICAgICAgICAgICAgJ3RyYWNrJyxcbiAgICAgICAgICAgICd2aWRlbycsXG4gICAgICAgIF1cbiAgICB9LFxuICAgIHNyY2RvYzogeyBhcHBsaWVzVG86IFsnaWZyYW1lJ10gfSxcbiAgICBzcmNsYW5nOiB7IGFwcGxpZXNUbzogWyd0cmFjayddIH0sXG4gICAgc3Jjc2V0OiB7IGFwcGxpZXNUbzogWydpbWcnXSB9LFxuICAgIHN0YXJ0OiB7IGFwcGxpZXNUbzogWydvbCddIH0sXG4gICAgc3RlcDogeyBhcHBsaWVzVG86IFsnaW5wdXQnXSB9LFxuICAgIHN0eWxlOiB7IHByb3BlcnR5TmFtZTogJ3N0eWxlLmNzc1RleHQnIH0sXG4gICAgc3VtbWFyeTogeyBhcHBsaWVzVG86IFsndGFibGUnXSB9LFxuICAgIHRhYmluZGV4OiB7IHByb3BlcnR5TmFtZTogJ3RhYkluZGV4JyB9LFxuICAgIHRhcmdldDogeyBhcHBsaWVzVG86IFsnYScsICdhcmVhJywgJ2Jhc2UnLCAnZm9ybSddIH0sXG4gICAgdGl0bGU6IHt9LFxuICAgIHR5cGU6IHtcbiAgICAgICAgYXBwbGllc1RvOiBbXG4gICAgICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgICAgICdpbnB1dCcsXG4gICAgICAgICAgICAnY29tbWFuZCcsXG4gICAgICAgICAgICAnZW1iZWQnLFxuICAgICAgICAgICAgJ29iamVjdCcsXG4gICAgICAgICAgICAnc2NyaXB0JyxcbiAgICAgICAgICAgICdzb3VyY2UnLFxuICAgICAgICAgICAgJ3N0eWxlJyxcbiAgICAgICAgICAgICdtZW51JyxcbiAgICAgICAgXVxuICAgIH0sXG4gICAgdXNlbWFwOiB7IHByb3BlcnR5TmFtZTogJ3VzZU1hcCcsIGFwcGxpZXNUbzogWydpbWcnLCAnaW5wdXQnLCAnb2JqZWN0J10gfSxcbiAgICB2YWx1ZToge1xuICAgICAgICBhcHBsaWVzVG86IFtcbiAgICAgICAgICAgICdidXR0b24nLFxuICAgICAgICAgICAgJ29wdGlvbicsXG4gICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgICdtZXRlcicsXG4gICAgICAgICAgICAncHJvZ3Jlc3MnLFxuICAgICAgICAgICAgJ3BhcmFtJyxcbiAgICAgICAgICAgICdzZWxlY3QnLFxuICAgICAgICAgICAgJ3RleHRhcmVhJyxcbiAgICAgICAgXVxuICAgIH0sXG4gICAgd2lkdGg6IHtcbiAgICAgICAgYXBwbGllc1RvOiBbJ2NhbnZhcycsICdlbWJlZCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ29iamVjdCcsICd2aWRlbyddXG4gICAgfSxcbiAgICB3cmFwOiB7IGFwcGxpZXNUbzogWyd0ZXh0YXJlYSddIH1cbn07XG5PYmplY3Qua2V5cyhhdHRyaWJ1dGVMb29rdXApLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbWV0YWRhdGEgPSBhdHRyaWJ1dGVMb29rdXBbbmFtZV07XG4gICAgaWYgKCFtZXRhZGF0YS5wcm9wZXJ0eU5hbWUpXG4gICAgICAgIG1ldGFkYXRhLnByb3BlcnR5TmFtZSA9IG5hbWU7XG59KTtcbmZ1bmN0aW9uIG9wdGltaXplU3R5bGUodmFsdWUpIHtcbiAgICB2YXIgZXhwZWN0aW5nS2V5ID0gdHJ1ZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIGNodW5rcyA9IHZhbHVlLnNsaWNlKCk7XG4gICAgd2hpbGUgKGNodW5rcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNodW5rID0gY2h1bmtzWzBdO1xuICAgICAgICBpZiAoY2h1bmsudHlwZSAhPT0gJ1RleHQnKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBrZXlNYXRjaCA9IC9eXFxzKihbXFx3LV0rKTpcXHMqLy5leGVjKGNodW5rLmRhdGEpO1xuICAgICAgICBpZiAoIWtleU1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHZhciBrZXkgPSBrZXlNYXRjaFsxXTtcbiAgICAgICAgdmFyIG9mZnNldCA9IGtleU1hdGNoLmluZGV4ICsga2V5TWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGF0YSA9IGNodW5rLmRhdGEuc2xpY2Uob2Zmc2V0KTtcbiAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGEpIHtcbiAgICAgICAgICAgIGNodW5rc1swXSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogY2h1bmsuc3RhcnQgKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBjaHVuay5lbmQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ1RleHQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlbWFpbmluZ0RhdGFcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjaHVua3Muc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZ2V0U3R5bGVWYWx1ZShjaHVua3MpO1xuICAgICAgICBpZiAoIXJlc3VsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBwcm9wcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiByZXN1bHQudmFsdWUgfSk7XG4gICAgICAgIGNodW5rcyA9IHJlc3VsdC5jaHVua3M7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn1cbmZ1bmN0aW9uIGdldFN0eWxlVmFsdWUoY2h1bmtzKSB7XG4gICAgdmFyIHZhbHVlID0gW107XG4gICAgdmFyIGluVXJsID0gZmFsc2U7XG4gICAgdmFyIHF1b3RlTWFyayA9IG51bGw7XG4gICAgdmFyIGVzY2FwZWQgPSBmYWxzZTtcbiAgICB3aGlsZSAoY2h1bmtzLmxlbmd0aCkge1xuICAgICAgICB2YXIgY2h1bmsgPSBjaHVua3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09ICdUZXh0Jykge1xuICAgICAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGMgPCBjaHVuay5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gY2h1bmsuZGF0YVtjXTtcbiAgICAgICAgICAgICAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoYXIgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBlc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gcXVvdGVNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1b3RlTWFyayA9PT0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJ1wiJyB8fCBjaGFyID09PSBcIidcIikge1xuICAgICAgICAgICAgICAgICAgICBxdW90ZU1hcmsgPSBjaGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnKScgJiYgaW5VcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5VcmwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hhciA9PT0gJ3UnICYmIGNodW5rLmRhdGEuc2xpY2UoYywgYyArIDQpID09PSAndXJsKCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5VcmwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGFyID09PSAnOycgJiYgIWluVXJsICYmICFxdW90ZU1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjID4gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnVGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBjaHVuay5zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBjaHVuay5zdGFydCArIGMsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGNodW5rLmRhdGEuc2xpY2UoMCwgYylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlICgvWztcXHNdLy50ZXN0KGNodW5rLmRhdGFbY10pKVxuICAgICAgICAgICAgICAgIGMgKz0gMTtcbiAgICAgICAgICAgIHZhciByZW1haW5pbmdEYXRhID0gY2h1bmsuZGF0YS5zbGljZShjKTtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnVuc2hpZnQoe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogY2h1bmsuc3RhcnQgKyBjLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGNodW5rLmVuZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1RleHQnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiByZW1haW5pbmdEYXRhXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZS5wdXNoKGNodW5rKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjaHVua3M6IGNodW5rcyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzRHluYW1pYyQxKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA+IDEgfHwgdmFsdWVbMF0udHlwZSAhPT0gJ1RleHQnO1xufVxudmFyIHRlbXBsYXRlT2JqZWN0XzEkMztcbnZhciB0ZW1wbGF0ZU9iamVjdF8yJDM7XG52YXIgdGVtcGxhdGVPYmplY3RfMyQzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzQkMztcblxudmFyIE5vZGUkMSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKGRhdGEpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBkYXRhKTtcbiAgICB9XG4gICAgTm9kZS5wcm90b3R5cGUuY2Fubm90VXNlSW5uZXJIVE1MID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5Vc2VJbm5lckhUTUwgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLmNhblVzZUlubmVySFRNTCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudC5jYW5ub3RVc2VJbm5lckhUTUwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMucGFyZW50LnR5cGUsIHRoaXMudHlwZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuY2Fubm90VXNlSW5uZXJIVE1MKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYmxvY2ssIHN0cmlwV2hpdGVzcGFjZSwgbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlc1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuaW5pdENoaWxkcmVuID0gZnVuY3Rpb24gKGJsb2NrLCBzdHJpcFdoaXRlc3BhY2UsIG5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIGdsdWUgdGV4dCBub2RlcyB0b2dldGhlclxuICAgICAgICB2YXIgY2xlYW5lZCA9IFtdO1xuICAgICAgICB2YXIgbGFzdENoaWxkO1xuICAgICAgICB2YXIgd2luZG93Q29tcG9uZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gJ0NvbW1lbnQnKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIHNwZWNpYWwgY2FzZSDigJQgdGhpcyBpcyBhbiBlYXN5IHdheSB0byByZW1vdmUgd2hpdGVzcGFjZSBzdXJyb3VuZGluZ1xuICAgICAgICAgICAgLy8gPDpXaW5kb3cvPi4gbGlsIGhhY2t5IGJ1dCBpdCB3b3Jrc1xuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdXaW5kb3cnKSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29tcG9uZW50ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdUZXh0JyAmJiBsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLnR5cGUgPT09ICdUZXh0Jykge1xuICAgICAgICAgICAgICAgIGxhc3RDaGlsZC5kYXRhICs9IGNoaWxkLmRhdGE7XG4gICAgICAgICAgICAgICAgbGFzdENoaWxkLmVuZCA9IGNoaWxkLmVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC50eXBlID09PSAnVGV4dCcgJiYgc3RyaXBXaGl0ZXNwYWNlICYmIGNsZWFuZWQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRhdGEgPSB0cmltU3RhcnQoY2hpbGQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5kYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW5lZC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuZWQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENoaWxkID0gY2hpbGQ7XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0Q2hpbGQgPSBudWxsO1xuICAgICAgICBjbGVhbmVkLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkLCBpKSB7XG4gICAgICAgICAgICBjaGlsZC5jYW5Vc2VJbm5lckhUTUwgPSAhX3RoaXMuZ2VuZXJhdG9yLmh5ZHJhdGFibGU7XG4gICAgICAgICAgICBjaGlsZC5pbml0KGJsb2NrLCBzdHJpcFdoaXRlc3BhY2UsIGNsZWFuZWRbaSArIDFdIHx8IG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIGlmIChjaGlsZC5zaG91bGRTa2lwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChsYXN0Q2hpbGQpXG4gICAgICAgICAgICAgICAgbGFzdENoaWxkLm5leHQgPSBjaGlsZDtcbiAgICAgICAgICAgIGNoaWxkLnByZXYgPSBsYXN0Q2hpbGQ7XG4gICAgICAgICAgICBsYXN0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gcmVtb3ZlIHRyYWlsaW5nIHdoaXRlc3BhY2UgaW5zaWRlIGFuIGVsZW1lbnQvY29tcG9uZW50L2Jsb2NrLFxuICAgICAgICAvLyAqdW5sZXNzKiB0aGVyZSBpcyBubyB3aGl0ZXNwYWNlIGJldHdlZW4gdGhpcyBub2RlIGFuZCBpdHMgbmV4dCBzaWJsaW5nXG4gICAgICAgIGlmIChzdHJpcFdoaXRlc3BhY2UgJiYgbGFzdENoaWxkICYmIGxhc3RDaGlsZC50eXBlID09PSAnVGV4dCcpIHtcbiAgICAgICAgICAgIHZhciBzaG91bGRUcmltID0gKG5leHRTaWJsaW5nID8gKG5leHRTaWJsaW5nLnR5cGUgPT09ICdUZXh0JyAmJiAvXlxccy8udGVzdChuZXh0U2libGluZy5kYXRhKSkgOiAhdGhpcy5oYXNBbmNlc3RvcignRWFjaEJsb2NrJykpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFRyaW0pIHtcbiAgICAgICAgICAgICAgICBsYXN0Q2hpbGQuZGF0YSA9IHRyaW1FbmQobGFzdENoaWxkLmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghbGFzdENoaWxkLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5lZC5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdENoaWxkID0gY2xlYW5lZFtjbGVhbmVkLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q2hpbGQubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjbGVhbmVkO1xuICAgICAgICBpZiAod2luZG93Q29tcG9uZW50KVxuICAgICAgICAgICAgY2xlYW5lZC51bnNoaWZ0KHdpbmRvd0NvbXBvbmVudCk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3Nlc1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuaXNEb21Ob2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSAnRWxlbWVudCcgfHwgdGhpcy50eXBlID09PSAnVGV4dCcgfHwgdGhpcy50eXBlID09PSAnTXVzdGFjaGVUYWcnO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuaGFzQW5jZXN0b3IgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgP1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQudHlwZSA9PT0gdHlwZSB8fCB0aGlzLnBhcmVudC5oYXNBbmNlc3Rvcih0eXBlKSA6XG4gICAgICAgICAgICBmYWxzZTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmZpbmROZWFyZXN0ID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgIGlmIChzZWxlY3Rvci50ZXN0KHRoaXMudHlwZSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmZpbmROZWFyZXN0KHNlbGVjdG9yKTtcbiAgICB9O1xuICAgIE5vZGUucHJvdG90eXBlLmdldE9yQ3JlYXRlQW5jaG9yID0gZnVuY3Rpb24gKGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2Rlcykge1xuICAgICAgICAvLyBUT0RPIHVzZSB0aGlzIGluIEVhY2hCbG9jayBhbmQgSWZCbG9jayDigJQgdHJpY2t5IGJlY2F1c2VcbiAgICAgICAgLy8gY2hpbGRyZW4gbmVlZCB0byBiZSBjcmVhdGVkIGZpcnN0XG4gICAgICAgIHZhciBuZWVkc0FuY2hvciA9IHRoaXMubmV4dCA/ICF0aGlzLm5leHQuaXNEb21Ob2RlKCkgOiAhcGFyZW50Tm9kZSB8fCAhdGhpcy5wYXJlbnQuaXNEb21Ob2RlKCk7XG4gICAgICAgIHZhciBhbmNob3IgPSBuZWVkc0FuY2hvclxuICAgICAgICAgICAgPyBibG9jay5nZXRVbmlxdWVOYW1lKHRoaXNbXCJ2YXJcIl0gKyBcIl9hbmNob3JcIilcbiAgICAgICAgICAgIDogKHRoaXMubmV4dCAmJiB0aGlzLm5leHRbXCJ2YXJcIl0pIHx8ICdudWxsJztcbiAgICAgICAgaWYgKG5lZWRzQW5jaG9yKSB7XG4gICAgICAgICAgICBibG9jay5hZGRFbGVtZW50KGFuY2hvciwgXCJAY3JlYXRlQ29tbWVudCgpXCIsIHBhcmVudE5vZGVzICYmIFwiQGNyZWF0ZUNvbW1lbnQoKVwiLCBwYXJlbnROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5jaG9yO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0VXBkYXRlTW91bnROb2RlID0gZnVuY3Rpb24gKGFuY2hvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuaXNEb21Ob2RlKCkgPyB0aGlzLnBhcmVudFtcInZhclwiXSA6IGFuY2hvciArIFwiLnBhcmVudE5vZGVcIjtcbiAgICB9O1xuICAgIHJldHVybiBOb2RlO1xufSgpKTtcblxuZnVuY3Rpb24gY3JlYXRlRGVidWdnaW5nQ29tbWVudChub2RlLCBnZW5lcmF0b3IpIHtcbiAgICB2YXIgbG9jYXRlID0gZ2VuZXJhdG9yLmxvY2F0ZSwgc291cmNlID0gZ2VuZXJhdG9yLnNvdXJjZTtcbiAgICB2YXIgYyA9IG5vZGUuc3RhcnQ7XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0Vsc2VCbG9jaycpIHtcbiAgICAgICAgd2hpbGUgKHNvdXJjZVtjXSAhPT0gJ3snKVxuICAgICAgICAgICAgYyAtPSAxO1xuICAgICAgICBjIC09IDE7XG4gICAgfVxuICAgIHZhciBkID0gbm9kZS5leHByZXNzaW9uID8gbm9kZS5leHByZXNzaW9uLmVuZCA6IGM7XG4gICAgd2hpbGUgKHNvdXJjZVtkXSAhPT0gJ30nKVxuICAgICAgICBkICs9IDE7XG4gICAgZCArPSAyO1xuICAgIHZhciBzdGFydCA9IGxvY2F0ZShjKTtcbiAgICB2YXIgbG9jID0gXCIoXCIgKyAoc3RhcnQubGluZSArIDEpICsgXCI6XCIgKyBzdGFydC5jb2x1bW4gKyBcIilcIjtcbiAgICByZXR1cm4gKGxvYyArIFwiIFwiICsgc291cmNlLnNsaWNlKGMsIGQpKS5yZXBsYWNlKC9cXG4vZywgJyAnKTtcbn1cblxudmFyIEF3YWl0QmxvY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEF3YWl0QmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXdhaXRCbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBd2FpdEJsb2NrLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGJsb2NrLCBzdHJpcFdoaXRlc3BhY2UsIG5leHRTaWJsaW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2Fubm90VXNlSW5uZXJIVE1MKCk7XG4gICAgICAgIHRoaXNbXCJ2YXJcIl0gPSBibG9jay5nZXRVbmlxdWVOYW1lKCdhd2FpdF9ibG9jaycpO1xuICAgICAgICBibG9jay5hZGREZXBlbmRlbmNpZXModGhpcy5tZXRhZGF0YS5kZXBlbmRlbmNpZXMpO1xuICAgICAgICB2YXIgZHluYW1pYyA9IGZhbHNlO1xuICAgICAgICBbXG4gICAgICAgICAgICBbJ3BlbmRpbmcnLCBudWxsXSxcbiAgICAgICAgICAgIFsndGhlbicsIHRoaXMudmFsdWVdLFxuICAgICAgICAgICAgWydjYXRjaCcsIHRoaXMuZXJyb3JdXG4gICAgICAgIF0uZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBzdGF0dXMgPSBfYVswXSwgYXJnID0gX2FbMV07XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBfdGhpc1tzdGF0dXNdO1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBibG9jay5nZXRVbmlxdWVOYW1lKGFyZyB8fCAnXycpO1xuICAgICAgICAgICAgdmFyIGNvbnRleHRzID0gbmV3IE1hcChibG9jay5jb250ZXh0cyk7XG4gICAgICAgICAgICBjb250ZXh0cy5zZXQoYXJnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNoaWxkLmJsb2NrID0gYmxvY2suY2hpbGQoe1xuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IGNyZWF0ZURlYnVnZ2luZ0NvbW1lbnQoY2hpbGQsIF90aGlzLmdlbmVyYXRvciksXG4gICAgICAgICAgICAgICAgbmFtZTogX3RoaXMuZ2VuZXJhdG9yLmdldFVuaXF1ZU5hbWUoXCJjcmVhdGVfXCIgKyBzdGF0dXMgKyBcIl9ibG9ja1wiKSxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IGJsb2NrLnBhcmFtcy5jb25jYXQoY29udGV4dCksXG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICBjb250ZXh0czogY29udGV4dHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2hpbGQuaW5pdENoaWxkcmVuKGNoaWxkLmJsb2NrLCBzdHJpcFdoaXRlc3BhY2UsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIF90aGlzLmdlbmVyYXRvci5ibG9ja3MucHVzaChjaGlsZC5ibG9jayk7XG4gICAgICAgICAgICBpZiAoY2hpbGQuYmxvY2suZGVwZW5kZW5jaWVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYmxvY2suYWRkRGVwZW5kZW5jaWVzKGNoaWxkLmJsb2NrLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBlbmRpbmcuYmxvY2suaGFzVXBkYXRlTWV0aG9kID0gZHluYW1pYztcbiAgICAgICAgdGhpcy50aGVuLmJsb2NrLmhhc1VwZGF0ZU1ldGhvZCA9IGR5bmFtaWM7XG4gICAgICAgIHRoaXNbXCJjYXRjaFwiXS5ibG9jay5oYXNVcGRhdGVNZXRob2QgPSBkeW5hbWljO1xuICAgIH07XG4gICAgQXdhaXRCbG9jay5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiAoYmxvY2ssIHBhcmVudE5vZGUsIHBhcmVudE5vZGVzKSB7XG4gICAgICAgIHZhciBuYW1lID0gdGhpc1tcInZhclwiXTtcbiAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuZ2V0T3JDcmVhdGVBbmNob3IoYmxvY2ssIHBhcmVudE5vZGUsIHBhcmVudE5vZGVzKTtcbiAgICAgICAgdmFyIHVwZGF0ZU1vdW50Tm9kZSA9IHRoaXMuZ2V0VXBkYXRlTW91bnROb2RlKGFuY2hvcik7XG4gICAgICAgIHZhciBwYXJhbXMgPSBibG9jay5wYXJhbXMuam9pbignLCAnKTtcbiAgICAgICAgYmxvY2suY29udGV4dHVhbGlzZSh0aGlzLmV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgc25pcHBldCA9IHRoaXMubWV0YWRhdGEuc25pcHBldDtcbiAgICAgICAgdmFyIHByb21pc2UgPSBibG9jay5nZXRVbmlxdWVOYW1lKFwicHJvbWlzZVwiKTtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcInJlc29sdmVkXCIpO1xuICAgICAgICB2YXIgYXdhaXRfYmxvY2sgPSBibG9jay5nZXRVbmlxdWVOYW1lKFwiYXdhaXRfYmxvY2tcIik7XG4gICAgICAgIHZhciBhd2FpdF9ibG9ja190eXBlID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcImF3YWl0X2Jsb2NrX3R5cGVcIik7XG4gICAgICAgIHZhciB0b2tlbiA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoXCJ0b2tlblwiKTtcbiAgICAgICAgdmFyIGF3YWl0X3Rva2VuID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcImF3YWl0X3Rva2VuXCIpO1xuICAgICAgICB2YXIgaGFuZGxlX3Byb21pc2UgPSBibG9jay5nZXRVbmlxdWVOYW1lKFwiaGFuZGxlX3Byb21pc2VcIik7XG4gICAgICAgIHZhciByZXBsYWNlX2F3YWl0X2Jsb2NrID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcInJlcGxhY2VfYXdhaXRfYmxvY2tcIik7XG4gICAgICAgIHZhciBvbGRfYmxvY2sgPSBibG9jay5nZXRVbmlxdWVOYW1lKFwib2xkX2Jsb2NrXCIpO1xuICAgICAgICB2YXIgdmFsdWUgPSBibG9jay5nZXRVbmlxdWVOYW1lKFwidmFsdWVcIik7XG4gICAgICAgIHZhciBlcnJvciA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoXCJlcnJvclwiKTtcbiAgICAgICAgdmFyIGNyZWF0ZV9wZW5kaW5nX2Jsb2NrID0gdGhpcy5wZW5kaW5nLmJsb2NrLm5hbWU7XG4gICAgICAgIHZhciBjcmVhdGVfdGhlbl9ibG9jayA9IHRoaXMudGhlbi5ibG9jay5uYW1lO1xuICAgICAgICB2YXIgY3JlYXRlX2NhdGNoX2Jsb2NrID0gdGhpc1tcImNhdGNoXCJdLmJsb2NrLm5hbWU7XG4gICAgICAgIGJsb2NrLmFkZFZhcmlhYmxlKGF3YWl0X2Jsb2NrKTtcbiAgICAgICAgYmxvY2suYWRkVmFyaWFibGUoYXdhaXRfYmxvY2tfdHlwZSk7XG4gICAgICAgIGJsb2NrLmFkZFZhcmlhYmxlKGF3YWl0X3Rva2VuKTtcbiAgICAgICAgYmxvY2suYWRkVmFyaWFibGUocHJvbWlzZSk7XG4gICAgICAgIGJsb2NrLmFkZFZhcmlhYmxlKHJlc29sdmVkKTtcbiAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihcIiwgXCIsIHR5cGUsIFwiLCBcIiwgXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIiAhPT0gXCIsIFwiKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcIiwgXCIgPSAoXCIsIFwiID0gdHlwZSkoXCIsIFwiLCBcIiwgXCIgPSBcIiwgXCIsICNjb21wb25lbnQpO1xcblxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIudSgpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIubShcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIoXCIsIFwiLCBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiID0ge307XFxuXFxuXFx0XFx0XFx0XFx0aWYgKEBpc1Byb21pc2UoXCIsIFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi50aGVuKGZ1bmN0aW9uKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIihcIiwgXCIsIFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdH0sIGZ1bmN0aW9uIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBhIHRoZW4vY2F0Y2ggYmxvY2ssIGRlc3Ryb3kgaXRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiICE9PSBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIG51bGwsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIgIT09IFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIihcIiwgXCIsIFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFwiLCBcIihcIiwgXCIgPSBcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIoXCIsIFwiLCB0eXBlLCBcIiwgXCIsIFwiLCBcIikge1xcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIgIT09IFwiLCBcIikgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCI7XFxuXFx0XFx0XFx0XFx0XCIsIFwiID0gKFwiLCBcIiA9IHR5cGUpKFwiLCBcIiwgXCIsIFwiID0gXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLnUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuZCgpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5jKCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLm0oXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKFwiLCBcIiwgXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIiA9IHt9O1xcblxcblxcdFxcdFxcdFxcdGlmIChAaXNQcm9taXNlKFwiLCBcIikpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIudGhlbihmdW5jdGlvbihcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9LCBmdW5jdGlvbiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiKFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaWYgd2UgcHJldmlvdXNseSBoYWQgYSB0aGVuL2NhdGNoIGJsb2NrLCBkZXN0cm95IGl0XFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIiAhPT0gXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiKFwiLCBcIiwgXCIsIFwiLCBudWxsLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiICE9PSBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcIiwgXCIoXCIsIFwiID0gXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFwiXSkpLCByZXBsYWNlX2F3YWl0X2Jsb2NrLCB0b2tlbiwgdmFsdWUsIHBhcmFtcywgdG9rZW4sIGF3YWl0X3Rva2VuLCBvbGRfYmxvY2ssIGF3YWl0X2Jsb2NrLCBhd2FpdF9ibG9jaywgYXdhaXRfYmxvY2tfdHlwZSwgcGFyYW1zLCByZXNvbHZlZCwgdmFsdWUsIG9sZF9ibG9jaywgb2xkX2Jsb2NrLCBvbGRfYmxvY2ssIGF3YWl0X2Jsb2NrLCBhd2FpdF9ibG9jaywgdXBkYXRlTW91bnROb2RlLCBhbmNob3IsIGhhbmRsZV9wcm9taXNlLCBwcm9taXNlLCBwYXJhbXMsIHRva2VuLCBhd2FpdF90b2tlbiwgcHJvbWlzZSwgcHJvbWlzZSwgdmFsdWUsIHJlcGxhY2VfYXdhaXRfYmxvY2ssIHRva2VuLCBjcmVhdGVfdGhlbl9ibG9jaywgdmFsdWUsIHBhcmFtcywgZXJyb3IsIHJlcGxhY2VfYXdhaXRfYmxvY2ssIHRva2VuLCBjcmVhdGVfY2F0Y2hfYmxvY2ssIGVycm9yLCBwYXJhbXMsIGF3YWl0X2Jsb2NrX3R5cGUsIGNyZWF0ZV9wZW5kaW5nX2Jsb2NrLCByZXBsYWNlX2F3YWl0X2Jsb2NrLCB0b2tlbiwgY3JlYXRlX3BlbmRpbmdfYmxvY2ssIHBhcmFtcywgcmVzb2x2ZWQsIHByb21pc2UsIGF3YWl0X2Jsb2NrX3R5cGUsIGNyZWF0ZV90aGVuX2Jsb2NrLCByZXBsYWNlX2F3YWl0X2Jsb2NrLCB0b2tlbiwgY3JlYXRlX3RoZW5fYmxvY2ssIHJlc29sdmVkLCBwYXJhbXMsIGhhbmRsZV9wcm9taXNlLCBwcm9taXNlLCBzbmlwcGV0LCBwYXJhbXMpKTtcbiAgICAgICAgYmxvY2suYnVpbGRlcnMuY3JlYXRlLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzIkNCB8fCAodGVtcGxhdGVPYmplY3RfMiQ0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFwiLCBcIi5jKCk7XFxuXFx0XFx0XCJdKSksIGF3YWl0X2Jsb2NrKSk7XG4gICAgICAgIGlmIChwYXJlbnROb2Rlcykge1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuY2xhaW0uYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMyQ0IHx8ICh0ZW1wbGF0ZU9iamVjdF8zJDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCIubChcIiwgXCIpO1xcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XCIsIFwiLmwoXCIsIFwiKTtcXG5cXHRcXHRcXHRcIl0pKSwgYXdhaXRfYmxvY2ssIHBhcmVudE5vZGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluaXRpYWxNb3VudE5vZGUgPSBwYXJlbnROb2RlIHx8ICcjdGFyZ2V0JztcbiAgICAgICAgdmFyIGFuY2hvck5vZGUgPSBwYXJlbnROb2RlID8gJ251bGwnIDogJ2FuY2hvcic7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLm1vdW50LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzQkNCB8fCAodGVtcGxhdGVPYmplY3RfNCQ0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XCIsIFwiLm0oXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XCIsIFwiLm0oXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFwiXSkpLCBhd2FpdF9ibG9jaywgaW5pdGlhbE1vdW50Tm9kZSwgYW5jaG9yTm9kZSkpO1xuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YS5kZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaChcIihcIiArIHRoaXMubWV0YWRhdGEuZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBcIidcIiArIGRlcCArIFwiJyBpbiBjaGFuZ2VkXCI7IH0pLmpvaW4oJyB8fCAnKSArIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25kaXRpb25zLnB1c2gocHJvbWlzZSArIFwiICE9PSAoXCIgKyBwcm9taXNlICsgXCIgPSBcIiArIHNuaXBwZXQgKyBcIilcIiwgaGFuZGxlX3Byb21pc2UgKyBcIihcIiArIHByb21pc2UgKyBcIiwgXCIgKyBwYXJhbXMgKyBcIilcIik7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmcuYmxvY2suaGFzVXBkYXRlTWV0aG9kKSB7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy51cGRhdGUuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNSQyIHx8ICh0ZW1wbGF0ZU9iamVjdF81JDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gbm90aGluZ1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLnAoY2hhbmdlZCwgXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBub3RoaW5nXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIucChjaGFuZ2VkLCBcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBjb25kaXRpb25zLmpvaW4oJyAmJiAnKSwgYXdhaXRfYmxvY2ssIHBhcmFtcywgcmVzb2x2ZWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF82JDIgfHwgKHRlbXBsYXRlT2JqZWN0XzYkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5tKFwiLCBcIi5wYXJlbnROb2RlLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5tKFwiLCBcIi5wYXJlbnROb2RlLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0pKSwgY29uZGl0aW9ucy5qb2luKCcgJiYgJyksIGF3YWl0X2Jsb2NrLCBhd2FpdF9ibG9jaywgYW5jaG9yLCBhbmNob3IpKTtcbiAgICAgICAgfVxuICAgICAgICBibG9jay5idWlsZGVycy51bm1vdW50LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzckMSB8fCAodGVtcGxhdGVPYmplY3RfNyQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XCIsIFwiLnUoKTtcXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFwiLCBcIi51KCk7XFxuXFx0XFx0XCJdKSksIGF3YWl0X2Jsb2NrKSk7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfOCQxIHx8ICh0ZW1wbGF0ZU9iamVjdF84JDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcIiwgXCIgPSBudWxsO1xcblxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcIiwgXCIgPSBudWxsO1xcblxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XCJdKSksIGF3YWl0X3Rva2VuLCBhd2FpdF9ibG9jaykpO1xuICAgICAgICBbdGhpcy5wZW5kaW5nLCB0aGlzLnRoZW4sIHRoaXNbXCJjYXRjaFwiXV0uZm9yRWFjaChmdW5jdGlvbiAoc3RhdHVzKSB7XG4gICAgICAgICAgICBzdGF0dXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5idWlsZChzdGF0dXMuYmxvY2ssIG51bGwsICdub2RlcycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEF3YWl0QmxvY2s7XG59KE5vZGUkMSkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkNDtcbnZhciB0ZW1wbGF0ZU9iamVjdF8yJDQ7XG52YXIgdGVtcGxhdGVPYmplY3RfMyQ0O1xudmFyIHRlbXBsYXRlT2JqZWN0XzQkNDtcbnZhciB0ZW1wbGF0ZU9iamVjdF81JDI7XG52YXIgdGVtcGxhdGVPYmplY3RfNiQyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzckMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF84JDE7XG5cbmZ1bmN0aW9uIGdldE9iamVjdChub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKVxuICAgICAgICBub2RlID0gbm9kZS5vYmplY3Q7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGdldFRhaWxTbmlwcGV0KG5vZGUpIHtcbiAgICB2YXIgZW5kID0gbm9kZS5lbmQ7XG4gICAgd2hpbGUgKG5vZGUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKVxuICAgICAgICBub2RlID0gbm9kZS5vYmplY3Q7XG4gICAgdmFyIHN0YXJ0ID0gbm9kZS5lbmQ7XG4gICAgcmV0dXJuIFwiW1xcdTI3MDJcIiArIHN0YXJ0ICsgXCItXCIgKyBlbmQgKyBcIlxcdTI3MDJdXCI7XG59XG5cbnZhciByZWFkT25seU1lZGlhQXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgICdkdXJhdGlvbicsXG4gICAgJ2J1ZmZlcmVkJyxcbiAgICAnc2Vla2FibGUnLFxuICAgICdwbGF5ZWQnXG5dKTtcbnZhciBCaW5kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCaW5kaW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJpbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQmluZGluZy5wcm90b3R5cGUubXVuZ2UgPSBmdW5jdGlvbiAoYmxvY2ssIGFsbFVzZWRDb250ZXh0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGFyZW50O1xuICAgICAgICB2YXIgbmVlZHNMb2NrID0gbm9kZS5uYW1lICE9PSAnaW5wdXQnIHx8ICEvcmFkaW98Y2hlY2tib3h8cmFuZ2V8Y29sb3IvLnRlc3Qobm9kZS5nZXRTdGF0aWNBdHRyaWJ1dGVWYWx1ZSgndHlwZScpKTtcbiAgICAgICAgdmFyIGlzUmVhZE9ubHkgPSBub2RlLmlzTWVkaWFOb2RlKCkgJiYgcmVhZE9ubHlNZWRpYUF0dHJpYnV0ZXMuaGFzKHRoaXMubmFtZSk7XG4gICAgICAgIHZhciB1cGRhdGVDb25kaXRpb247XG4gICAgICAgIHZhciBuYW1lID0gZ2V0T2JqZWN0KHRoaXMudmFsdWUpLm5hbWU7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IGJsb2NrLmNvbnRleHR1YWxpc2UodGhpcy52YWx1ZSkuY29udGV4dHM7XG4gICAgICAgIHZhciBzbmlwcGV0ID0gdGhpcy5tZXRhZGF0YS5zbmlwcGV0O1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IGlmIHlvdSBoYXZlIGUuZy4gYDxpbnB1dCB0eXBlPWNoZWNrYm94IGJpbmQ6Y2hlY2tlZD1zZWxlY3RlZC5kb25lPmBcbiAgICAgICAgLy8gYW5kIGBzZWxlY3RlZGAgaXMgYW4gb2JqZWN0IGNob3NlbiB3aXRoIGEgPHNlbGVjdD4sIHRoZW4gd2hlbiBgY2hlY2tlZGAgY2hhbmdlcyxcbiAgICAgICAgLy8gd2UgbmVlZCB0byB0ZWxsIHRoZSBjb21wb25lbnQgdG8gdXBkYXRlIGFsbCB0aGUgdmFsdWVzIGBzZWxlY3RlZGAgbWlnaHQgYmVcbiAgICAgICAgLy8gcG9pbnRpbmcgdG9cbiAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBoYXBwZW4gaW4gcHJlcHJvY2Vzcz9cbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IHRoaXMubWV0YWRhdGEuZGVwZW5kZW5jaWVzLnNsaWNlKCk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEuZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIHZhciBpbmRpcmVjdERlcGVuZGVuY2llcyA9IF90aGlzLmdlbmVyYXRvci5pbmRpcmVjdERlcGVuZGVuY2llcy5nZXQocHJvcCk7XG4gICAgICAgICAgICBpZiAoaW5kaXJlY3REZXBlbmRlbmNpZXMpIHtcbiAgICAgICAgICAgICAgICBpbmRpcmVjdERlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmRpcmVjdERlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF+ZGVwZW5kZW5jaWVzLmluZGV4T2YoaW5kaXJlY3REZXBlbmRlbmN5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKGluZGlyZWN0RGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb250ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICBhbGxVc2VkQ29udGV4dHMuYWRkKGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gdmlldyB0byBtb2RlbFxuICAgICAgICB2YXIgdmFsdWVGcm9tRG9tID0gZ2V0VmFsdWVGcm9tRG9tKHRoaXMuZ2VuZXJhdG9yLCBub2RlLCB0aGlzKTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBnZXRFdmVudEhhbmRsZXIodGhpcy5nZW5lcmF0b3IsIGJsb2NrLCBuYW1lLCBzbmlwcGV0LCB0aGlzLCBkZXBlbmRlbmNpZXMsIHZhbHVlRnJvbURvbSk7XG4gICAgICAgIC8vIG1vZGVsIHRvIHZpZXdcbiAgICAgICAgdmFyIHVwZGF0ZURvbSA9IGdldERvbVVwZGF0ZXIobm9kZSwgdGhpcywgc25pcHBldCk7XG4gICAgICAgIHZhciBpbml0aWFsVXBkYXRlID0gdXBkYXRlRG9tO1xuICAgICAgICAvLyBzcGVjaWFsIGNhc2VzXG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIHZhciBiaW5kaW5nR3JvdXAgPSBnZXRCaW5kaW5nR3JvdXAodGhpcy5nZW5lcmF0b3IsIHRoaXMudmFsdWUpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaHlkcmF0ZS5hZGRMaW5lKFwiI2NvbXBvbmVudC5fYmluZGluZ0dyb3Vwc1tcIiArIGJpbmRpbmdHcm91cCArIFwiXS5wdXNoKFwiICsgbm9kZVtcInZhclwiXSArIFwiKTtcIik7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5kZXN0cm95LmFkZExpbmUoXCIjY29tcG9uZW50Ll9iaW5kaW5nR3JvdXBzW1wiICsgYmluZGluZ0dyb3VwICsgXCJdLnNwbGljZSgjY29tcG9uZW50Ll9iaW5kaW5nR3JvdXBzW1wiICsgYmluZGluZ0dyb3VwICsgXCJdLmluZGV4T2YoXCIgKyBub2RlW1widmFyXCJdICsgXCIpLCAxKTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gJ2N1cnJlbnRUaW1lJykge1xuICAgICAgICAgICAgdXBkYXRlQ29uZGl0aW9uID0gXCIhaXNOYU4oXCIgKyBzbmlwcGV0ICsgXCIpXCI7XG4gICAgICAgICAgICBpbml0aWFsVXBkYXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uYW1lID09PSAncGF1c2VkJykge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCBhdWRpbyByZXN0YXJ0aW5nIGJ5IGl0c2VsZlxuICAgICAgICAgICAgdmFyIGxhc3QgPSBibG9jay5nZXRVbmlxdWVOYW1lKG5vZGVbXCJ2YXJcIl0gKyBcIl9pc19wYXVzZWRcIik7XG4gICAgICAgICAgICBibG9jay5hZGRWYXJpYWJsZShsYXN0LCAndHJ1ZScpO1xuICAgICAgICAgICAgdXBkYXRlQ29uZGl0aW9uID0gbGFzdCArIFwiICE9PSAoXCIgKyBsYXN0ICsgXCIgPSBcIiArIHNuaXBwZXQgKyBcIilcIjtcbiAgICAgICAgICAgIHVwZGF0ZURvbSA9IG5vZGVbXCJ2YXJcIl0gKyBcIltcIiArIGxhc3QgKyBcIiA/IFxcXCJwYXVzZVxcXCIgOiBcXFwicGxheVxcXCJdKCk7XCI7XG4gICAgICAgICAgICBpbml0aWFsVXBkYXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgb2JqZWN0OiBuYW1lLFxuICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcixcbiAgICAgICAgICAgIHVwZGF0ZURvbTogdXBkYXRlRG9tLFxuICAgICAgICAgICAgaW5pdGlhbFVwZGF0ZTogaW5pdGlhbFVwZGF0ZSxcbiAgICAgICAgICAgIG5lZWRzTG9jazogIWlzUmVhZE9ubHkgJiYgbmVlZHNMb2NrLFxuICAgICAgICAgICAgdXBkYXRlQ29uZGl0aW9uOiB1cGRhdGVDb25kaXRpb24sXG4gICAgICAgICAgICBpc1JlYWRPbmx5TWVkaWFBdHRyaWJ1dGU6IHRoaXMuaXNSZWFkT25seU1lZGlhQXR0cmlidXRlKClcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEJpbmRpbmcucHJvdG90eXBlLmlzUmVhZE9ubHlNZWRpYUF0dHJpYnV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRPbmx5TWVkaWFBdHRyaWJ1dGVzLmhhcyh0aGlzLm5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEJpbmRpbmc7XG59KE5vZGUkMSkpO1xuZnVuY3Rpb24gZ2V0RG9tVXBkYXRlcihub2RlLCBiaW5kaW5nLCBzbmlwcGV0KSB7XG4gICAgaWYgKGJpbmRpbmcuaXNSZWFkT25seU1lZGlhQXR0cmlidXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmIChub2RlLm5hbWUgPT09ICdzZWxlY3QnKSB7XG4gICAgICAgIHJldHVybiBub2RlLmdldFN0YXRpY0F0dHJpYnV0ZVZhbHVlKCdtdWx0aXBsZScpID09PSB0cnVlID9cbiAgICAgICAgICAgIFwiQHNlbGVjdE9wdGlvbnMoXCIgKyBub2RlW1widmFyXCJdICsgXCIsIFwiICsgc25pcHBldCArIFwiKVwiIDpcbiAgICAgICAgICAgIFwiQHNlbGVjdE9wdGlvbihcIiArIG5vZGVbXCJ2YXJcIl0gKyBcIiwgXCIgKyBzbmlwcGV0ICsgXCIpXCI7XG4gICAgfVxuICAgIGlmIChiaW5kaW5nLm5hbWUgPT09ICdncm91cCcpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBub2RlLmdldFN0YXRpY0F0dHJpYnV0ZVZhbHVlKCd0eXBlJyk7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB0eXBlID09PSAnY2hlY2tib3gnXG4gICAgICAgICAgICA/IFwiflwiICsgc25pcHBldCArIFwiLmluZGV4T2YoXCIgKyBub2RlW1widmFyXCJdICsgXCIuX192YWx1ZSlcIlxuICAgICAgICAgICAgOiBub2RlW1widmFyXCJdICsgXCIuX192YWx1ZSA9PT0gXCIgKyBzbmlwcGV0O1xuICAgICAgICByZXR1cm4gbm9kZVtcInZhclwiXSArIFwiLmNoZWNrZWQgPSBcIiArIGNvbmRpdGlvbiArIFwiO1wiO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZVtcInZhclwiXSArIFwiLlwiICsgYmluZGluZy5uYW1lICsgXCIgPSBcIiArIHNuaXBwZXQgKyBcIjtcIjtcbn1cbmZ1bmN0aW9uIGdldEJpbmRpbmdHcm91cChnZW5lcmF0b3IsIHZhbHVlKSB7XG4gICAgdmFyIHBhcnRzID0gZmxhdHRlbih2YWx1ZSkucGFydHM7IC8vIFRPRE8gaGFuZGxlIGNhc2VzIGludm9sdmluZyBjb21wdXRlZCBtZW1iZXIgZXhwcmVzc2lvbnNcbiAgICB2YXIga2V5cGF0aCA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAvLyBUT0RPIGhhbmRsZSBjb250ZXh0dWFsIGJpbmRpbmdzIOKAlCBga2V5cGF0aGAgc2hvdWxkIGluY2x1ZGUgdW5pcXVlIElEIG9mXG4gICAgLy8gZWFjaCBibG9jayB0aGF0IHByb3ZpZGVzIGNvbnRleHRcbiAgICB2YXIgaW5kZXggPSBnZW5lcmF0b3IuYmluZGluZ0dyb3Vwcy5pbmRleE9mKGtleXBhdGgpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaW5kZXggPSBnZW5lcmF0b3IuYmluZGluZ0dyb3Vwcy5sZW5ndGg7XG4gICAgICAgIGdlbmVyYXRvci5iaW5kaW5nR3JvdXBzLnB1c2goa2V5cGF0aCk7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50SGFuZGxlcihnZW5lcmF0b3IsIGJsb2NrLCBuYW1lLCBzbmlwcGV0LCBhdHRyaWJ1dGUsIGRlcGVuZGVuY2llcywgdmFsdWUpIHtcbiAgICB2YXIgc3RvcmVEZXBlbmRlbmNpZXMgPSBbXTtcbiAgICBpZiAoZ2VuZXJhdG9yLm9wdGlvbnMuc3RvcmUpIHtcbiAgICAgICAgc3RvcmVEZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXMuZmlsdGVyKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wWzBdID09PSAnJCc7IH0pLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcHJvcC5zbGljZSgxKTsgfSk7XG4gICAgICAgIGRlcGVuZGVuY2llcyA9IGRlcGVuZGVuY2llcy5maWx0ZXIoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByb3BbMF0gIT09ICckJzsgfSk7XG4gICAgfVxuICAgIGlmIChibG9jay5jb250ZXh0cy5oYXMobmFtZSkpIHtcbiAgICAgICAgdmFyIHRhaWwgPSBhdHRyaWJ1dGUudmFsdWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nXG4gICAgICAgICAgICA/IGdldFRhaWxTbmlwcGV0KGF0dHJpYnV0ZS52YWx1ZSlcbiAgICAgICAgICAgIDogJyc7XG4gICAgICAgIHZhciBsaXN0ID0gXCJjb250ZXh0LlwiICsgYmxvY2subGlzdE5hbWVzLmdldChuYW1lKTtcbiAgICAgICAgdmFyIGluZGV4ID0gXCJjb250ZXh0LlwiICsgYmxvY2suaW5kZXhOYW1lcy5nZXQobmFtZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1c2VzQ29udGV4dDogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXNTdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIHVzZXNTdG9yZTogc3RvcmVEZXBlbmRlbmNpZXMubGVuZ3RoID4gMCxcbiAgICAgICAgICAgIG11dGF0aW9uOiBsaXN0ICsgXCJbXCIgKyBpbmRleCArIFwiXVwiICsgdGFpbCArIFwiID0gXCIgKyB2YWx1ZSArIFwiO1wiLFxuICAgICAgICAgICAgcHJvcHM6IGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByb3AgKyBcIjogc3RhdGUuXCIgKyBwcm9wOyB9KSxcbiAgICAgICAgICAgIHN0b3JlUHJvcHM6IHN0b3JlRGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcHJvcCArIFwiOiAkLlwiICsgcHJvcDsgfSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS52YWx1ZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGxpdHRsZSBjb25mdXNpbmcsIGFuZCBzaG91bGQgcHJvYmFibHkgYmUgdGlkaWVkIHVwXG4gICAgICAgIC8vIGF0IHNvbWUgcG9pbnQuIEl0IGFkZHJlc3NlcyBhIHRyaWNreSBidWcgKCM4OTMpLCB3aGVyZWluXG4gICAgICAgIC8vIFN2ZWx0ZSB0cmllcyB0byBgc2V0KClgIGEgY29tcHV0ZWQgcHJvcGVydHksIHdoaWNoIHRocm93cyBhblxuICAgICAgICAvLyBlcnJvciBpbiBkZXYgbW9kZS4gYSkgaXQncyBwb3NzaWJsZSB0aGF0IHdlIHNob3VsZCBiZVxuICAgICAgICAvLyByZXBsYWNpbmcgY29tcHV0YXRpb25zIHdpdGggKnRoZWlyKiBkZXBlbmRlbmNpZXMsIGFuZCBiKVxuICAgICAgICAvLyB3ZSBzaG91bGQgcHJvYmFibHkgcG9wdWxhdGUgYGdlbmVyYXRvci5yZWFkb25seWAgc29vbmVyIHNvXG4gICAgICAgIC8vIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBkbyB0aGUgYC5zb21lKClgIGhlcmVcbiAgICAgICAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLmZpbHRlcihmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gIWdlbmVyYXRvci5jb21wdXRhdGlvbnMuc29tZShmdW5jdGlvbiAoY29tcHV0YXRpb24pIHsgcmV0dXJuIGNvbXB1dGF0aW9uLmtleSA9PT0gcHJvcDsgfSk7IH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlc0NvbnRleHQ6IGZhbHNlLFxuICAgICAgICAgICAgdXNlc1N0YXRlOiB0cnVlLFxuICAgICAgICAgICAgdXNlc1N0b3JlOiBzdG9yZURlcGVuZGVuY2llcy5sZW5ndGggPiAwLFxuICAgICAgICAgICAgbXV0YXRpb246IHNuaXBwZXQgKyBcIiA9IFwiICsgdmFsdWUsXG4gICAgICAgICAgICBwcm9wczogZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcHJvcCArIFwiOiBzdGF0ZS5cIiArIHByb3A7IH0pLFxuICAgICAgICAgICAgc3RvcmVQcm9wczogc3RvcmVEZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wICsgXCI6ICQuXCIgKyBwcm9wOyB9KVxuICAgICAgICB9O1xuICAgIH1cbiAgICB2YXIgcHJvcHM7XG4gICAgdmFyIHN0b3JlUHJvcHM7XG4gICAgaWYgKGdlbmVyYXRvci5vcHRpb25zLnN0b3JlICYmIG5hbWVbMF0gPT09ICckJykge1xuICAgICAgICBwcm9wcyA9IFtdO1xuICAgICAgICBzdG9yZVByb3BzID0gW25hbWUuc2xpY2UoMSkgKyBcIjogXCIgKyB2YWx1ZV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcm9wcyA9IFtuYW1lICsgXCI6IFwiICsgdmFsdWVdO1xuICAgICAgICBzdG9yZVByb3BzID0gW107XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZXNDb250ZXh0OiBmYWxzZSxcbiAgICAgICAgdXNlc1N0YXRlOiBmYWxzZSxcbiAgICAgICAgdXNlc1N0b3JlOiBmYWxzZSxcbiAgICAgICAgbXV0YXRpb246IG51bGwsXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgc3RvcmVQcm9wczogc3RvcmVQcm9wc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21Eb20oZ2VuZXJhdG9yLCBub2RlLCBiaW5kaW5nKSB7XG4gICAgLy8gPHNlbGVjdCBiaW5kOnZhbHVlPSdzZWxlY3RlZD5cbiAgICBpZiAobm9kZS5uYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICByZXR1cm4gbm9kZS5nZXRTdGF0aWNBdHRyaWJ1dGVWYWx1ZSgnbXVsdGlwbGUnKSA9PT0gdHJ1ZSA/XG4gICAgICAgICAgICBcIkBzZWxlY3RNdWx0aXBsZVZhbHVlKFwiICsgbm9kZVtcInZhclwiXSArIFwiKVwiIDpcbiAgICAgICAgICAgIFwiQHNlbGVjdFZhbHVlKFwiICsgbm9kZVtcInZhclwiXSArIFwiKVwiO1xuICAgIH1cbiAgICB2YXIgdHlwZSA9IG5vZGUuZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUoJ3R5cGUnKTtcbiAgICAvLyA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIGJpbmQ6Z3JvdXA9J2Zvbyc+XG4gICAgaWYgKGJpbmRpbmcubmFtZSA9PT0gJ2dyb3VwJykge1xuICAgICAgICB2YXIgYmluZGluZ0dyb3VwID0gZ2V0QmluZGluZ0dyb3VwKGdlbmVyYXRvciwgYmluZGluZy52YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJAZ2V0QmluZGluZ0dyb3VwVmFsdWUoI2NvbXBvbmVudC5fYmluZGluZ0dyb3Vwc1tcIiArIGJpbmRpbmdHcm91cCArIFwiXSlcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZVtcInZhclwiXSArIFwiLl9fdmFsdWVcIjtcbiAgICB9XG4gICAgLy8gPGlucHV0IHR5cGU9J3JhbmdlfG51bWJlcicgYmluZDp2YWx1ZT5cbiAgICBpZiAodHlwZSA9PT0gJ3JhbmdlJyB8fCB0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gXCJAdG9OdW1iZXIoXCIgKyBub2RlW1widmFyXCJdICsgXCIuXCIgKyBiaW5kaW5nLm5hbWUgKyBcIilcIjtcbiAgICB9XG4gICAgaWYgKChiaW5kaW5nLm5hbWUgPT09ICdidWZmZXJlZCcgfHwgYmluZGluZy5uYW1lID09PSAnc2Vla2FibGUnIHx8IGJpbmRpbmcubmFtZSA9PT0gJ3BsYXllZCcpKSB7XG4gICAgICAgIHJldHVybiBcIkB0aW1lUmFuZ2VzVG9BcnJheShcIiArIG5vZGVbXCJ2YXJcIl0gKyBcIi5cIiArIGJpbmRpbmcubmFtZSArIFwiKVwiO1xuICAgIH1cbiAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICByZXR1cm4gbm9kZVtcInZhclwiXSArIFwiLlwiICsgYmluZGluZy5uYW1lO1xufVxuXG52YXIgQ2F0Y2hCbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ2F0Y2hCbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYXRjaEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDYXRjaEJsb2NrO1xufShOb2RlJDEpKTtcblxudmFyIENvbW1lbnQkMiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21tZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBDb21tZW50O1xufShOb2RlJDEpKTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcHMocHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuICd7fSc7XG4gICAgdmFyIGpvaW5lZCA9IHByb3BzLmpvaW4oJywgJyk7XG4gICAgaWYgKGpvaW5lZC5sZW5ndGggPiA0MCkge1xuICAgICAgICAvLyBtYWtlIGxhcmdlciBkYXRhIG9iamVjdHMgcmVhZGFibGVcbiAgICAgICAgcmV0dXJuIFwie1xcblxcdFwiICsgcHJvcHMuam9pbignLFxcblxcdCcpICsgXCJcXG59XCI7XG4gICAgfVxuICAgIHJldHVybiBcInsgXCIgKyBqb2luZWQgKyBcIiB9XCI7XG59XG5cbnZhciBDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbXBvbmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGJsb2NrLCBzdHJpcFdoaXRlc3BhY2UsIG5leHRTaWJsaW5nKSB7XG4gICAgICAgIHRoaXMuY2Fubm90VXNlSW5uZXJIVE1MKCk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ0F0dHJpYnV0ZScgJiYgYXR0cmlidXRlLnZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLnZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaHVuay50eXBlICE9PSAnVGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSBjaHVuay5tZXRhZGF0YS5kZXBlbmRlbmNpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5hZGREZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnRXZlbnRIYW5kbGVyJyAmJiBhdHRyaWJ1dGUuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuZXhwcmVzc2lvbi5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5hZGREZXBlbmRlbmNpZXMoYXJnLm1ldGFkYXRhLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ0JpbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmFkZERlcGVuZGVuY2llcyhhdHRyaWJ1dGUubWV0YWRhdGEuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzW1widmFyXCJdID0gYmxvY2suZ2V0VW5pcXVlTmFtZSgodGhpcy5uYW1lID09PSAnOlNlbGYnID8gdGhpcy5nZW5lcmF0b3IubmFtZSA6XG4gICAgICAgICAgICB0aGlzLm5hbWUgPT09ICc6Q29tcG9uZW50JyA/ICdzd2l0Y2hfaW5zdGFuY2UnIDpcbiAgICAgICAgICAgICAgICB0aGlzLm5hbWUpLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Nsb3RzID0gbmV3IFNldChbJ2RlZmF1bHQnXSk7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuaW5pdChibG9jaywgc3RyaXBXaGl0ZXNwYWNlLCBuZXh0U2libGluZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IHRoaXMuZ2VuZXJhdG9yO1xuICAgICAgICBnZW5lcmF0b3IuaGFzQ29tcG9uZW50cyA9IHRydWU7XG4gICAgICAgIHZhciBuYW1lID0gdGhpc1tcInZhclwiXTtcbiAgICAgICAgdmFyIGNvbXBvbmVudEluaXRQcm9wZXJ0aWVzID0gW1wicm9vdDogI2NvbXBvbmVudC5yb290XCJdO1xuICAgICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc2xvdHMgPSBBcnJheS5mcm9tKHRoaXMuX3Nsb3RzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgKyBcIjogQGNyZWF0ZUZyYWdtZW50KClcIjsgfSk7XG4gICAgICAgICAgICBjb21wb25lbnRJbml0UHJvcGVydGllcy5wdXNoKFwic2xvdHM6IHsgXCIgKyBzbG90cy5qb2luKCcsICcpICsgXCIgfVwiKTtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZC5idWlsZChibG9jaywgX3RoaXNbXCJ2YXJcIl0gKyBcIi5fc2xvdHRlZC5kZWZhdWx0XCIsICdub2RlcycpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsbENvbnRleHRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgc3RhdGVtZW50cyA9IFtdO1xuICAgICAgICB2YXIgbmFtZV9jb250ZXh0ID0gYmxvY2suZ2V0VW5pcXVlTmFtZShuYW1lICsgXCJfY29udGV4dFwiKTtcbiAgICAgICAgdmFyIG5hbWVfdXBkYXRpbmc7XG4gICAgICAgIHZhciBuYW1lX2luaXRpYWxfZGF0YTtcbiAgICAgICAgdmFyIGJlZm9yZWNyZWF0ZSA9IG51bGw7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnR5cGUgPT09ICdBdHRyaWJ1dGUnOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoYSkgeyByZXR1cm4gbXVuZ2VBdHRyaWJ1dGUoYSwgYmxvY2spOyB9KTtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5hdHRyaWJ1dGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnR5cGUgPT09ICdCaW5kaW5nJzsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG11bmdlQmluZGluZyhhLCBibG9jayk7IH0pO1xuICAgICAgICB2YXIgZXZlbnRIYW5kbGVycyA9IHRoaXMuYXR0cmlidXRlc1xuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50eXBlID09PSAnRXZlbnRIYW5kbGVyJzsgfSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIG11bmdlRXZlbnRIYW5kbGVyKGdlbmVyYXRvciwgX3RoaXMsIGEsIGJsb2NrLCBuYW1lX2NvbnRleHQsIGFsbENvbnRleHRzKTsgfSk7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLmF0dHJpYnV0ZXMuZmluZChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50eXBlID09PSAnUmVmJzsgfSk7XG4gICAgICAgIGlmIChyZWYpXG4gICAgICAgICAgICBnZW5lcmF0b3IudXNlc1JlZnMgPSB0cnVlO1xuICAgICAgICB2YXIgdXBkYXRlcyA9IFtdO1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5sZW5ndGggfHwgYmluZGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFByb3BzID0gYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyByZXR1cm4gYXR0cmlidXRlLm5hbWUgKyBcIjogXCIgKyBhdHRyaWJ1dGUudmFsdWU7IH0pO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxQcm9wU3RyaW5nID0gc3RyaW5naWZ5UHJvcHMoaW5pdGlhbFByb3BzKTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgcmV0dXJuIGF0dHJpYnV0ZS5keW5hbWljOyB9KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlLmRlcGVuZGVuY2llcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlcy5wdXNoKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkNSB8fCAodGVtcGxhdGVPYmplY3RfMSQ1ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikgXCIsIFwiX2NoYW5nZXMuXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIpIFwiLCBcIl9jaGFuZ2VzLlwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIl0pKSwgYXR0cmlidXRlLmRlcGVuZGVuY2llc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZGVwZW5kZW5jeSkgeyByZXR1cm4gXCJjaGFuZ2VkLlwiICsgZGVwZW5kZW5jeTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcgfHwgJyksIG5hbWUsIGF0dHJpYnV0ZS5uYW1lLCBhdHRyaWJ1dGUudmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBpcyBhbiBvZGQgc2l0dWF0aW9uIHRvIGVuY291bnRlciDigJMgSSAqdGhpbmsqIGl0IHNob3VsZCBvbmx5IGhhcHBlbiB3aXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIGVhY2ggYmxvY2sgaW5kaWNlcywgaW4gd2hpY2ggY2FzZSBpdCBtYXkgYmUgcG9zc2libGUgdG8gb3B0aW1pc2UgdGhpc1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2gobmFtZSArIFwiX2NoYW5nZXMuXCIgKyBhdHRyaWJ1dGUubmFtZSArIFwiID0gXCIgKyBhdHRyaWJ1dGUudmFsdWUgKyBcIjtcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYmluZGluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdG9yLmhhc0NvbXBsZXhCaW5kaW5ncyA9IHRydWU7XG4gICAgICAgICAgICAgICAgbmFtZV91cGRhdGluZyA9IGJsb2NrLmFsaWFzKG5hbWUgKyBcIl91cGRhdGluZ1wiKTtcbiAgICAgICAgICAgICAgICBuYW1lX2luaXRpYWxfZGF0YSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUobmFtZSArIFwiX2luaXRpYWxfZGF0YVwiKTtcbiAgICAgICAgICAgICAgICBibG9jay5hZGRWYXJpYWJsZShuYW1lX3VwZGF0aW5nLCAne30nKTtcbiAgICAgICAgICAgICAgICBzdGF0ZW1lbnRzLnB1c2goXCJ2YXIgXCIgKyBuYW1lX2luaXRpYWxfZGF0YSArIFwiID0gXCIgKyBpbml0aWFsUHJvcFN0cmluZyArIFwiO1wiKTtcbiAgICAgICAgICAgICAgICB2YXIgc2V0UGFyZW50RnJvbUNoaWxkT25DaGFuZ2VfMSA9IG5ldyBDb2RlQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIHZhciBzZXRQYXJlbnRGcm9tQ2hpbGRPbkluaXRfMSA9IG5ldyBDb2RlQnVpbGRlcigpO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNldFBhcmVudEZyb21DaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZy5jb250ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxDb250ZXh0cy5hZGQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0T2JqZWN0KGJpbmRpbmcudmFsdWUpLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9jay5jb250ZXh0cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHByb3AgPSBiaW5kaW5nLmRlcGVuZGVuY2llc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb21wdXRlZCA9IGlzQ29tcHV0ZWQkMShiaW5kaW5nLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWlsID0gYmluZGluZy52YWx1ZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgPyBnZXRUYWlsU25pcHBldChiaW5kaW5nLnZhbHVlKSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0UGFyZW50RnJvbUNoaWxkID0gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMiQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgbGlzdCA9IFwiLCBcIi5cIiwgXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gXCIsIFwiLlwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsaXN0W2luZGV4XVwiLCBcIiA9IGNoaWxkU3RhdGUuXCIsIFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGxpc3QgPSBcIiwgXCIuXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbmRleCA9IFwiLCBcIi5cIiwgXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGlzdFtpbmRleF1cIiwgXCIgPSBjaGlsZFN0YXRlLlwiLCBcIjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiXSkpLCBuYW1lX2NvbnRleHQsIGJsb2NrLmxpc3ROYW1lcy5nZXQoa2V5KSwgbmFtZV9jb250ZXh0LCBibG9jay5pbmRleE5hbWVzLmdldChrZXkpLCB0YWlsLCBiaW5kaW5nLm5hbWUsIGJpbmRpbmcuZGVwZW5kZW5jaWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gXCJuZXdTdGF0ZS5cIiArIHByb3AgKyBcIiA9IHN0YXRlLlwiICsgcHJvcCArIFwiO1wiOyB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYmluZGluZy52YWx1ZS50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFBhcmVudEZyb21DaGlsZCA9IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzMkNSB8fCAodGVtcGxhdGVPYmplY3RfMyQ1ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gY2hpbGRTdGF0ZS5cIiwgXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBjaGlsZFN0YXRlLlwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIl0pKSwgYmluZGluZy5zbmlwcGV0LCBiaW5kaW5nLm5hbWUsIGJpbmRpbmcuZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gXCJuZXdTdGF0ZS5cIiArIHByb3AgKyBcIiA9IHN0YXRlLlwiICsgcHJvcCArIFwiO1wiOyB9KS5qb2luKCdcXG4nKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRQYXJlbnRGcm9tQ2hpbGQgPSBcIm5ld1N0YXRlLlwiICsgYmluZGluZy52YWx1ZS5uYW1lICsgXCIgPSBjaGlsZFN0YXRlLlwiICsgYmluZGluZy5uYW1lICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzQkNSB8fCAodGVtcGxhdGVPYmplY3RfNCQ1ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIiBpbiBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5cIiwgXCIgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIgaW4gXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLlwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuXCIsIFwiID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XCJdKSksIGJpbmRpbmcucHJvcCwgYmluZGluZy5vYmosIG5hbWVfaW5pdGlhbF9kYXRhLCBiaW5kaW5nLm5hbWUsIGJpbmRpbmcuc25pcHBldCwgbmFtZV91cGRhdGluZywgYmluZGluZy5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFBhcmVudEZyb21DaGlsZE9uQ2hhbmdlXzEuYWRkQ29uZGl0aW9uYWwoXCIhXCIgKyBuYW1lX3VwZGF0aW5nICsgXCIuXCIgKyBiaW5kaW5nLm5hbWUgKyBcIiAmJiBjaGFuZ2VkLlwiICsgYmluZGluZy5uYW1lLCBzZXRQYXJlbnRGcm9tQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBzZXRQYXJlbnRGcm9tQ2hpbGRPbkluaXRfMS5hZGRDb25kaXRpb25hbChcIiFcIiArIG5hbWVfdXBkYXRpbmcgKyBcIi5cIiArIGJpbmRpbmcubmFtZSwgc2V0UGFyZW50RnJvbUNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjb3VsZCBiaW5kaW5nLmRlcGVuZGVuY2llcy5sZW5ndGggZXZlciBiZSAwP1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmluZGluZy5kZXBlbmRlbmNpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzLnB1c2goZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNSQzIHx8ICh0ZW1wbGF0ZU9iamVjdF81JDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIVwiLCBcIi5cIiwgXCIgJiYgXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiX2NoYW5nZXMuXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5cIiwgXCIgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghXCIsIFwiLlwiLCBcIiAmJiBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJfY2hhbmdlcy5cIiwgXCIgPSBcIiwgXCI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLlwiLCBcIiA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFwiXSkpLCBuYW1lX3VwZGF0aW5nLCBiaW5kaW5nLm5hbWUsIGJpbmRpbmcuZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwZW5kZW5jeSkgeyByZXR1cm4gXCJjaGFuZ2VkLlwiICsgZGVwZW5kZW5jeTsgfSkuam9pbignIHx8ICcpLCBuYW1lLCBiaW5kaW5nLm5hbWUsIGJpbmRpbmcuc25pcHBldCwgbmFtZV91cGRhdGluZywgYmluZGluZy5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRJbml0UHJvcGVydGllcy5wdXNoKFwiZGF0YTogXCIgKyBuYW1lX2luaXRpYWxfZGF0YSk7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50SW5pdFByb3BlcnRpZXMucHVzaChkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF82JDMgfHwgKHRlbXBsYXRlT2JqZWN0XzYkMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdF9iaW5kOiBmdW5jdGlvbihjaGFuZ2VkLCBjaGlsZFN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHN0YXRlID0gI2NvbXBvbmVudC5nZXQoKSwgbmV3U3RhdGUgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBAYXNzaWduKHt9LCBjaGFuZ2VkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQjY29tcG9uZW50Ll9zZXQobmV3U3RhdGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdF9iaW5kOiBmdW5jdGlvbihjaGFuZ2VkLCBjaGlsZFN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHN0YXRlID0gI2NvbXBvbmVudC5nZXQoKSwgbmV3U3RhdGUgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBAYXNzaWduKHt9LCBjaGFuZ2VkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQjY29tcG9uZW50Ll9zZXQobmV3U3RhdGUpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcIl0pKSwgc2V0UGFyZW50RnJvbUNoaWxkT25DaGFuZ2VfMSwgbmFtZV91cGRhdGluZywgbmFtZV91cGRhdGluZykpO1xuICAgICAgICAgICAgICAgIGJlZm9yZWNyZWF0ZSA9IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzckMiB8fCAodGVtcGxhdGVPYmplY3RfNyQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0I2NvbXBvbmVudC5yb290Ll9iZWZvcmVjcmVhdGUucHVzaChmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc3RhdGUgPSAjY29tcG9uZW50LmdldCgpLCBjaGlsZFN0YXRlID0gXCIsIFwiLmdldCgpLCBuZXdTdGF0ZSA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICghY2hpbGRTdGF0ZSkgcmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IHsgXCIsIFwiIH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0I2NvbXBvbmVudC5fc2V0KG5ld1N0YXRlKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQucm9vdC5fYmVmb3JlY3JlYXRlLnB1c2goZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHN0YXRlID0gI2NvbXBvbmVudC5nZXQoKSwgY2hpbGRTdGF0ZSA9IFwiLCBcIi5nZXQoKSwgbmV3U3RhdGUgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIWNoaWxkU3RhdGUpIHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSB7IFwiLCBcIiB9O1xcblxcdFxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQuX3NldChuZXdTdGF0ZSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0ge307XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XCJdKSksIG5hbWUsIHNldFBhcmVudEZyb21DaGlsZE9uSW5pdF8xLCBuYW1lX3VwZGF0aW5nLCBiaW5kaW5ncy5tYXAoZnVuY3Rpb24gKGJpbmRpbmcpIHsgcmV0dXJuIGJpbmRpbmcubmFtZSArIFwiOiB0cnVlXCI7IH0pLmpvaW4oJywgJyksIG5hbWVfdXBkYXRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaW5pdGlhbFByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudEluaXRQcm9wZXJ0aWVzLnB1c2goXCJkYXRhOiBcIiArIGluaXRpYWxQcm9wU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNEeW5hbWljQ29tcG9uZW50ID0gdGhpcy5uYW1lID09PSAnOkNvbXBvbmVudCc7XG4gICAgICAgIHZhciBzd2l0Y2hfdmFycyA9IGlzRHluYW1pY0NvbXBvbmVudCAmJiB7XG4gICAgICAgICAgICB2YWx1ZTogYmxvY2suZ2V0VW5pcXVlTmFtZSgnc3dpdGNoX3ZhbHVlJyksXG4gICAgICAgICAgICBwcm9wczogYmxvY2suZ2V0VW5pcXVlTmFtZSgnc3dpdGNoX3Byb3BzJylcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGV4cHJlc3Npb24gPSAodGhpcy5uYW1lID09PSAnOlNlbGYnID8gZ2VuZXJhdG9yLm5hbWUgOlxuICAgICAgICAgICAgaXNEeW5hbWljQ29tcG9uZW50ID8gc3dpdGNoX3ZhcnMudmFsdWUgOlxuICAgICAgICAgICAgICAgIFwiJWNvbXBvbmVudHMtXCIgKyB0aGlzLm5hbWUpO1xuICAgICAgICBpZiAoaXNEeW5hbWljQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBibG9jay5jb250ZXh0dWFsaXNlKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgICAgICAgICB2YXIgX2EgPSB0aGlzLm1ldGFkYXRhLCBkZXBlbmRlbmNpZXMgPSBfYS5kZXBlbmRlbmNpZXMsIHNuaXBwZXQgPSBfYS5zbmlwcGV0O1xuICAgICAgICAgICAgdmFyIGFuY2hvciA9IHRoaXMuZ2V0T3JDcmVhdGVBbmNob3IoYmxvY2ssIHBhcmVudE5vZGUsIHBhcmVudE5vZGVzKTtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBibG9jay5wYXJhbXMuam9pbignLCAnKTtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmluaXQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfOCQyIHx8ICh0ZW1wbGF0ZU9iamVjdF84JDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gbmV3IFwiLCBcIihcIiwgXCIoXCIsIFwiKSk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIjtcXG5cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IG5ldyBcIiwgXCIoXCIsIFwiKFwiLCBcIikpO1xcblxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcIixcbiAgICAgICAgICAgICAgICBcIlxcblxcdFxcdFxcdFwiXSkpLCBzd2l0Y2hfdmFycy52YWx1ZSwgc25pcHBldCwgc3dpdGNoX3ZhcnMucHJvcHMsIHBhcmFtcywgY29tcG9uZW50SW5pdFByb3BlcnRpZXMuam9pbignLFxcbicpLCBzd2l0Y2hfdmFycy52YWx1ZSwgc3RhdGVtZW50cy5sZW5ndGggPiAwICYmIHN0YXRlbWVudHMuam9pbignXFxuJyksIG5hbWUsIGV4cHJlc3Npb24sIHN3aXRjaF92YXJzLnByb3BzLCBwYXJhbXMsIGJlZm9yZWNyZWF0ZSwgZXZlbnRIYW5kbGVycy5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzkkMSB8fCAodGVtcGxhdGVPYmplY3RfOSQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5vbihcXFwiXCIsIFwiXFxcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSBcIiwgXCIub24oXFxcIlwiLCBcIlxcXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XCJdKSksIGhhbmRsZXJbXCJ2YXJcIl0sIGhhbmRsZXIuYm9keSwgbmFtZSwgbmFtZSwgaGFuZGxlci5uYW1lLCBoYW5kbGVyW1widmFyXCJdKTsgfSkpKTtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNyZWF0ZS5hZGRMaW5lKFwiaWYgKFwiICsgbmFtZSArIFwiKSBcIiArIG5hbWUgKyBcIi5fZnJhZ21lbnQuYygpO1wiKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2Rlcykge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNsYWltLmFkZExpbmUoXCJpZiAoXCIgKyBuYW1lICsgXCIpIFwiICsgbmFtZSArIFwiLl9mcmFnbWVudC5sKFwiICsgcGFyZW50Tm9kZXMgKyBcIik7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMubW91bnQuYWRkTGluZShcImlmIChcIiArIG5hbWUgKyBcIikgXCIgKyBuYW1lICsgXCIuX21vdW50KFwiICsgKHBhcmVudE5vZGUgfHwgJyN0YXJnZXQnKSArIFwiLCBcIiArIChwYXJlbnROb2RlID8gJ251bGwnIDogJ2FuY2hvcicpICsgXCIpO1wiKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVNb3VudE5vZGUgPSB0aGlzLmdldFVwZGF0ZU1vdW50Tm9kZShhbmNob3IpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMudXBkYXRlLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEwJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzEwJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiICE9PSAoXCIsIFwiID0gXCIsIFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5kZXN0cm95KCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IG5ldyBcIiwgXCIoXCIsIFwiKFwiLCBcIikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5fZnJhZ21lbnQuYygpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5fbW91bnQoXCIsIFwiLCBcIiwgXCIpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiICE9PSAoXCIsIFwiID0gXCIsIFwiKSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5kZXN0cm95KCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IG5ldyBcIiwgXCIoXCIsIFwiKFwiLCBcIikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5fZnJhZ21lbnQuYygpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5fbW91bnQoXCIsIFwiLCBcIiwgXCIpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBzd2l0Y2hfdmFycy52YWx1ZSwgc3dpdGNoX3ZhcnMudmFsdWUsIHNuaXBwZXQsIG5hbWUsIG5hbWUsIHN3aXRjaF92YXJzLnZhbHVlLCBuYW1lLCBzd2l0Y2hfdmFycy52YWx1ZSwgc3dpdGNoX3ZhcnMucHJvcHMsIHBhcmFtcywgbmFtZSwgdGhpcy5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiByZW1vdW50KGdlbmVyYXRvciwgY2hpbGQsIG5hbWUpOyB9KSwgbmFtZSwgdXBkYXRlTW91bnROb2RlLCBhbmNob3IsIGV2ZW50SGFuZGxlcnMubWFwKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xMSQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8xMSQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLm9uKFxcXCJcIiwgXCJcXFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLm9uKFxcXCJcIiwgXCJcXFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiXSkpLCBuYW1lLCBoYW5kbGVyLm5hbWUsIGhhbmRsZXJbXCJ2YXJcIl0pOyB9KSwgcmVmICYmIFwiI2NvbXBvbmVudC5yZWZzLlwiICsgcmVmLm5hbWUgKyBcIiA9IFwiICsgbmFtZSArIFwiO1wiLCByZWYgJiYgZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTIkMSB8fCAodGVtcGxhdGVPYmplY3RfMTIkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdGVsc2UgaWYgKCNjb21wb25lbnQucmVmcy5cIiwgXCIgPT09IFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQucmVmcy5cIiwgXCIgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdGVsc2UgaWYgKCNjb21wb25lbnQucmVmcy5cIiwgXCIgPT09IFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQucmVmcy5cIiwgXCIgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cIl0pKSwgcmVmLm5hbWUsIG5hbWUsIHJlZi5uYW1lKSkpO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMudXBkYXRlLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEzJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzEzJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgXCIsIFwiX2NoYW5nZXMgPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuX3NldChcIiwgXCJfY2hhbmdlcyk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFwiLCBcIl9jaGFuZ2VzID0ge307XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLl9zZXQoXCIsIFwiX2NoYW5nZXMpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcIl0pKSwgbmFtZSwgdXBkYXRlcy5qb2luKCdcXG4nKSwgbmFtZSwgbmFtZSwgYmluZGluZ3MubGVuZ3RoICYmIG5hbWVfdXBkYXRpbmcgKyBcIiA9IHt9O1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMudW5tb3VudC5hZGRMaW5lKFwiaWYgKFwiICsgbmFtZSArIFwiKSBcIiArIG5hbWUgKyBcIi5fdW5tb3VudCgpO1wiKTtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kuYWRkTGluZShcImlmIChcIiArIG5hbWUgKyBcIikgXCIgKyBuYW1lICsgXCIuZGVzdHJveShmYWxzZSk7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xNCQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8xNCQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IG5ldyBcIiwgXCIoe1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IG5ldyBcIiwgXCIoe1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XCJdKSksIHN0YXRlbWVudHMuam9pbignXFxuJyksIG5hbWUsIGV4cHJlc3Npb24sIGNvbXBvbmVudEluaXRQcm9wZXJ0aWVzLmpvaW4oJyxcXG4nKSwgYmVmb3JlY3JlYXRlLCBldmVudEhhbmRsZXJzLm1hcChmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTUkMSB8fCAodGVtcGxhdGVPYmplY3RfMTUkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5vbihcXFwiXCIsIFwiXFxcIiwgZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5vbihcXFwiXCIsIFwiXFxcIiwgZnVuY3Rpb24oZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcIl0pKSwgbmFtZSwgaGFuZGxlci5uYW1lLCBoYW5kbGVyLmJvZHkpOyB9KSwgcmVmICYmIFwiI2NvbXBvbmVudC5yZWZzLlwiICsgcmVmLm5hbWUgKyBcIiA9IFwiICsgbmFtZSArIFwiO1wiKSk7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5jcmVhdGUuYWRkTGluZShuYW1lICsgXCIuX2ZyYWdtZW50LmMoKTtcIik7XG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZXMpIHtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy5jbGFpbS5hZGRMaW5lKG5hbWUgKyBcIi5fZnJhZ21lbnQubChcIiArIHBhcmVudE5vZGVzICsgXCIpO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLm1vdW50LmFkZExpbmUobmFtZSArIFwiLl9tb3VudChcIiArIChwYXJlbnROb2RlIHx8ICcjdGFyZ2V0JykgKyBcIiwgXCIgKyAocGFyZW50Tm9kZSA/ICdudWxsJyA6ICdhbmNob3InKSArIFwiKTtcIik7XG4gICAgICAgICAgICBpZiAodXBkYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy51cGRhdGUuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTYkMSB8fCAodGVtcGxhdGVPYmplY3RfMTYkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdHZhciBcIiwgXCJfY2hhbmdlcyA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5fc2V0KFwiLCBcIl9jaGFuZ2VzKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdHZhciBcIiwgXCJfY2hhbmdlcyA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5fc2V0KFwiLCBcIl9jaGFuZ2VzKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcIl0pKSwgbmFtZSwgdXBkYXRlcy5qb2luKCdcXG4nKSwgbmFtZSwgbmFtZSwgYmluZGluZ3MubGVuZ3RoICYmIG5hbWVfdXBkYXRpbmcgKyBcIiA9IHt9O1wiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMudW5tb3VudC5hZGRMaW5lKG5hbWUgKyBcIi5fdW5tb3VudCgpO1wiKTtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kuYWRkTGluZShkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xNyQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8xNyQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XCIsIFwiLmRlc3Ryb3koZmFsc2UpO1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XCIsIFwiLmRlc3Ryb3koZmFsc2UpO1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFwiXSkpLCBuYW1lLCByZWYgJiYgXCJpZiAoI2NvbXBvbmVudC5yZWZzLlwiICsgcmVmLm5hbWUgKyBcIiA9PT0gXCIgKyBuYW1lICsgXCIpICNjb21wb25lbnQucmVmcy5cIiArIHJlZi5uYW1lICsgXCIgPSBudWxsO1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFpbnRhaW4gY29tcG9uZW50IGNvbnRleHRcbiAgICAgICAgaWYgKGFsbENvbnRleHRzLnNpemUpIHtcbiAgICAgICAgICAgIHZhciBjb250ZXh0cyA9IEFycmF5LmZyb20oYWxsQ29udGV4dHMpO1xuICAgICAgICAgICAgdmFyIGluaXRpYWxQcm9wcyA9IGNvbnRleHRzXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoY29udGV4dE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dE5hbWUgPT09ICdzdGF0ZScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0YXRlOiBzdGF0ZVwiO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0TmFtZSA9IGJsb2NrLmxpc3ROYW1lcy5nZXQoY29udGV4dE5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE5hbWUgPSBibG9jay5pbmRleE5hbWVzLmdldChjb250ZXh0TmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3ROYW1lICsgXCI6IFwiICsgbGlzdE5hbWUgKyBcIixcXG5cIiArIGluZGV4TmFtZSArIFwiOiBcIiArIGluZGV4TmFtZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJyxcXG4nKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVzXzEgPSBjb250ZXh0c1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNvbnRleHROYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHROYW1lID09PSAnc3RhdGUnKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmFtZV9jb250ZXh0ICsgXCIuc3RhdGUgPSBzdGF0ZTtcIjtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdE5hbWUgPSBibG9jay5saXN0TmFtZXMuZ2V0KGNvbnRleHROYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhOYW1lID0gYmxvY2suaW5kZXhOYW1lcy5nZXQoY29udGV4dE5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lX2NvbnRleHQgKyBcIi5cIiArIGxpc3ROYW1lICsgXCIgPSBcIiArIGxpc3ROYW1lICsgXCI7XFxuXCIgKyBuYW1lX2NvbnRleHQgKyBcIi5cIiArIGluZGV4TmFtZSArIFwiID0gXCIgKyBpbmRleE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xOCQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8xOCQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFwiXSkpLCBuYW1lX2NvbnRleHQsIGluaXRpYWxQcm9wcykpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMudXBkYXRlLmFkZEJsb2NrKHVwZGF0ZXNfMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb21wb25lbnQ7XG59KE5vZGUkMSkpO1xuZnVuY3Rpb24gbXVuZ2VBdHRyaWJ1dGUoYXR0cmlidXRlLCBibG9jaykge1xuICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgLy8gYXR0cmlidXRlcyB3aXRob3V0IHZhbHVlcywgZS5nLiA8dGV4dGFyZWEgcmVhZG9ubHk+XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBhdHRyaWJ1dGUubmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgZHluYW1pYzogZmFsc2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IGF0dHJpYnV0ZS5uYW1lLFxuICAgICAgICAgICAgdmFsdWU6IFwiJydcIixcbiAgICAgICAgICAgIGR5bmFtaWM6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciB2YWx1ZV8xID0gYXR0cmlidXRlLnZhbHVlWzBdO1xuICAgICAgICBpZiAodmFsdWVfMS50eXBlID09PSAnVGV4dCcpIHtcbiAgICAgICAgICAgIC8vIHN0YXRpYyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGF0dHJpYnV0ZS5uYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBpc05hTih2YWx1ZV8xLmRhdGEpID8gc3RyaW5naWZ5KHZhbHVlXzEuZGF0YSkgOiB2YWx1ZV8xLmRhdGEsXG4gICAgICAgICAgICAgICAgZHluYW1pYzogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2ltcGxlIGR5bmFtaWMgYXR0cmlidXRlc1xuICAgICAgICBibG9jay5jb250ZXh0dWFsaXNlKHZhbHVlXzEuZXhwcmVzc2lvbik7IC8vIFRPRE8gcmVtb3ZlXG4gICAgICAgIHZhciBfYSA9IHZhbHVlXzEubWV0YWRhdGEsIGRlcGVuZGVuY2llcyA9IF9hLmRlcGVuZGVuY2llcywgc25pcHBldCA9IF9hLnNuaXBwZXQ7XG4gICAgICAgIC8vIFRPRE8gb25seSB1cGRhdGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZFxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogYXR0cmlidXRlLm5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogc25pcHBldCxcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogZGVwZW5kZW5jaWVzLFxuICAgICAgICAgICAgZHluYW1pYzogdHJ1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBvdGhlcndpc2Ugd2UncmUgZGVhbGluZyB3aXRoIGEgY29tcGxleCBkeW5hbWljIGF0dHJpYnV0ZVxuICAgIHZhciBhbGxEZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHZhbHVlID0gKGF0dHJpYnV0ZS52YWx1ZVswXS50eXBlID09PSAnVGV4dCcgPyAnJyA6IFwiXFxcIlxcXCIgKyBcIikgK1xuICAgICAgICBhdHRyaWJ1dGUudmFsdWVcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gJ1RleHQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeShjaHVuay5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJsb2NrLmNvbnRleHR1YWxpc2UoY2h1bmsuZXhwcmVzc2lvbik7IC8vIFRPRE8gcmVtb3ZlXG4gICAgICAgICAgICAgICAgdmFyIF9hID0gY2h1bmsubWV0YWRhdGEsIGRlcGVuZGVuY2llcyA9IF9hLmRlcGVuZGVuY2llcywgc25pcHBldCA9IF9hLnNuaXBwZXQ7XG4gICAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsRGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RXhwcmVzc2lvblByZWNlZGVuY2UoY2h1bmsuZXhwcmVzc2lvbikgPD0gMTMgPyBcIihcIiArIHNuaXBwZXQgKyBcIilcIiA6IHNuaXBwZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuam9pbignICsgJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogYXR0cmlidXRlLm5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBBcnJheS5mcm9tKGFsbERlcGVuZGVuY2llcyksXG4gICAgICAgIGR5bmFtaWM6IHRydWVcbiAgICB9O1xufVxuZnVuY3Rpb24gbXVuZ2VCaW5kaW5nKGJpbmRpbmcsIGJsb2NrKSB7XG4gICAgdmFyIG5hbWUgPSBnZXRPYmplY3QoYmluZGluZy52YWx1ZSkubmFtZTtcbiAgICB2YXIgY29udGV4dHMgPSBibG9jay5jb250ZXh0dWFsaXNlKGJpbmRpbmcudmFsdWUpLmNvbnRleHRzO1xuICAgIHZhciBfYSA9IGJpbmRpbmcubWV0YWRhdGEsIGRlcGVuZGVuY2llcyA9IF9hLmRlcGVuZGVuY2llcywgc25pcHBldCA9IF9hLnNuaXBwZXQ7XG4gICAgdmFyIGNvbnRleHR1YWwgPSBibG9jay5jb250ZXh0cy5oYXMobmFtZSk7XG4gICAgdmFyIG9iajtcbiAgICB2YXIgcHJvcDtcbiAgICBpZiAoY29udGV4dHVhbCkge1xuICAgICAgICBvYmogPSBibG9jay5saXN0TmFtZXMuZ2V0KG5hbWUpO1xuICAgICAgICBwcm9wID0gYmxvY2suaW5kZXhOYW1lcy5nZXQobmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpbmRpbmcudmFsdWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKSB7XG4gICAgICAgIHByb3AgPSBcIltcXHUyNzAyXCIgKyBiaW5kaW5nLnZhbHVlLnByb3BlcnR5LnN0YXJ0ICsgXCItXCIgKyBiaW5kaW5nLnZhbHVlLnByb3BlcnR5LmVuZCArIFwiXFx1MjcwMl1cIjtcbiAgICAgICAgaWYgKCFiaW5kaW5nLnZhbHVlLmNvbXB1dGVkKVxuICAgICAgICAgICAgcHJvcCA9IFwiJ1wiICsgcHJvcCArIFwiJ1wiO1xuICAgICAgICBvYmogPSBcIltcXHUyNzAyXCIgKyBiaW5kaW5nLnZhbHVlLm9iamVjdC5zdGFydCArIFwiLVwiICsgYmluZGluZy52YWx1ZS5vYmplY3QuZW5kICsgXCJcXHUyNzAyXVwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb2JqID0gJ3N0YXRlJztcbiAgICAgICAgcHJvcCA9IFwiJ1wiICsgbmFtZSArIFwiJ1wiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBiaW5kaW5nLm5hbWUsXG4gICAgICAgIHZhbHVlOiBiaW5kaW5nLnZhbHVlLFxuICAgICAgICBjb250ZXh0czogY29udGV4dHMsXG4gICAgICAgIHNuaXBwZXQ6IHNuaXBwZXQsXG4gICAgICAgIG9iajogb2JqLFxuICAgICAgICBwcm9wOiBwcm9wLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llc1xuICAgIH07XG59XG5mdW5jdGlvbiBtdW5nZUV2ZW50SGFuZGxlcihnZW5lcmF0b3IsIG5vZGUsIGhhbmRsZXIsIGJsb2NrLCBuYW1lX2NvbnRleHQsIGFsbENvbnRleHRzKSB7XG4gICAgdmFyIGJvZHk7XG4gICAgaWYgKGhhbmRsZXIuZXhwcmVzc2lvbikge1xuICAgICAgICBnZW5lcmF0b3IuYWRkU291cmNlbWFwTG9jYXRpb25zKGhhbmRsZXIuZXhwcmVzc2lvbik7XG4gICAgICAgIGdlbmVyYXRvci5jb2RlLnByZXBlbmRSaWdodChoYW5kbGVyLmV4cHJlc3Npb24uc3RhcnQsIGJsb2NrLmFsaWFzKCdjb21wb25lbnQnKSArIFwiLlwiKTtcbiAgICAgICAgdmFyIHVzZWRDb250ZXh0c18xID0gW107XG4gICAgICAgIGhhbmRsZXIuZXhwcmVzc2lvbi5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dHMgPSBibG9jay5jb250ZXh0dWFsaXNlKGFyZywgbnVsbCwgdHJ1ZSkuY29udGV4dHM7XG4gICAgICAgICAgICBjb250ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF+dXNlZENvbnRleHRzXzEuaW5kZXhPZihjb250ZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgdXNlZENvbnRleHRzXzEucHVzaChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICBhbGxDb250ZXh0cy5hZGQoY29udGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRPRE8gaG9pc3QgZXZlbnQgaGFuZGxlcnM/IGNhbiBkbyBgdGhpcy5fX2NvbXBvbmVudC5tZXRob2QoLi4uKWBcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9IHVzZWRDb250ZXh0c18xLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdzdGF0ZScpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmFyIHN0YXRlID0gXCIgKyBuYW1lX2NvbnRleHQgKyBcIi5zdGF0ZTtcIjtcbiAgICAgICAgICAgIHZhciBsaXN0TmFtZSA9IGJsb2NrLmxpc3ROYW1lcy5nZXQobmFtZSk7XG4gICAgICAgICAgICB2YXIgaW5kZXhOYW1lID0gYmxvY2suaW5kZXhOYW1lcy5nZXQobmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gXCJ2YXIgXCIgKyBsaXN0TmFtZSArIFwiID0gXCIgKyBuYW1lX2NvbnRleHQgKyBcIi5cIiArIGxpc3ROYW1lICsgXCIsIFwiICsgaW5kZXhOYW1lICsgXCIgPSBcIiArIG5hbWVfY29udGV4dCArIFwiLlwiICsgaW5kZXhOYW1lICsgXCIsIFwiICsgbmFtZSArIFwiID0gXCIgKyBsaXN0TmFtZSArIFwiW1wiICsgaW5kZXhOYW1lICsgXCJdXCI7XG4gICAgICAgIH0pO1xuICAgICAgICBib2R5ID0gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTkkMSB8fCAodGVtcGxhdGVPYmplY3RfMTkkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFtcXHUyNzAyXCIsIFwiLVwiLCBcIlxcdTI3MDJdO1xcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XFx0W1xcdTI3MDJcIiwgXCItXCIsIFwiXFx1MjcwMl07XFxuXFx0XFx0XCJdKSksIGRlY2xhcmF0aW9ucywgaGFuZGxlci5leHByZXNzaW9uLnN0YXJ0LCBoYW5kbGVyLmV4cHJlc3Npb24uZW5kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJvZHkgPSBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yMCB8fCAodGVtcGxhdGVPYmplY3RfMjAgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcIiwgXCIuZmlyZSgnXCIsIFwiJywgZXZlbnQpO1xcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XCIsIFwiLmZpcmUoJ1wiLCBcIicsIGV2ZW50KTtcXG5cXHRcXHRcIl0pKSwgYmxvY2suYWxpYXMoJ2NvbXBvbmVudCcpLCBoYW5kbGVyLm5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBoYW5kbGVyLm5hbWUsXG4gICAgICAgIFwidmFyXCI6IGJsb2NrLmdldFVuaXF1ZU5hbWUobm9kZVtcInZhclwiXSArIFwiX1wiICsgaGFuZGxlci5uYW1lKSxcbiAgICAgICAgYm9keTogYm9keVxuICAgIH07XG59XG5mdW5jdGlvbiBpc0NvbXB1dGVkJDEobm9kZSkge1xuICAgIHdoaWxlIChub2RlLnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJykge1xuICAgICAgICBpZiAobm9kZS5jb21wdXRlZClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBub2RlID0gbm9kZS5vYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlbW91bnQoZ2VuZXJhdG9yLCBub2RlLCBuYW1lKSB7XG4gICAgLy8gVE9ETyBtYWtlIHRoaXMgYSBtZXRob2Qgb2YgdGhlIG5vZGVzXG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ0NvbXBvbmVudCcpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVbXCJ2YXJcIl0gKyBcIi5fbW91bnQoXCIgKyBuYW1lICsgXCIuX3Nsb3R0ZWQuZGVmYXVsdCwgbnVsbCk7XCI7XG4gICAgfVxuICAgIGlmIChub2RlLnR5cGUgPT09ICdFbGVtZW50Jykge1xuICAgICAgICB2YXIgc2xvdCA9IG5vZGUuYXR0cmlidXRlcy5maW5kKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lID09PSAnc2xvdCc7IH0pO1xuICAgICAgICBpZiAoc2xvdCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiQGFwcGVuZE5vZGUoXCIgKyBub2RlW1widmFyXCJdICsgXCIsIFwiICsgbmFtZSArIFwiLl9zbG90dGVkLlwiICsgbm9kZS5nZXRTdGF0aWNBdHRyaWJ1dGVWYWx1ZSgnc2xvdCcpICsgXCIpO1wiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIkBhcHBlbmROb2RlKFwiICsgbm9kZVtcInZhclwiXSArIFwiLCBcIiArIG5hbWUgKyBcIi5fc2xvdHRlZC5kZWZhdWx0KTtcIjtcbiAgICB9XG4gICAgaWYgKG5vZGUudHlwZSA9PT0gJ1RleHQnIHx8IG5vZGUudHlwZSA9PT0gJ011c3RhY2hlVGFnJyB8fCBub2RlLnR5cGUgPT09ICdSYXdNdXN0YWNoZVRhZycpIHtcbiAgICAgICAgcmV0dXJuIFwiQGFwcGVuZE5vZGUoXCIgKyBub2RlW1widmFyXCJdICsgXCIsIFwiICsgbmFtZSArIFwiLl9zbG90dGVkLmRlZmF1bHQpO1wiO1xuICAgIH1cbiAgICBpZiAobm9kZS50eXBlID09PSAnRWFjaEJsb2NrJykge1xuICAgICAgICAvLyBUT0RPIGNvbnNpZGVyIGtleWVkIGJsb2Nrc1xuICAgICAgICByZXR1cm4gXCJmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIgKyBub2RlLml0ZXJhdGlvbnMgKyBcIi5sZW5ndGg7ICNpICs9IDEpIFwiICsgbm9kZS5pdGVyYXRpb25zICsgXCJbI2ldLm0oXCIgKyBuYW1lICsgXCIuX3Nsb3R0ZWQuZGVmYXVsdCwgbnVsbCk7XCI7XG4gICAgfVxuICAgIHJldHVybiBub2RlW1widmFyXCJdICsgXCIubShcIiArIG5hbWUgKyBcIi5fc2xvdHRlZC5kZWZhdWx0LCBudWxsKTtcIjtcbn1cbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDU7XG52YXIgdGVtcGxhdGVPYmplY3RfMiQ1O1xudmFyIHRlbXBsYXRlT2JqZWN0XzMkNTtcbnZhciB0ZW1wbGF0ZU9iamVjdF80JDU7XG52YXIgdGVtcGxhdGVPYmplY3RfNSQzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzYkMztcbnZhciB0ZW1wbGF0ZU9iamVjdF83JDI7XG52YXIgdGVtcGxhdGVPYmplY3RfOSQxO1xudmFyIHRlbXBsYXRlT2JqZWN0XzgkMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMSQxO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEyJDE7XG52YXIgdGVtcGxhdGVPYmplY3RfMTAkMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMyQxO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE1JDE7XG52YXIgdGVtcGxhdGVPYmplY3RfMTQkMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xNiQxO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE3JDE7XG52YXIgdGVtcGxhdGVPYmplY3RfMTgkMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xOSQxO1xudmFyIHRlbXBsYXRlT2JqZWN0XzIwO1xuXG52YXIgRWFjaEJsb2NrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFYWNoQmxvY2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRWFjaEJsb2NrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEVhY2hCbG9jay5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChibG9jaywgc3RyaXBXaGl0ZXNwYWNlLCBuZXh0U2libGluZykge1xuICAgICAgICB0aGlzLmNhbm5vdFVzZUlubmVySFRNTCgpO1xuICAgICAgICB0aGlzW1widmFyXCJdID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcImVhY2hcIik7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9ucyA9IGJsb2NrLmdldFVuaXF1ZU5hbWUodGhpc1tcInZhclwiXSArIFwiX2Jsb2Nrc1wiKTtcbiAgICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IHRoaXMubWV0YWRhdGEuZGVwZW5kZW5jaWVzO1xuICAgICAgICBibG9jay5hZGREZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgdmFyIGluZGV4TmFtZXMgPSBuZXcgTWFwKGJsb2NrLmluZGV4TmFtZXMpO1xuICAgICAgICB2YXIgaW5kZXhOYW1lID0gdGhpcy5pbmRleCB8fCBibG9jay5nZXRVbmlxdWVOYW1lKHRoaXMuY29udGV4dCArIFwiX2luZGV4XCIpO1xuICAgICAgICBpbmRleE5hbWVzLnNldCh0aGlzLmNvbnRleHQsIGluZGV4TmFtZSk7XG4gICAgICAgIHZhciBsaXN0TmFtZXMgPSBuZXcgTWFwKGJsb2NrLmxpc3ROYW1lcyk7XG4gICAgICAgIHZhciBsaXN0TmFtZSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoKHRoaXMuZXhwcmVzc2lvbi50eXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgIXRoaXMuZXhwcmVzc2lvbi5jb21wdXRlZCkgPyB0aGlzLmV4cHJlc3Npb24ucHJvcGVydHkubmFtZSA6XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb24udHlwZSA9PT0gJ0lkZW50aWZpZXInID8gdGhpcy5leHByZXNzaW9uLm5hbWUgOlxuICAgICAgICAgICAgICAgIFwiZWFjaF92YWx1ZVwiKTtcbiAgICAgICAgbGlzdE5hbWVzLnNldCh0aGlzLmNvbnRleHQsIGxpc3ROYW1lKTtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBibG9jay5nZXRVbmlxdWVOYW1lKHRoaXMuY29udGV4dCk7XG4gICAgICAgIHZhciBjb250ZXh0cyA9IG5ldyBNYXAoYmxvY2suY29udGV4dHMpO1xuICAgICAgICBjb250ZXh0cy5zZXQodGhpcy5jb250ZXh0LCBjb250ZXh0KTtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBuZXcgTWFwKGJsb2NrLmluZGV4ZXMpO1xuICAgICAgICBpZiAodGhpcy5pbmRleClcbiAgICAgICAgICAgIGluZGV4ZXMuc2V0KHRoaXMuaW5kZXgsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIHZhciBjaGFuZ2VhYmxlSW5kZXhlcyA9IG5ldyBNYXAoYmxvY2suY2hhbmdlYWJsZUluZGV4ZXMpO1xuICAgICAgICBpZiAodGhpcy5pbmRleClcbiAgICAgICAgICAgIGNoYW5nZWFibGVJbmRleGVzLnNldCh0aGlzLmluZGV4LCB0aGlzLmtleSk7XG4gICAgICAgIGlmICh0aGlzLmRlc3RydWN0dXJlZENvbnRleHRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGVzdHJ1Y3R1cmVkQ29udGV4dHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0cy5zZXQodGhpcy5kZXN0cnVjdHVyZWRDb250ZXh0c1tpXSwgY29udGV4dCArIFwiW1wiICsgaSArIFwiXVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJsb2NrID0gYmxvY2suY2hpbGQoe1xuICAgICAgICAgICAgY29tbWVudDogY3JlYXRlRGVidWdnaW5nQ29tbWVudCh0aGlzLCB0aGlzLmdlbmVyYXRvciksXG4gICAgICAgICAgICBuYW1lOiB0aGlzLmdlbmVyYXRvci5nZXRVbmlxdWVOYW1lKCdjcmVhdGVfZWFjaF9ibG9jaycpLFxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LFxuICAgICAgICAgICAga2V5OiB0aGlzLmtleSxcbiAgICAgICAgICAgIGNvbnRleHRzOiBjb250ZXh0cyxcbiAgICAgICAgICAgIGluZGV4ZXM6IGluZGV4ZXMsXG4gICAgICAgICAgICBjaGFuZ2VhYmxlSW5kZXhlczogY2hhbmdlYWJsZUluZGV4ZXMsXG4gICAgICAgICAgICBsaXN0TmFtZTogbGlzdE5hbWUsXG4gICAgICAgICAgICBpbmRleE5hbWU6IGluZGV4TmFtZSxcbiAgICAgICAgICAgIGluZGV4TmFtZXM6IGluZGV4TmFtZXMsXG4gICAgICAgICAgICBsaXN0TmFtZXM6IGxpc3ROYW1lcyxcbiAgICAgICAgICAgIHBhcmFtczogYmxvY2sucGFyYW1zLmNvbmNhdChsaXN0TmFtZSwgY29udGV4dCwgaW5kZXhOYW1lKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IuYmxvY2tzLnB1c2godGhpcy5ibG9jayk7XG4gICAgICAgIHRoaXMuaW5pdENoaWxkcmVuKHRoaXMuYmxvY2ssIHN0cmlwV2hpdGVzcGFjZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICBibG9jay5hZGREZXBlbmRlbmNpZXModGhpcy5ibG9jay5kZXBlbmRlbmNpZXMpO1xuICAgICAgICB0aGlzLmJsb2NrLmhhc1VwZGF0ZU1ldGhvZCA9IHRoaXMuYmxvY2suZGVwZW5kZW5jaWVzLnNpemUgPiAwO1xuICAgICAgICBpZiAodGhpc1tcImVsc2VcIl0pIHtcbiAgICAgICAgICAgIHRoaXNbXCJlbHNlXCJdLmJsb2NrID0gYmxvY2suY2hpbGQoe1xuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IGNyZWF0ZURlYnVnZ2luZ0NvbW1lbnQodGhpc1tcImVsc2VcIl0sIHRoaXMuZ2VuZXJhdG9yKSxcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLmdlbmVyYXRvci5nZXRVbmlxdWVOYW1lKHRoaXMuYmxvY2submFtZSArIFwiX2Vsc2VcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5nZW5lcmF0b3IuYmxvY2tzLnB1c2godGhpc1tcImVsc2VcIl0uYmxvY2spO1xuICAgICAgICAgICAgdGhpc1tcImVsc2VcIl0uaW5pdENoaWxkcmVuKHRoaXNbXCJlbHNlXCJdLmJsb2NrLCBzdHJpcFdoaXRlc3BhY2UsIG5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgIHRoaXNbXCJlbHNlXCJdLmJsb2NrLmhhc1VwZGF0ZU1ldGhvZCA9IHRoaXNbXCJlbHNlXCJdLmJsb2NrLmRlcGVuZGVuY2llcy5zaXplID4gMDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRWFjaEJsb2NrLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IHRoaXMuZ2VuZXJhdG9yO1xuICAgICAgICB2YXIgZWFjaCA9IHRoaXNbXCJ2YXJcIl07XG4gICAgICAgIHZhciBjcmVhdGVfZWFjaF9ibG9jayA9IHRoaXMuYmxvY2submFtZTtcbiAgICAgICAgdmFyIGVhY2hfYmxvY2tfdmFsdWUgPSB0aGlzLmJsb2NrLmxpc3ROYW1lO1xuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IHRoaXMuaXRlcmF0aW9ucztcbiAgICAgICAgdmFyIHBhcmFtcyA9IGJsb2NrLnBhcmFtcy5qb2luKCcsICcpO1xuICAgICAgICB2YXIgbmVlZHNBbmNob3IgPSB0aGlzLm5leHQgPyAhdGhpcy5uZXh0LmlzRG9tTm9kZSgpIDogIXBhcmVudE5vZGUgfHwgIXRoaXMucGFyZW50LmlzRG9tTm9kZSgpO1xuICAgICAgICB2YXIgYW5jaG9yID0gbmVlZHNBbmNob3JcbiAgICAgICAgICAgID8gYmxvY2suZ2V0VW5pcXVlTmFtZShlYWNoICsgXCJfYW5jaG9yXCIpXG4gICAgICAgICAgICA6ICh0aGlzLm5leHQgJiYgdGhpcy5uZXh0W1widmFyXCJdKSB8fCAnbnVsbCc7XG4gICAgICAgIC8vIGhhY2sgdGhlIHNvdXJjZW1hcCwgc28gdGhhdCBpZiBkYXRhIGlzIG1pc3NpbmcgdGhlIGJ1Z1xuICAgICAgICAvLyBpcyBlYXN5IHRvIGZpbmRcbiAgICAgICAgdmFyIGMgPSB0aGlzLnN0YXJ0ICsgMztcbiAgICAgICAgd2hpbGUgKGdlbmVyYXRvci5zb3VyY2VbY10gIT09ICdlJylcbiAgICAgICAgICAgIGMgKz0gMTtcbiAgICAgICAgZ2VuZXJhdG9yLmNvZGUub3ZlcndyaXRlKGMsIGMgKyA0LCAnbGVuZ3RoJyk7XG4gICAgICAgIHZhciBsZW5ndGggPSBcIltcXHUyNzAyXCIgKyBjICsgXCItXCIgKyAoYyArIDQpICsgXCJcXHUyNzAyXVwiO1xuICAgICAgICB2YXIgbW91bnRPckludHJvID0gdGhpcy5ibG9jay5oYXNJbnRyb01ldGhvZCA/ICdpJyA6ICdtJztcbiAgICAgICAgdmFyIHZhcnMgPSB7XG4gICAgICAgICAgICBlYWNoOiBlYWNoLFxuICAgICAgICAgICAgY3JlYXRlX2VhY2hfYmxvY2s6IGNyZWF0ZV9lYWNoX2Jsb2NrLFxuICAgICAgICAgICAgZWFjaF9ibG9ja192YWx1ZTogZWFjaF9ibG9ja192YWx1ZSxcbiAgICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgICAgaXRlcmF0aW9uczogaXRlcmF0aW9ucyxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgYW5jaG9yOiBhbmNob3IsXG4gICAgICAgICAgICBtb3VudE9ySW50cm86IG1vdW50T3JJbnRyb1xuICAgICAgICB9O1xuICAgICAgICBibG9jay5jb250ZXh0dWFsaXNlKHRoaXMuZXhwcmVzc2lvbik7XG4gICAgICAgIHZhciBzbmlwcGV0ID0gdGhpcy5tZXRhZGF0YS5zbmlwcGV0O1xuICAgICAgICBibG9jay5idWlsZGVycy5pbml0LmFkZExpbmUoXCJ2YXIgXCIgKyBlYWNoX2Jsb2NrX3ZhbHVlICsgXCIgPSBcIiArIHNuaXBwZXQgKyBcIjtcIik7XG4gICAgICAgIGlmICh0aGlzLmtleSkge1xuICAgICAgICAgICAgdGhpcy5idWlsZEtleWVkKGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2Rlcywgc25pcHBldCwgdmFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkVW5rZXllZChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMsIHNuaXBwZXQsIHZhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc0FuY2hvcikge1xuICAgICAgICAgICAgYmxvY2suYWRkRWxlbWVudChhbmNob3IsIFwiQGNyZWF0ZUNvbW1lbnQoKVwiLCBwYXJlbnROb2RlcyAmJiBcIkBjcmVhdGVDb21tZW50KClcIiwgcGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXNbXCJlbHNlXCJdKSB7XG4gICAgICAgICAgICB2YXIgZWFjaF9ibG9ja19lbHNlID0gZ2VuZXJhdG9yLmdldFVuaXF1ZU5hbWUoZWFjaCArIFwiX2Vsc2VcIik7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5pbml0LmFkZExpbmUoXCJ2YXIgXCIgKyBlYWNoX2Jsb2NrX2Vsc2UgKyBcIiA9IG51bGw7XCIpO1xuICAgICAgICAgICAgLy8gVE9ETyBuZWF0ZW4gdGhpcyB1cC4uLiB3aWxsIGVuZCB1cCB3aXRoIGFuIGVtcHR5IGxpbmUgaW4gdGhlIGJsb2NrXG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5pbml0LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkNiB8fCAodGVtcGxhdGVPYmplY3RfMSQ2ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0aWYgKCFcIiwgXCIuXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRpZiAoIVwiLCBcIi5cIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIoXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0pKSwgZWFjaF9ibG9ja192YWx1ZSwgbGVuZ3RoLCBlYWNoX2Jsb2NrX2Vsc2UsIHRoaXNbXCJlbHNlXCJdLmJsb2NrLm5hbWUsIHBhcmFtcywgZWFjaF9ibG9ja19lbHNlKSk7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5tb3VudC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yJDYgfHwgKHRlbXBsYXRlT2JqZWN0XzIkNiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuXCIsIFwiKFwiLCBcIiwgbnVsbCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5cIiwgXCIoXCIsIFwiLCBudWxsKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIGVhY2hfYmxvY2tfZWxzZSwgZWFjaF9ibG9ja19lbHNlLCBtb3VudE9ySW50cm8sIHBhcmVudE5vZGUgfHwgJyN0YXJnZXQnKSk7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbE1vdW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgYW5jaG9yICsgXCIucGFyZW50Tm9kZVwiO1xuICAgICAgICAgICAgaWYgKHRoaXNbXCJlbHNlXCJdLmJsb2NrLmhhc1VwZGF0ZU1ldGhvZCkge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8zJDYgfHwgKHRlbXBsYXRlT2JqZWN0XzMkNiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdGlmICghXCIsIFwiLlwiLCBcIiAmJiBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIucCggY2hhbmdlZCwgXCIsIFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICghXCIsIFwiLlwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIihcIiwgXCIsICNjb21wb25lbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5jKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLlwiLCBcIihcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIudSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIVwiLCBcIi5cIiwgXCIgJiYgXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLnAoIGNoYW5nZWQsIFwiLCBcIiApO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIVwiLCBcIi5cIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIoXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5cIiwgXCIoXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLnUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuZCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFwiXSkpLCBlYWNoX2Jsb2NrX3ZhbHVlLCBsZW5ndGgsIGVhY2hfYmxvY2tfZWxzZSwgZWFjaF9ibG9ja19lbHNlLCBwYXJhbXMsIGVhY2hfYmxvY2tfdmFsdWUsIGxlbmd0aCwgZWFjaF9ibG9ja19lbHNlLCB0aGlzW1wiZWxzZVwiXS5ibG9jay5uYW1lLCBwYXJhbXMsIGVhY2hfYmxvY2tfZWxzZSwgZWFjaF9ibG9ja19lbHNlLCBtb3VudE9ySW50cm8sIGluaXRpYWxNb3VudE5vZGUsIGFuY2hvciwgZWFjaF9ibG9ja19lbHNlLCBlYWNoX2Jsb2NrX2Vsc2UsIGVhY2hfYmxvY2tfZWxzZSwgZWFjaF9ibG9ja19lbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy51cGRhdGUuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNCQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF80JDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiLlwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIudSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICghXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuXCIsIFwiKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiLlwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIudSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICghXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuXCIsIFwiKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XCJdKSksIGVhY2hfYmxvY2tfdmFsdWUsIGxlbmd0aCwgZWFjaF9ibG9ja19lbHNlLCBlYWNoX2Jsb2NrX2Vsc2UsIGVhY2hfYmxvY2tfZWxzZSwgZWFjaF9ibG9ja19lbHNlLCBlYWNoX2Jsb2NrX2Vsc2UsIGVhY2hfYmxvY2tfZWxzZSwgdGhpc1tcImVsc2VcIl0uYmxvY2submFtZSwgcGFyYW1zLCBlYWNoX2Jsb2NrX2Vsc2UsIGVhY2hfYmxvY2tfZWxzZSwgbW91bnRPckludHJvLCBpbml0aWFsTW91bnROb2RlLCBhbmNob3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVubW91bnQuYWRkTGluZShcImlmIChcIiArIGVhY2hfYmxvY2tfZWxzZSArIFwiKSBcIiArIGVhY2hfYmxvY2tfZWxzZSArIFwiLnUoKVwiKTtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNSQ0IHx8ICh0ZW1wbGF0ZU9iamVjdF81JDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSBcIiwgXCIuZCgpO1xcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIikgXCIsIFwiLmQoKTtcXG5cXHRcXHRcXHRcIl0pKSwgZWFjaF9ibG9ja19lbHNlLCBlYWNoX2Jsb2NrX2Vsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5idWlsZChfdGhpcy5ibG9jaywgbnVsbCwgJ25vZGVzJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpc1tcImVsc2VcIl0pIHtcbiAgICAgICAgICAgIHRoaXNbXCJlbHNlXCJdLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYnVpbGQoX3RoaXNbXCJlbHNlXCJdLmJsb2NrLCBudWxsLCAnbm9kZXMnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFYWNoQmxvY2sucHJvdG90eXBlLmJ1aWxkS2V5ZWQgPSBmdW5jdGlvbiAoYmxvY2ssIHBhcmVudE5vZGUsIHBhcmVudE5vZGVzLCBzbmlwcGV0LCBfYSkge1xuICAgICAgICB2YXIgZWFjaCA9IF9hLmVhY2gsIGNyZWF0ZV9lYWNoX2Jsb2NrID0gX2EuY3JlYXRlX2VhY2hfYmxvY2ssIGVhY2hfYmxvY2tfdmFsdWUgPSBfYS5lYWNoX2Jsb2NrX3ZhbHVlLCBsZW5ndGggPSBfYS5sZW5ndGgsIHBhcmFtcyA9IF9hLnBhcmFtcywgYW5jaG9yID0gX2EuYW5jaG9yLCBtb3VudE9ySW50cm8gPSBfYS5tb3VudE9ySW50cm87XG4gICAgICAgIHZhciBrZXkgPSBibG9jay5nZXRVbmlxdWVOYW1lKCdrZXknKTtcbiAgICAgICAgdmFyIGxvb2t1cCA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoZWFjaCArIFwiX2xvb2t1cFwiKTtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbiA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoZWFjaCArIFwiX2l0ZXJhdGlvblwiKTtcbiAgICAgICAgdmFyIGhlYWQgPSBibG9jay5nZXRVbmlxdWVOYW1lKGVhY2ggKyBcIl9oZWFkXCIpO1xuICAgICAgICB2YXIgbGFzdCA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoZWFjaCArIFwiX2xhc3RcIik7XG4gICAgICAgIHZhciBleHBlY3RlZCA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoZWFjaCArIFwiX2V4cGVjdGVkXCIpO1xuICAgICAgICBibG9jay5hZGRWYXJpYWJsZShsb29rdXAsIFwiQGJsYW5rT2JqZWN0KClcIik7XG4gICAgICAgIGJsb2NrLmFkZFZhcmlhYmxlKGhlYWQpO1xuICAgICAgICBibG9jay5hZGRWYXJpYWJsZShsYXN0KTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5bMF0uaXNEb21Ob2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuYmxvY2suZmlyc3QgPSB0aGlzLmNoaWxkcmVuWzBdW1widmFyXCJdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ibG9jay5maXJzdCA9IHRoaXMuYmxvY2suZ2V0VW5pcXVlTmFtZSgnZmlyc3QnKTtcbiAgICAgICAgICAgIHRoaXMuYmxvY2suYWRkRWxlbWVudCh0aGlzLmJsb2NrLmZpcnN0LCBcIkBjcmVhdGVDb21tZW50KClcIiwgcGFyZW50Tm9kZXMgJiYgXCJAY3JlYXRlQ29tbWVudCgpXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmluaXQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNiQ0IHx8ICh0ZW1wbGF0ZU9iamVjdF82JDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIsIFwiLlwiLCBcIjsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCJbI2ldLlwiLCBcIjtcXG5cXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiW1wiLCBcIl0gPSBcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpLCAjY29tcG9uZW50LCBcIiwgXCIpO1xcblxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5uZXh0ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFwiLCBcIi5sYXN0ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoI2kgPT09IDApIFwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIsIFwiLlwiLCBcIjsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCJbI2ldLlwiLCBcIjtcXG5cXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiW1wiLCBcIl0gPSBcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpLCAjY29tcG9uZW50LCBcIiwgXCIpO1xcblxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5uZXh0ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFwiLCBcIi5sYXN0ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoI2kgPT09IDApIFwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdKSksIGVhY2hfYmxvY2tfdmFsdWUsIGxlbmd0aCwga2V5LCBlYWNoX2Jsb2NrX3ZhbHVlLCB0aGlzLmtleSwgaXRlcmF0aW9uLCBsb29rdXAsIGtleSwgY3JlYXRlX2VhY2hfYmxvY2ssIHBhcmFtcywgZWFjaF9ibG9ja192YWx1ZSwgZWFjaF9ibG9ja192YWx1ZSwga2V5LCBsYXN0LCBsYXN0LCBpdGVyYXRpb24sIGl0ZXJhdGlvbiwgbGFzdCwgbGFzdCwgaXRlcmF0aW9uLCBoZWFkLCBpdGVyYXRpb24pKTtcbiAgICAgICAgdmFyIGluaXRpYWxNb3VudE5vZGUgPSBwYXJlbnROb2RlIHx8ICcjdGFyZ2V0JztcbiAgICAgICAgdmFyIHVwZGF0ZU1vdW50Tm9kZSA9IHRoaXMuZ2V0VXBkYXRlTW91bnROb2RlKGFuY2hvcik7XG4gICAgICAgIHZhciBhbmNob3JOb2RlID0gcGFyZW50Tm9kZSA/ICdudWxsJyA6ICdhbmNob3InO1xuICAgICAgICBibG9jay5idWlsZGVycy5jcmVhdGUuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNyQzIHx8ICh0ZW1wbGF0ZU9iamVjdF83JDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdHdoaWxlIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIi5uZXh0O1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCI7XFxuXFx0XFx0XFx0d2hpbGUgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFwiLCBcIi5jKCk7XFxuXFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiLm5leHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSkpLCBpdGVyYXRpb24sIGhlYWQsIGl0ZXJhdGlvbiwgaXRlcmF0aW9uLCBpdGVyYXRpb24sIGl0ZXJhdGlvbikpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNsYWltLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzgkMyB8fCAodGVtcGxhdGVPYmplY3RfOCQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHR3aGlsZSAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLmwoXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdHdoaWxlIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIubChcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIi5uZXh0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0pKSwgaXRlcmF0aW9uLCBoZWFkLCBpdGVyYXRpb24sIGl0ZXJhdGlvbiwgcGFyZW50Tm9kZXMsIGl0ZXJhdGlvbiwgaXRlcmF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2suYnVpbGRlcnMubW91bnQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfOSQyIHx8ICh0ZW1wbGF0ZU9iamVjdF85JDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdHdoaWxlIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCIuXCIsIFwiKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdHdoaWxlIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCIuXCIsIFwiKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdKSksIGl0ZXJhdGlvbiwgaGVhZCwgaXRlcmF0aW9uLCBpdGVyYXRpb24sIG1vdW50T3JJbnRybywgaW5pdGlhbE1vdW50Tm9kZSwgYW5jaG9yTm9kZSwgaXRlcmF0aW9uLCBpdGVyYXRpb24pKTtcbiAgICAgICAgdmFyIGR5bmFtaWMgPSB0aGlzLmJsb2NrLmhhc1VwZGF0ZU1ldGhvZDtcbiAgICAgICAgdmFyIGRlc3Ryb3k7XG4gICAgICAgIGlmICh0aGlzLmJsb2NrLmhhc091dHJvTWV0aG9kKSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBibG9jay5nZXRVbmlxdWVOYW1lKGVhY2ggKyBcIl9vdXRyb1wiKTtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmluaXQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTAkMiB8fCAodGVtcGxhdGVPYmplY3RfMTAkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihpdGVyYXRpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVyYXRpb24ubyhmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpdGVyYXRpb24udSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGl0ZXJhdGlvbi5kKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiW2l0ZXJhdGlvbi5rZXldID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIoaXRlcmF0aW9uKSB7XFxuXFx0XFx0XFx0XFx0XFx0aXRlcmF0aW9uLm8oZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aXRlcmF0aW9uLnUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpdGVyYXRpb24uZCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIltpdGVyYXRpb24ua2V5XSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBmbiwgbG9va3VwKSk7XG4gICAgICAgICAgICBkZXN0cm95ID0gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTEkMiB8fCAodGVtcGxhdGVPYmplY3RfMTEkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdHdoaWxlIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIoXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICgjaSA9IDA7ICNpIDwgZGlzY2FyZF9waWxlLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkaXNjYXJkX3BpbGVbI2ldLmRpc2NhcmQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIoZGlzY2FyZF9waWxlWyNpXSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdHdoaWxlIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIoXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICgjaSA9IDA7ICNpIDwgZGlzY2FyZF9waWxlLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFxcdGlmIChkaXNjYXJkX3BpbGVbI2ldLmRpc2NhcmQpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIoZGlzY2FyZF9waWxlWyNpXSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0pKSwgZXhwZWN0ZWQsIGZuLCBleHBlY3RlZCwgZXhwZWN0ZWQsIGV4cGVjdGVkLCBmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBibG9jay5nZXRVbmlxdWVOYW1lKGVhY2ggKyBcIl9kZXN0cm95XCIpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xMiQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8xMiQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKGl0ZXJhdGlvbikge1xcblxcdFxcdFxcdFxcdFxcdGl0ZXJhdGlvbi51KCk7XFxuXFx0XFx0XFx0XFx0XFx0aXRlcmF0aW9uLmQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJbaXRlcmF0aW9uLmtleV0gPSBudWxsO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihpdGVyYXRpb24pIHtcXG5cXHRcXHRcXHRcXHRcXHRpdGVyYXRpb24udSgpO1xcblxcdFxcdFxcdFxcdFxcdGl0ZXJhdGlvbi5kKCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiW2l0ZXJhdGlvbi5rZXldID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIGZuLCBsb29rdXApKTtcbiAgICAgICAgICAgIGRlc3Ryb3kgPSBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xMyQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8xMyQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0d2hpbGUgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIihcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIi5uZXh0O1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCNpID0gMDsgI2kgPCBkaXNjYXJkX3BpbGUubGVuZ3RoOyAjaSArPSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IGRpc2NhcmRfcGlsZVsjaV07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIi5kaXNjYXJkKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiKFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdHdoaWxlIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIoXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICgjaSA9IDA7ICNpIDwgZGlzY2FyZF9waWxlLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBkaXNjYXJkX3BpbGVbI2ldO1xcblxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIuZGlzY2FyZCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIihcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIGV4cGVjdGVkLCBmbiwgZXhwZWN0ZWQsIGV4cGVjdGVkLCBleHBlY3RlZCwgaXRlcmF0aW9uLCBpdGVyYXRpb24sIGZuLCBpdGVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xNCQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8xNCQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIjtcXG5cXG5cXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdHZhciBcIiwgXCIgPSBudWxsO1xcblxcblxcdFxcdFxcdHZhciBkaXNjYXJkX3BpbGUgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCNpID0gMDsgI2kgPCBcIiwgXCIuXCIsIFwiOyAjaSArPSAxKSB7XFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIlsjaV0uXCIsIFwiO1xcblxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCJbXCIsIFwiXTtcXG5cXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIiA9PT0gXCIsIFwiLmtleSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIi5uZXh0O1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHByb2JhYmx5IGEgZGVsZXRpb25cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3aGlsZSAoXCIsIFwiICYmIFwiLCBcIi5rZXkgIT09IFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5kaXNjYXJkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXNjYXJkX3BpbGUucHVzaChcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIi5uZXh0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiICYmIFwiLCBcIi5uZXh0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5kaXNjYXJkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLmxhc3QgPSBcIiwgXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCFcIiwgXCIpIFwiLCBcIi5tKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGtleSBpcyBiZWluZyBpbnNlcnRlZFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIltcIiwgXCJdID0gXCIsIFwiKFwiLCBcIiwgXCIsIFwiLCBcIiwgXCJbI2ldLCAjaSwgI2NvbXBvbmVudCwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5cIiwgXCIoXCIsIFwiLCBcIiwgXCIuZmlyc3QpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5sYXN0ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5uZXh0ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyB3ZSdyZSBhcHBlbmRpbmcgZnJvbSB0aGlzIHBvaW50IGZvcndhcmRcXG5cXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLmRpc2NhcmQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIubmV4dCA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLm0oXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiW1wiLCBcIl0gPSBcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpLCAjY29tcG9uZW50LCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5jKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLlwiLCBcIihcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSBcIiwgXCIubmV4dCA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcIiwgXCIubGFzdCA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCI7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5uZXh0ID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCJbXCIsIFwiWzBdICYmIFwiLCBcIlswXS5cIiwgXCJdO1xcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIjtcXG5cXG5cXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdHZhciBcIiwgXCIgPSBudWxsO1xcblxcblxcdFxcdFxcdHZhciBkaXNjYXJkX3BpbGUgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCNpID0gMDsgI2kgPCBcIiwgXCIuXCIsIFwiOyAjaSArPSAxKSB7XFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIlsjaV0uXCIsIFwiO1xcblxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCJbXCIsIFwiXTtcXG5cXG5cXHRcXHRcXHRcXHRcIixcbiAgICAgICAgICAgIFwiXFxuXFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIgPT09IFwiLCBcIi5rZXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBwcm9iYWJseSBhIGRlbGV0aW9uXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0d2hpbGUgKFwiLCBcIiAmJiBcIiwgXCIua2V5ICE9PSBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuZGlzY2FyZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzY2FyZF9waWxlLnB1c2goXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIiAmJiBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuZGlzY2FyZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5sYXN0ID0gXCIsIFwiO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghXCIsIFwiKSBcIiwgXCIubShcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBrZXkgaXMgYmVpbmcgaW5zZXJ0ZWRcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCJbXCIsIFwiXSA9IFwiLCBcIihcIiwgXCIsIFwiLCBcIiwgXCIsIFwiWyNpXSwgI2ksICNjb21wb25lbnQsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuXCIsIFwiKFwiLCBcIiwgXCIsIFwiLmZpcnN0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIubGFzdCA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIubmV4dCA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gd2UncmUgYXBwZW5kaW5nIGZyb20gdGhpcyBwb2ludCBmb3J3YXJkXFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5kaXNjYXJkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLm5leHQgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5tKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIltcIiwgXCJdID0gXCIsIFwiKFwiLCBcIiwgXCIsIFwiLCBcIiwgXCJbI2ldLCAjaSwgI2NvbXBvbmVudCwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIi5cIiwgXCIoXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIikgXCIsIFwiLm5leHQgPSBcIiwgXCI7XFxuXFx0XFx0XFx0XFx0XCIsIFwiLmxhc3QgPSBcIiwgXCI7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoXCIsIFwiKSBcIiwgXCIubmV4dCA9IG51bGw7XFxuXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiW1wiLCBcIlswXSAmJiBcIiwgXCJbMF0uXCIsIFwiXTtcXG5cXHRcXHRcIl0pKSwgZWFjaF9ibG9ja192YWx1ZSwgc25pcHBldCwgZXhwZWN0ZWQsIGhlYWQsIGxhc3QsIGVhY2hfYmxvY2tfdmFsdWUsIGxlbmd0aCwga2V5LCBlYWNoX2Jsb2NrX3ZhbHVlLCB0aGlzLmtleSwgaXRlcmF0aW9uLCBsb29rdXAsIGtleSwgZHluYW1pYyAmJlxuICAgICAgICAgICAgXCJpZiAoXCIgKyBpdGVyYXRpb24gKyBcIikgXCIgKyBpdGVyYXRpb24gKyBcIi5wKGNoYW5nZWQsIFwiICsgcGFyYW1zICsgXCIsIFwiICsgZWFjaF9ibG9ja192YWx1ZSArIFwiLCBcIiArIGVhY2hfYmxvY2tfdmFsdWUgKyBcIlsjaV0sICNpKTtcIiwgZXhwZWN0ZWQsIGtleSwgZXhwZWN0ZWQsIGV4cGVjdGVkLCBleHBlY3RlZCwgaXRlcmF0aW9uLCBleHBlY3RlZCwgZXhwZWN0ZWQsIGtleSwgZXhwZWN0ZWQsIGV4cGVjdGVkLCBleHBlY3RlZCwgZXhwZWN0ZWQsIGV4cGVjdGVkLCBleHBlY3RlZCwgZXhwZWN0ZWQsIGl0ZXJhdGlvbiwgaXRlcmF0aW9uLCBsYXN0LCBleHBlY3RlZCwgaXRlcmF0aW9uLCB1cGRhdGVNb3VudE5vZGUsIGFuY2hvciwgaXRlcmF0aW9uLCBsb29rdXAsIGtleSwgY3JlYXRlX2VhY2hfYmxvY2ssIHBhcmFtcywgZWFjaF9ibG9ja192YWx1ZSwgZWFjaF9ibG9ja192YWx1ZSwga2V5LCBpdGVyYXRpb24sIGl0ZXJhdGlvbiwgbW91bnRPckludHJvLCB1cGRhdGVNb3VudE5vZGUsIGV4cGVjdGVkLCBleHBlY3RlZCwgaXRlcmF0aW9uLCBpdGVyYXRpb24sIGV4cGVjdGVkLCBpdGVyYXRpb24sIGl0ZXJhdGlvbiwgaXRlcmF0aW9uLCBpdGVyYXRpb24sIHVwZGF0ZU1vdW50Tm9kZSwgYW5jaG9yLCBpdGVyYXRpb24sIGxvb2t1cCwga2V5LCBjcmVhdGVfZWFjaF9ibG9jaywgcGFyYW1zLCBlYWNoX2Jsb2NrX3ZhbHVlLCBlYWNoX2Jsb2NrX3ZhbHVlLCBrZXksIGl0ZXJhdGlvbiwgaXRlcmF0aW9uLCBtb3VudE9ySW50cm8sIHVwZGF0ZU1vdW50Tm9kZSwgYW5jaG9yLCBsYXN0LCBsYXN0LCBpdGVyYXRpb24sIGl0ZXJhdGlvbiwgbGFzdCwgdGhpcy5ibG9jay5oYXNJbnRyb01ldGhvZCAmJiBpdGVyYXRpb24gKyBcIi5pKFwiICsgdXBkYXRlTW91bnROb2RlICsgXCIsIFwiICsgYW5jaG9yICsgXCIpO1wiLCBsYXN0LCBpdGVyYXRpb24sIGxhc3QsIGxhc3QsIGRlc3Ryb3ksIGhlYWQsIGxvb2t1cCwgZWFjaF9ibG9ja192YWx1ZSwgZWFjaF9ibG9ja192YWx1ZSwgdGhpcy5rZXkpKTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy51bm1vdW50LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE1JDIgfHwgKHRlbXBsYXRlT2JqZWN0XzE1JDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdHdoaWxlIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIudSgpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIi5uZXh0O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCI7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi51KCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiLm5leHQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBpdGVyYXRpb24sIGhlYWQsIGl0ZXJhdGlvbiwgaXRlcmF0aW9uLCBpdGVyYXRpb24sIGl0ZXJhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTYkMiB8fCAodGVtcGxhdGVPYmplY3RfMTYkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCI7XFxuXFx0XFx0XFx0d2hpbGUgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiLm5leHQ7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHR3aGlsZSAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiLmQoKTtcXG5cXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIubmV4dDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdKSksIGl0ZXJhdGlvbiwgaGVhZCwgaXRlcmF0aW9uLCBpdGVyYXRpb24sIGl0ZXJhdGlvbiwgaXRlcmF0aW9uKSk7XG4gICAgfTtcbiAgICBFYWNoQmxvY2sucHJvdG90eXBlLmJ1aWxkVW5rZXllZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMsIHNuaXBwZXQsIF9hKSB7XG4gICAgICAgIHZhciBjcmVhdGVfZWFjaF9ibG9jayA9IF9hLmNyZWF0ZV9lYWNoX2Jsb2NrLCBlYWNoX2Jsb2NrX3ZhbHVlID0gX2EuZWFjaF9ibG9ja192YWx1ZSwgbGVuZ3RoID0gX2EubGVuZ3RoLCBpdGVyYXRpb25zID0gX2EuaXRlcmF0aW9ucywgcGFyYW1zID0gX2EucGFyYW1zLCBhbmNob3IgPSBfYS5hbmNob3IsIG1vdW50T3JJbnRybyA9IF9hLm1vdW50T3JJbnRybztcbiAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xNyQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8xNyQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0dmFyIFwiLCBcIiA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAodmFyICNpID0gMDsgI2kgPCBcIiwgXCIuXCIsIFwiOyAjaSArPSAxKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiWyNpXSA9IFwiLCBcIihcIiwgXCIsIFwiLCBcIiwgXCIsIFwiWyNpXSwgI2ksICNjb21wb25lbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdHZhciBcIiwgXCIgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIsIFwiLlwiLCBcIjsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFwiLCBcIlsjaV0gPSBcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdKSksIGl0ZXJhdGlvbnMsIGVhY2hfYmxvY2tfdmFsdWUsIGxlbmd0aCwgaXRlcmF0aW9ucywgY3JlYXRlX2VhY2hfYmxvY2ssIHBhcmFtcywgZWFjaF9ibG9ja192YWx1ZSwgZWFjaF9ibG9ja192YWx1ZSkpO1xuICAgICAgICB2YXIgaW5pdGlhbE1vdW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgJyN0YXJnZXQnO1xuICAgICAgICB2YXIgdXBkYXRlTW91bnROb2RlID0gdGhpcy5nZXRVcGRhdGVNb3VudE5vZGUoYW5jaG9yKTtcbiAgICAgICAgdmFyIGFuY2hvck5vZGUgPSBwYXJlbnROb2RlID8gJ251bGwnIDogJ2FuY2hvcic7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNyZWF0ZS5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xOCQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8xOCQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0Zm9yICh2YXIgI2kgPSAwOyAjaSA8IFwiLCBcIi5sZW5ndGg7ICNpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCJbI2ldLmMoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIsIFwiLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFwiLCBcIlsjaV0uYygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0pKSwgaXRlcmF0aW9ucywgaXRlcmF0aW9ucykpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNsYWltLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE5JDIgfHwgKHRlbXBsYXRlT2JqZWN0XzE5JDIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIsIFwiLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0ubChcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGZvciAodmFyICNpID0gMDsgI2kgPCBcIiwgXCIubGVuZ3RoOyAjaSArPSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiWyNpXS5sKFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBpdGVyYXRpb25zLCBpdGVyYXRpb25zLCBwYXJlbnROb2RlcykpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLm1vdW50LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzIwJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzIwJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIsIFwiLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFwiLCBcIlsjaV0uXCIsIFwiKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIsIFwiLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFwiLCBcIlsjaV0uXCIsIFwiKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdKSksIGl0ZXJhdGlvbnMsIGl0ZXJhdGlvbnMsIG1vdW50T3JJbnRybywgaW5pdGlhbE1vdW50Tm9kZSwgYW5jaG9yTm9kZSkpO1xuICAgICAgICB2YXIgYWxsRGVwZW5kZW5jaWVzID0gbmV3IFNldCh0aGlzLmJsb2NrLmRlcGVuZGVuY2llcyk7XG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXMgPSB0aGlzLm1ldGFkYXRhLmRlcGVuZGVuY2llcztcbiAgICAgICAgZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgIGFsbERlcGVuZGVuY2llcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUT0RPIGRvIHRoaXMgZm9yIGtleWVkIGJsb2NrcyBhcyB3ZWxsXG4gICAgICAgIHZhciBjb25kaXRpb24gPSBBcnJheS5mcm9tKGFsbERlcGVuZGVuY2llcylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHsgcmV0dXJuIFwiY2hhbmdlZC5cIiArIGRlcGVuZGVuY3k7IH0pXG4gICAgICAgICAgICAuam9pbignIHx8ICcpO1xuICAgICAgICBpZiAoY29uZGl0aW9uICE9PSAnJykge1xuICAgICAgICAgICAgdmFyIGZvckxvb3BCb2R5ID0gdGhpcy5ibG9jay5oYXNVcGRhdGVNZXRob2RcbiAgICAgICAgICAgICAgICA/IHRoaXMuYmxvY2suaGFzSW50cm9NZXRob2RcbiAgICAgICAgICAgICAgICAgICAgPyBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yMSB8fCAodGVtcGxhdGVPYmplY3RfMjEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiWyNpXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0ucChjaGFuZ2VkLCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiWyNpXSwgI2kpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiWyNpXSA9IFwiLCBcIihcIiwgXCIsIFwiLCBcIiwgXCIsIFwiWyNpXSwgI2ksICNjb21wb25lbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0uYygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLmkoXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIlsjaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLnAoY2hhbmdlZCwgXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0gPSBcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiWyNpXS5pKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcIl0pKSwgaXRlcmF0aW9ucywgaXRlcmF0aW9ucywgcGFyYW1zLCBlYWNoX2Jsb2NrX3ZhbHVlLCBlYWNoX2Jsb2NrX3ZhbHVlLCBpdGVyYXRpb25zLCBjcmVhdGVfZWFjaF9ibG9jaywgcGFyYW1zLCBlYWNoX2Jsb2NrX3ZhbHVlLCBlYWNoX2Jsb2NrX3ZhbHVlLCBpdGVyYXRpb25zLCBpdGVyYXRpb25zLCB1cGRhdGVNb3VudE5vZGUsIGFuY2hvcikgOiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yMiB8fCAodGVtcGxhdGVPYmplY3RfMjIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiWyNpXSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0ucChjaGFuZ2VkLCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiWyNpXSwgI2kpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiWyNpXSA9IFwiLCBcIihcIiwgXCIsIFwiLCBcIiwgXCIsIFwiWyNpXSwgI2ksICNjb21wb25lbnQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0uYygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0ubShcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIlsjaV0pIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLnAoY2hhbmdlZCwgXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0gPSBcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLm0oXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcIl0pKSwgaXRlcmF0aW9ucywgaXRlcmF0aW9ucywgcGFyYW1zLCBlYWNoX2Jsb2NrX3ZhbHVlLCBlYWNoX2Jsb2NrX3ZhbHVlLCBpdGVyYXRpb25zLCBjcmVhdGVfZWFjaF9ibG9jaywgcGFyYW1zLCBlYWNoX2Jsb2NrX3ZhbHVlLCBlYWNoX2Jsb2NrX3ZhbHVlLCBpdGVyYXRpb25zLCBpdGVyYXRpb25zLCB1cGRhdGVNb3VudE5vZGUsIGFuY2hvcilcbiAgICAgICAgICAgICAgICA6IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzIzIHx8ICh0ZW1wbGF0ZU9iamVjdF8yMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0gPSBcIiwgXCIoXCIsIFwiLCBcIiwgXCIsIFwiLCBcIlsjaV0sICNpLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLlwiLCBcIihcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldID0gXCIsIFwiKFwiLCBcIiwgXCIsIFwiLCBcIiwgXCJbI2ldLCAjaSwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiWyNpXS5jKCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiWyNpXS5cIiwgXCIoXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFwiXSkpLCBpdGVyYXRpb25zLCBjcmVhdGVfZWFjaF9ibG9jaywgcGFyYW1zLCBlYWNoX2Jsb2NrX3ZhbHVlLCBlYWNoX2Jsb2NrX3ZhbHVlLCBpdGVyYXRpb25zLCBpdGVyYXRpb25zLCBtb3VudE9ySW50cm8sIHVwZGF0ZU1vdW50Tm9kZSwgYW5jaG9yKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuYmxvY2suaGFzVXBkYXRlTWV0aG9kID8gJzAnIDogaXRlcmF0aW9ucyArIFwiLmxlbmd0aFwiO1xuICAgICAgICAgICAgdmFyIG91dHJvID0gYmxvY2suZ2V0VW5pcXVlTmFtZSgnb3V0cm8nKTtcbiAgICAgICAgICAgIHZhciBkZXN0cm95ID0gdGhpcy5ibG9jay5oYXNPdXRyb01ldGhvZFxuICAgICAgICAgICAgICAgID8gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMjQgfHwgKHRlbXBsYXRlT2JqZWN0XzI0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKGkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiW2ldKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiW2ldLm8oZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiW2ldLnUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbaV0uZCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIltpXSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKDsgI2kgPCBcIiwgXCIubGVuZ3RoOyAjaSArPSAxKSBcIiwgXCIoI2kpO1xcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKGkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiW2ldKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiW2ldLm8oZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiW2ldLnUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbaV0uZCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIltpXSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKDsgI2kgPCBcIiwgXCIubGVuZ3RoOyAjaSArPSAxKSBcIiwgXCIoI2kpO1xcblxcdFxcdFxcdFxcdFwiXSkpLCBvdXRybywgaXRlcmF0aW9ucywgaXRlcmF0aW9ucywgaXRlcmF0aW9ucywgaXRlcmF0aW9ucywgaXRlcmF0aW9ucywgaXRlcmF0aW9ucywgb3V0cm8pIDogZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMjUgfHwgKHRlbXBsYXRlT2JqZWN0XzI1ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICg7ICNpIDwgXCIsIFwiLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0udSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlsjaV0uZCgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIubGVuZ3RoID0gXCIsIFwiLlwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdGZvciAoOyAjaSA8IFwiLCBcIi5sZW5ndGg7ICNpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLnUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJbI2ldLmQoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLmxlbmd0aCA9IFwiLCBcIi5cIiwgXCI7XFxuXFx0XFx0XFx0XFx0XCJdKSksIGl0ZXJhdGlvbnMsIGl0ZXJhdGlvbnMsIGl0ZXJhdGlvbnMsIGl0ZXJhdGlvbnMsIGVhY2hfYmxvY2tfdmFsdWUsIGxlbmd0aCk7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy51cGRhdGUuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMjYgfHwgKHRlbXBsYXRlT2JqZWN0XzI2ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0Zm9yICh2YXIgI2kgPSBcIiwgXCI7ICNpIDwgXCIsIFwiLlwiLCBcIjsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRmb3IgKHZhciAjaSA9IFwiLCBcIjsgI2kgPCBcIiwgXCIuXCIsIFwiOyAjaSArPSAxKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0pKSwgZWFjaF9ibG9ja192YWx1ZSwgc25pcHBldCwgY29uZGl0aW9uLCBzdGFydCwgZWFjaF9ibG9ja192YWx1ZSwgbGVuZ3RoLCBmb3JMb29wQm9keSwgZGVzdHJveSkpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVubW91bnQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMjcgfHwgKHRlbXBsYXRlT2JqZWN0XzI3ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0Zm9yICh2YXIgI2kgPSAwOyAjaSA8IFwiLCBcIi5sZW5ndGg7ICNpICs9IDEpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCJbI2ldLnUoKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRmb3IgKHZhciAjaSA9IDA7ICNpIDwgXCIsIFwiLmxlbmd0aDsgI2kgKz0gMSkge1xcblxcdFxcdFxcdFxcdFwiLCBcIlsjaV0udSgpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0pKSwgaXRlcmF0aW9ucywgaXRlcmF0aW9ucykpO1xuICAgICAgICBibG9jay5idWlsZGVycy5kZXN0cm95LmFkZEJsb2NrKFwiQGRlc3Ryb3lFYWNoKFwiICsgaXRlcmF0aW9ucyArIFwiKTtcIik7XG4gICAgfTtcbiAgICByZXR1cm4gRWFjaEJsb2NrO1xufShOb2RlJDEpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDY7XG52YXIgdGVtcGxhdGVPYmplY3RfMiQ2O1xudmFyIHRlbXBsYXRlT2JqZWN0XzMkNjtcbnZhciB0ZW1wbGF0ZU9iamVjdF80JDY7XG52YXIgdGVtcGxhdGVPYmplY3RfNSQ0O1xudmFyIHRlbXBsYXRlT2JqZWN0XzYkNDtcbnZhciB0ZW1wbGF0ZU9iamVjdF83JDM7XG52YXIgdGVtcGxhdGVPYmplY3RfOCQzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzkkMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMCQyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzExJDI7XG52YXIgdGVtcGxhdGVPYmplY3RfMTIkMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMyQyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE0JDI7XG52YXIgdGVtcGxhdGVPYmplY3RfMTUkMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xNiQyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE3JDI7XG52YXIgdGVtcGxhdGVPYmplY3RfMTgkMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xOSQyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzIwJDE7XG52YXIgdGVtcGxhdGVPYmplY3RfMjE7XG52YXIgdGVtcGxhdGVPYmplY3RfMjI7XG52YXIgdGVtcGxhdGVPYmplY3RfMjM7XG52YXIgdGVtcGxhdGVPYmplY3RfMjQ7XG52YXIgdGVtcGxhdGVPYmplY3RfMjU7XG52YXIgdGVtcGxhdGVPYmplY3RfMjY7XG52YXIgdGVtcGxhdGVPYmplY3RfMjc7XG5cbnZhciBFbGVtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFbGVtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRWxlbWVudC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChibG9jaywgc3RyaXBXaGl0ZXNwYWNlLCBuZXh0U2libGluZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5uYW1lID09PSAnc2xvdCcgfHwgdGhpcy5uYW1lID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5jYW5ub3RVc2VJbm5lckhUTUwoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmZpbmROZWFyZXN0KC9eRWxlbWVudC8pO1xuICAgICAgICB0aGlzLm5hbWVzcGFjZSA9IHRoaXMubmFtZSA9PT0gJ3N2ZycgP1xuICAgICAgICAgICAgc3ZnIDpcbiAgICAgICAgICAgIHBhcmVudEVsZW1lbnQgPyBwYXJlbnRFbGVtZW50Lm5hbWVzcGFjZSA6IHRoaXMuZ2VuZXJhdG9yLm5hbWVzcGFjZTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnQXR0cmlidXRlJyAmJiBhdHRyaWJ1dGUudmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2Ug4oCUIHhtbG5zXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5uYW1lID09PSAneG1sbnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBhdHRyaWJ1dGUgbXVzdCBiZSBzdGF0aWMg4oCTIGVuZm9yY2UgYXQgY29tcGlsZSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5hbWVzcGFjZSA9IGF0dHJpYnV0ZS52YWx1ZVswXS5kYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUudmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgIT09ICdUZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLnBhcmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJlbnQuY2Fubm90VXNlSW5uZXJIVE1MKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzXzEgPSBjaHVuay5tZXRhZGF0YS5kZXBlbmRlbmNpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5hZGREZXBlbmRlbmNpZXMoZGVwZW5kZW5jaWVzXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlIOKAlCA8b3B0aW9uIHZhbHVlPSd7e2Zvb319Jz4g4oCUIHNlZSBiZWxvd1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLm5hbWUgPT09ICdvcHRpb24nICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlLm5hbWUgPT09ICd2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0ID0gX3RoaXMucGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzZWxlY3QgJiYgc2VsZWN0LnR5cGUgIT09ICdFbGVtZW50JyB8fCBzZWxlY3QubmFtZSAhPT0gJ3NlbGVjdCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IHNlbGVjdC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdCAmJiBzZWxlY3Quc2VsZWN0QmluZGluZ0RlcGVuZGVuY2llcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Quc2VsZWN0QmluZGluZ0RlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXNfMS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2VuZXJhdG9yLmluZGlyZWN0RGVwZW5kZW5jaWVzLmdldChwcm9wKS5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJlbnQuY2Fubm90VXNlSW5uZXJIVE1MKCk7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnRXZlbnRIYW5kbGVyJyAmJiBhdHRyaWJ1dGUuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUuZXhwcmVzc2lvbi5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5hZGREZXBlbmRlbmNpZXMoYXJnLm1ldGFkYXRhLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ0JpbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmFkZERlcGVuZGVuY2llcyhhdHRyaWJ1dGUubWV0YWRhdGEuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0cmlidXRlLnR5cGUgPT09ICdUcmFuc2l0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlLmludHJvKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2VuZXJhdG9yLmhhc0ludHJvVHJhbnNpdGlvbnMgPSBibG9jay5oYXNJbnRyb01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUub3V0cm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmdlbmVyYXRvci5oYXNPdXRyb1RyYW5zaXRpb25zID0gYmxvY2suaGFzT3V0cm9NZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sub3V0cm9zICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdmFsdWVBdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuZmluZChmdW5jdGlvbiAoYXR0cmlidXRlKSB7IHJldHVybiBhdHRyaWJ1dGUubmFtZSA9PT0gJ3ZhbHVlJzsgfSk7XG4gICAgICAgIGlmICh0aGlzLm5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgYW4gZWdyZWdpb3VzIGhhY2ssIGJ1dCBpdCdzIHRoZSBlYXNpZXN0IHdheSB0byBnZXQgPHRleHRhcmVhPlxuICAgICAgICAgICAgLy8gY2hpbGRyZW4gdHJlYXRlZCB0aGUgc2FtZSB3YXkgYXMgYSB2YWx1ZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChuZXcgQXR0cmlidXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLmdlbmVyYXRvcixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuY2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIOKAlCBpbiBhIGNhc2UgbGlrZSB0aGlzLi4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vICAgPHNlbGVjdCBiaW5kOnZhbHVlPSdmb28nPlxuICAgICAgICAvLyAgICAgPG9wdGlvbiB2YWx1ZT0ne3tiYXJ9fSc+YmFyPC9vcHRpb24+XG4gICAgICAgIC8vICAgICA8b3B0aW9uIHZhbHVlPSd7e2Jhen19Jz5iYXo8L29wdGlvbj5cbiAgICAgICAgLy8gICA8L29wdGlvbj5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gLi4ud2UgbmVlZCB0byBrbm93IHRoYXQgYGZvb2AgZGVwZW5kcyBvbiBgYmFyYCBhbmQgYGJhemAsXG4gICAgICAgIC8vIHNvIHRoYXQgaWYgYGZvby5xdXhgIGNoYW5nZXMsIHdlIGtub3cgdGhhdCB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIG1hcmsgYGJhcmAgYW5kIGBiYXpgIGFzIGRpcnR5IHRvb1xuICAgICAgICBpZiAodGhpcy5uYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmF0dHJpYnV0ZXMuZmluZChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50eXBlID09PSAnQmluZGluZycgJiYgbm9kZS5uYW1lID09PSAndmFsdWUnOyB9KTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBkb2VzIHRoaXMgYWxzbyBhcHBseSB0byBlLmcuIGA8aW5wdXQgdHlwZT0nY2hlY2tib3gnIGJpbmQ6Z3JvdXA9J2Zvbyc+YD9cbiAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gYmluZGluZy5tZXRhZGF0YS5kZXBlbmRlbmNpZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RCaW5kaW5nRGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzO1xuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmdlbmVyYXRvci5pbmRpcmVjdERlcGVuZGVuY2llcy5zZXQocHJvcCwgbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0QmluZGluZ0RlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmdldFN0YXRpY0F0dHJpYnV0ZVZhbHVlKCdzbG90Jyk7XG4gICAgICAgIGlmIChzbG90ICYmIHRoaXMuaGFzQW5jZXN0b3IoJ0NvbXBvbmVudCcpKSB7XG4gICAgICAgICAgICB0aGlzLmNhbm5vdFVzZUlubmVySFRNTCgpO1xuICAgICAgICAgICAgdGhpcy5zbG90dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRPRE8gdmFsaWRhdGUgc2xvdHMg4oCUIG5vIG5lc3RpbmcsIG5vIGR5bmFtaWMgbmFtZXMuLi5cbiAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmZpbmROZWFyZXN0KC9eQ29tcG9uZW50Lyk7XG4gICAgICAgICAgICBjb21wb25lbnQuX3Nsb3RzLmFkZChzbG90KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW1widmFyXCJdID0gYmxvY2suZ2V0VW5pcXVlTmFtZSh0aGlzLm5hbWUucmVwbGFjZSgvW15hLXpBLVowLTlfJF0vZywgJ18nKSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdG9yLnN0eWxlc2hlZXQuYXBwbHkodGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gJ3ByZScgfHwgdGhpcy5uYW1lID09PSAndGV4dGFyZWEnKVxuICAgICAgICAgICAgICAgIHN0cmlwV2hpdGVzcGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pbml0Q2hpbGRyZW4oYmxvY2ssIHN0cmlwV2hpdGVzcGFjZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IHRoaXMuZ2VuZXJhdG9yO1xuICAgICAgICBpZiAodGhpcy5uYW1lID09PSAnc2xvdCcpIHtcbiAgICAgICAgICAgIHZhciBzbG90TmFtZSA9IHRoaXMuZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUoJ25hbWUnKSB8fCAnZGVmYXVsdCc7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRvci5zbG90cy5hZGQoc2xvdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGlsZFN0YXRlID0ge1xuICAgICAgICAgICAgcGFyZW50Tm9kZTogdGhpc1tcInZhclwiXSxcbiAgICAgICAgICAgIHBhcmVudE5vZGVzOiBwYXJlbnROb2RlcyAmJiBibG9jay5nZXRVbmlxdWVOYW1lKHRoaXNbXCJ2YXJcIl0gKyBcIl9ub2Rlc1wiKSAvLyBpZiB3ZSdyZSBpbiB1bmNsYWltYWJsZSB0ZXJyaXRvcnksIGkuZS4gPGhlYWQ+LCBwYXJlbnROb2RlcyBpcyBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBuYW1lID0gdGhpc1tcInZhclwiXTtcbiAgICAgICAgdmFyIGFsbFVzZWRDb250ZXh0cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdmFyIHNsb3QgPSB0aGlzLmF0dHJpYnV0ZXMuZmluZChmdW5jdGlvbiAoYXR0cmlidXRlKSB7IHJldHVybiBhdHRyaWJ1dGUubmFtZSA9PT0gJ3Nsb3QnOyB9KTtcbiAgICAgICAgdmFyIGluaXRpYWxNb3VudE5vZGUgPSB0aGlzLnNsb3R0ZWQgP1xuICAgICAgICAgICAgdGhpcy5maW5kTmVhcmVzdCgvXkNvbXBvbmVudC8pW1widmFyXCJdICsgXCIuX3Nsb3R0ZWQuXCIgKyBzbG90LnZhbHVlWzBdLmRhdGEgOiAvLyBUT0RPIHRoaXMgbG9va3MgYm9ua2Vyc1xuICAgICAgICAgICAgcGFyZW50Tm9kZTtcbiAgICAgICAgYmxvY2suYWRkVmFyaWFibGUobmFtZSk7XG4gICAgICAgIHZhciByZW5kZXJTdGF0ZW1lbnQgPSBnZXRSZW5kZXJTdGF0ZW1lbnQodGhpcy5nZW5lcmF0b3IsIHRoaXMubmFtZXNwYWNlLCB0aGlzLm5hbWUpO1xuICAgICAgICBibG9jay5idWlsZGVycy5jcmVhdGUuYWRkTGluZShuYW1lICsgXCIgPSBcIiArIHJlbmRlclN0YXRlbWVudCArIFwiO1wiKTtcbiAgICAgICAgaWYgKHRoaXMuZ2VuZXJhdG9yLmh5ZHJhdGFibGUpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2Rlcykge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNsYWltLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkNyB8fCAodGVtcGxhdGVPYmplY3RfMSQ3ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBAY2hpbGRyZW4oXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgXCIsIFwiID0gQGNoaWxkcmVuKFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XCJdKSksIG5hbWUsIGdldENsYWltU3RhdGVtZW50KGdlbmVyYXRvciwgdGhpcy5uYW1lc3BhY2UsIHBhcmVudE5vZGVzLCB0aGlzKSwgY2hpbGRTdGF0ZS5wYXJlbnROb2RlcywgbmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuY2xhaW0uYWRkTGluZShuYW1lICsgXCIgPSBcIiArIHJlbmRlclN0YXRlbWVudCArIFwiO1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbE1vdW50Tm9kZSkge1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMubW91bnQuYWRkTGluZShcIkBhcHBlbmROb2RlKFwiICsgbmFtZSArIFwiLCBcIiArIGluaXRpYWxNb3VudE5vZGUgKyBcIik7XCIpO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxNb3VudE5vZGUgPT09ICdkb2N1bWVudC5oZWFkJykge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVubW91bnQuYWRkTGluZShcIkBkZXRhY2hOb2RlKFwiICsgbmFtZSArIFwiKTtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5tb3VudC5hZGRMaW5lKFwiQGluc2VydE5vZGUoXCIgKyBuYW1lICsgXCIsICN0YXJnZXQsIGFuY2hvcik7XCIpO1xuICAgICAgICAgICAgLy8gVE9ETyB3ZSBldmVudHVhbGx5IG5lZWQgdG8gY29uc2lkZXIgd2hhdCBoYXBwZW5zIHRvIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyB0aGF0IGJlbG9uZyB0byB0aGUgc2FtZSBvdXRncm91cCBhcyBhbiBvdXRyb2luZyBlbGVtZW50Li4uXG4gICAgICAgICAgICBibG9jay5idWlsZGVycy51bm1vdW50LmFkZExpbmUoXCJAZGV0YWNoTm9kZShcIiArIG5hbWUgKyBcIik7XCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBDU1MgZW5jYXBzdWxhdGlvbiBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKHRoaXMuX25lZWRzQ3NzQXR0cmlidXRlICYmICF0aGlzLmdlbmVyYXRvci5jdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRvci5uZWVkc0VuY2Fwc3VsYXRlSGVscGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmh5ZHJhdGUuYWRkTGluZShcIkBlbmNhcHN1bGF0ZVN0eWxlcyhcIiArIG5hbWUgKyBcIik7XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nzc1JlZkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmh5ZHJhdGUuYWRkTGluZShcIkBzZXRBdHRyaWJ1dGUoXCIgKyBuYW1lICsgXCIsIFxcXCJzdmVsdGUtcmVmLVwiICsgdGhpcy5fY3NzUmVmQXR0cmlidXRlICsgXCJcXFwiLCBcXFwiXFxcIik7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGluc2VydCBzdGF0aWMgY2hpbGRyZW4gd2l0aCB0ZXh0Q29udGVudCBvciBpbm5lckhUTUxcbiAgICAgICAgaWYgKCF0aGlzLm5hbWVzcGFjZSAmJiB0aGlzLmNhblVzZUlubmVySFRNTCAmJiB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiB0aGlzLmNoaWxkcmVuWzBdLnR5cGUgPT09ICdUZXh0Jykge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNyZWF0ZS5hZGRMaW5lKG5hbWUgKyBcIi50ZXh0Q29udGVudCA9IFwiICsgc3RyaW5naWZ5KHRoaXMuY2hpbGRyZW5bMF0uZGF0YSkgKyBcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy5jcmVhdGUuYWRkTGluZShuYW1lICsgXCIuaW5uZXJIVE1MID0gXCIgKyBzdHJpbmdpZnkodGhpcy5jaGlsZHJlbi5tYXAodG9IVE1MKS5qb2luKCcnKSkgKyBcIjtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYnVpbGQoYmxvY2ssIGNoaWxkU3RhdGUucGFyZW50Tm9kZSwgY2hpbGRTdGF0ZS5wYXJlbnROb2Rlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZEJpbmRpbmdzKGJsb2NrLCBhbGxVc2VkQ29udGV4dHMpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhLnR5cGUgPT09ICdBdHRyaWJ1dGUnOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZS5yZW5kZXIoYmxvY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgICAgICAgdmFyIGV2ZW50SGFuZGxlclVzZXNDb21wb25lbnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50eXBlID09PSAnRXZlbnRIYW5kbGVyJzsgfSkuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgaXNDdXN0b21FdmVudCA9IGdlbmVyYXRvci5ldmVudHMuaGFzKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRIb2lzdCA9ICFpc0N1c3RvbUV2ZW50ICYmIF90aGlzLmhhc0FuY2VzdG9yKCdFYWNoQmxvY2snKTtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gc2hvdWxkSG9pc3QgPyBudWxsIDogbmFtZTtcbiAgICAgICAgICAgIHZhciB1c2VkQ29udGV4dHMgPSBbXTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgIGdlbmVyYXRvci5hZGRTb3VyY2VtYXBMb2NhdGlvbnMoYXR0cmlidXRlLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIHZhciBmbGF0dGVuZWQgPSBmbGF0dGVuKGF0dHJpYnV0ZS5leHByZXNzaW9uLmNhbGxlZSk7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZENhbGxlZU9iamVjdHMuaGFzKGZsYXR0ZW5lZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5zZWxlY3QoKSBldGNcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB2ZXJpZnkgdGhhdCBpdCdzIGEgdmFsaWQgY2FsbGVlIChpLmUuIGJ1aWx0LWluIG9yIGRlY2xhcmVkIG1ldGhvZClcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yLmNvZGUucHJlcGVuZFJpZ2h0KGF0dHJpYnV0ZS5leHByZXNzaW9uLnN0YXJ0LCBibG9jay5hbGlhcygnY29tcG9uZW50JykgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRIb2lzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlclVzZXNDb21wb25lbnQgPSB0cnVlOyAvLyB0aGlzIGZlZWxzIGEgYml0IGhhY2t5IGJ1dCBpdCB3b3JrcyFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlLmV4cHJlc3Npb24uYXJndW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dHMgPSBibG9jay5jb250ZXh0dWFsaXNlKGFyZywgY29udGV4dCwgdHJ1ZSkuY29udGV4dHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghfnVzZWRDb250ZXh0cy5pbmRleE9mKGNvbnRleHQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRDb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsVXNlZENvbnRleHRzLmFkZChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3R4ID0gY29udGV4dCB8fCAndGhpcyc7XG4gICAgICAgICAgICB2YXIgZGVjbGFyYXRpb25zID0gdXNlZENvbnRleHRzLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnc3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRIb2lzdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50SGFuZGxlclVzZXNDb21wb25lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ2YXIgc3RhdGUgPSBcIiArIGJsb2NrLmFsaWFzKCdjb21wb25lbnQnKSArIFwiLmdldCgpO1wiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGlzdE5hbWUgPSBibG9jay5saXN0TmFtZXMuZ2V0KG5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE5hbWUgPSBibG9jay5pbmRleE5hbWVzLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udGV4dE5hbWUgPSBibG9jay5jb250ZXh0cy5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmFyIFwiICsgbGlzdE5hbWUgKyBcIiA9IFwiICsgY3R4ICsgXCIuX3N2ZWx0ZS5cIiArIGxpc3ROYW1lICsgXCIsIFwiICsgaW5kZXhOYW1lICsgXCIgPSBcIiArIGN0eCArIFwiLl9zdmVsdGUuXCIgKyBpbmRleE5hbWUgKyBcIiwgXCIgKyBjb250ZXh0TmFtZSArIFwiID0gXCIgKyBsaXN0TmFtZSArIFwiW1wiICsgaW5kZXhOYW1lICsgXCJdO1wiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBnZXQgYSBuYW1lIGZvciB0aGUgZXZlbnQgaGFuZGxlciB0aGF0IGlzIGdsb2JhbGx5IHVuaXF1ZVxuICAgICAgICAgICAgLy8gaWYgaG9pc3RlZCwgbG9jYWxseSB1bmlxdWUgb3RoZXJ3aXNlXG4gICAgICAgICAgICB2YXIgaGFuZGxlck5hbWUgPSAoc2hvdWxkSG9pc3QgPyBnZW5lcmF0b3IgOiBibG9jaykuZ2V0VW5pcXVlTmFtZShhdHRyaWJ1dGUubmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV8kXS9nLCAnXycpICsgXCJfaGFuZGxlclwiKTtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSB0aGUgaGFuZGxlciBib2R5XG4gICAgICAgICAgICB2YXIgaGFuZGxlckJvZHkgPSBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yJDcgfHwgKHRlbXBsYXRlT2JqZWN0XzIkNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XCIsXG4gICAgICAgICAgICAgICAgXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcIixcbiAgICAgICAgICAgICAgICBcIlxcblxcdFxcdFxcdFwiXSkpLCBldmVudEhhbmRsZXJVc2VzQ29tcG9uZW50ICYmXG4gICAgICAgICAgICAgICAgXCJ2YXIgXCIgKyBibG9jay5hbGlhcygnY29tcG9uZW50JykgKyBcIiA9IFwiICsgY3R4ICsgXCIuX3N2ZWx0ZS5jb21wb25lbnQ7XCIsIGRlY2xhcmF0aW9ucywgYXR0cmlidXRlLmV4cHJlc3Npb24gP1xuICAgICAgICAgICAgICAgIFwiW1xcdTI3MDJcIiArIGF0dHJpYnV0ZS5leHByZXNzaW9uLnN0YXJ0ICsgXCItXCIgKyBhdHRyaWJ1dGUuZXhwcmVzc2lvbi5lbmQgKyBcIlxcdTI3MDJdO1wiIDpcbiAgICAgICAgICAgICAgICBibG9jay5hbGlhcygnY29tcG9uZW50JykgKyBcIi5maXJlKFxcXCJcIiArIGF0dHJpYnV0ZS5uYW1lICsgXCJcXFwiLCBldmVudCk7XCIpO1xuICAgICAgICAgICAgaWYgKGlzQ3VzdG9tRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBibG9jay5hZGRWYXJpYWJsZShoYW5kbGVyTmFtZSk7XG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaHlkcmF0ZS5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8zJDcgfHwgKHRlbXBsYXRlT2JqZWN0XzMkNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9ICVldmVudHMtXCIsIFwiLmNhbGwoI2NvbXBvbmVudCwgXCIsIFwiLCBmdW5jdGlvbihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gJWV2ZW50cy1cIiwgXCIuY2FsbCgjY29tcG9uZW50LCBcIiwgXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XCJdKSksIGhhbmRsZXJOYW1lLCBhdHRyaWJ1dGUubmFtZSwgbmFtZSwgaGFuZGxlckJvZHkpKTtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy5kZXN0cm95LmFkZExpbmUoZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNCQ3IHx8ICh0ZW1wbGF0ZU9iamVjdF80JDcgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIudGVhcmRvd24oKTtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi50ZWFyZG93bigpO1xcblxcdFxcdFxcdFxcdFwiXSkpLCBoYW5kbGVyTmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF81JDUgfHwgKHRlbXBsYXRlT2JqZWN0XzUkNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcIl0pKSwgaGFuZGxlck5hbWUsIGhhbmRsZXJCb2R5KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkSG9pc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yLmJsb2Nrcy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRCbG9jayhoYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaHlkcmF0ZS5hZGRMaW5lKFwiQGFkZExpc3RlbmVyKFwiICsgbmFtZSArIFwiLCBcXFwiXCIgKyBhdHRyaWJ1dGUubmFtZSArIFwiXFxcIiwgXCIgKyBoYW5kbGVyTmFtZSArIFwiKTtcIik7XG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuZGVzdHJveS5hZGRMaW5lKFwiQHJlbW92ZUxpc3RlbmVyKFwiICsgbmFtZSArIFwiLCBcXFwiXCIgKyBhdHRyaWJ1dGUubmFtZSArIFwiXFxcIiwgXCIgKyBoYW5kbGVyTmFtZSArIFwiKTtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyByZWZzXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudHlwZSA9PT0gJ1JlZic7IH0pLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdmFyIHJlZiA9IFwiI2NvbXBvbmVudC5yZWZzLlwiICsgYXR0cmlidXRlLm5hbWU7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5tb3VudC5hZGRMaW5lKHJlZiArIFwiID0gXCIgKyBuYW1lICsgXCI7XCIpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuZGVzdHJveS5hZGRMaW5lKFwiaWYgKFwiICsgcmVmICsgXCIgPT09IFwiICsgbmFtZSArIFwiKSBcIiArIHJlZiArIFwiID0gbnVsbDtcIik7XG4gICAgICAgICAgICBnZW5lcmF0b3IudXNlc1JlZnMgPSB0cnVlOyAvLyBzbyBjb21wb25lbnQucmVmcyBvYmplY3QgaXMgY3JlYXRlZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hZGRUcmFuc2l0aW9ucyhibG9jayk7XG4gICAgICAgIGlmIChhbGxVc2VkQ29udGV4dHMuc2l6ZSB8fCBldmVudEhhbmRsZXJVc2VzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbFByb3BzXzEgPSBbXTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVzXzEgPSBbXTtcbiAgICAgICAgICAgIGlmIChldmVudEhhbmRsZXJVc2VzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFByb3BzXzEucHVzaChcImNvbXBvbmVudDogI2NvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbFVzZWRDb250ZXh0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb250ZXh0TmFtZSkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0TmFtZSA9PT0gJ3N0YXRlJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBsaXN0TmFtZSA9IGJsb2NrLmxpc3ROYW1lcy5nZXQoY29udGV4dE5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleE5hbWUgPSBibG9jay5pbmRleE5hbWVzLmdldChjb250ZXh0TmFtZSk7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFByb3BzXzEucHVzaChsaXN0TmFtZSArIFwiOiBcIiArIGxpc3ROYW1lICsgXCIsXFxuXCIgKyBpbmRleE5hbWUgKyBcIjogXCIgKyBpbmRleE5hbWUpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZXNfMS5wdXNoKG5hbWUgKyBcIi5fc3ZlbHRlLlwiICsgbGlzdE5hbWUgKyBcIiA9IFwiICsgbGlzdE5hbWUgKyBcIjtcXG5cIiArIG5hbWUgKyBcIi5fc3ZlbHRlLlwiICsgaW5kZXhOYW1lICsgXCIgPSBcIiArIGluZGV4TmFtZSArIFwiO1wiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluaXRpYWxQcm9wc18xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmh5ZHJhdGUuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNiQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF82JDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuX3N2ZWx0ZSA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLl9zdmVsdGUgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcXHRcIl0pKSwgbmFtZSwgaW5pdGlhbFByb3BzXzEuam9pbignLFxcbicpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlc18xLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRCbG9jayh1cGRhdGVzXzEuam9pbignXFxuJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxVcGRhdGUpIHtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLm1vdW50LmFkZEJsb2NrKHRoaXMuaW5pdGlhbFVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkU3RhdGUucGFyZW50Tm9kZXMpIHtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNsYWltLmFkZExpbmUoY2hpbGRTdGF0ZS5wYXJlbnROb2RlcyArIFwiLmZvckVhY2goQGRldGFjaE5vZGUpO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0hUTUwobm9kZSkge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1RleHQnKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmRhdGE7XG4gICAgICAgICAgICB2YXIgb3BlbiA9IFwiPFwiICsgbm9kZS5uYW1lO1xuICAgICAgICAgICAgaWYgKG5vZGUuX25lZWRzQ3NzQXR0cmlidXRlKSB7XG4gICAgICAgICAgICAgICAgb3BlbiArPSBcIiBcIiArIGdlbmVyYXRvci5zdHlsZXNoZWV0LmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuX2Nzc1JlZkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIG9wZW4gKz0gXCIgc3ZlbHRlLXJlZi1cIiArIG5vZGUuX2Nzc1JlZkF0dHJpYnV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICAgICAgb3BlbiArPSBcIiBcIiArIGF0dHIubmFtZSArIHN0cmluZ2lmeUF0dHJpYnV0ZVZhbHVlKGF0dHIudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaXNWb2lkRWxlbWVudE5hbWUobm9kZS5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlbiArICc+JztcbiAgICAgICAgICAgIHJldHVybiBvcGVuICsgXCI+XCIgKyBub2RlLmNoaWxkcmVuLm1hcCh0b0hUTUwpLmpvaW4oJycpICsgXCI8L1wiICsgbm9kZS5uYW1lICsgXCI+XCI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmFkZEJpbmRpbmdzID0gZnVuY3Rpb24gKGJsb2NrLCBhbGxVc2VkQ29udGV4dHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGJpbmRpbmdzID0gdGhpcy5hdHRyaWJ1dGVzLmZpbHRlcihmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50eXBlID09PSAnQmluZGluZyc7IH0pO1xuICAgICAgICBpZiAoYmluZGluZ3MubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5uYW1lID09PSAnc2VsZWN0JyB8fCB0aGlzLmlzTWVkaWFOb2RlKCkpXG4gICAgICAgICAgICB0aGlzLmdlbmVyYXRvci5oYXNDb21wbGV4QmluZGluZ3MgPSB0cnVlO1xuICAgICAgICB2YXIgbmVlZHNMb2NrID0gdGhpcy5uYW1lICE9PSAnaW5wdXQnIHx8ICEvcmFkaW98Y2hlY2tib3h8cmFuZ2V8Y29sb3IvLnRlc3QodGhpcy5nZXRTdGF0aWNBdHRyaWJ1dGVWYWx1ZSgndHlwZScpKTtcbiAgICAgICAgdmFyIG11bmdlZEJpbmRpbmdzID0gYmluZGluZ3MubWFwKGZ1bmN0aW9uIChiaW5kaW5nKSB7IHJldHVybiBiaW5kaW5nLm11bmdlKGJsb2NrLCBhbGxVc2VkQ29udGV4dHMpOyB9KTtcbiAgICAgICAgdmFyIGxvY2sgPSBtdW5nZWRCaW5kaW5ncy5zb21lKGZ1bmN0aW9uIChiaW5kaW5nKSB7IHJldHVybiBiaW5kaW5nLm5lZWRzTG9jazsgfSkgP1xuICAgICAgICAgICAgYmxvY2suZ2V0VW5pcXVlTmFtZSh0aGlzW1widmFyXCJdICsgXCJfdXBkYXRpbmdcIikgOlxuICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgaWYgKGxvY2spXG4gICAgICAgICAgICBibG9jay5hZGRWYXJpYWJsZShsb2NrLCAnZmFsc2UnKTtcbiAgICAgICAgdmFyIGdyb3VwcyA9IGV2ZW50cyQxXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBldmVudHM6IGV2ZW50LmV2ZW50TmFtZXMsXG4gICAgICAgICAgICAgICAgYmluZGluZ3M6IG11bmdlZEJpbmRpbmdzLmZpbHRlcihmdW5jdGlvbiAoYmluZGluZykgeyByZXR1cm4gZXZlbnQuZmlsdGVyKF90aGlzLCBiaW5kaW5nLm5hbWUpOyB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGdyb3VwKSB7IHJldHVybiBncm91cC5iaW5kaW5ncy5sZW5ndGg7IH0pO1xuICAgICAgICBncm91cHMuZm9yRWFjaChmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gYmxvY2suZ2V0VW5pcXVlTmFtZShfdGhpc1tcInZhclwiXSArIFwiX1wiICsgZ3JvdXAuZXZlbnRzLmpvaW4oJ18nKSArIFwiX2hhbmRsZXJcIik7XG4gICAgICAgICAgICB2YXIgbmVlZHNMb2NrID0gZ3JvdXAuYmluZGluZ3Muc29tZShmdW5jdGlvbiAoYmluZGluZykgeyByZXR1cm4gYmluZGluZy5uZWVkc0xvY2s7IH0pO1xuICAgICAgICAgICAgZ3JvdXAuYmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICAgICAgICAgIGlmICghYmluZGluZy51cGRhdGVEb20pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlQ29uZGl0aW9ucyA9IG5lZWRzTG9jayA/IFtcIiFcIiArIGxvY2tdIDogW107XG4gICAgICAgICAgICAgICAgaWYgKGJpbmRpbmcudXBkYXRlQ29uZGl0aW9uKVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDb25kaXRpb25zLnB1c2goYmluZGluZy51cGRhdGVDb25kaXRpb24pO1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRMaW5lKHVwZGF0ZUNvbmRpdGlvbnMubGVuZ3RoID8gXCJpZiAoXCIgKyB1cGRhdGVDb25kaXRpb25zLmpvaW4oJyAmJiAnKSArIFwiKSBcIiArIGJpbmRpbmcudXBkYXRlRG9tIDogYmluZGluZy51cGRhdGVEb20pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdXNlc0NvbnRleHQgPSBncm91cC5iaW5kaW5ncy5zb21lKGZ1bmN0aW9uIChiaW5kaW5nKSB7IHJldHVybiBiaW5kaW5nLmhhbmRsZXIudXNlc0NvbnRleHQ7IH0pO1xuICAgICAgICAgICAgdmFyIHVzZXNTdGF0ZSA9IGdyb3VwLmJpbmRpbmdzLnNvbWUoZnVuY3Rpb24gKGJpbmRpbmcpIHsgcmV0dXJuIGJpbmRpbmcuaGFuZGxlci51c2VzU3RhdGU7IH0pO1xuICAgICAgICAgICAgdmFyIHVzZXNTdG9yZSA9IGdyb3VwLmJpbmRpbmdzLnNvbWUoZnVuY3Rpb24gKGJpbmRpbmcpIHsgcmV0dXJuIGJpbmRpbmcuaGFuZGxlci51c2VzU3RvcmU7IH0pO1xuICAgICAgICAgICAgdmFyIG11dGF0aW9ucyA9IGdyb3VwLmJpbmRpbmdzLm1hcChmdW5jdGlvbiAoYmluZGluZykgeyByZXR1cm4gYmluZGluZy5oYW5kbGVyLm11dGF0aW9uOyB9KS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICB2YXIgc3RvcmVQcm9wcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGdyb3VwLmJpbmRpbmdzLmZvckVhY2goZnVuY3Rpb24gKGJpbmRpbmcpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5nLmhhbmRsZXIucHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy5hZGQocHJvcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYmluZGluZy5oYW5kbGVyLnN0b3JlUHJvcHMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZVByb3BzLmFkZChwcm9wKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pOyAvLyBUT0RPIHVzZSBzdHJpbmdpZnlQcm9wcyBoZXJlLCBvbmNlIGluZGVudGluZyBpcyBmaXhlZFxuICAgICAgICAgICAgLy8gbWVkaWEgYmluZGluZ3Mg4oCUIGF3a3dhcmQgc3BlY2lhbCBjYXNlLiBUaGUgbmF0aXZlIHRpbWV1cGRhdGUgZXZlbnRzXG4gICAgICAgICAgICAvLyBmaXJlIHRvbyBpbmZyZXF1ZW50bHksIHNvIHdlIG5lZWQgdG8gdGFrZSBtYXR0ZXJzIGludG8gb3VyXG4gICAgICAgICAgICAvLyBvd24gaGFuZHNcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25fZnJhbWU7XG4gICAgICAgICAgICBpZiAoZ3JvdXAuZXZlbnRzWzBdID09PSAndGltZXVwZGF0ZScpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fZnJhbWUgPSBibG9jay5nZXRVbmlxdWVOYW1lKF90aGlzW1widmFyXCJdICsgXCJfYW5pbWF0aW9uZnJhbWVcIik7XG4gICAgICAgICAgICAgICAgYmxvY2suYWRkVmFyaWFibGUoYW5pbWF0aW9uX2ZyYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmluaXQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNyQ0IHx8ICh0ZW1wbGF0ZU9iamVjdF83JDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKCkge1xcblxcdFxcdFxcdFxcdFxcdFwiLFxuICAgICAgICAgICAgICAgIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBoYW5kbGVyLCBhbmltYXRpb25fZnJhbWUgJiYgZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfOCQ0IHx8ICh0ZW1wbGF0ZU9iamVjdF84JDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYW5jZWxBbmltYXRpb25GcmFtZShcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghXCIsIFwiLnBhdXNlZCkgXCIsIFwiID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFwiLCBcIik7XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYW5jZWxBbmltYXRpb25GcmFtZShcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICghXCIsIFwiLnBhdXNlZCkgXCIsIFwiID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFwiLCBcIik7XCJdKSksIGFuaW1hdGlvbl9mcmFtZSwgX3RoaXNbXCJ2YXJcIl0sIGFuaW1hdGlvbl9mcmFtZSwgaGFuZGxlciksIHVzZXNDb250ZXh0ICYmIFwidmFyIGNvbnRleHQgPSBcIiArIF90aGlzW1widmFyXCJdICsgXCIuX3N2ZWx0ZTtcIiwgdXNlc1N0YXRlICYmIFwidmFyIHN0YXRlID0gI2NvbXBvbmVudC5nZXQoKTtcIiwgdXNlc1N0b3JlICYmIFwidmFyICQgPSAjY29tcG9uZW50LnN0b3JlLmdldCgpO1wiLCBuZWVkc0xvY2sgJiYgbG9jayArIFwiID0gdHJ1ZTtcIiwgbXV0YXRpb25zLmxlbmd0aCA+IDAgJiYgbXV0YXRpb25zLCBwcm9wcy5zaXplID4gMCAmJiBcIiNjb21wb25lbnQuc2V0KHsgXCIgKyBBcnJheS5mcm9tKHByb3BzKS5qb2luKCcsICcpICsgXCIgfSk7XCIsIHN0b3JlUHJvcHMuc2l6ZSA+IDAgJiYgXCIjY29tcG9uZW50LnN0b3JlLnNldCh7IFwiICsgQXJyYXkuZnJvbShzdG9yZVByb3BzKS5qb2luKCcsICcpICsgXCIgfSk7XCIsIG5lZWRzTG9jayAmJiBsb2NrICsgXCIgPSBmYWxzZTtcIikpO1xuICAgICAgICAgICAgZ3JvdXAuZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy5oeWRyYXRlLmFkZExpbmUoXCJAYWRkTGlzdGVuZXIoXCIgKyBfdGhpc1tcInZhclwiXSArIFwiLCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIiArIGhhbmRsZXIgKyBcIik7XCIpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kuYWRkTGluZShcIkByZW1vdmVMaXN0ZW5lcihcIiArIF90aGlzW1widmFyXCJdICsgXCIsIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIsIFwiICsgaGFuZGxlciArIFwiKTtcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBhbGxJbml0aWFsU3RhdGVJc0RlZmluZWQgPSBncm91cC5iaW5kaW5nc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGJpbmRpbmcpIHsgcmV0dXJuIFwiJ1wiICsgYmluZGluZy5vYmplY3QgKyBcIicgaW4gc3RhdGVcIjsgfSlcbiAgICAgICAgICAgICAgICAuam9pbignICYmICcpO1xuICAgICAgICAgICAgaWYgKF90aGlzLm5hbWUgPT09ICdzZWxlY3QnIHx8IGdyb3VwLmJpbmRpbmdzLmZpbmQoZnVuY3Rpb24gKGJpbmRpbmcpIHsgcmV0dXJuIGJpbmRpbmcubmFtZSA9PT0gJ2luZGV0ZXJtaW5hdGUnIHx8IGJpbmRpbmcuaXNSZWFkT25seU1lZGlhQXR0cmlidXRlOyB9KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmdlbmVyYXRvci5oYXNDb21wbGV4QmluZGluZ3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmh5ZHJhdGUuYWRkTGluZShcImlmICghKFwiICsgYWxsSW5pdGlhbFN0YXRlSXNEZWZpbmVkICsgXCIpKSAjY29tcG9uZW50LnJvb3QuX2JlZm9yZWNyZWF0ZS5wdXNoKFwiICsgaGFuZGxlciArIFwiKTtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmluaXRpYWxVcGRhdGUgPSBtdW5nZWRCaW5kaW5ncy5tYXAoZnVuY3Rpb24gKGJpbmRpbmcpIHsgcmV0dXJuIGJpbmRpbmcuaW5pdGlhbFVwZGF0ZTsgfSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuICAgIH07XG4gICAgRWxlbWVudC5wcm90b3R5cGUuYWRkVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIGludHJvID0gdGhpcy5hdHRyaWJ1dGVzLmZpbmQoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudHlwZSA9PT0gJ1RyYW5zaXRpb24nICYmIGEuaW50cm87IH0pO1xuICAgICAgICB2YXIgb3V0cm8gPSB0aGlzLmF0dHJpYnV0ZXMuZmluZChmdW5jdGlvbiAoYSkgeyByZXR1cm4gYS50eXBlID09PSAnVHJhbnNpdGlvbicgJiYgYS5vdXRybzsgfSk7XG4gICAgICAgIGlmICghaW50cm8gJiYgIW91dHJvKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoaW50cm8gPT09IG91dHJvKSB7XG4gICAgICAgICAgICBibG9jay5jb250ZXh0dWFsaXNlKGludHJvLmV4cHJlc3Npb24pOyAvLyBUT0RPIHJlbW92ZSBhbGwgdGhlc2VcbiAgICAgICAgICAgIHZhciBuYW1lID0gYmxvY2suZ2V0VW5pcXVlTmFtZSh0aGlzW1widmFyXCJdICsgXCJfdHJhbnNpdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBzbmlwcGV0ID0gaW50cm8uZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgID8gaW50cm8ubWV0YWRhdGEuc25pcHBldFxuICAgICAgICAgICAgICAgIDogJ3t9JztcbiAgICAgICAgICAgIGJsb2NrLmFkZFZhcmlhYmxlKG5hbWUpO1xuICAgICAgICAgICAgdmFyIGZuID0gXCIldHJhbnNpdGlvbnMtXCIgKyBpbnRyby5uYW1lO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW50cm8uYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfOSQzIHx8ICh0ZW1wbGF0ZU9iamVjdF85JDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHQjY29tcG9uZW50LnJvb3QuX2FmdGVyY3JlYXRlLnB1c2goZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFcIiwgXCIpIFwiLCBcIiA9IEB3cmFwVHJhbnNpdGlvbigjY29tcG9uZW50LCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiLCB0cnVlLCBudWxsKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIucnVuKHRydWUsIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQuZmlyZShcXFwiaW50cm8uZW5kXFxcIiwgeyBub2RlOiBcIiwgXCIgfSk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHQjY29tcG9uZW50LnJvb3QuX2FmdGVyY3JlYXRlLnB1c2goZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFcIiwgXCIpIFwiLCBcIiA9IEB3cmFwVHJhbnNpdGlvbigjY29tcG9uZW50LCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiLCB0cnVlLCBudWxsKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIucnVuKHRydWUsIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQuZmlyZShcXFwiaW50cm8uZW5kXFxcIiwgeyBub2RlOiBcIiwgXCIgfSk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XCJdKSksIG5hbWUsIG5hbWUsIHRoaXNbXCJ2YXJcIl0sIGZuLCBzbmlwcGV0LCBuYW1lLCB0aGlzW1widmFyXCJdKSk7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5vdXRyby5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xMCQzIHx8ICh0ZW1wbGF0ZU9iamVjdF8xMCQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XCIsIFwiLnJ1bihmYWxzZSwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0I2NvbXBvbmVudC5maXJlKFxcXCJvdXRyby5lbmRcXFwiLCB7IG5vZGU6IFwiLCBcIiB9KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoLS0jb3V0cm9zID09PSAwKSAjb3V0cm9jYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IG51bGw7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCIucnVuKGZhbHNlLCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHQjY29tcG9uZW50LmZpcmUoXFxcIm91dHJvLmVuZFxcXCIsIHsgbm9kZTogXCIsIFwiIH0pO1xcblxcdFxcdFxcdFxcdFxcdGlmICgtLSNvdXRyb3MgPT09IDApICNvdXRyb2NhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcIl0pKSwgbmFtZSwgdGhpc1tcInZhclwiXSwgbmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGludHJvTmFtZSA9IGludHJvICYmIGJsb2NrLmdldFVuaXF1ZU5hbWUodGhpc1tcInZhclwiXSArIFwiX2ludHJvXCIpO1xuICAgICAgICAgICAgdmFyIG91dHJvTmFtZSA9IG91dHJvICYmIGJsb2NrLmdldFVuaXF1ZU5hbWUodGhpc1tcInZhclwiXSArIFwiX291dHJvXCIpO1xuICAgICAgICAgICAgaWYgKGludHJvKSB7XG4gICAgICAgICAgICAgICAgYmxvY2suY29udGV4dHVhbGlzZShpbnRyby5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBibG9jay5hZGRWYXJpYWJsZShpbnRyb05hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBzbmlwcGV0ID0gaW50cm8uZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICA/IGludHJvLm1ldGFkYXRhLnNuaXBwZXRcbiAgICAgICAgICAgICAgICAgICAgOiAne30nO1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IFwiJXRyYW5zaXRpb25zLVwiICsgaW50cm8ubmFtZTsgLy8gVE9ETyBhZGQgYnVpbHQtaW4gdHJhbnNpdGlvbnM/XG4gICAgICAgICAgICAgICAgaWYgKG91dHJvKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmludHJvLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzExJDMgfHwgKHRlbXBsYXRlT2JqZWN0XzExJDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSBcIiwgXCIuYWJvcnQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSBcIiwgXCIuYWJvcnQoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5hYm9ydCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5hYm9ydCgpO1xcblxcdFxcdFxcdFxcdFxcdFwiXSkpLCBpbnRyb05hbWUsIGludHJvTmFtZSwgb3V0cm9OYW1lLCBvdXRyb05hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW50cm8uYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTIkMyB8fCAodGVtcGxhdGVPYmplY3RfMTIkMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQucm9vdC5fYWZ0ZXJjcmVhdGUucHVzaChmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBAd3JhcFRyYW5zaXRpb24oI2NvbXBvbmVudCwgXCIsIFwiLCBcIiwgXCIsIFwiLCBcIiwgdHJ1ZSwgbnVsbCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiLnJ1bih0cnVlLCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQjY29tcG9uZW50LmZpcmUoXFxcImludHJvLmVuZFxcXCIsIHsgbm9kZTogXCIsIFwiIH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0I2NvbXBvbmVudC5yb290Ll9hZnRlcmNyZWF0ZS5wdXNoKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IEB3cmFwVHJhbnNpdGlvbigjY29tcG9uZW50LCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiLCB0cnVlLCBudWxsKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIucnVuKHRydWUsIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQuZmlyZShcXFwiaW50cm8uZW5kXFxcIiwgeyBub2RlOiBcIiwgXCIgfSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XCJdKSksIGludHJvTmFtZSwgdGhpc1tcInZhclwiXSwgZm4sIHNuaXBwZXQsIGludHJvTmFtZSwgdGhpc1tcInZhclwiXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG91dHJvKSB7XG4gICAgICAgICAgICAgICAgYmxvY2suY29udGV4dHVhbGlzZShvdXRyby5leHByZXNzaW9uKTtcbiAgICAgICAgICAgICAgICBibG9jay5hZGRWYXJpYWJsZShvdXRyb05hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBzbmlwcGV0ID0gb3V0cm8uZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICA/IG91dHJvLm1ldGFkYXRhLnNuaXBwZXRcbiAgICAgICAgICAgICAgICAgICAgOiAne30nO1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IFwiJXRyYW5zaXRpb25zLVwiICsgb3V0cm8ubmFtZTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGhpZGUgZWxlbWVudHMgdGhhdCBoYXZlIG91dHJvJ2QgKHVubGVzcyB0aGV5IGJlbG9uZyB0byBhIHN0aWxsLW91dHJvaW5nXG4gICAgICAgICAgICAgICAgLy8gZ3JvdXApIHByaW9yIHRvIHRoZWlyIHJlbW92YWwgZnJvbSB0aGUgRE9NXG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMub3V0cm8uYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTMkMyB8fCAodGVtcGxhdGVPYmplY3RfMTMkMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IEB3cmFwVHJhbnNpdGlvbigjY29tcG9uZW50LCBcIiwgXCIsIFwiLCBcIiwgXCIsIFwiLCBmYWxzZSwgbnVsbCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLnJ1bihmYWxzZSwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0I2NvbXBvbmVudC5maXJlKFxcXCJvdXRyby5lbmRcXFwiLCB7IG5vZGU6IFwiLCBcIiB9KTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoLS0jb3V0cm9zID09PSAwKSAjb3V0cm9jYWxsYmFjaygpO1xcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gQHdyYXBUcmFuc2l0aW9uKCNjb21wb25lbnQsIFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIsIGZhbHNlLCBudWxsKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIucnVuKGZhbHNlLCBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQjY29tcG9uZW50LmZpcmUoXFxcIm91dHJvLmVuZFxcXCIsIHsgbm9kZTogXCIsIFwiIH0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICgtLSNvdXRyb3MgPT09IDApICNvdXRyb2NhbGxiYWNrKCk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XCJdKSksIG91dHJvTmFtZSwgdGhpc1tcInZhclwiXSwgZm4sIHNuaXBwZXQsIG91dHJvTmFtZSwgdGhpc1tcInZhclwiXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFbGVtZW50LnByb3RvdHlwZS5nZXRTdGF0aWNBdHRyaWJ1dGVWYWx1ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMuZmluZChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci50eXBlID09PSAnQXR0cmlidXRlJyAmJiBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZTsgfSk7XG4gICAgICAgIGlmICghYXR0cmlidXRlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoID09PSAxICYmIGF0dHJpYnV0ZS52YWx1ZVswXS50eXBlID09PSAnVGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGUudmFsdWVbMF0uZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIEVsZW1lbnQucHJvdG90eXBlLmlzTWVkaWFOb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lID09PSAnYXVkaW8nIHx8IHRoaXMubmFtZSA9PT0gJ3ZpZGVvJztcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50O1xufShOb2RlJDEpKTtcbmZ1bmN0aW9uIGdldFJlbmRlclN0YXRlbWVudChnZW5lcmF0b3IsIG5hbWVzcGFjZSwgbmFtZSkge1xuICAgIGlmIChuYW1lc3BhY2UgPT09ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycpIHtcbiAgICAgICAgcmV0dXJuIFwiQGNyZWF0ZVN2Z0VsZW1lbnQoXFxcIlwiICsgbmFtZSArIFwiXFxcIilcIjtcbiAgICB9XG4gICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICByZXR1cm4gXCJkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXFxcIlwiICsgbmFtZXNwYWNlICsgXCJcXFwiLCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiKVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJAY3JlYXRlRWxlbWVudChcXFwiXCIgKyBuYW1lICsgXCJcXFwiKVwiO1xufVxuZnVuY3Rpb24gZ2V0Q2xhaW1TdGF0ZW1lbnQoZ2VuZXJhdG9yLCBuYW1lc3BhY2UsIG5vZGVzLCBub2RlKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXNcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci50eXBlID09PSAnQXR0cmlidXRlJzsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gcXVvdGVQcm9wKGF0dHIubmFtZSwgZ2VuZXJhdG9yLmxlZ2FjeSkgKyBcIjogdHJ1ZVwiOyB9KVxuICAgICAgICAuam9pbignLCAnKTtcbiAgICB2YXIgbmFtZSA9IG5hbWVzcGFjZSA/IG5vZGUubmFtZSA6IG5vZGUubmFtZS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBcIkBjbGFpbUVsZW1lbnQoXCIgKyBub2RlcyArIFwiLCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLCBcIiArIChhdHRyaWJ1dGVzXG4gICAgICAgID8gXCJ7IFwiICsgYXR0cmlidXRlcyArIFwiIH1cIlxuICAgICAgICA6IFwie31cIikgKyBcIiwgXCIgKyAobmFtZXNwYWNlID09PSBzdmcgPyB0cnVlIDogZmFsc2UpICsgXCIpXCI7XG59XG5mdW5jdGlvbiBxdW90ZVByb3AobmFtZSwgbGVnYWN5KSB7XG4gICAgdmFyIGlzTGVnYWN5UHJvcE5hbWUgPSBsZWdhY3kgJiYgcmVzZXJ2ZWROYW1lcy5oYXMobmFtZSk7XG4gICAgaWYgKC9bXmEtekEtWl8kMC05XS8udGVzdChuYW1lKSB8fCBpc0xlZ2FjeVByb3BOYW1lKVxuICAgICAgICByZXR1cm4gXCJcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCI7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlBdHRyaWJ1dGVWYWx1ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBcIj1cXFwiXFxcIlwiO1xuICAgIHZhciBkYXRhID0gdmFsdWVbMF0uZGF0YTtcbiAgICByZXR1cm4gXCI9XCIgKyBKU09OLnN0cmluZ2lmeShkYXRhKTtcbn1cbnZhciBldmVudHMkMSA9IFtcbiAgICB7XG4gICAgICAgIGV2ZW50TmFtZXM6IFsnaW5wdXQnXSxcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubmFtZSA9PT0gJ3RleHRhcmVhJyB8fFxuICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9PT0gJ2lucHV0JyAmJiAhL3JhZGlvfGNoZWNrYm94Ly50ZXN0KG5vZGUuZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUoJ3R5cGUnKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgZXZlbnROYW1lczogWydjaGFuZ2UnXSxcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubmFtZSA9PT0gJ3NlbGVjdCcgfHxcbiAgICAgICAgICAgICAgICBub2RlLm5hbWUgPT09ICdpbnB1dCcgJiYgL3JhZGlvfGNoZWNrYm94fHJhbmdlLy50ZXN0KG5vZGUuZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUoJ3R5cGUnKSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8vIG1lZGlhIGV2ZW50c1xuICAgIHtcbiAgICAgICAgZXZlbnROYW1lczogWyd0aW1ldXBkYXRlJ10sXG4gICAgICAgIGZpbHRlcjogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmlzTWVkaWFOb2RlKCkgJiZcbiAgICAgICAgICAgICAgICAobmFtZSA9PT0gJ2N1cnJlbnRUaW1lJyB8fCBuYW1lID09PSAncGxheWVkJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgZXZlbnROYW1lczogWydkdXJhdGlvbmNoYW5nZSddLFxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5pc01lZGlhTm9kZSgpICYmXG4gICAgICAgICAgICAgICAgbmFtZSA9PT0gJ2R1cmF0aW9uJztcbiAgICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgICBldmVudE5hbWVzOiBbJ3BsYXknLCAncGF1c2UnXSxcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuaXNNZWRpYU5vZGUoKSAmJlxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdwYXVzZWQnO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAgIGV2ZW50TmFtZXM6IFsncHJvZ3Jlc3MnXSxcbiAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAobm9kZSwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuaXNNZWRpYU5vZGUoKSAmJlxuICAgICAgICAgICAgICAgIG5hbWUgPT09ICdidWZmZXJlZCc7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgICAgZXZlbnROYW1lczogWydsb2FkZWRtZXRhZGF0YSddLFxuICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uIChub2RlLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5pc01lZGlhTm9kZSgpICYmXG4gICAgICAgICAgICAgICAgKG5hbWUgPT09ICdidWZmZXJlZCcgfHwgbmFtZSA9PT0gJ3NlZWthYmxlJyk7XG4gICAgICAgIH1cbiAgICB9XG5dO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkNztcbnZhciB0ZW1wbGF0ZU9iamVjdF8yJDc7XG52YXIgdGVtcGxhdGVPYmplY3RfMyQ3O1xudmFyIHRlbXBsYXRlT2JqZWN0XzQkNztcbnZhciB0ZW1wbGF0ZU9iamVjdF81JDU7XG52YXIgdGVtcGxhdGVPYmplY3RfNiQ1O1xudmFyIHRlbXBsYXRlT2JqZWN0XzgkNDtcbnZhciB0ZW1wbGF0ZU9iamVjdF83JDQ7XG52YXIgdGVtcGxhdGVPYmplY3RfOSQzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEwJDM7XG52YXIgdGVtcGxhdGVPYmplY3RfMTEkMztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMiQzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEzJDM7XG5cbnZhciBFbHNlQmxvY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEVsc2VCbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbHNlQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEVsc2VCbG9jaztcbn0oTm9kZSQxKSk7XG5cbnZhciBFdmVudEhhbmRsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEV2ZW50SGFuZGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVudEhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50SGFuZGxlcjtcbn0oTm9kZSQxKSk7XG5cbnZhciBCbG9jayQyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJsb2NrKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IgPSBvcHRpb25zLmdlbmVyYXRvcjtcbiAgICAgICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb24gPSBvcHRpb25zLmV4cHJlc3Npb247XG4gICAgICAgIHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgdGhpcy5kZXN0cnVjdHVyZWRDb250ZXh0cyA9IG9wdGlvbnMuZGVzdHJ1Y3R1cmVkQ29udGV4dHM7XG4gICAgICAgIHRoaXMuY29tbWVudCA9IG9wdGlvbnMuY29tbWVudDtcbiAgICAgICAgLy8gZm9yIGtleWVkIGVhY2ggYmxvY2tzXG4gICAgICAgIHRoaXMua2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgICAgIHRoaXMuZmlyc3QgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbnRleHRzID0gb3B0aW9ucy5jb250ZXh0cztcbiAgICAgICAgdGhpcy5pbmRleGVzID0gb3B0aW9ucy5pbmRleGVzO1xuICAgICAgICB0aGlzLmNoYW5nZWFibGVJbmRleGVzID0gb3B0aW9ucy5jaGFuZ2VhYmxlSW5kZXhlcztcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG4gICAgICAgIHRoaXMuaW5kZXhOYW1lcyA9IG9wdGlvbnMuaW5kZXhOYW1lcztcbiAgICAgICAgdGhpcy5saXN0TmFtZXMgPSBvcHRpb25zLmxpc3ROYW1lcztcbiAgICAgICAgdGhpcy5saXN0TmFtZSA9IG9wdGlvbnMubGlzdE5hbWU7XG4gICAgICAgIHRoaXMuYnVpbGRlcnMgPSB7XG4gICAgICAgICAgICBpbml0OiBuZXcgQ29kZUJ1aWxkZXIoKSxcbiAgICAgICAgICAgIGNyZWF0ZTogbmV3IENvZGVCdWlsZGVyKCksXG4gICAgICAgICAgICBjbGFpbTogbmV3IENvZGVCdWlsZGVyKCksXG4gICAgICAgICAgICBoeWRyYXRlOiBuZXcgQ29kZUJ1aWxkZXIoKSxcbiAgICAgICAgICAgIG1vdW50OiBuZXcgQ29kZUJ1aWxkZXIoKSxcbiAgICAgICAgICAgIGludHJvOiBuZXcgQ29kZUJ1aWxkZXIoKSxcbiAgICAgICAgICAgIHVwZGF0ZTogbmV3IENvZGVCdWlsZGVyKCksXG4gICAgICAgICAgICBvdXRybzogbmV3IENvZGVCdWlsZGVyKCksXG4gICAgICAgICAgICB1bm1vdW50OiBuZXcgQ29kZUJ1aWxkZXIoKSxcbiAgICAgICAgICAgIGRldGFjaFJhdzogbmV3IENvZGVCdWlsZGVyKCksXG4gICAgICAgICAgICBkZXN0cm95OiBuZXcgQ29kZUJ1aWxkZXIoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhc0ludHJvTWV0aG9kID0gZmFsc2U7IC8vIGEgYmxvY2sgY291bGQgaGF2ZSBhbiBpbnRybyBtZXRob2QgYnV0IG5vdCBpbnRybyB0cmFuc2l0aW9ucywgZS5nLiBpZiBhIHNpYmxpbmcgYmxvY2sgaGFzIGludHJvc1xuICAgICAgICB0aGlzLmhhc091dHJvTWV0aG9kID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3V0cm9zID0gMDtcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5nZXRVbmlxdWVOYW1lID0gdGhpcy5nZW5lcmF0b3IuZ2V0VW5pcXVlTmFtZU1ha2VyKG9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgdGhpcy5oYXNVcGRhdGVNZXRob2QgPSBmYWxzZTsgLy8gZGV0ZXJtaW5lZCBsYXRlclxuICAgIH1cbiAgICBCbG9jay5wcm90b3R5cGUuYWRkRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKGRlcGVuZGVuY2llcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBkZXBlbmRlbmNpZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwZW5kZW5jeSkge1xuICAgICAgICAgICAgX3RoaXMuZGVwZW5kZW5jaWVzLmFkZChkZXBlbmRlbmN5KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCbG9jay5wcm90b3R5cGUuYWRkRWxlbWVudCA9IGZ1bmN0aW9uIChuYW1lLCByZW5kZXJTdGF0ZW1lbnQsIGNsYWltU3RhdGVtZW50LCBwYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuYWRkVmFyaWFibGUobmFtZSk7XG4gICAgICAgIHRoaXMuYnVpbGRlcnMuY3JlYXRlLmFkZExpbmUobmFtZSArIFwiID0gXCIgKyByZW5kZXJTdGF0ZW1lbnQgKyBcIjtcIik7XG4gICAgICAgIHRoaXMuYnVpbGRlcnMuY2xhaW0uYWRkTGluZShuYW1lICsgXCIgPSBcIiArIChjbGFpbVN0YXRlbWVudCB8fCByZW5kZXJTdGF0ZW1lbnQpICsgXCI7XCIpO1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5idWlsZGVycy5tb3VudC5hZGRMaW5lKFwiQGFwcGVuZE5vZGUoXCIgKyBuYW1lICsgXCIsIFwiICsgcGFyZW50Tm9kZSArIFwiKTtcIik7XG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSA9PT0gJ2RvY3VtZW50LmhlYWQnKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRlcnMudW5tb3VudC5hZGRMaW5lKFwiQGRldGFjaE5vZGUoXCIgKyBuYW1lICsgXCIpO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlcnMubW91bnQuYWRkTGluZShcIkBpbnNlcnROb2RlKFwiICsgbmFtZSArIFwiLCAjdGFyZ2V0LCBhbmNob3IpO1wiKTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlcnMudW5tb3VudC5hZGRMaW5lKFwiQGRldGFjaE5vZGUoXCIgKyBuYW1lICsgXCIpO1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmxvY2sucHJvdG90eXBlLmFkZFZhcmlhYmxlID0gZnVuY3Rpb24gKG5hbWUsIGluaXQpIHtcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVzLmhhcyhuYW1lKSAmJiB0aGlzLnZhcmlhYmxlcy5nZXQobmFtZSkgIT09IGluaXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlICdcIiArIG5hbWUgKyBcIicgYWxyZWFkeSBpbml0aWFsaXNlZCB3aXRoIGEgZGlmZmVyZW50IHZhbHVlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFyaWFibGVzLnNldChuYW1lLCBpbml0KTtcbiAgICB9O1xuICAgIEJsb2NrLnByb3RvdHlwZS5hbGlhcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGlhc2VzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5hbGlhc2VzLnNldChuYW1lLCB0aGlzLmdldFVuaXF1ZU5hbWUobmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFsaWFzZXMuZ2V0KG5hbWUpO1xuICAgIH07XG4gICAgQmxvY2sucHJvdG90eXBlLmNoaWxkID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9jayhPYmplY3QuYXNzaWduKHt9LCB0aGlzLCBvcHRpb25zLCB7IHBhcmVudDogdGhpcyB9KSk7XG4gICAgfTtcbiAgICBCbG9jay5wcm90b3R5cGUuY29udGV4dHVhbGlzZSA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBjb250ZXh0LCBpc0V2ZW50SGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmF0b3IuY29udGV4dHVhbGlzZSh0aGlzLmNvbnRleHRzLCB0aGlzLmluZGV4ZXMsIGV4cHJlc3Npb24sIGNvbnRleHQsIGlzRXZlbnRIYW5kbGVyKTtcbiAgICB9O1xuICAgIEJsb2NrLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGludHJvaW5nO1xuICAgICAgICB2YXIgaGFzSW50cm9zID0gIXRoaXMuYnVpbGRlcnMuaW50cm8uaXNFbXB0eSgpO1xuICAgICAgICBpZiAoaGFzSW50cm9zKSB7XG4gICAgICAgICAgICBpbnRyb2luZyA9IHRoaXMuZ2V0VW5pcXVlTmFtZSgnaW50cm9pbmcnKTtcbiAgICAgICAgICAgIHRoaXMuYWRkVmFyaWFibGUoaW50cm9pbmcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXRyb2luZztcbiAgICAgICAgdmFyIGhhc091dHJvcyA9ICF0aGlzLmJ1aWxkZXJzLm91dHJvLmlzRW1wdHkoKTtcbiAgICAgICAgaWYgKGhhc091dHJvcykge1xuICAgICAgICAgICAgb3V0cm9pbmcgPSB0aGlzLmFsaWFzKCdvdXRyb2luZycpO1xuICAgICAgICAgICAgdGhpcy5hZGRWYXJpYWJsZShvdXRyb2luZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0b2ZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkZXJzLm1vdW50LmFkZExpbmUodGhpcy5hdXRvZm9jdXMgKyBcIi5mb2N1cygpO1wiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtaW5vciBoYWNrIOKAkyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IGFueSB7e3t0cmlwbGVzfX19IGFyZSBkZXRhY2hlZCBmaXJzdFxuICAgICAgICB0aGlzLmJ1aWxkZXJzLnVubW91bnQuYWRkQmxvY2tBdFN0YXJ0KHRoaXMuYnVpbGRlcnMuZGV0YWNoUmF3LnRvU3RyaW5nKCkpO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IG5ldyBDb2RlQnVpbGRlcigpO1xuICAgICAgICB2YXIgbG9jYWxLZXk7XG4gICAgICAgIGlmICh0aGlzLmtleSkge1xuICAgICAgICAgICAgbG9jYWxLZXkgPSB0aGlzLmdldFVuaXF1ZU5hbWUoJ2tleScpO1xuICAgICAgICAgICAgcHJvcGVydGllcy5hZGRCbG9jayhcImtleTogXCIgKyBsb2NhbEtleSArIFwiLFwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maXJzdCkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5hZGRCbG9jayhcImZpcnN0OiBudWxsLFwiKTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRlcnMuaHlkcmF0ZS5hZGRMaW5lKFwidGhpcy5maXJzdCA9IFwiICsgdGhpcy5maXJzdCArIFwiO1wiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5idWlsZGVycy5jcmVhdGUuaXNFbXB0eSgpICYmIHRoaXMuYnVpbGRlcnMuaHlkcmF0ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuYWRkQmxvY2soXCJjOiBAbm9vcCxcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkOCB8fCAodGVtcGxhdGVPYmplY3RfMSQ4ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0YzogZnVuY3Rpb24gY3JlYXRlKCkge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRjOiBmdW5jdGlvbiBjcmVhdGUoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcIl0pKSwgdGhpcy5idWlsZGVycy5jcmVhdGUsICF0aGlzLmJ1aWxkZXJzLmh5ZHJhdGUuaXNFbXB0eSgpICYmIFwidGhpcy5oKCk7XCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5nZW5lcmF0b3IuaHlkcmF0YWJsZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYnVpbGRlcnMuY2xhaW0uaXNFbXB0eSgpICYmIHRoaXMuYnVpbGRlcnMuaHlkcmF0ZS5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmFkZEJsb2NrKFwibDogQG5vb3AsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yJDggfHwgKHRlbXBsYXRlT2JqZWN0XzIkOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdGw6IGZ1bmN0aW9uIGNsYWltKG5vZGVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdGw6IGZ1bmN0aW9uIGNsYWltKG5vZGVzKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcIl0pKSwgdGhpcy5idWlsZGVycy5jbGFpbSwgIXRoaXMuYnVpbGRlcnMuaHlkcmF0ZS5pc0VtcHR5KCkgJiYgXCJ0aGlzLmgoKTtcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5idWlsZGVycy5oeWRyYXRlLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcHJvcGVydGllcy5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8zJDggfHwgKHRlbXBsYXRlT2JqZWN0XzMkOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGg6IGZ1bmN0aW9uIGh5ZHJhdGUoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGg6IGZ1bmN0aW9uIGh5ZHJhdGUoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcIl0pKSwgdGhpcy5idWlsZGVycy5oeWRyYXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVpbGRlcnMubW91bnQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmFkZEJsb2NrKFwibTogQG5vb3AsXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvcGVydGllcy5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF80JDggfHwgKHRlbXBsYXRlT2JqZWN0XzQkOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdG06IGZ1bmN0aW9uIG1vdW50KCN0YXJnZXQsIGFuY2hvcikge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRtOiBmdW5jdGlvbiBtb3VudCgjdGFyZ2V0LCBhbmNob3IpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFwiXSkpLCB0aGlzLmJ1aWxkZXJzLm1vdW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaGFzVXBkYXRlTWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5idWlsZGVycy51cGRhdGUuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5hZGRCbG9jayhcInA6IEBub29wLFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNSQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF81JDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRwOiBmdW5jdGlvbiB1cGRhdGUoY2hhbmdlZCwgXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdHA6IGZ1bmN0aW9uIHVwZGF0ZShjaGFuZ2VkLCBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFwiXSkpLCB0aGlzLnBhcmFtcy5qb2luKCcsICcpLCB0aGlzLmJ1aWxkZXJzLnVwZGF0ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc0ludHJvTWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAoaGFzSW50cm9zKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF82JDYgfHwgKHRlbXBsYXRlT2JqZWN0XzYkNiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdGk6IGZ1bmN0aW9uIGludHJvKCN0YXJnZXQsIGFuY2hvcikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubSgjdGFyZ2V0LCBhbmNob3IpO1xcblxcdFxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRpOiBmdW5jdGlvbiBpbnRybygjdGFyZ2V0LCBhbmNob3IpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSByZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm0oI3RhcmdldCwgYW5jaG9yKTtcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFwiXSkpLCBpbnRyb2luZywgaW50cm9pbmcsIGhhc091dHJvcyAmJiBvdXRyb2luZyArIFwiID0gZmFsc2U7XCIsIHRoaXMuYnVpbGRlcnMuaW50cm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNyQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF83JDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRpOiBmdW5jdGlvbiBpbnRybygjdGFyZ2V0LCBhbmNob3IpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm0oI3RhcmdldCwgYW5jaG9yKTtcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0aTogZnVuY3Rpb24gaW50cm8oI3RhcmdldCwgYW5jaG9yKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tKCN0YXJnZXQsIGFuY2hvcik7XFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcIl0pKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmhhc091dHJvTWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3V0cm9zKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF84JDUgfHwgKHRlbXBsYXRlT2JqZWN0XzgkNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdG86IGZ1bmN0aW9uIG91dHJvKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdG86IGZ1bmN0aW9uIG91dHJvKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRcIl0pKSwgdGhpcy5hbGlhcygnb3V0cm9jYWxsYmFjaycpLCBvdXRyb2luZywgb3V0cm9pbmcsIGhhc0ludHJvcyAmJiBpbnRyb2luZyArIFwiID0gZmFsc2U7XCIsIHRoaXMuYWxpYXMoJ291dHJvcycpLCB0aGlzLm91dHJvcywgdGhpcy5idWlsZGVycy5vdXRybykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSBhIGhlbHBlcj9cbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzkkNCB8fCAodGVtcGxhdGVPYmplY3RfOSQ0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0bzogZnVuY3Rpb24gb3V0cm8ob3V0cm9jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG91dHJvY2FsbGJhY2soKTtcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0bzogZnVuY3Rpb24gb3V0cm8ob3V0cm9jYWxsYmFjaykge1xcblxcdFxcdFxcdFxcdFxcdFxcdG91dHJvY2FsbGJhY2soKTtcXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFwiXSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYnVpbGRlcnMudW5tb3VudC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuYWRkQmxvY2soXCJ1OiBAbm9vcCxcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEwJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzEwJDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHR1OiBmdW5jdGlvbiB1bm1vdW50KCkge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHR1OiBmdW5jdGlvbiB1bm1vdW50KCkge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XCJdKSksIHRoaXMuYnVpbGRlcnMudW5tb3VudCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1aWxkZXJzLmRlc3Ryb3kuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmFkZEJsb2NrKFwiZDogQG5vb3BcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzExJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzExJDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRkOiBmdW5jdGlvbiBkZXN0cm95KCkge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGQ6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCB0aGlzLmJ1aWxkZXJzLmRlc3Ryb3kpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTIkNCB8fCAodGVtcGxhdGVPYmplY3RfMTIkNCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihcIiwgXCIsICNjb21wb25lbnRcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFwiLFxuICAgICAgICAgICAgXCJcXG5cXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSkpLCB0aGlzLmNvbW1lbnQgJiYgXCIvLyBcIiArIGVzY2FwZSh0aGlzLmNvbW1lbnQpLCB0aGlzLm5hbWUsIHRoaXMucGFyYW1zLmpvaW4oJywgJyksIHRoaXMua2V5ID8gXCIsIFwiICsgbG9jYWxLZXkgOiAnJywgdGhpcy52YXJpYWJsZXMuc2l6ZSA+IDAgJiZcbiAgICAgICAgICAgIFwidmFyIFwiICsgQXJyYXkuZnJvbSh0aGlzLnZhcmlhYmxlcy5rZXlzKCkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGluaXQgPSBfdGhpcy52YXJpYWJsZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluaXQgIT09IHVuZGVmaW5lZCA/IGtleSArIFwiID0gXCIgKyBpbml0IDoga2V5O1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKSArIFwiO1wiLCAhdGhpcy5idWlsZGVycy5pbml0LmlzRW1wdHkoKSAmJiB0aGlzLmJ1aWxkZXJzLmluaXQsIHByb3BlcnRpZXMpLnJlcGxhY2UoLygjKykoXFx3KikvZywgZnVuY3Rpb24gKG1hdGNoLCBzaWdpbCwgbmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNpZ2lsID09PSAnIycgPyBfdGhpcy5hbGlhcyhuYW1lKSA6IHNpZ2lsLnNsaWNlKDEpICsgbmFtZTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2s7XG59KCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkODtcbnZhciB0ZW1wbGF0ZU9iamVjdF8yJDg7XG52YXIgdGVtcGxhdGVPYmplY3RfMyQ4O1xudmFyIHRlbXBsYXRlT2JqZWN0XzQkODtcbnZhciB0ZW1wbGF0ZU9iamVjdF81JDY7XG52YXIgdGVtcGxhdGVPYmplY3RfNiQ2O1xudmFyIHRlbXBsYXRlT2JqZWN0XzckNTtcbnZhciB0ZW1wbGF0ZU9iamVjdF84JDU7XG52YXIgdGVtcGxhdGVPYmplY3RfOSQ0O1xudmFyIHRlbXBsYXRlT2JqZWN0XzEwJDQ7XG52YXIgdGVtcGxhdGVPYmplY3RfMTEkNDtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMiQ0O1xuXG52YXIgRnJhZ21lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZyYWdtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZyYWdtZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEZyYWdtZW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJsb2NrID0gbmV3IEJsb2NrJDIoe1xuICAgICAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLmdlbmVyYXRvcixcbiAgICAgICAgICAgIG5hbWU6ICdAY3JlYXRlX21haW5fZnJhZ21lbnQnLFxuICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgY29udGV4dHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGluZGV4ZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGNoYW5nZWFibGVJbmRleGVzOiBuZXcgTWFwKCksXG4gICAgICAgICAgICBwYXJhbXM6IFsnc3RhdGUnXSxcbiAgICAgICAgICAgIGluZGV4TmFtZXM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGxpc3ROYW1lczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBuZXcgU2V0KClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2VuZXJhdG9yLmJsb2Nrcy5wdXNoKHRoaXMuYmxvY2spO1xuICAgICAgICB0aGlzLmluaXRDaGlsZHJlbih0aGlzLmJsb2NrLCB0cnVlLCBudWxsKTtcbiAgICAgICAgdGhpcy5ibG9jay5oYXNVcGRhdGVNZXRob2QgPSB0cnVlO1xuICAgIH07XG4gICAgRnJhZ21lbnQucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQuYnVpbGQoX3RoaXMuYmxvY2ssIG51bGwsICdub2RlcycpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBGcmFnbWVudDtcbn0oTm9kZSQxKSk7XG5cbnZhciBIZWFkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIZWFkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhlYWQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgSGVhZC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChibG9jaywgc3RyaXBXaGl0ZXNwYWNlLCBuZXh0U2libGluZykge1xuICAgICAgICB0aGlzLmluaXRDaGlsZHJlbihibG9jaywgdHJ1ZSwgbnVsbCk7XG4gICAgfTtcbiAgICBIZWFkLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IHRoaXMuZ2VuZXJhdG9yO1xuICAgICAgICB0aGlzW1widmFyXCJdID0gJ2RvY3VtZW50LmhlYWQnO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5idWlsZChibG9jaywgJ2RvY3VtZW50LmhlYWQnLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSGVhZDtcbn0oTm9kZSQxKSk7XG5cbmZ1bmN0aW9uIGlzRWxzZUlmKG5vZGUpIHtcbiAgICByZXR1cm4gKG5vZGUgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAnSWZCbG9jaycpO1xufVxuZnVuY3Rpb24gaXNFbHNlQnJhbmNoKGJyYW5jaCkge1xuICAgIHJldHVybiBicmFuY2guYmxvY2sgJiYgIWJyYW5jaC5jb25kaXRpb247XG59XG52YXIgSWZCbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSWZCbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJZkJsb2NrKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIElmQmxvY2sucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYmxvY2ssIHN0cmlwV2hpdGVzcGFjZSwgbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdmFyIGdlbmVyYXRvciA9IHRoaXMuZ2VuZXJhdG9yO1xuICAgICAgICB0aGlzLmNhbm5vdFVzZUlubmVySFRNTCgpO1xuICAgICAgICB2YXIgYmxvY2tzID0gW107XG4gICAgICAgIHZhciBkeW5hbWljID0gZmFsc2U7XG4gICAgICAgIHZhciBoYXNJbnRyb3MgPSBmYWxzZTtcbiAgICAgICAgdmFyIGhhc091dHJvcyA9IGZhbHNlO1xuICAgICAgICBmdW5jdGlvbiBhdHRhY2hCbG9ja3Mobm9kZSkge1xuICAgICAgICAgICAgbm9kZVtcInZhclwiXSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoXCJpZl9ibG9ja1wiKTtcbiAgICAgICAgICAgIGJsb2NrLmFkZERlcGVuZGVuY2llcyhub2RlLm1ldGFkYXRhLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICBub2RlLmJsb2NrID0gYmxvY2suY2hpbGQoe1xuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IGNyZWF0ZURlYnVnZ2luZ0NvbW1lbnQobm9kZSwgZ2VuZXJhdG9yKSxcbiAgICAgICAgICAgICAgICBuYW1lOiBnZW5lcmF0b3IuZ2V0VW5pcXVlTmFtZShcImNyZWF0ZV9pZl9ibG9ja1wiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBibG9ja3MucHVzaChub2RlLmJsb2NrKTtcbiAgICAgICAgICAgIG5vZGUuaW5pdENoaWxkcmVuKG5vZGUuYmxvY2ssIHN0cmlwV2hpdGVzcGFjZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKG5vZGUuYmxvY2suZGVwZW5kZW5jaWVzLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYmxvY2suYWRkRGVwZW5kZW5jaWVzKG5vZGUuYmxvY2suZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmJsb2NrLmhhc0ludHJvTWV0aG9kKVxuICAgICAgICAgICAgICAgIGhhc0ludHJvcyA9IHRydWU7XG4gICAgICAgICAgICBpZiAobm9kZS5ibG9jay5oYXNPdXRyb01ldGhvZClcbiAgICAgICAgICAgICAgICBoYXNPdXRyb3MgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGlzRWxzZUlmKG5vZGVbXCJlbHNlXCJdKSkge1xuICAgICAgICAgICAgICAgIGF0dGFjaEJsb2Nrcyhub2RlW1wiZWxzZVwiXS5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlW1wiZWxzZVwiXSkge1xuICAgICAgICAgICAgICAgIG5vZGVbXCJlbHNlXCJdLmJsb2NrID0gYmxvY2suY2hpbGQoe1xuICAgICAgICAgICAgICAgICAgICBjb21tZW50OiBjcmVhdGVEZWJ1Z2dpbmdDb21tZW50KG5vZGVbXCJlbHNlXCJdLCBnZW5lcmF0b3IpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZW5lcmF0b3IuZ2V0VW5pcXVlTmFtZShcImNyZWF0ZV9pZl9ibG9ja1wiKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKG5vZGVbXCJlbHNlXCJdLmJsb2NrKTtcbiAgICAgICAgICAgICAgICBub2RlW1wiZWxzZVwiXS5pbml0Q2hpbGRyZW4obm9kZVtcImVsc2VcIl0uYmxvY2ssIHN0cmlwV2hpdGVzcGFjZSwgbmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlW1wiZWxzZVwiXS5ibG9jay5kZXBlbmRlbmNpZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZHluYW1pYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmFkZERlcGVuZGVuY2llcyhub2RlW1wiZWxzZVwiXS5ibG9jay5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhdHRhY2hCbG9ja3ModGhpcyk7XG4gICAgICAgIGJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgYmxvY2suaGFzVXBkYXRlTWV0aG9kID0gZHluYW1pYztcbiAgICAgICAgICAgIGJsb2NrLmhhc0ludHJvTWV0aG9kID0gaGFzSW50cm9zO1xuICAgICAgICAgICAgYmxvY2suaGFzT3V0cm9NZXRob2QgPSBoYXNPdXRyb3M7XG4gICAgICAgIH0pO1xuICAgICAgICAoX2EgPSBnZW5lcmF0b3IuYmxvY2tzKS5wdXNoLmFwcGx5KF9hLCBibG9ja3MpO1xuICAgICAgICB2YXIgX2E7XG4gICAgfTtcbiAgICBJZkJsb2NrLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgdmFyIG5hbWUgPSB0aGlzW1widmFyXCJdO1xuICAgICAgICB2YXIgbmVlZHNBbmNob3IgPSB0aGlzLm5leHQgPyAhdGhpcy5uZXh0LmlzRG9tTm9kZSgpIDogIXBhcmVudE5vZGUgfHwgIXRoaXMucGFyZW50LmlzRG9tTm9kZSgpO1xuICAgICAgICB2YXIgYW5jaG9yID0gbmVlZHNBbmNob3JcbiAgICAgICAgICAgID8gYmxvY2suZ2V0VW5pcXVlTmFtZShuYW1lICsgXCJfYW5jaG9yXCIpXG4gICAgICAgICAgICA6ICh0aGlzLm5leHQgJiYgdGhpcy5uZXh0W1widmFyXCJdKSB8fCAnbnVsbCc7XG4gICAgICAgIHZhciBwYXJhbXMgPSBibG9jay5wYXJhbXMuam9pbignLCAnKTtcbiAgICAgICAgdmFyIGJyYW5jaGVzID0gZ2V0QnJhbmNoZXModGhpcy5nZW5lcmF0b3IsIGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2RlcywgdGhpcyk7XG4gICAgICAgIHZhciBoYXNFbHNlID0gaXNFbHNlQnJhbmNoKGJyYW5jaGVzW2JyYW5jaGVzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgdmFyIGlmX25hbWUgPSBoYXNFbHNlID8gJycgOiBcImlmIChcIiArIG5hbWUgKyBcIikgXCI7XG4gICAgICAgIHZhciBkeW5hbWljID0gYnJhbmNoZXNbMF0uaGFzVXBkYXRlTWV0aG9kOyAvLyBjYW4gdXNlIFswXSBhcyBwcm94eSBmb3IgYWxsLCBzaW5jZSB0aGV5IG5lY2Vzc2FyaWx5IGhhdmUgdGhlIHNhbWUgdmFsdWVcbiAgICAgICAgdmFyIGhhc091dHJvcyA9IGJyYW5jaGVzWzBdLmhhc091dHJvTWV0aG9kO1xuICAgICAgICB2YXIgdmFycyA9IHsgbmFtZTogbmFtZSwgYW5jaG9yOiBhbmNob3IsIHBhcmFtczogcGFyYW1zLCBpZl9uYW1lOiBpZl9uYW1lLCBoYXNFbHNlOiBoYXNFbHNlIH07XG4gICAgICAgIGlmICh0aGlzW1wiZWxzZVwiXSkge1xuICAgICAgICAgICAgaWYgKGhhc091dHJvcykge1xuICAgICAgICAgICAgICAgIGNvbXBvdW5kV2l0aE91dHJvcyh0aGlzLmdlbmVyYXRvciwgYmxvY2ssIHBhcmVudE5vZGUsIHBhcmVudE5vZGVzLCB0aGlzLCBicmFuY2hlcywgZHluYW1pYywgdmFycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb21wb3VuZCh0aGlzLmdlbmVyYXRvciwgYmxvY2ssIHBhcmVudE5vZGUsIHBhcmVudE5vZGVzLCB0aGlzLCBicmFuY2hlcywgZHluYW1pYywgdmFycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaW1wbGUodGhpcy5nZW5lcmF0b3IsIGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2RlcywgdGhpcywgYnJhbmNoZXNbMF0sIGR5bmFtaWMsIHZhcnMpO1xuICAgICAgICB9XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNyZWF0ZS5hZGRMaW5lKFwiXCIgKyBpZl9uYW1lICsgbmFtZSArIFwiLmMoKTtcIik7XG4gICAgICAgIGlmIChwYXJlbnROb2Rlcykge1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuY2xhaW0uYWRkTGluZShcIlwiICsgaWZfbmFtZSArIG5hbWUgKyBcIi5sKFwiICsgcGFyZW50Tm9kZXMgKyBcIik7XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc0FuY2hvcikge1xuICAgICAgICAgICAgYmxvY2suYWRkRWxlbWVudChhbmNob3IsIFwiQGNyZWF0ZUNvbW1lbnQoKVwiLCBwYXJlbnROb2RlcyAmJiBcIkBjcmVhdGVDb21tZW50KClcIiwgcGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBJZkJsb2NrO1xufShOb2RlJDEpKTtcbi8vIFRPRE8gbW92ZSBhbGwgdGhpcyBpbnRvIHRoZSBjbGFzc1xuZnVuY3Rpb24gZ2V0QnJhbmNoZXMoZ2VuZXJhdG9yLCBibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMsIG5vZGUpIHtcbiAgICBibG9jay5jb250ZXh0dWFsaXNlKG5vZGUuZXhwcmVzc2lvbik7IC8vIFRPRE8gcmVtb3ZlXG4gICAgdmFyIGJyYW5jaGVzID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICBjb25kaXRpb246IG5vZGUubWV0YWRhdGEuc25pcHBldCxcbiAgICAgICAgICAgIGJsb2NrOiBub2RlLmJsb2NrLm5hbWUsXG4gICAgICAgICAgICBoYXNVcGRhdGVNZXRob2Q6IG5vZGUuYmxvY2suaGFzVXBkYXRlTWV0aG9kLFxuICAgICAgICAgICAgaGFzSW50cm9NZXRob2Q6IG5vZGUuYmxvY2suaGFzSW50cm9NZXRob2QsXG4gICAgICAgICAgICBoYXNPdXRyb01ldGhvZDogbm9kZS5ibG9jay5oYXNPdXRyb01ldGhvZFxuICAgICAgICB9LFxuICAgIF07XG4gICAgdmlzaXRDaGlsZHJlbihnZW5lcmF0b3IsIGJsb2NrLCBub2RlKTtcbiAgICBpZiAoaXNFbHNlSWYobm9kZVtcImVsc2VcIl0pKSB7XG4gICAgICAgIGJyYW5jaGVzLnB1c2guYXBwbHkoYnJhbmNoZXMsIGdldEJyYW5jaGVzKGdlbmVyYXRvciwgYmxvY2ssIHBhcmVudE5vZGUsIHBhcmVudE5vZGVzLCBub2RlW1wiZWxzZVwiXS5jaGlsZHJlblswXSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYnJhbmNoZXMucHVzaCh7XG4gICAgICAgICAgICBjb25kaXRpb246IG51bGwsXG4gICAgICAgICAgICBibG9jazogbm9kZVtcImVsc2VcIl0gPyBub2RlW1wiZWxzZVwiXS5ibG9jay5uYW1lIDogbnVsbCxcbiAgICAgICAgICAgIGhhc1VwZGF0ZU1ldGhvZDogbm9kZVtcImVsc2VcIl0gPyBub2RlW1wiZWxzZVwiXS5ibG9jay5oYXNVcGRhdGVNZXRob2QgOiBmYWxzZSxcbiAgICAgICAgICAgIGhhc0ludHJvTWV0aG9kOiBub2RlW1wiZWxzZVwiXSA/IG5vZGVbXCJlbHNlXCJdLmJsb2NrLmhhc0ludHJvTWV0aG9kIDogZmFsc2UsXG4gICAgICAgICAgICBoYXNPdXRyb01ldGhvZDogbm9kZVtcImVsc2VcIl0gPyBub2RlW1wiZWxzZVwiXS5ibG9jay5oYXNPdXRyb01ldGhvZCA6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9kZVtcImVsc2VcIl0pIHtcbiAgICAgICAgICAgIHZpc2l0Q2hpbGRyZW4oZ2VuZXJhdG9yLCBibG9jaywgbm9kZVtcImVsc2VcIl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBicmFuY2hlcztcbn1cbmZ1bmN0aW9uIHZpc2l0Q2hpbGRyZW4oZ2VuZXJhdG9yLCBibG9jaywgbm9kZSkge1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuYnVpbGQobm9kZS5ibG9jaywgbnVsbCwgJ25vZGVzJyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzaW1wbGUoZ2VuZXJhdG9yLCBibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMsIG5vZGUsIGJyYW5jaCwgZHluYW1pYywgX2EpIHtcbiAgICB2YXIgbmFtZSA9IF9hLm5hbWUsIGFuY2hvciA9IF9hLmFuY2hvciwgcGFyYW1zID0gX2EucGFyYW1zLCBpZl9uYW1lID0gX2EuaWZfbmFtZTtcbiAgICBibG9jay5idWlsZGVycy5pbml0LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkOSB8fCAodGVtcGxhdGVPYmplY3RfMSQ5ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0dmFyIFwiLCBcIiA9IChcIiwgXCIpICYmIFwiLCBcIihcIiwgXCIsICNjb21wb25lbnQpO1xcblxcdFwiXSwgW1wiXFxuXFx0XFx0dmFyIFwiLCBcIiA9IChcIiwgXCIpICYmIFwiLCBcIihcIiwgXCIsICNjb21wb25lbnQpO1xcblxcdFwiXSkpLCBuYW1lLCBicmFuY2guY29uZGl0aW9uLCBicmFuY2guYmxvY2ssIHBhcmFtcykpO1xuICAgIHZhciBtb3VudE9ySW50cm8gPSBicmFuY2guaGFzSW50cm9NZXRob2QgPyAnaScgOiAnbSc7XG4gICAgdmFyIGluaXRpYWxNb3VudE5vZGUgPSBwYXJlbnROb2RlIHx8ICcjdGFyZ2V0JztcbiAgICB2YXIgYW5jaG9yTm9kZSA9IHBhcmVudE5vZGUgPyAnbnVsbCcgOiAnYW5jaG9yJztcbiAgICBibG9jay5idWlsZGVycy5tb3VudC5hZGRMaW5lKFwiaWYgKFwiICsgbmFtZSArIFwiKSBcIiArIG5hbWUgKyBcIi5cIiArIG1vdW50T3JJbnRybyArIFwiKFwiICsgaW5pdGlhbE1vdW50Tm9kZSArIFwiLCBcIiArIGFuY2hvck5vZGUgKyBcIik7XCIpO1xuICAgIHZhciB1cGRhdGVNb3VudE5vZGUgPSBub2RlLmdldFVwZGF0ZU1vdW50Tm9kZShhbmNob3IpO1xuICAgIHZhciBlbnRlciA9IGR5bmFtaWNcbiAgICAgICAgPyBicmFuY2guaGFzSW50cm9NZXRob2RcbiAgICAgICAgICAgID8gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMiQ5IHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDkgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLnAoY2hhbmdlZCwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIihcIiwgXCIsICNjb21wb25lbnQpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIFwiLCBcIi5jKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFwiLCBcIi5pKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIucChjaGFuZ2VkLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikgXCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XCIsIFwiLmkoXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFwiXSkpLCBuYW1lLCBuYW1lLCBwYXJhbXMsIG5hbWUsIGJyYW5jaC5ibG9jaywgcGFyYW1zLCBuYW1lLCBuYW1lLCBuYW1lLCB1cGRhdGVNb3VudE5vZGUsIGFuY2hvcikgOiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8zJDkgfHwgKHRlbXBsYXRlT2JqZWN0XzMkOSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIucChjaGFuZ2VkLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIubShcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5wKGNoYW5nZWQsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIoXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5tKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIG5hbWUsIG5hbWUsIHBhcmFtcywgbmFtZSwgYnJhbmNoLmJsb2NrLCBwYXJhbXMsIG5hbWUsIG5hbWUsIHVwZGF0ZU1vdW50Tm9kZSwgYW5jaG9yKVxuICAgICAgICA6IGJyYW5jaC5oYXNJbnRyb01ldGhvZFxuICAgICAgICAgICAgPyBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF80JDkgfHwgKHRlbXBsYXRlT2JqZWN0XzQkOSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGlmICghXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XCIsIFwiLmkoXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0aWYgKCFcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIoXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcIiwgXCIuaShcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XCJdKSksIG5hbWUsIG5hbWUsIGJyYW5jaC5ibG9jaywgcGFyYW1zLCBuYW1lLCBuYW1lLCB1cGRhdGVNb3VudE5vZGUsIGFuY2hvcikgOiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF81JDcgfHwgKHRlbXBsYXRlT2JqZWN0XzUkNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGlmICghXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIubShcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0aWYgKCFcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIoXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5tKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIG5hbWUsIG5hbWUsIGJyYW5jaC5ibG9jaywgcGFyYW1zLCBuYW1lLCBuYW1lLCB1cGRhdGVNb3VudE5vZGUsIGFuY2hvcik7XG4gICAgLy8gbm8gYHAoKWAgaGVyZSDigJQgd2UgZG9uJ3Qgd2FudCB0byB1cGRhdGUgb3V0cm9pbmcgbm9kZXMsXG4gICAgLy8gYXMgdGhhdCB3aWxsIHR5cGljYWxseSByZXN1bHQgaW4gZ2xpdGNoaW5nXG4gICAgdmFyIGV4aXQgPSBicmFuY2guaGFzT3V0cm9NZXRob2RcbiAgICAgICAgPyBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF82JDcgfHwgKHRlbXBsYXRlT2JqZWN0XzYkNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFwiLCBcIi5vKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFwiLCBcIi51KCk7XFxuXFx0XFx0XFx0XFx0XCIsIFwiLmQoKTtcXG5cXHRcXHRcXHRcXHRcIiwgXCIgPSBudWxsO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XCIsIFwiLm8oZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiLnUoKTtcXG5cXHRcXHRcXHRcXHRcIiwgXCIuZCgpO1xcblxcdFxcdFxcdFxcdFwiLCBcIiA9IG51bGw7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XCJdKSksIG5hbWUsIG5hbWUsIG5hbWUsIG5hbWUpIDogZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNyQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF83JDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcIiwgXCIudSgpO1xcblxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XFx0XCIsIFwiID0gbnVsbDtcXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFwiLCBcIi51KCk7XFxuXFx0XFx0XFx0XCIsIFwiLmQoKTtcXG5cXHRcXHRcXHRcIiwgXCIgPSBudWxsO1xcblxcdFxcdFwiXSkpLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICBibG9jay5idWlsZGVycy51cGRhdGUuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfOCQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF84JDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0fSBlbHNlIGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHR9XFxuXFx0XCJdLCBbXCJcXG5cXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0fSBlbHNlIGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHR9XFxuXFx0XCJdKSksIGJyYW5jaC5jb25kaXRpb24sIGVudGVyLCBuYW1lLCBleGl0KSk7XG4gICAgYmxvY2suYnVpbGRlcnMudW5tb3VudC5hZGRMaW5lKFwiXCIgKyBpZl9uYW1lICsgbmFtZSArIFwiLnUoKTtcIik7XG4gICAgYmxvY2suYnVpbGRlcnMuZGVzdHJveS5hZGRMaW5lKFwiXCIgKyBpZl9uYW1lICsgbmFtZSArIFwiLmQoKTtcIik7XG59XG5mdW5jdGlvbiBjb21wb3VuZChnZW5lcmF0b3IsIGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2Rlcywgbm9kZSwgYnJhbmNoZXMsIGR5bmFtaWMsIF9hKSB7XG4gICAgdmFyIG5hbWUgPSBfYS5uYW1lLCBhbmNob3IgPSBfYS5hbmNob3IsIHBhcmFtcyA9IF9hLnBhcmFtcywgaGFzRWxzZSA9IF9hLmhhc0Vsc2UsIGlmX25hbWUgPSBfYS5pZl9uYW1lO1xuICAgIHZhciBzZWxlY3RfYmxvY2tfdHlwZSA9IGdlbmVyYXRvci5nZXRVbmlxdWVOYW1lKFwic2VsZWN0X2Jsb2NrX3R5cGVcIik7XG4gICAgdmFyIGN1cnJlbnRfYmxvY2tfdHlwZSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoXCJjdXJyZW50X2Jsb2NrX3R5cGVcIik7XG4gICAgdmFyIGN1cnJlbnRfYmxvY2tfdHlwZV9hbmQgPSBoYXNFbHNlID8gJycgOiBjdXJyZW50X2Jsb2NrX3R5cGUgKyBcIiAmJiBcIjtcbiAgICBnZW5lcmF0b3IuYmxvY2tzLnB1c2goZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfOSQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF85JDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRmdW5jdGlvbiBcIiwgXCIoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0fVxcblxcdFwiXSwgW1wiXFxuXFx0XFx0ZnVuY3Rpb24gXCIsIFwiKFwiLCBcIikge1xcblxcdFxcdFxcdFwiLFxuICAgICAgICBcIlxcblxcdFxcdH1cXG5cXHRcIl0pKSwgc2VsZWN0X2Jsb2NrX3R5cGUsIHBhcmFtcywgYnJhbmNoZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IF9hLmNvbmRpdGlvbiwgYmxvY2sgPSBfYS5ibG9jaztcbiAgICAgICAgcmV0dXJuIChjb25kaXRpb24gPyBcImlmIChcIiArIGNvbmRpdGlvbiArIFwiKSBcIiA6ICcnKSArIFwicmV0dXJuIFwiICsgYmxvY2sgKyBcIjtcIjtcbiAgICB9KVxuICAgICAgICAuam9pbignXFxuJykpKTtcbiAgICBibG9jay5idWlsZGVycy5pbml0LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEwJDUgfHwgKHRlbXBsYXRlT2JqZWN0XzEwJDUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiKFwiLCBcIik7XFxuXFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIlwiLCBcIihcIiwgXCIsICNjb21wb25lbnQpO1xcblxcdFwiXSwgW1wiXFxuXFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIihcIiwgXCIpO1xcblxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCJcIiwgXCIoXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcIl0pKSwgY3VycmVudF9ibG9ja190eXBlLCBzZWxlY3RfYmxvY2tfdHlwZSwgcGFyYW1zLCBuYW1lLCBjdXJyZW50X2Jsb2NrX3R5cGVfYW5kLCBjdXJyZW50X2Jsb2NrX3R5cGUsIHBhcmFtcykpO1xuICAgIHZhciBtb3VudE9ySW50cm8gPSBicmFuY2hlc1swXS5oYXNJbnRyb01ldGhvZCA/ICdpJyA6ICdtJztcbiAgICB2YXIgaW5pdGlhbE1vdW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgJyN0YXJnZXQnO1xuICAgIHZhciBhbmNob3JOb2RlID0gcGFyZW50Tm9kZSA/ICdudWxsJyA6ICdhbmNob3InO1xuICAgIGJsb2NrLmJ1aWxkZXJzLm1vdW50LmFkZExpbmUoXCJcIiArIGlmX25hbWUgKyBuYW1lICsgXCIuXCIgKyBtb3VudE9ySW50cm8gKyBcIihcIiArIGluaXRpYWxNb3VudE5vZGUgKyBcIiwgXCIgKyBhbmNob3JOb2RlICsgXCIpO1wiKTtcbiAgICB2YXIgdXBkYXRlTW91bnROb2RlID0gbm9kZS5nZXRVcGRhdGVNb3VudE5vZGUoYW5jaG9yKTtcbiAgICB2YXIgY2hhbmdlQmxvY2sgPSBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xMSQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF8xMSQ1ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiID0gXCIsIFwiXCIsIFwiKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XCIsIFwiXCIsIFwiLmMoKTtcXG5cXHRcXHRcIiwgXCJcIiwgXCIuXCIsIFwiKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcIl0sIFtcIlxcblxcdFxcdFwiLFxuICAgICAgICBcIlxcblxcdFxcdFwiLCBcIiA9IFwiLCBcIlwiLCBcIihcIiwgXCIsICNjb21wb25lbnQpO1xcblxcdFxcdFwiLCBcIlwiLCBcIi5jKCk7XFxuXFx0XFx0XCIsIFwiXCIsIFwiLlwiLCBcIihcIiwgXCIsIFwiLCBcIik7XFxuXFx0XCJdKSksIGhhc0Vsc2VcbiAgICAgICAgPyBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xMiQ1IHx8ICh0ZW1wbGF0ZU9iamVjdF8xMiQ1ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XCIsIFwiLnUoKTtcXG5cXHRcXHRcXHRcXHRcIiwgXCIuZCgpO1xcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XCIsIFwiLnUoKTtcXG5cXHRcXHRcXHRcXHRcIiwgXCIuZCgpO1xcblxcdFxcdFxcdFwiXSkpLCBuYW1lLCBuYW1lKSA6IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEzJDQgfHwgKHRlbXBsYXRlT2JqZWN0XzEzJDQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiLnUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIuZCgpO1xcblxcdFxcdFxcdFxcdH1cIl0sIFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCIudSgpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIi5kKCk7XFxuXFx0XFx0XFx0XFx0fVwiXSkpLCBuYW1lLCBuYW1lLCBuYW1lKSwgbmFtZSwgY3VycmVudF9ibG9ja190eXBlX2FuZCwgY3VycmVudF9ibG9ja190eXBlLCBwYXJhbXMsIGlmX25hbWUsIG5hbWUsIGlmX25hbWUsIG5hbWUsIG1vdW50T3JJbnRybywgdXBkYXRlTW91bnROb2RlLCBhbmNob3IpO1xuICAgIGlmIChkeW5hbWljKSB7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xNCQzIHx8ICh0ZW1wbGF0ZU9iamVjdF8xNCQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0aWYgKFwiLCBcIiA9PT0gKFwiLCBcIiA9IFwiLCBcIihcIiwgXCIpKSAmJiBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCIucChjaGFuZ2VkLCBcIiwgXCIpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0aWYgKFwiLCBcIiA9PT0gKFwiLCBcIiA9IFwiLCBcIihcIiwgXCIpKSAmJiBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCIucChjaGFuZ2VkLCBcIiwgXCIpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSkpLCBjdXJyZW50X2Jsb2NrX3R5cGUsIGN1cnJlbnRfYmxvY2tfdHlwZSwgc2VsZWN0X2Jsb2NrX3R5cGUsIHBhcmFtcywgbmFtZSwgbmFtZSwgcGFyYW1zLCBjaGFuZ2VCbG9jaykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmxvY2suYnVpbGRlcnMudXBkYXRlLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE1JDMgfHwgKHRlbXBsYXRlT2JqZWN0XzE1JDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRpZiAoXCIsIFwiICE9PSAoXCIsIFwiID0gXCIsIFwiKFwiLCBcIikpKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0aWYgKFwiLCBcIiAhPT0gKFwiLCBcIiA9IFwiLCBcIihcIiwgXCIpKSkge1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0pKSwgY3VycmVudF9ibG9ja190eXBlLCBjdXJyZW50X2Jsb2NrX3R5cGUsIHNlbGVjdF9ibG9ja190eXBlLCBwYXJhbXMsIGNoYW5nZUJsb2NrKSk7XG4gICAgfVxuICAgIGJsb2NrLmJ1aWxkZXJzLnVubW91bnQuYWRkTGluZShcIlwiICsgaWZfbmFtZSArIG5hbWUgKyBcIi51KCk7XCIpO1xuICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kuYWRkTGluZShcIlwiICsgaWZfbmFtZSArIG5hbWUgKyBcIi5kKCk7XCIpO1xufVxuLy8gaWYgYW55IG9mIHRoZSBzaWJsaW5ncyBoYXZlIG91dHJvcywgd2UgbmVlZCB0byBrZWVwIHJlZmVyZW5jZXMgdG8gdGhlIGJsb2Nrc1xuLy8gKFRPRE8gZG9lcyB0aGlzIG9ubHkgYXBwbHkgdG8gYmlkaSB0cmFuc2l0aW9ucz8pXG5mdW5jdGlvbiBjb21wb3VuZFdpdGhPdXRyb3MoZ2VuZXJhdG9yLCBibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMsIG5vZGUsIGJyYW5jaGVzLCBkeW5hbWljLCBfYSkge1xuICAgIHZhciBuYW1lID0gX2EubmFtZSwgYW5jaG9yID0gX2EuYW5jaG9yLCBwYXJhbXMgPSBfYS5wYXJhbXMsIGhhc0Vsc2UgPSBfYS5oYXNFbHNlO1xuICAgIHZhciBzZWxlY3RfYmxvY2tfdHlwZSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoXCJzZWxlY3RfYmxvY2tfdHlwZVwiKTtcbiAgICB2YXIgY3VycmVudF9ibG9ja190eXBlX2luZGV4ID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcImN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleFwiKTtcbiAgICB2YXIgcHJldmlvdXNfYmxvY2tfaW5kZXggPSBibG9jay5nZXRVbmlxdWVOYW1lKFwicHJldmlvdXNfYmxvY2tfaW5kZXhcIik7XG4gICAgdmFyIGlmX2Jsb2NrX2NyZWF0b3JzID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcImlmX2Jsb2NrX2NyZWF0b3JzXCIpO1xuICAgIHZhciBpZl9ibG9ja3MgPSBibG9jay5nZXRVbmlxdWVOYW1lKFwiaWZfYmxvY2tzXCIpO1xuICAgIHZhciBpZl9jdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPSBoYXNFbHNlXG4gICAgICAgID8gJydcbiAgICAgICAgOiBcImlmICh+XCIgKyBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggKyBcIikgXCI7XG4gICAgYmxvY2suYWRkVmFyaWFibGUoY3VycmVudF9ibG9ja190eXBlX2luZGV4KTtcbiAgICBibG9jay5hZGRWYXJpYWJsZShuYW1lKTtcbiAgICBibG9jay5idWlsZGVycy5pbml0LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE2JDMgfHwgKHRlbXBsYXRlT2JqZWN0XzE2JDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHR2YXIgXCIsIFwiID0gW1xcblxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdF07XFxuXFxuXFx0XFx0dmFyIFwiLCBcIiA9IFtdO1xcblxcblxcdFxcdGZ1bmN0aW9uIFwiLCBcIihcIiwgXCIpIHtcXG5cXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHR9XFxuXFx0XCJdLCBbXCJcXG5cXHRcXHR2YXIgXCIsIFwiID0gW1xcblxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdF07XFxuXFxuXFx0XFx0dmFyIFwiLCBcIiA9IFtdO1xcblxcblxcdFxcdGZ1bmN0aW9uIFwiLCBcIihcIiwgXCIpIHtcXG5cXHRcXHRcXHRcIixcbiAgICAgICAgXCJcXG5cXHRcXHR9XFxuXFx0XCJdKSksIGlmX2Jsb2NrX2NyZWF0b3JzLCBicmFuY2hlcy5tYXAoZnVuY3Rpb24gKGJyYW5jaCkgeyByZXR1cm4gYnJhbmNoLmJsb2NrOyB9KS5qb2luKCcsXFxuJyksIGlmX2Jsb2Nrcywgc2VsZWN0X2Jsb2NrX3R5cGUsIHBhcmFtcywgYnJhbmNoZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EsIGkpIHtcbiAgICAgICAgdmFyIGNvbmRpdGlvbiA9IF9hLmNvbmRpdGlvbiwgYmxvY2sgPSBfYS5ibG9jaztcbiAgICAgICAgcmV0dXJuIChjb25kaXRpb24gPyBcImlmIChcIiArIGNvbmRpdGlvbiArIFwiKSBcIiA6ICcnKSArIFwicmV0dXJuIFwiICsgKGJsb2NrID8gaSA6IC0xKSArIFwiO1wiO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCdcXG4nKSkpO1xuICAgIGlmIChoYXNFbHNlKSB7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmluaXQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTckMyB8fCAodGVtcGxhdGVPYmplY3RfMTckMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIihcIiwgXCIpO1xcblxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIltcIiwgXCJdID0gXCIsIFwiW1wiLCBcIl0oXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIihcIiwgXCIpO1xcblxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIltcIiwgXCJdID0gXCIsIFwiW1wiLCBcIl0oXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcIl0pKSwgY3VycmVudF9ibG9ja190eXBlX2luZGV4LCBzZWxlY3RfYmxvY2tfdHlwZSwgcGFyYW1zLCBuYW1lLCBpZl9ibG9ja3MsIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCwgaWZfYmxvY2tfY3JlYXRvcnMsIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCwgcGFyYW1zKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBibG9jay5idWlsZGVycy5pbml0LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE4JDMgfHwgKHRlbXBsYXRlT2JqZWN0XzE4JDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRpZiAofihcIiwgXCIgPSBcIiwgXCIoXCIsIFwiKSkpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCJbXCIsIFwiXSA9IFwiLCBcIltcIiwgXCJdKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0aWYgKH4oXCIsIFwiID0gXCIsIFwiKFwiLCBcIikpKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiW1wiLCBcIl0gPSBcIiwgXCJbXCIsIFwiXShcIiwgXCIsICNjb21wb25lbnQpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0pKSwgY3VycmVudF9ibG9ja190eXBlX2luZGV4LCBzZWxlY3RfYmxvY2tfdHlwZSwgcGFyYW1zLCBuYW1lLCBpZl9ibG9ja3MsIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCwgaWZfYmxvY2tfY3JlYXRvcnMsIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCwgcGFyYW1zKSk7XG4gICAgfVxuICAgIHZhciBtb3VudE9ySW50cm8gPSBicmFuY2hlc1swXS5oYXNJbnRyb01ldGhvZCA/ICdpJyA6ICdtJztcbiAgICB2YXIgaW5pdGlhbE1vdW50Tm9kZSA9IHBhcmVudE5vZGUgfHwgJyN0YXJnZXQnO1xuICAgIHZhciBhbmNob3JOb2RlID0gcGFyZW50Tm9kZSA/ICdudWxsJyA6ICdhbmNob3InO1xuICAgIGJsb2NrLmJ1aWxkZXJzLm1vdW50LmFkZExpbmUoXCJcIiArIGlmX2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCArIGlmX2Jsb2NrcyArIFwiW1wiICsgY3VycmVudF9ibG9ja190eXBlX2luZGV4ICsgXCJdLlwiICsgbW91bnRPckludHJvICsgXCIoXCIgKyBpbml0aWFsTW91bnROb2RlICsgXCIsIFwiICsgYW5jaG9yTm9kZSArIFwiKTtcIik7XG4gICAgdmFyIHVwZGF0ZU1vdW50Tm9kZSA9IG5vZGUuZ2V0VXBkYXRlTW91bnROb2RlKGFuY2hvcik7XG4gICAgdmFyIGRlc3Ryb3lPbGRCbG9jayA9IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE5JDMgfHwgKHRlbXBsYXRlT2JqZWN0XzE5JDMgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcIiwgXCIubyhmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcIiwgXCJbIFwiLCBcIiBdLnUoKTtcXG5cXHRcXHRcXHRcIiwgXCJbIFwiLCBcIiBdLmQoKTtcXG5cXHRcXHRcXHRcIiwgXCJbIFwiLCBcIiBdID0gbnVsbDtcXG5cXHRcXHR9KTtcXG5cXHRcIl0sIFtcIlxcblxcdFxcdFwiLCBcIi5vKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFwiLCBcIlsgXCIsIFwiIF0udSgpO1xcblxcdFxcdFxcdFwiLCBcIlsgXCIsIFwiIF0uZCgpO1xcblxcdFxcdFxcdFwiLCBcIlsgXCIsIFwiIF0gPSBudWxsO1xcblxcdFxcdH0pO1xcblxcdFwiXSkpLCBuYW1lLCBpZl9ibG9ja3MsIHByZXZpb3VzX2Jsb2NrX2luZGV4LCBpZl9ibG9ja3MsIHByZXZpb3VzX2Jsb2NrX2luZGV4LCBpZl9ibG9ja3MsIHByZXZpb3VzX2Jsb2NrX2luZGV4KTtcbiAgICB2YXIgY3JlYXRlTmV3QmxvY2sgPSBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yMCQyIHx8ICh0ZW1wbGF0ZU9iamVjdF8yMCQyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XCIsIFwiID0gXCIsIFwiW1wiLCBcIl07XFxuXFx0XFx0aWYgKCFcIiwgXCIpIHtcXG5cXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCJbXCIsIFwiXSA9IFwiLCBcIltcIiwgXCJdKFwiLCBcIiwgI2NvbXBvbmVudCk7XFxuXFx0XFx0XFx0XCIsIFwiLmMoKTtcXG5cXHRcXHR9XFxuXFx0XFx0XCIsIFwiLlwiLCBcIihcIiwgXCIsIFwiLCBcIik7XFxuXFx0XCJdLCBbXCJcXG5cXHRcXHRcIiwgXCIgPSBcIiwgXCJbXCIsIFwiXTtcXG5cXHRcXHRpZiAoIVwiLCBcIikge1xcblxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIltcIiwgXCJdID0gXCIsIFwiW1wiLCBcIl0oXCIsIFwiLCAjY29tcG9uZW50KTtcXG5cXHRcXHRcXHRcIiwgXCIuYygpO1xcblxcdFxcdH1cXG5cXHRcXHRcIiwgXCIuXCIsIFwiKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcIl0pKSwgbmFtZSwgaWZfYmxvY2tzLCBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXgsIG5hbWUsIG5hbWUsIGlmX2Jsb2NrcywgY3VycmVudF9ibG9ja190eXBlX2luZGV4LCBpZl9ibG9ja19jcmVhdG9ycywgY3VycmVudF9ibG9ja190eXBlX2luZGV4LCBwYXJhbXMsIG5hbWUsIG5hbWUsIG1vdW50T3JJbnRybywgdXBkYXRlTW91bnROb2RlLCBhbmNob3IpO1xuICAgIHZhciBjaGFuZ2VCbG9jayA9IGhhc0Vsc2VcbiAgICAgICAgPyBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yMSQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8yMSQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcIiwgXCJcXG5cXG5cXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcIl0pKSwgZGVzdHJveU9sZEJsb2NrLCBjcmVhdGVOZXdCbG9jaykgOiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yMiQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8yMiQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoflwiLCBcIikge1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiID0gbnVsbDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh+XCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCIgPSBudWxsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0pKSwgbmFtZSwgZGVzdHJveU9sZEJsb2NrLCBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXgsIGNyZWF0ZU5ld0Jsb2NrLCBuYW1lKTtcbiAgICBpZiAoZHluYW1pYykge1xuICAgICAgICBibG9jay5idWlsZGVycy51cGRhdGUuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMjMkMSB8fCAodGVtcGxhdGVPYmplY3RfMjMkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCI7XFxuXFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIik7XFxuXFx0XFx0XFx0aWYgKFwiLCBcIiA9PT0gXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXCIsIFwiW1wiLCBcIl0ucChjaGFuZ2VkLCBcIiwgXCIpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0dmFyIFwiLCBcIiA9IFwiLCBcIjtcXG5cXHRcXHRcXHRcIiwgXCIgPSBcIiwgXCIoXCIsIFwiKTtcXG5cXHRcXHRcXHRpZiAoXCIsIFwiID09PSBcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcIiwgXCJbXCIsIFwiXS5wKGNoYW5nZWQsIFwiLCBcIik7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdKSksIHByZXZpb3VzX2Jsb2NrX2luZGV4LCBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXgsIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCwgc2VsZWN0X2Jsb2NrX3R5cGUsIHBhcmFtcywgY3VycmVudF9ibG9ja190eXBlX2luZGV4LCBwcmV2aW91c19ibG9ja19pbmRleCwgaWZfY3VycmVudF9ibG9ja190eXBlX2luZGV4LCBpZl9ibG9ja3MsIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCwgcGFyYW1zLCBjaGFuZ2VCbG9jaykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmxvY2suYnVpbGRlcnMudXBkYXRlLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzI0JDEgfHwgKHRlbXBsYXRlT2JqZWN0XzI0JDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHR2YXIgXCIsIFwiID0gXCIsIFwiO1xcblxcdFxcdFxcdFwiLCBcIiA9IFwiLCBcIihcIiwgXCIpO1xcblxcdFxcdFxcdGlmIChcIiwgXCIgIT09IFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdHZhciBcIiwgXCIgPSBcIiwgXCI7XFxuXFx0XFx0XFx0XCIsIFwiID0gXCIsIFwiKFwiLCBcIik7XFxuXFx0XFx0XFx0aWYgKFwiLCBcIiAhPT0gXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSkpLCBwcmV2aW91c19ibG9ja19pbmRleCwgY3VycmVudF9ibG9ja190eXBlX2luZGV4LCBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXgsIHNlbGVjdF9ibG9ja190eXBlLCBwYXJhbXMsIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCwgcHJldmlvdXNfYmxvY2tfaW5kZXgsIGNoYW5nZUJsb2NrKSk7XG4gICAgfVxuICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kuYWRkTGluZShkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yNSQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8yNSQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XCIsIFwie1xcblxcdFxcdFxcdFwiLCBcIltcIiwgXCJdLnUoKTtcXG5cXHRcXHRcXHRcIiwgXCJbXCIsIFwiXS5kKCk7XFxuXFx0XFx0fVxcblxcdFwiXSwgW1wiXFxuXFx0XFx0XCIsIFwie1xcblxcdFxcdFxcdFwiLCBcIltcIiwgXCJdLnUoKTtcXG5cXHRcXHRcXHRcIiwgXCJbXCIsIFwiXS5kKCk7XFxuXFx0XFx0fVxcblxcdFwiXSkpLCBpZl9jdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXgsIGlmX2Jsb2NrcywgY3VycmVudF9ibG9ja190eXBlX2luZGV4LCBpZl9ibG9ja3MsIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCkpO1xufVxudmFyIHRlbXBsYXRlT2JqZWN0XzEkOTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8yJDk7XG52YXIgdGVtcGxhdGVPYmplY3RfMyQ5O1xudmFyIHRlbXBsYXRlT2JqZWN0XzQkOTtcbnZhciB0ZW1wbGF0ZU9iamVjdF81JDc7XG52YXIgdGVtcGxhdGVPYmplY3RfNiQ3O1xudmFyIHRlbXBsYXRlT2JqZWN0XzckNjtcbnZhciB0ZW1wbGF0ZU9iamVjdF84JDY7XG52YXIgdGVtcGxhdGVPYmplY3RfOSQ1O1xudmFyIHRlbXBsYXRlT2JqZWN0XzEwJDU7XG52YXIgdGVtcGxhdGVPYmplY3RfMTIkNTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMyQ0O1xudmFyIHRlbXBsYXRlT2JqZWN0XzExJDU7XG52YXIgdGVtcGxhdGVPYmplY3RfMTQkMztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xNSQzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE2JDM7XG52YXIgdGVtcGxhdGVPYmplY3RfMTckMztcbnZhciB0ZW1wbGF0ZU9iamVjdF8xOCQzO1xudmFyIHRlbXBsYXRlT2JqZWN0XzE5JDM7XG52YXIgdGVtcGxhdGVPYmplY3RfMjAkMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF8yMSQxO1xudmFyIHRlbXBsYXRlT2JqZWN0XzIyJDE7XG52YXIgdGVtcGxhdGVPYmplY3RfMjMkMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8yNCQxO1xudmFyIHRlbXBsYXRlT2JqZWN0XzI1JDE7XG5cbnZhciBUYWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGFnLnByb3RvdHlwZS5yZW5hbWVUaGlzTWV0aG9kID0gZnVuY3Rpb24gKGJsb2NrLCB1cGRhdGUpIHtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBibG9jay5jb250ZXh0dWFsaXNlKHRoaXMuZXhwcmVzc2lvbikuaW5kZXhlcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5tZXRhZGF0YSwgZGVwZW5kZW5jaWVzID0gX2EuZGVwZW5kZW5jaWVzLCBzbmlwcGV0ID0gX2Euc25pcHBldDtcbiAgICAgICAgdmFyIGhhc0NoYW5nZWFibGVJbmRleCA9IEFycmF5LmZyb20oaW5kZXhlcykuc29tZShmdW5jdGlvbiAoaW5kZXgpIHsgcmV0dXJuIGJsb2NrLmNoYW5nZWFibGVJbmRleGVzLmdldChpbmRleCk7IH0pO1xuICAgICAgICB2YXIgc2hvdWxkQ2FjaGUgPSAodGhpcy5leHByZXNzaW9uLnR5cGUgIT09ICdJZGVudGlmaWVyJyB8fFxuICAgICAgICAgICAgYmxvY2suY29udGV4dHMuaGFzKHRoaXMuZXhwcmVzc2lvbi5uYW1lKSB8fFxuICAgICAgICAgICAgaGFzQ2hhbmdlYWJsZUluZGV4KTtcbiAgICAgICAgdmFyIHZhbHVlID0gc2hvdWxkQ2FjaGUgJiYgYmxvY2suZ2V0VW5pcXVlTmFtZSh0aGlzW1widmFyXCJdICsgXCJfdmFsdWVcIik7XG4gICAgICAgIHZhciBjb250ZW50ID0gc2hvdWxkQ2FjaGUgPyB2YWx1ZSA6IHNuaXBwZXQ7XG4gICAgICAgIGlmIChzaG91bGRDYWNoZSlcbiAgICAgICAgICAgIGJsb2NrLmFkZFZhcmlhYmxlKHZhbHVlLCBzbmlwcGV0KTtcbiAgICAgICAgaWYgKGRlcGVuZGVuY2llcy5sZW5ndGggfHwgaGFzQ2hhbmdlYWJsZUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlZENoZWNrID0gKChibG9jay5oYXNPdXRyb01ldGhvZCA/IFwiI291dHJvaW5nIHx8IFwiIDogJycpICtcbiAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMubWFwKGZ1bmN0aW9uIChkZXBlbmRlbmN5KSB7IHJldHVybiBcImNoYW5nZWQuXCIgKyBkZXBlbmRlbmN5OyB9KS5qb2luKCcgfHwgJykpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZUNhY2hlZFZhbHVlID0gdmFsdWUgKyBcIiAhPT0gKFwiICsgdmFsdWUgKyBcIiA9IFwiICsgc25pcHBldCArIFwiKVwiO1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IHNob3VsZENhY2hlID9cbiAgICAgICAgICAgICAgICAoZGVwZW5kZW5jaWVzLmxlbmd0aCA/IFwiKFwiICsgY2hhbmdlZENoZWNrICsgXCIpICYmIFwiICsgdXBkYXRlQ2FjaGVkVmFsdWUgOiB1cGRhdGVDYWNoZWRWYWx1ZSkgOlxuICAgICAgICAgICAgICAgIGNoYW5nZWRDaGVjaztcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVwZGF0ZS5hZGRDb25kaXRpb25hbChjb25kaXRpb24sIHVwZGF0ZShjb250ZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW5pdDogY29udGVudCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRhZztcbn0oTm9kZSQxKSk7XG5cbnZhciBNdXN0YWNoZVRhZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTXVzdGFjaGVUYWcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTXVzdGFjaGVUYWcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgTXVzdGFjaGVUYWcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdGhpcy5jYW5ub3RVc2VJbm5lckhUTUwoKTtcbiAgICAgICAgdGhpc1tcInZhclwiXSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoJ3RleHQnKTtcbiAgICAgICAgYmxvY2suYWRkRGVwZW5kZW5jaWVzKHRoaXMubWV0YWRhdGEuZGVwZW5kZW5jaWVzKTtcbiAgICB9O1xuICAgIE11c3RhY2hlVGFnLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGluaXQgPSB0aGlzLnJlbmFtZVRoaXNNZXRob2QoYmxvY2ssIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXNbXCJ2YXJcIl0gKyBcIi5kYXRhID0gXCIgKyB2YWx1ZSArIFwiO1wiOyB9KS5pbml0O1xuICAgICAgICBibG9jay5hZGRFbGVtZW50KHRoaXNbXCJ2YXJcIl0sIFwiQGNyZWF0ZVRleHQoXCIgKyBpbml0ICsgXCIpXCIsIHBhcmVudE5vZGVzICYmIFwiQGNsYWltVGV4dChcIiArIHBhcmVudE5vZGVzICsgXCIsIFwiICsgaW5pdCArIFwiKVwiLCBwYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIHJldHVybiBNdXN0YWNoZVRhZztcbn0oVGFnKSk7XG5cbnZhciBQZW5kaW5nQmxvY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlbmRpbmdCbG9jaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQZW5kaW5nQmxvY2soKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFBlbmRpbmdCbG9jaztcbn0oTm9kZSQxKSk7XG5cbnZhciBSYXdNdXN0YWNoZVRhZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmF3TXVzdGFjaGVUYWcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmF3TXVzdGFjaGVUYWcoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgUmF3TXVzdGFjaGVUYWcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdGhpcy5jYW5ub3RVc2VJbm5lckhUTUwoKTtcbiAgICAgICAgdGhpc1tcInZhclwiXSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoJ3JhdycpO1xuICAgICAgICBibG9jay5hZGREZXBlbmRlbmNpZXModGhpcy5tZXRhZGF0YS5kZXBlbmRlbmNpZXMpO1xuICAgIH07XG4gICAgUmF3TXVzdGFjaGVUYWcucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2Rlcykge1xuICAgICAgICB2YXIgbmFtZSA9IHRoaXNbXCJ2YXJcIl07XG4gICAgICAgIHZhciBuZWVkc0FuY2hvckJlZm9yZSA9IHRoaXMucHJldiA/IHRoaXMucHJldi50eXBlICE9PSAnRWxlbWVudCcgOiAhcGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIG5lZWRzQW5jaG9yQWZ0ZXIgPSB0aGlzLm5leHQgPyB0aGlzLm5leHQudHlwZSAhPT0gJ0VsZW1lbnQnIDogIXBhcmVudE5vZGU7XG4gICAgICAgIHZhciBhbmNob3JCZWZvcmUgPSBuZWVkc0FuY2hvckJlZm9yZVxuICAgICAgICAgICAgPyBibG9jay5nZXRVbmlxdWVOYW1lKG5hbWUgKyBcIl9iZWZvcmVcIilcbiAgICAgICAgICAgIDogKHRoaXMucHJldiAmJiB0aGlzLnByZXZbXCJ2YXJcIl0pIHx8ICdudWxsJztcbiAgICAgICAgdmFyIGFuY2hvckFmdGVyID0gbmVlZHNBbmNob3JBZnRlclxuICAgICAgICAgICAgPyBibG9jay5nZXRVbmlxdWVOYW1lKG5hbWUgKyBcIl9hZnRlclwiKVxuICAgICAgICAgICAgOiAodGhpcy5uZXh0ICYmIHRoaXMubmV4dFtcInZhclwiXSkgfHwgJ251bGwnO1xuICAgICAgICB2YXIgZGV0YWNoO1xuICAgICAgICB2YXIgaW5zZXJ0O1xuICAgICAgICB2YXIgdXNlSW5uZXJIVE1MID0gZmFsc2U7XG4gICAgICAgIGlmIChhbmNob3JCZWZvcmUgPT09ICdudWxsJyAmJiBhbmNob3JBZnRlciA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICB1c2VJbm5lckhUTUwgPSB0cnVlO1xuICAgICAgICAgICAgZGV0YWNoID0gcGFyZW50Tm9kZSArIFwiLmlubmVySFRNTCA9ICcnO1wiO1xuICAgICAgICAgICAgaW5zZXJ0ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgcmV0dXJuIHBhcmVudE5vZGUgKyBcIi5pbm5lckhUTUwgPSBcIiArIGNvbnRlbnQgKyBcIjtcIjsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbmNob3JCZWZvcmUgPT09ICdudWxsJykge1xuICAgICAgICAgICAgZGV0YWNoID0gXCJAZGV0YWNoQmVmb3JlKFwiICsgYW5jaG9yQWZ0ZXIgKyBcIik7XCI7XG4gICAgICAgICAgICBpbnNlcnQgPSBmdW5jdGlvbiAoY29udGVudCkgeyByZXR1cm4gYW5jaG9yQWZ0ZXIgKyBcIi5pbnNlcnRBZGphY2VudEhUTUwoXFxcImJlZm9yZWJlZ2luXFxcIiwgXCIgKyBjb250ZW50ICsgXCIpO1wiOyB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFuY2hvckFmdGVyID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIGRldGFjaCA9IFwiQGRldGFjaEFmdGVyKFwiICsgYW5jaG9yQmVmb3JlICsgXCIpO1wiO1xuICAgICAgICAgICAgaW5zZXJ0ID0gZnVuY3Rpb24gKGNvbnRlbnQpIHsgcmV0dXJuIGFuY2hvckJlZm9yZSArIFwiLmluc2VydEFkamFjZW50SFRNTChcXFwiYWZ0ZXJlbmRcXFwiLCBcIiArIGNvbnRlbnQgKyBcIik7XCI7IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXRhY2ggPSBcIkBkZXRhY2hCZXR3ZWVuKFwiICsgYW5jaG9yQmVmb3JlICsgXCIsIFwiICsgYW5jaG9yQWZ0ZXIgKyBcIik7XCI7XG4gICAgICAgICAgICBpbnNlcnQgPSBmdW5jdGlvbiAoY29udGVudCkgeyByZXR1cm4gYW5jaG9yQmVmb3JlICsgXCIuaW5zZXJ0QWRqYWNlbnRIVE1MKFxcXCJhZnRlcmVuZFxcXCIsIFwiICsgY29udGVudCArIFwiKTtcIjsgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5pdCA9IHRoaXMucmVuYW1lVGhpc01ldGhvZChibG9jaywgZnVuY3Rpb24gKGNvbnRlbnQpIHsgcmV0dXJuIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkMTAgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMTAgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFwiXSkpLCAhdXNlSW5uZXJIVE1MICYmIGRldGFjaCwgaW5zZXJ0KGNvbnRlbnQpKTsgfSkuaW5pdDtcbiAgICAgICAgLy8gd2Ugd291bGQgaGF2ZSB1c2VkIGNvbW1lbnRzIGhlcmUsIGJ1dCB0aGUgYGluc2VydEFkamFjZW50SFRNTGAgYXBpIG9ubHlcbiAgICAgICAgLy8gZXhpc3RzIGZvciBgRWxlbWVudGBzLlxuICAgICAgICBpZiAobmVlZHNBbmNob3JCZWZvcmUpIHtcbiAgICAgICAgICAgIGJsb2NrLmFkZEVsZW1lbnQoYW5jaG9yQmVmb3JlLCBcIkBjcmVhdGVFbGVtZW50KCdub3NjcmlwdCcpXCIsIHBhcmVudE5vZGVzICYmIFwiQGNyZWF0ZUVsZW1lbnQoJ25vc2NyaXB0JylcIiwgcGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYWRkQW5jaG9yQWZ0ZXIoKSB7XG4gICAgICAgICAgICBibG9jay5hZGRFbGVtZW50KGFuY2hvckFmdGVyLCBcIkBjcmVhdGVFbGVtZW50KCdub3NjcmlwdCcpXCIsIHBhcmVudE5vZGVzICYmIFwiQGNyZWF0ZUVsZW1lbnQoJ25vc2NyaXB0JylcIiwgcGFyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzQW5jaG9yQWZ0ZXIgJiYgYW5jaG9yQmVmb3JlID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIC8vIGFuY2hvckFmdGVyIG5lZWRzIHRvIGJlIGluIHRoZSBET00gYmVmb3JlIHdlXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIEhUTUwuLi5cbiAgICAgICAgICAgIGFkZEFuY2hvckFmdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2suYnVpbGRlcnMubW91bnQuYWRkTGluZShpbnNlcnQoaW5pdCkpO1xuICAgICAgICBibG9jay5idWlsZGVycy5kZXRhY2hSYXcuYWRkQmxvY2soZGV0YWNoKTtcbiAgICAgICAgaWYgKG5lZWRzQW5jaG9yQWZ0ZXIgJiYgYW5jaG9yQmVmb3JlICE9PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIC8vIC4uLm90aGVyd2lzZSBpdCBzaG91bGQgZ28gYWZ0ZXJ3YXJkc1xuICAgICAgICAgICAgYWRkQW5jaG9yQWZ0ZXIoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJhd011c3RhY2hlVGFnO1xufShUYWcpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDEwO1xuXG52YXIgUmVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZWYsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVmKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBSZWY7XG59KE5vZGUkMSkpO1xuXG52YXIgU2xvdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2xvdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTbG90KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNsb3QucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYmxvY2ssIHN0cmlwV2hpdGVzcGFjZSwgbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdGhpcy5jYW5ub3RVc2VJbm5lckhUTUwoKTtcbiAgICAgICAgdGhpc1tcInZhclwiXSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoJ3Nsb3QnKTtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRDaGlsZHJlbihibG9jaywgc3RyaXBXaGl0ZXNwYWNlLCBuZXh0U2libGluZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNsb3QucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2Rlcykge1xuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gdGhpcy5nZW5lcmF0b3I7XG4gICAgICAgIHZhciBzbG90TmFtZSA9IHRoaXMuZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUoJ25hbWUnKSB8fCAnZGVmYXVsdCc7XG4gICAgICAgIGdlbmVyYXRvci5zbG90cy5hZGQoc2xvdE5hbWUpO1xuICAgICAgICB2YXIgY29udGVudF9uYW1lID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcInNsb3RfY29udGVudF9cIiArIHNsb3ROYW1lKTtcbiAgICAgICAgYmxvY2suYWRkVmFyaWFibGUoY29udGVudF9uYW1lLCBcIiNjb21wb25lbnQuX3Nsb3R0ZWQuXCIgKyBzbG90TmFtZSk7XG4gICAgICAgIHZhciBuZWVkc0FuY2hvckJlZm9yZSA9IHRoaXMucHJldiA/IHRoaXMucHJldi50eXBlICE9PSAnRWxlbWVudCcgOiAhcGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIG5lZWRzQW5jaG9yQWZ0ZXIgPSB0aGlzLm5leHQgPyB0aGlzLm5leHQudHlwZSAhPT0gJ0VsZW1lbnQnIDogIXBhcmVudE5vZGU7XG4gICAgICAgIHZhciBhbmNob3JCZWZvcmUgPSBuZWVkc0FuY2hvckJlZm9yZVxuICAgICAgICAgICAgPyBibG9jay5nZXRVbmlxdWVOYW1lKGNvbnRlbnRfbmFtZSArIFwiX2JlZm9yZVwiKVxuICAgICAgICAgICAgOiAodGhpcy5wcmV2ICYmIHRoaXMucHJldltcInZhclwiXSkgfHwgJ251bGwnO1xuICAgICAgICB2YXIgYW5jaG9yQWZ0ZXIgPSBuZWVkc0FuY2hvckFmdGVyXG4gICAgICAgICAgICA/IGJsb2NrLmdldFVuaXF1ZU5hbWUoY29udGVudF9uYW1lICsgXCJfYWZ0ZXJcIilcbiAgICAgICAgICAgIDogKHRoaXMubmV4dCAmJiB0aGlzLm5leHRbXCJ2YXJcIl0pIHx8ICdudWxsJztcbiAgICAgICAgaWYgKG5lZWRzQW5jaG9yQmVmb3JlKVxuICAgICAgICAgICAgYmxvY2suYWRkVmFyaWFibGUoYW5jaG9yQmVmb3JlKTtcbiAgICAgICAgaWYgKG5lZWRzQW5jaG9yQWZ0ZXIpXG4gICAgICAgICAgICBibG9jay5hZGRWYXJpYWJsZShhbmNob3JBZnRlcik7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmNyZWF0ZS5wdXNoQ29uZGl0aW9uKFwiIVwiICsgY29udGVudF9uYW1lKTtcbiAgICAgICAgYmxvY2suYnVpbGRlcnMuaHlkcmF0ZS5wdXNoQ29uZGl0aW9uKFwiIVwiICsgY29udGVudF9uYW1lKTtcbiAgICAgICAgYmxvY2suYnVpbGRlcnMubW91bnQucHVzaENvbmRpdGlvbihcIiFcIiArIGNvbnRlbnRfbmFtZSk7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVubW91bnQucHVzaENvbmRpdGlvbihcIiFcIiArIGNvbnRlbnRfbmFtZSk7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmRlc3Ryb3kucHVzaENvbmRpdGlvbihcIiFcIiArIGNvbnRlbnRfbmFtZSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLmJ1aWxkKGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2Rlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBibG9jay5idWlsZGVycy5jcmVhdGUucG9wQ29uZGl0aW9uKCk7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLmh5ZHJhdGUucG9wQ29uZGl0aW9uKCk7XG4gICAgICAgIGJsb2NrLmJ1aWxkZXJzLm1vdW50LnBvcENvbmRpdGlvbigpO1xuICAgICAgICBibG9jay5idWlsZGVycy51bm1vdW50LnBvcENvbmRpdGlvbigpO1xuICAgICAgICBibG9jay5idWlsZGVycy5kZXN0cm95LnBvcENvbmRpdGlvbigpO1xuICAgICAgICAvLyBUT0RPIGNhbiB3ZSB1c2UgYW4gZWxzZSBoZXJlP1xuICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMubW91bnQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMSQxMSB8fCAodGVtcGxhdGVPYmplY3RfMSQxMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHRAYXBwZW5kTm9kZShcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdEBhcHBlbmROb2RlKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIGNvbnRlbnRfbmFtZSwgbmVlZHNBbmNob3JCZWZvcmUgJiYgXCJAYXBwZW5kTm9kZShcIiArIGFuY2hvckJlZm9yZSArIFwiIHx8IChcIiArIGFuY2hvckJlZm9yZSArIFwiID0gQGNyZWF0ZUNvbW1lbnQoKSksIFwiICsgcGFyZW50Tm9kZSArIFwiKTtcIiwgY29udGVudF9uYW1lLCBwYXJlbnROb2RlLCBuZWVkc0FuY2hvckFmdGVyICYmIFwiQGFwcGVuZE5vZGUoXCIgKyBhbmNob3JBZnRlciArIFwiIHx8IChcIiArIGFuY2hvckFmdGVyICsgXCIgPSBAY3JlYXRlQ29tbWVudCgpKSwgXCIgKyBwYXJlbnROb2RlICsgXCIpO1wiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5tb3VudC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yJDEwIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDEwID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdEBpbnNlcnROb2RlKFwiLCBcIiwgI3RhcmdldCwgYW5jaG9yKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0QGluc2VydE5vZGUoXCIsIFwiLCAjdGFyZ2V0LCBhbmNob3IpO1xcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0pKSwgY29udGVudF9uYW1lLCBuZWVkc0FuY2hvckJlZm9yZSAmJiBcIkBpbnNlcnROb2RlKFwiICsgYW5jaG9yQmVmb3JlICsgXCIgfHwgKFwiICsgYW5jaG9yQmVmb3JlICsgXCIgPSBAY3JlYXRlQ29tbWVudCgpKSwgI3RhcmdldCwgYW5jaG9yKTtcIiwgY29udGVudF9uYW1lLCBuZWVkc0FuY2hvckFmdGVyICYmIFwiQGluc2VydE5vZGUoXCIgKyBhbmNob3JBZnRlciArIFwiIHx8IChcIiArIGFuY2hvckFmdGVyICsgXCIgPSBAY3JlYXRlQ29tbWVudCgpKSwgI3RhcmdldCwgYW5jaG9yKTtcIikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBzbG90IGlzIHVubW91bnRlZCwgbW92ZSBub2RlcyBiYWNrIGludG8gdGhlIGRvY3VtZW50IGZyYWdtZW50LFxuICAgICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSByZWluc2VydGVkIGxhdGVyXG4gICAgICAgIC8vIFRPRE8gc28gdGhhdCB0aGlzIGNhbiB3b3JrIHdpdGggcHVibGljIEFQSSwgY29tcG9uZW50Ll9zbG90dGVkIHNob3VsZFxuICAgICAgICAvLyBiZSBhbGwgZnJhZ21lbnRzLCBkZXJpdmVkIGZyb20gb3B0aW9ucy5zbG90cy4gTm90ID09PSBvcHRpb25zLnNsb3RzXG4gICAgICAgIC8vIFRPRE8gY2FuIHdlIHVzZSBhbiBlbHNlIGhlcmU/XG4gICAgICAgIGlmIChhbmNob3JCZWZvcmUgPT09ICdudWxsJyAmJiBhbmNob3JBZnRlciA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy51bm1vdW50LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzMkMTAgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMTAgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0QHJlaW5zZXJ0Q2hpbGRyZW4oXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRAcmVpbnNlcnRDaGlsZHJlbihcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBjb250ZW50X25hbWUsIHBhcmVudE5vZGUsIGNvbnRlbnRfbmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFuY2hvckJlZm9yZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy51bm1vdW50LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzQkMTAgfHwgKHRlbXBsYXRlT2JqZWN0XzQkMTAgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0QHJlaW5zZXJ0QmVmb3JlKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0QHJlaW5zZXJ0QmVmb3JlKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIGNvbnRlbnRfbmFtZSwgYW5jaG9yQWZ0ZXIsIGNvbnRlbnRfbmFtZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFuY2hvckFmdGVyID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLnVubW91bnQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNSQ4IHx8ICh0ZW1wbGF0ZU9iamVjdF81JDggPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0QHJlaW5zZXJ0QWZ0ZXIoXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRAcmVpbnNlcnRBZnRlcihcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBjb250ZW50X25hbWUsIGFuY2hvckJlZm9yZSwgY29udGVudF9uYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy51bm1vdW50LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzYkOCB8fCAodGVtcGxhdGVPYmplY3RfNiQ4ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdEByZWluc2VydEJldHdlZW4oXCIsIFwiLCBcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0QGRldGFjaE5vZGUoXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcXHRAZGV0YWNoTm9kZShcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGlmIChcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRAcmVpbnNlcnRCZXR3ZWVuKFwiLCBcIiwgXCIsIFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFxcdEBkZXRhY2hOb2RlKFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0XFx0QGRldGFjaE5vZGUoXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIGNvbnRlbnRfbmFtZSwgYW5jaG9yQmVmb3JlLCBhbmNob3JBZnRlciwgY29udGVudF9uYW1lLCBhbmNob3JCZWZvcmUsIGFuY2hvckFmdGVyKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNsb3QucHJvdG90eXBlLmdldFN0YXRpY0F0dHJpYnV0ZVZhbHVlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5maW5kKGZ1bmN0aW9uIChhdHRyKSB7IHJldHVybiBhdHRyLm5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZTsgfSk7XG4gICAgICAgIGlmICghYXR0cmlidXRlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUgPT09IHRydWUpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoID09PSAxICYmIGF0dHJpYnV0ZS52YWx1ZVswXS50eXBlID09PSAnVGV4dCcpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGUudmFsdWVbMF0uZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBTbG90O1xufShFbGVtZW50KSk7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQxMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8yJDEwO1xudmFyIHRlbXBsYXRlT2JqZWN0XzMkMTA7XG52YXIgdGVtcGxhdGVPYmplY3RfNCQxMDtcbnZhciB0ZW1wbGF0ZU9iamVjdF81JDg7XG52YXIgdGVtcGxhdGVPYmplY3RfNiQ4O1xuXG4vLyBXaGl0ZXNwYWNlIGluc2lkZSBvbmUgb2YgdGhlc2UgZWxlbWVudHMgd2lsbCBub3QgcmVzdWx0IGluXG4vLyBhIHdoaXRlc3BhY2Ugbm9kZSBiZWluZyBjcmVhdGVkIGluIGFueSBjaXJjdW1zdGFuY2VzLiAoVGhpc1xuLy8gbGlzdCBpcyBhbG1vc3QgY2VydGFpbmx5IHZlcnkgaW5jb21wbGV0ZSlcbnZhciBlbGVtZW50c1dpdGhvdXRUZXh0ID0gbmV3IFNldChbXG4gICAgJ2F1ZGlvJyxcbiAgICAnZGF0YWxpc3QnLFxuICAgICdkbCcsXG4gICAgJ29sJyxcbiAgICAnb3B0Z3JvdXAnLFxuICAgICdzZWxlY3QnLFxuICAgICd1bCcsXG4gICAgJ3ZpZGVvJyxcbl0pO1xuZnVuY3Rpb24gc2hvdWxkU2tpcCQxKG5vZGUpIHtcbiAgICBpZiAoL1xcUy8udGVzdChub2RlLmRhdGEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHBhcmVudEVsZW1lbnQgPSBub2RlLmZpbmROZWFyZXN0KC8oPzpFbGVtZW50fENvbXBvbmVudCkvKTtcbiAgICBpZiAoIXBhcmVudEVsZW1lbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAocGFyZW50RWxlbWVudC50eXBlID09PSAnQ29tcG9uZW50JylcbiAgICAgICAgcmV0dXJuIHBhcmVudEVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUgPT09IHBhcmVudEVsZW1lbnQuY2hpbGRyZW5bMF07XG4gICAgcmV0dXJuIHBhcmVudEVsZW1lbnQubmFtZXNwYWNlIHx8IGVsZW1lbnRzV2l0aG91dFRleHQuaGFzKHBhcmVudEVsZW1lbnQubmFtZSk7XG59XG52YXIgVGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGV4dCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZXh0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRleHQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSB0aGlzLmZpbmROZWFyZXN0KC8oPzpFbGVtZW50fENvbXBvbmVudCkvKTtcbiAgICAgICAgaWYgKHNob3VsZFNraXAkMSh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5zaG91bGRTa2lwID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW1widmFyXCJdID0gYmxvY2suZ2V0VW5pcXVlTmFtZShcInRleHRcIik7XG4gICAgfTtcbiAgICBUZXh0LnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChibG9jaywgcGFyZW50Tm9kZSwgcGFyZW50Tm9kZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU2tpcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYmxvY2suYWRkRWxlbWVudCh0aGlzW1widmFyXCJdLCBcIkBjcmVhdGVUZXh0KFwiICsgc3RyaW5naWZ5KHRoaXMuZGF0YSkgKyBcIilcIiwgcGFyZW50Tm9kZXMgJiYgXCJAY2xhaW1UZXh0KFwiICsgcGFyZW50Tm9kZXMgKyBcIiwgXCIgKyBzdHJpbmdpZnkodGhpcy5kYXRhKSArIFwiKVwiLCBwYXJlbnROb2RlKTtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0O1xufShOb2RlJDEpKTtcblxudmFyIFRoZW5CbG9jayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGhlbkJsb2NrLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRoZW5CbG9jaygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVGhlbkJsb2NrO1xufShOb2RlJDEpKTtcblxudmFyIFRyYW5zaXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRyYW5zaXRpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNpdGlvbjtcbn0oTm9kZSQxKSk7XG5cbnZhciBhc3NvY2lhdGVkRXZlbnRzID0ge1xuICAgIGlubmVyV2lkdGg6ICdyZXNpemUnLFxuICAgIGlubmVySGVpZ2h0OiAncmVzaXplJyxcbiAgICBvdXRlcldpZHRoOiAncmVzaXplJyxcbiAgICBvdXRlckhlaWdodDogJ3Jlc2l6ZScsXG4gICAgc2Nyb2xsWDogJ3Njcm9sbCcsXG4gICAgc2Nyb2xsWTogJ3Njcm9sbCdcbn07XG52YXIgcmVhZG9ubHkgPSBuZXcgU2V0KFtcbiAgICAnaW5uZXJXaWR0aCcsXG4gICAgJ2lubmVySGVpZ2h0JyxcbiAgICAnb3V0ZXJXaWR0aCcsXG4gICAgJ291dGVySGVpZ2h0JyxcbiAgICAnb25saW5lJyxcbl0pO1xudmFyIFdpbmRvdyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2luZG93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdpbmRvdygpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBXaW5kb3cucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGJsb2NrLCBwYXJlbnROb2RlLCBwYXJlbnROb2Rlcykge1xuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gdGhpcy5nZW5lcmF0b3I7XG4gICAgICAgIHZhciBldmVudHMgPSB7fTtcbiAgICAgICAgdmFyIGJpbmRpbmdzID0ge307XG4gICAgICAgIHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ0V2ZW50SGFuZGxlcicpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHZlcmlmeSB0aGF0IGl0J3MgYSB2YWxpZCBjYWxsZWUgKGkuZS4gYnVpbHQtaW4gb3IgZGVjbGFyZWQgbWV0aG9kKVxuICAgICAgICAgICAgICAgIGdlbmVyYXRvci5hZGRTb3VyY2VtYXBMb2NhdGlvbnMoYXR0cmlidXRlLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIHZhciB1c2VzU3RhdGVfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZS5leHByZXNzaW9uLmFyZ3VtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suY29udGV4dHVhbGlzZShhcmcsIG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gYXJnLm1ldGFkYXRhLmRlcGVuZGVuY2llcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcGVuZGVuY2llcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VzU3RhdGVfMSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGZsYXR0ZW5lZCA9IGZsYXR0ZW4oYXR0cmlidXRlLmV4cHJlc3Npb24uY2FsbGVlKTtcbiAgICAgICAgICAgICAgICBpZiAoZmxhdHRlbmVkLm5hbWUgIT09ICdldmVudCcgJiYgZmxhdHRlbmVkLm5hbWUgIT09ICd0aGlzJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBhbGxvdyBldmVudC5zdG9wUHJvcGFnYXRpb24oKSwgdGhpcy5zZWxlY3QoKSBldGNcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yLmNvZGUucHJlcGVuZFJpZ2h0KGF0dHJpYnV0ZS5leHByZXNzaW9uLnN0YXJ0LCBibG9jay5hbGlhcygnY29tcG9uZW50JykgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyTmFtZSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoXCJvbndpbmRvd1wiICsgYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyQm9keSA9IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkMTIgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMTIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcXHRbXFx1MjcwMlwiLCBcIi1cIiwgXCJcXHUyNzAyXTtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFtcXHUyNzAyXCIsIFwiLVwiLCBcIlxcdTI3MDJdO1xcblxcdFxcdFxcdFxcdFwiXSkpLCB1c2VzU3RhdGVfMSAmJiBcInZhciBzdGF0ZSA9ICNjb21wb25lbnQuZ2V0KCk7XCIsIGF0dHJpYnV0ZS5leHByZXNzaW9uLnN0YXJ0LCBhdHRyaWJ1dGUuZXhwcmVzc2lvbi5lbmQpO1xuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmluaXQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMiQxMSB8fCAodGVtcGxhdGVPYmplY3RfMiQxMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcXFwiXCIsIFwiXFxcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcXFwiXCIsIFwiXFxcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcIl0pKSwgaGFuZGxlck5hbWUsIGhhbmRsZXJCb2R5LCBhdHRyaWJ1dGUubmFtZSwgaGFuZGxlck5hbWUpKTtcbiAgICAgICAgICAgICAgICBibG9jay5idWlsZGVycy5kZXN0cm95LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzMkMTEgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMTEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwiXCIsIFwiXFxcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJcIiwgXCJcXFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFxcdFwiXSkpLCBhdHRyaWJ1dGUubmFtZSwgaGFuZGxlck5hbWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ0JpbmRpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gZGV2IG1vZGUsIHRocm93IGlmIHJlYWQtb25seSB2YWx1ZXMgYXJlIHdyaXR0ZW4gdG9cbiAgICAgICAgICAgICAgICBpZiAocmVhZG9ubHkuaGFzKGF0dHJpYnV0ZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3IucmVhZG9ubHkuYWRkKGF0dHJpYnV0ZS52YWx1ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmluZGluZ3NbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlLm5hbWU7XG4gICAgICAgICAgICAgICAgLy8gYmluZDpvbmxpbmUgaXMgYSBzcGVjaWFsIGNhc2UsIHdlIG5lZWQgdG8gbGlzdGVuIGZvciB0d28gc2VwYXJhdGUgZXZlbnRzXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS5uYW1lID09PSAnb25saW5lJylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBhc3NvY2lhdGVkRXZlbnQgPSBhc3NvY2lhdGVkRXZlbnRzW2F0dHJpYnV0ZS5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoIWV2ZW50c1thc3NvY2lhdGVkRXZlbnRdKVxuICAgICAgICAgICAgICAgICAgICBldmVudHNbYXNzb2NpYXRlZEV2ZW50XSA9IFtdO1xuICAgICAgICAgICAgICAgIGV2ZW50c1thc3NvY2lhdGVkRXZlbnRdLnB1c2goYXR0cmlidXRlLnZhbHVlLm5hbWUgKyBcIjogdGhpcy5cIiArIGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBhZGQgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgICAgIGdlbmVyYXRvci5tZXRhQmluZGluZ3MucHVzaChcInRoaXMuX3N0YXRlLlwiICsgYXR0cmlidXRlLnZhbHVlLm5hbWUgKyBcIiA9IHdpbmRvdy5cIiArIGF0dHJpYnV0ZS5uYW1lICsgXCI7XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxvY2sgPSBibG9jay5nZXRVbmlxdWVOYW1lKFwid2luZG93X3VwZGF0aW5nXCIpO1xuICAgICAgICBPYmplY3Qua2V5cyhldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlck5hbWUgPSBibG9jay5nZXRVbmlxdWVOYW1lKFwib253aW5kb3dcIiArIGV2ZW50KTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGV2ZW50c1tldmVudF0uam9pbignLFxcbicpO1xuICAgICAgICAgICAgaWYgKGV2ZW50ID09PSAnc2Nyb2xsJykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gb3RoZXIgYmlkaXJlY3Rpb25hbCBiaW5kaW5ncy4uLlxuICAgICAgICAgICAgICAgIGJsb2NrLmFkZFZhcmlhYmxlKGxvY2ssICdmYWxzZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhhbmRsZXJCb2R5ID0gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNCQxMSB8fCAodGVtcGxhdGVPYmplY3RfNCQxMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdCNjb21wb25lbnQuc2V0KHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdCNjb21wb25lbnQuc2V0KHtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcIl0pKSwgZXZlbnQgPT09ICdzY3JvbGwnICYmIGxvY2sgKyBcIiA9IHRydWU7XCIsIGdlbmVyYXRvci5vcHRpb25zLmRldiAmJiBcImNvbXBvbmVudC5fdXBkYXRpbmdSZWFkb25seVByb3BlcnR5ID0gdHJ1ZTtcIiwgcHJvcHMsIGdlbmVyYXRvci5vcHRpb25zLmRldiAmJiBcImNvbXBvbmVudC5fdXBkYXRpbmdSZWFkb25seVByb3BlcnR5ID0gZmFsc2U7XCIsIGV2ZW50ID09PSAnc2Nyb2xsJyAmJiBsb2NrICsgXCIgPSBmYWxzZTtcIik7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5pbml0LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzUkOSB8fCAodGVtcGxhdGVPYmplY3RfNSQ5ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJcIiwgXCJcXFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxcXCJcIiwgXCJcXFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFwiXSkpLCBoYW5kbGVyTmFtZSwgaGFuZGxlckJvZHksIGV2ZW50LCBoYW5kbGVyTmFtZSkpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuZGVzdHJveS5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF82JDkgfHwgKHRlbXBsYXRlT2JqZWN0XzYkOSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJcIiwgXCJcXFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcIlwiLCBcIlxcXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XCJdKSksIGV2ZW50LCBoYW5kbGVyTmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlLi4uIG1pZ2h0IG5lZWQgdG8gYWJzdHJhY3QgdGhpcyBvdXQgaWYgd2UgYWRkIG1vcmUgc3BlY2lhbCBjYXNlc1xuICAgICAgICBpZiAoYmluZGluZ3Muc2Nyb2xsWCAmJiBiaW5kaW5ncy5zY3JvbGxZKSB7XG4gICAgICAgICAgICB2YXIgb2JzZXJ2ZXJDYWxsYmFjayA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoXCJzY3JvbGxvYnNlcnZlclwiKTtcbiAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmluaXQuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNyQ3IHx8ICh0ZW1wbGF0ZU9iamVjdF83JDcgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikgcmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdHZhciB4ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdHZhciB5ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdFxcdHdpbmRvdy5zY3JvbGxUbyh4LCB5KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIoKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikgcmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdHZhciB4ID0gXCIsXG4gICAgICAgICAgICAgICAgXCI7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHkgPSBcIixcbiAgICAgICAgICAgICAgICBcIjtcXG5cXHRcXHRcXHRcXHRcXHR3aW5kb3cuc2Nyb2xsVG8oeCwgeSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpLCBvYnNlcnZlckNhbGxiYWNrLCBsb2NrLCBiaW5kaW5ncy5zY3JvbGxYXG4gICAgICAgICAgICAgICAgPyBcIiNjb21wb25lbnQuZ2V0KFxcXCJcIiArIGJpbmRpbmdzLnNjcm9sbFggKyBcIlxcXCIpXCJcbiAgICAgICAgICAgICAgICA6IFwid2luZG93LnNjcm9sbFhcIiwgYmluZGluZ3Muc2Nyb2xsWVxuICAgICAgICAgICAgICAgID8gXCIjY29tcG9uZW50LmdldChcXFwiXCIgKyBiaW5kaW5ncy5zY3JvbGxZICsgXCJcXFwiKVwiXG4gICAgICAgICAgICAgICAgOiBcIndpbmRvdy5zY3JvbGxZXCIpKTtcbiAgICAgICAgICAgIGlmIChiaW5kaW5ncy5zY3JvbGxYKVxuICAgICAgICAgICAgICAgIGJsb2NrLmJ1aWxkZXJzLmluaXQuYWRkTGluZShcIiNjb21wb25lbnQub2JzZXJ2ZShcXFwiXCIgKyBiaW5kaW5ncy5zY3JvbGxYICsgXCJcXFwiLCBcIiArIG9ic2VydmVyQ2FsbGJhY2sgKyBcIik7XCIpO1xuICAgICAgICAgICAgaWYgKGJpbmRpbmdzLnNjcm9sbFkpXG4gICAgICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRMaW5lKFwiI2NvbXBvbmVudC5vYnNlcnZlKFxcXCJcIiArIGJpbmRpbmdzLnNjcm9sbFkgKyBcIlxcXCIsIFwiICsgb2JzZXJ2ZXJDYWxsYmFjayArIFwiKTtcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmluZGluZ3Muc2Nyb2xsWCB8fCBiaW5kaW5ncy5zY3JvbGxZKSB7XG4gICAgICAgICAgICB2YXIgaXNYID0gISFiaW5kaW5ncy5zY3JvbGxYO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF84JDcgfHwgKHRlbXBsYXRlT2JqZWN0XzgkNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdCNjb21wb25lbnQub2JzZXJ2ZShcXFwiXCIsIFwiXFxcIiwgZnVuY3Rpb24oXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKFwiLCBcIikgcmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdHdpbmRvdy5zY3JvbGxUbyhcIiwgXCIpO1xcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0I2NvbXBvbmVudC5vYnNlcnZlKFxcXCJcIiwgXCJcXFwiLCBmdW5jdGlvbihcIiwgXCIpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoXCIsIFwiKSByZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0d2luZG93LnNjcm9sbFRvKFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XCJdKSksIGJpbmRpbmdzLnNjcm9sbFggfHwgYmluZGluZ3Muc2Nyb2xsWSwgaXNYID8gJ3gnIDogJ3knLCBsb2NrLCBpc1ggPyAneCwgd2luZG93LnNjcm9sbFknIDogJ3dpbmRvdy5zY3JvbGxYLCB5JykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFub3RoZXIgc3BlY2lhbCBjYXNlLiAoSSdtIHN0YXJ0aW5nIHRvIHRoaW5rIHRoZXNlIGFyZSBhbGwgc3BlY2lhbCBjYXNlcy4pXG4gICAgICAgIGlmIChiaW5kaW5ncy5vbmxpbmUpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyTmFtZSA9IGJsb2NrLmdldFVuaXF1ZU5hbWUoXCJvbmxpbmVzdGF0dXNjaGFuZ2VkXCIpO1xuICAgICAgICAgICAgYmxvY2suYnVpbGRlcnMuaW5pdC5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF85JDYgfHwgKHRlbXBsYXRlT2JqZWN0XzkkNiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIFwiLCBcIihldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdCNjb21wb25lbnQuc2V0KHsgXCIsIFwiOiBuYXZpZ2F0b3Iub25MaW5lIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcXFwib25saW5lXFxcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcXFwib2ZmbGluZVxcXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHQjY29tcG9uZW50LnNldCh7IFwiLCBcIjogbmF2aWdhdG9yLm9uTGluZSB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXFxcIm9ubGluZVxcXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXFxcIm9mZmxpbmVcXFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdFwiXSkpLCBoYW5kbGVyTmFtZSwgYmluZGluZ3Mub25saW5lLCBoYW5kbGVyTmFtZSwgaGFuZGxlck5hbWUpKTtcbiAgICAgICAgICAgIC8vIGFkZCBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICBnZW5lcmF0b3IubWV0YUJpbmRpbmdzLnB1c2goXCJ0aGlzLl9zdGF0ZS5cIiArIGJpbmRpbmdzLm9ubGluZSArIFwiID0gbmF2aWdhdG9yLm9uTGluZTtcIik7XG4gICAgICAgICAgICBibG9jay5idWlsZGVycy5kZXN0cm95LmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEwJDYgfHwgKHRlbXBsYXRlT2JqZWN0XzEwJDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwib25saW5lXFxcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwib2ZmbGluZVxcXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwib25saW5lXFxcIiwgXCIsIFwiKTtcXG5cXHRcXHRcXHRcXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwib2ZmbGluZVxcXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0XCJdKSksIGhhbmRsZXJOYW1lLCBoYW5kbGVyTmFtZSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gV2luZG93O1xufShOb2RlJDEpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDEyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzIkMTE7XG52YXIgdGVtcGxhdGVPYmplY3RfMyQxMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF80JDExO1xudmFyIHRlbXBsYXRlT2JqZWN0XzUkOTtcbnZhciB0ZW1wbGF0ZU9iamVjdF82JDk7XG52YXIgdGVtcGxhdGVPYmplY3RfNyQ3O1xudmFyIHRlbXBsYXRlT2JqZWN0XzgkNztcbnZhciB0ZW1wbGF0ZU9iamVjdF85JDY7XG52YXIgdGVtcGxhdGVPYmplY3RfMTAkNjtcblxudmFyIG5vZGVzID0ge1xuICAgIEF0dHJpYnV0ZTogQXR0cmlidXRlLFxuICAgIEF3YWl0QmxvY2s6IEF3YWl0QmxvY2ssXG4gICAgQmluZGluZzogQmluZGluZyxcbiAgICBDYXRjaEJsb2NrOiBDYXRjaEJsb2NrLFxuICAgIENvbW1lbnQ6IENvbW1lbnQkMixcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgICBFYWNoQmxvY2s6IEVhY2hCbG9jayxcbiAgICBFbGVtZW50OiBFbGVtZW50LFxuICAgIEVsc2VCbG9jazogRWxzZUJsb2NrLFxuICAgIEV2ZW50SGFuZGxlcjogRXZlbnRIYW5kbGVyLFxuICAgIEZyYWdtZW50OiBGcmFnbWVudCxcbiAgICBIZWFkOiBIZWFkLFxuICAgIElmQmxvY2s6IElmQmxvY2ssXG4gICAgTXVzdGFjaGVUYWc6IE11c3RhY2hlVGFnLFxuICAgIFBlbmRpbmdCbG9jazogUGVuZGluZ0Jsb2NrLFxuICAgIFJhd011c3RhY2hlVGFnOiBSYXdNdXN0YWNoZVRhZyxcbiAgICBSZWY6IFJlZixcbiAgICBTbG90OiBTbG90LFxuICAgIFRleHQ6IFRleHQsXG4gICAgVGhlbkJsb2NrOiBUaGVuQmxvY2ssXG4gICAgVHJhbnNpdGlvbjogVHJhbnNpdGlvbixcbiAgICBXaW5kb3c6IFdpbmRvd1xufTtcblxuZnVuY3Rpb24gZGV0ZWN0SW5kZW50YXRpb24oc3RyKSB7XG4gICAgdmFyIHBhdHRlcm4gPSAvXltcXHRcXHNdezEsNH0vZ207XG4gICAgdmFyIG1hdGNoO1xuICAgIHdoaWxlIChtYXRjaCA9IHBhdHRlcm4uZXhlYyhzdHIpKSB7XG4gICAgICAgIGlmIChtYXRjaFswXVswXSA9PT0gJ1xcdCcpXG4gICAgICAgICAgICByZXR1cm4gJ1xcdCc7XG4gICAgICAgIGlmIChtYXRjaFswXS5sZW5ndGggPT09IDIpXG4gICAgICAgICAgICByZXR1cm4gJyAgJztcbiAgICB9XG4gICAgcmV0dXJuICcgICAgJztcbn1cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uTGV2ZWwoc3RyLCBiKSB7XG4gICAgdmFyIGEgPSBiO1xuICAgIHdoaWxlIChhID4gMCAmJiBzdHJbYSAtIDFdICE9PSAnXFxuJylcbiAgICAgICAgYSAtPSAxO1xuICAgIHJldHVybiAvXlxccyovLmV4ZWMoc3RyLnNsaWNlKGEsIGIpKVswXTtcbn1cbmZ1bmN0aW9uIGdldEluZGVudEV4Y2x1c2lvblJhbmdlcyhub2RlKSB7XG4gICAgdmFyIHJhbmdlcyA9IFtdO1xuICAgIHdhbGsobm9kZSwge1xuICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdUZW1wbGF0ZUVsZW1lbnQnKVxuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbmZ1bmN0aW9uIHJlbW92ZUluZGVudGF0aW9uKGNvZGUsIHN0YXJ0LCBlbmQsIGluZGVudGF0aW9uTGV2ZWwsIHJhbmdlcykge1xuICAgIHZhciBzdHIgPSBjb2RlLm9yaWdpbmFsLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIHZhciBwYXR0ZXJuID0gbmV3IFJlZ0V4cChcIl5cIiArIGluZGVudGF0aW9uTGV2ZWwsICdnbScpO1xuICAgIHZhciBtYXRjaDtcbiAgICB3aGlsZSAobWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKSkge1xuICAgICAgICAvLyBUT0RPIGJhaWwgaWYgd2UncmUgaW5zaWRlIGFuIGV4Y2x1c2lvbiByYW5nZVxuICAgICAgICBjb2RlLnJlbW92ZShzdGFydCArIG1hdGNoLmluZGV4LCBzdGFydCArIG1hdGNoLmluZGV4ICsgaW5kZW50YXRpb25MZXZlbC5sZW5ndGgpO1xuICAgIH1cbn1cbi8vIFdlIG5lZWQgdG8gdGVsbCBlc3RyZWUtd2Fsa2VyIHRoYXQgaXQgc2hvdWxkIGFsd2F5c1xuLy8gbG9vayBmb3IgYW4gYGVsc2VgIGJsb2NrLCBvdGhlcndpc2UgaXQgbWlnaHQgZ2V0XG4vLyB0aGUgd3JvbmcgaWRlYSBhYm91dCB0aGUgc2hhcGUgb2YgZWFjaC9pZiBibG9ja3NcbmNoaWxkS2V5cy5FYWNoQmxvY2sgPSBjaGlsZEtleXMuSWZCbG9jayA9IFsnY2hpbGRyZW4nLCAnZWxzZSddO1xuY2hpbGRLZXlzLkF0dHJpYnV0ZSA9IFsndmFsdWUnXTtcbnZhciBHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR2VuZXJhdG9yKHBhcnNlZCwgc291cmNlLCBuYW1lLCBzdHlsZXNoZWV0LCBvcHRpb25zLCBkb20pIHtcbiAgICAgICAgdGhpcy5hc3QgPSBjbG9uZShwYXJzZWQpO1xuICAgICAgICB0aGlzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaW1wb3J0cyA9IFtdO1xuICAgICAgICB0aGlzLmhlbHBlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuaW1wb3J0ZWRDb21wb25lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNsb3RzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmJpbmRpbmdHcm91cHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRpcmVjdERlcGVuZGVuY2llcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sb2NhdGUgPSBnZXRMb2NhdG9yKHRoaXMuc291cmNlKTtcbiAgICAgICAgLy8gdHJhY2sgd2hpY2ggcHJvcGVydGllcyBhcmUgbmVlZGVkLCBzbyB3ZSBjYW4gcHJvdmlkZSB1c2VmdWwgaW5mb1xuICAgICAgICAvLyBpbiBkZXYgbW9kZVxuICAgICAgICB0aGlzLmV4cGVjdGVkUHJvcGVydGllcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gbmV3IE1hZ2ljU3RyaW5nJDEoc291cmNlKTtcbiAgICAgICAgdGhpcy51c2VzUmVmcyA9IGZhbHNlO1xuICAgICAgICAvLyBzdHlsZXNcbiAgICAgICAgdGhpcy5zdHlsZXNoZWV0ID0gc3R5bGVzaGVldDtcbiAgICAgICAgLy8gYWxsb3cgY29tcGlsZXIgdG8gZGVjb25mbGljdCB1c2VyJ3MgYGltcG9ydCB7IGdldCB9IGZyb20gJ3doYXRldmVyJ2AgYW5kXG4gICAgICAgIC8vIFN2ZWx0ZSdzIGJ1aWx0aW4gYGltcG9ydCB7IGdldCwgLi4uIH0gZnJvbSAnc3ZlbHRlL3NoYXJlZC50cydgO1xuICAgICAgICB0aGlzLnVzZXJWYXJzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlVmFycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbGlhc2VzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnVzZWROYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jb21wdXRhdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdGhpcy53YWxrSnMoZG9tKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5hbGlhcyhuYW1lKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY3VzdG9tRWxlbWVudCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21FbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIHRhZzogdGhpcy50YWcsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHRoaXMucHJvcHMgLy8gVE9ETyBhdXRvZmlsbCB0aGlzIGluXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21FbGVtZW50ID0gb3B0aW9ucy5jdXN0b21FbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbUVsZW1lbnQgJiYgIXRoaXMuY3VzdG9tRWxlbWVudC50YWcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHRhZyBuYW1lIHNwZWNpZmllZFwiKTsgLy8gVE9ETyBiZXR0ZXIgZXJyb3JcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndhbGtUZW1wbGF0ZSgpO1xuICAgIH1cbiAgICBHZW5lcmF0b3IucHJvdG90eXBlLmFkZFNvdXJjZW1hcExvY2F0aW9ucyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHdhbGsobm9kZSwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29kZS5hZGRTb3VyY2VtYXBMb2NhdGlvbihub2RlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb2RlLmFkZFNvdXJjZW1hcExvY2F0aW9uKG5vZGUuZW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFsaWFzZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFsaWFzZXMuc2V0KG5hbWUsIHRoaXMuZ2V0VW5pcXVlTmFtZShuYW1lKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWxpYXNlcy5nZXQobmFtZSk7XG4gICAgfTtcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlLmNvbnRleHR1YWxpc2UgPSBmdW5jdGlvbiAoY29udGV4dHMsIGluZGV4ZXMsIGV4cHJlc3Npb24sIGNvbnRleHQsIGlzRXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIC8vIHRoaXMuYWRkU291cmNlbWFwTG9jYXRpb25zKGV4cHJlc3Npb24pO1xuICAgICAgICB2YXIgdXNlZENvbnRleHRzID0gbmV3IFNldCgpO1xuICAgICAgICB2YXIgdXNlZEluZGV4ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvZGUgPSBfYS5jb2RlLCBoZWxwZXJzID0gX2EuaGVscGVycztcbiAgICAgICAgdmFyIHNjb3BlO1xuICAgICAgICB2YXIgbGV4aWNhbERlcHRoID0gMDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB3YWxrKGV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50LCBrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoL15GdW5jdGlvbi8udGVzdChub2RlLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBsZXhpY2FsRGVwdGggKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5fc2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBub2RlLl9zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnVGhpc0V4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZXhpY2FsRGVwdGggPT09IDAgJiYgY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKG5vZGUuc3RhcnQsIG5vZGUuZW5kLCBjb250ZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVOYW1lOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRPbmx5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKG5vZGUsIHBhcmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmbGF0dGVuKG5vZGUpLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY29wZSAmJiBzY29wZS5oYXMobmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnZXZlbnQnICYmIGlzRXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29udGV4dHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dE5hbWUgPSBjb250ZXh0cy5nZXQobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRydWUgZm9yICdyZXNlcnZlZCcgbmFtZXMgbGlrZSBgc3RhdGVgIGFuZCBgY29tcG9uZW50YFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKG5vZGUuc3RhcnQsIG5vZGUuc3RhcnQgKyBuYW1lLmxlbmd0aCwgY29udGV4dE5hbWUsIHsgc3RvcmVOYW1lOiB0cnVlLCBjb250ZW50T25seTogZmFsc2UgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VkQ29udGV4dHMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhlbHBlcnMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2JqZWN0ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvYmplY3QudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC5vYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSBzZWxmLnRlbXBsYXRlVmFycy5nZXQoXCJoZWxwZXJzLVwiICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWxpYXMgIT09IG5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUob2JqZWN0LnN0YXJ0LCBvYmplY3QuZW5kLCBhbGlhcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXhlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0XzEgPSBpbmRleGVzLmdldChuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRDb250ZXh0cy5hZGQoY29udGV4dF8xKTsgLy8gVE9ETyBpcyB0aGlzIHJpZ2h0P1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlZEluZGV4ZXMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHNob3J0aGFuZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC50eXBlID09PSAnUHJvcGVydHknICYmIHBhcmVudC5zaG9ydGhhbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSAna2V5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLmFwcGVuZExlZnQobm9kZS5zdGFydCwgbmFtZSArIFwiOiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLnByZXBlbmRSaWdodChub2RlLnN0YXJ0LCBcInN0YXRlLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZWRDb250ZXh0cy5hZGQoJ3N0YXRlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGlmICgvXkZ1bmN0aW9uLy50ZXN0KG5vZGUudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgIGxleGljYWxEZXB0aCAtPSAxO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLl9zY29wZSlcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGV4dHM6IHVzZWRDb250ZXh0cyxcbiAgICAgICAgICAgIGluZGV4ZXM6IHVzZWRJbmRleGVzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBHZW5lcmF0b3IucHJvdG90eXBlLmdlbmVyYXRlID0gZnVuY3Rpb24gKHJlc3VsdCwgb3B0aW9ucywgX2EpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9iID0gX2EuYmFubmVyLCBiYW5uZXIgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYiwgc2hhcmVkUGF0aCA9IF9hLnNoYXJlZFBhdGgsIGhlbHBlcnMgPSBfYS5oZWxwZXJzLCBuYW1lID0gX2EubmFtZSwgZm9ybWF0ID0gX2EuZm9ybWF0O1xuICAgICAgICB2YXIgcGF0dGVybiA9IC9cXFvinIIoXFxkKyktKFxcZCspJC87XG4gICAgICAgIHZhciBtb2R1bGUgPSB3cmFwTW9kdWxlKHJlc3VsdCwgZm9ybWF0LCBuYW1lLCBvcHRpb25zLCBiYW5uZXIsIHNoYXJlZFBhdGgsIGhlbHBlcnMsIHRoaXMuaW1wb3J0cywgdGhpcy5zb3VyY2UpO1xuICAgICAgICB2YXIgcGFydHMgPSBtb2R1bGUuc3BsaXQoJ+Kcgl0nKTtcbiAgICAgICAgdmFyIGZpbmFsQ2h1bmsgPSBwYXJ0cy5wb3AoKTtcbiAgICAgICAgdmFyIGNvbXBpbGVkID0gbmV3IEJ1bmRsZSh7IHNlcGFyYXRvcjogJycgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGFkZFN0cmluZyhzdHIpIHtcbiAgICAgICAgICAgIGNvbXBpbGVkLmFkZFNvdXJjZSh7XG4gICAgICAgICAgICAgICAgY29udGVudDogbmV3IE1hZ2ljU3RyaW5nJDEoc3RyKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpbGVuYW1lID0gb3B0aW9ucy5maWxlbmFtZTtcbiAgICAgICAgLy8gc3BlY2lhbCBjYXNlIOKAlCB0aGUgc291cmNlIGZpbGUgZG9lc24ndCBhY3R1YWxseSBnZXQgdXNlZCBhbnl3aGVyZS4gd2UgbmVlZFxuICAgICAgICAvLyB0byBhZGQgYW4gZW1wdHkgZmlsZSB0byBwb3B1bGF0ZSBtYXAuc291cmNlcyBhbmQgbWFwLnNvdXJjZXNDb250ZW50XG4gICAgICAgIGlmICghcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb21waWxlZC5hZGRTb3VyY2Uoe1xuICAgICAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlbmFtZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiBuZXcgTWFnaWNTdHJpbmckMSh0aGlzLnNvdXJjZSkucmVtb3ZlKDAsIHRoaXMuc291cmNlLmxlbmd0aClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLmZvckVhY2goZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdmFyIGNodW5rID0gc3RyLnJlcGxhY2UocGF0dGVybiwgJycpO1xuICAgICAgICAgICAgaWYgKGNodW5rKVxuICAgICAgICAgICAgICAgIGFkZFN0cmluZyhjaHVuayk7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBwYXR0ZXJuLmV4ZWMoc3RyKTtcbiAgICAgICAgICAgIHZhciBzbmlwcGV0ID0gX3RoaXMuY29kZS5zbmlwKCttYXRjaFsxXSwgK21hdGNoWzJdKTtcbiAgICAgICAgICAgIGNvbXBpbGVkLmFkZFNvdXJjZSh7XG4gICAgICAgICAgICAgICAgZmlsZW5hbWU6IGZpbGVuYW1lLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHNuaXBwZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkU3RyaW5nKGZpbmFsQ2h1bmspO1xuICAgICAgICB2YXIgX2MgPSB0aGlzLmN1c3RvbUVsZW1lbnQgP1xuICAgICAgICAgICAgeyBjc3M6IG51bGwsIGNzc01hcDogbnVsbCB9IDpcbiAgICAgICAgICAgIHRoaXMuc3R5bGVzaGVldC5yZW5kZXIob3B0aW9ucy5jc3NPdXRwdXRGaWxlbmFtZSwgdHJ1ZSksIGNzcyA9IF9jLmNzcywgY3NzTWFwID0gX2MuY3NzTWFwO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXN0OiB0aGlzLmFzdCxcbiAgICAgICAgICAgIGNvZGU6IGNvbXBpbGVkLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBtYXA6IGNvbXBpbGVkLmdlbmVyYXRlTWFwKHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlQ29udGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmaWxlOiBvcHRpb25zLm91dHB1dEZpbGVuYW1lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNzczogY3NzLFxuICAgICAgICAgICAgY3NzTWFwOiBjc3NNYXBcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0VW5pcXVlTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICh0ZXN0KVxuICAgICAgICAgICAgbmFtZSA9IG5hbWUgKyBcIiRcIjtcbiAgICAgICAgdmFyIGFsaWFzID0gbmFtZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IHJlc2VydmVkTmFtZXMuaGFzKGFsaWFzKSB8fFxuICAgICAgICAgICAgdGhpcy51c2VyVmFycy5oYXMoYWxpYXMpIHx8XG4gICAgICAgICAgICB0aGlzLnVzZWROYW1lcy5oYXMoYWxpYXMpOyBhbGlhcyA9IG5hbWUgKyBcIl9cIiArIGkrKylcbiAgICAgICAgICAgIDtcbiAgICAgICAgdGhpcy51c2VkTmFtZXMuYWRkKGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIGFsaWFzO1xuICAgIH07XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZS5nZXRVbmlxdWVOYW1lTWFrZXIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2NhbFVzZWROYW1lcyA9IG5ldyBTZXQocGFyYW1zKTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKG5hbWUpIHtcbiAgICAgICAgICAgIGxvY2FsVXNlZE5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXNlcnZlZE5hbWVzLmZvckVhY2goYWRkKTtcbiAgICAgICAgdGhpcy51c2VyVmFycy5mb3JFYWNoKGFkZCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRlc3QpXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgKyBcIiRcIjtcbiAgICAgICAgICAgIHZhciBhbGlhcyA9IG5hbWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgX3RoaXMudXNlZE5hbWVzLmhhcyhhbGlhcykgfHxcbiAgICAgICAgICAgICAgICBsb2NhbFVzZWROYW1lcy5oYXMoYWxpYXMpOyBhbGlhcyA9IG5hbWUgKyBcIl9cIiArIGkrKylcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBsb2NhbFVzZWROYW1lcy5hZGQoYWxpYXMpO1xuICAgICAgICAgICAgcmV0dXJuIGFsaWFzO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZS53YWxrSnMgPSBmdW5jdGlvbiAoZG9tKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIGNvZGUgPSBfYS5jb2RlLCBzb3VyY2UgPSBfYS5zb3VyY2UsIGNvbXB1dGF0aW9ucyA9IF9hLmNvbXB1dGF0aW9ucywgdGVtcGxhdGVQcm9wZXJ0aWVzID0gX2EudGVtcGxhdGVQcm9wZXJ0aWVzLCBpbXBvcnRzID0gX2EuaW1wb3J0cztcbiAgICAgICAgdmFyIGpzID0gdGhpcy5wYXJzZWQuanM7XG4gICAgICAgIHZhciBjb21wb25lbnREZWZpbml0aW9uID0gbmV3IENvZGVCdWlsZGVyKCk7XG4gICAgICAgIGlmIChqcykge1xuICAgICAgICAgICAgdGhpcy5hZGRTb3VyY2VtYXBMb2NhdGlvbnMoanMuY29udGVudCk7XG4gICAgICAgICAgICB2YXIgaW5kZW50YXRpb24gPSBkZXRlY3RJbmRlbnRhdGlvbihzb3VyY2Uuc2xpY2UoanMuc3RhcnQsIGpzLmVuZCkpO1xuICAgICAgICAgICAgdmFyIGluZGVudGF0aW9uTGV2ZWwgPSBnZXRJbmRlbnRhdGlvbkxldmVsKHNvdXJjZSwganMuY29udGVudC5ib2R5WzBdLnN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBpbmRlbnRFeGNsdXNpb25SYW5nZXNfMSA9IGdldEluZGVudEV4Y2x1c2lvblJhbmdlcyhqcy5jb250ZW50KTtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IGFubm90YXRlV2l0aFNjb3Blcyhqcy5jb250ZW50KTtcbiAgICAgICAgICAgIHNjb3BlLmRlY2xhcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudXNlclZhcnMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgYm9keSA9IGpzLmNvbnRlbnQuYm9keS5zbGljZSgpOyAvLyBzbGljZSwgYmVjYXVzZSB3ZSdyZSBnb2luZyB0byBiZSBtdXRhdGluZyB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIGltcG9ydHMgbmVlZCB0byBiZSBob2lzdGVkIG91dCBvZiB0aGUgSUlGRVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBib2R5W2ldO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdJbXBvcnREZWNsYXJhdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTm9kZShjb2RlLCBqcy5jb250ZW50LCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0cy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNwZWNpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoc3BlY2lmaWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy51c2VyVmFycy5hZGQoc3BlY2lmaWVyLmxvY2FsLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVmYXVsdEV4cG9ydCA9IHRoaXMuZGVmYXVsdEV4cG9ydCA9IGJvZHkuZmluZChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS50eXBlID09PSAnRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uJzsgfSk7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdEV4cG9ydCkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRFeHBvcnQuZGVjbGFyYXRpb24ucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUHJvcGVydGllc1tnZXRNZXRob2ROYW1lKHByb3Aua2V5KV0gPSBwcm9wO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIFsnaGVscGVycycsICdldmVudHMnLCAnY29tcG9uZW50cycsICd0cmFuc2l0aW9ucyddLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVQcm9wZXJ0aWVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUHJvcGVydGllc1trZXldLnZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzW2tleV0uYWRkKGdldE1ldGhvZE5hbWUocHJvcC5rZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGFkZEFycm93RnVuY3Rpb25FeHByZXNzaW9uXzEgPSBmdW5jdGlvbiAobmFtZSwgbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm9keSA9IG5vZGUuYm9keSwgcGFyYW1zID0gbm9kZS5wYXJhbXMsIGFzeW5jID0gbm9kZS5hc3luYztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuS2V5d29yZCA9IGFzeW5jID8gJ2FzeW5jIGZ1bmN0aW9uJyA6ICdmdW5jdGlvbic7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbVN0cmluZyA9IHBhcmFtcy5sZW5ndGggP1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJbXFx1MjcwMlwiICsgcGFyYW1zWzBdLnN0YXJ0ICsgXCItXCIgKyBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdLmVuZCArIFwiXFx1MjcwMl1cIiA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS50eXBlID09PSAnQmxvY2tTdGF0ZW1lbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnREZWZpbml0aW9uLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEkMSB8fCAodGVtcGxhdGVPYmplY3RfMSQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XCIsIFwiIFwiLCBcIihcIiwgXCIpIFtcXHUyNzAyXCIsIFwiLVwiLCBcIlxcdTI3MDJdXFxuXFx0XFx0XFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgXCIsIFwiKFwiLCBcIikgW1xcdTI3MDJcIiwgXCItXCIsIFwiXFx1MjcwMl1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcIl0pKSwgZm5LZXl3b3JkLCBuYW1lLCBwYXJhbVN0cmluZywgYm9keS5zdGFydCwgYm9keS5lbmQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudERlZmluaXRpb24uYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMiQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgXCIsIFwiKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBbXFx1MjcwMlwiLCBcIi1cIiwgXCJcXHUyNzAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcIiwgXCIgXCIsIFwiKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBbXFx1MjcwMlwiLCBcIi1cIiwgXCJcXHUyNzAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XCJdKSksIGZuS2V5d29yZCwgbmFtZSwgcGFyYW1TdHJpbmcsIGJvZHkuc3RhcnQsIGJvZHkuZW5kKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBhZGRGdW5jdGlvbkV4cHJlc3Npb25fMSA9IGZ1bmN0aW9uIChuYW1lLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhc3luYyA9IG5vZGUuYXN5bmM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbktleXdvcmQgPSBhc3luYyA/ICdhc3luYyBmdW5jdGlvbicgOiAnZnVuY3Rpb24nO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG5vZGUuc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChfdGhpcy5zb3VyY2VbY10gIT09ICcoJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RGVmaW5pdGlvbi5hZGRCbG9jayhkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8zJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiBcIiwgXCJbXFx1MjcwMlwiLCBcIi1cIiwgXCJcXHUyNzAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIiBcIiwgXCJbXFx1MjcwMlwiLCBcIi1cIiwgXCJcXHUyNzAyXTtcXG5cXHRcXHRcXHRcXHRcXHRcIl0pKSwgZm5LZXl3b3JkLCBuYW1lLCBjLCBub2RlLmVuZCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGFkZFZhbHVlXzEgPSBmdW5jdGlvbiAobmFtZSwgbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnREZWZpbml0aW9uLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzQkMSB8fCAodGVtcGxhdGVPYmplY3RfNCQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFtcXHUyNzAyXCIsIFwiLVwiLCBcIlxcdTI3MDJdO1xcblxcdFxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIFwiLCBcIiA9IFtcXHUyNzAyXCIsIFwiLVwiLCBcIlxcdTI3MDJdO1xcblxcdFxcdFxcdFxcdFxcdFwiXSkpLCBuYW1lLCBub2RlLnN0YXJ0LCBub2RlLmVuZCkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdmFyIGFkZERlY2xhcmF0aW9uXzEgPSBmdW5jdGlvbiAoa2V5LCBub2RlLCBkaXNhbWJpZ3VhdG9yLCBjb25mbGljdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1YWxpZmllZCA9IGRpc2FtYmlndWF0b3IgPyBkaXNhbWJpZ3VhdG9yICsgXCItXCIgKyBrZXkgOiBrZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJiBub2RlLm5hbWUgPT09IGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudGVtcGxhdGVWYXJzLnNldChxdWFsaWZpZWQsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY29uZmxpY3RlZCA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZsaWN0cylcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChkZWNvbmZsaWN0ZWQgaW4gY29uZmxpY3RzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29uZmxpY3RlZCArPSAnXyc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gX3RoaXMuZ2V0VW5pcXVlTmFtZShkZWNvbmZsaWN0ZWQpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50ZW1wbGF0ZVZhcnMuc2V0KHF1YWxpZmllZCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlaW5kZW50XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRlbnRhdGlvbkxldmVsID0gZ2V0SW5kZW50YXRpb25MZXZlbChzb3VyY2UsIG5vZGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZW50YXRpb25MZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSW5kZW50YXRpb24oY29kZSwgbm9kZS5zdGFydCwgbm9kZS5lbmQsIGluZGVudGF0aW9uTGV2ZWwsIGluZGVudEV4Y2x1c2lvblJhbmdlc18xKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnQXJyb3dGdW5jdGlvbkV4cHJlc3Npb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvbl8xKG5hbWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUudHlwZSA9PT0gJ0Z1bmN0aW9uRXhwcmVzc2lvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZ1bmN0aW9uRXhwcmVzc2lvbl8xKG5hbWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVmFsdWVfMShuYW1lLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlUHJvcGVydGllcy5jb21wb25lbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUHJvcGVydGllcy5jb21wb25lbnRzLnZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9uXzEoZ2V0TWV0aG9kTmFtZShwcm9wZXJ0eS5rZXkpLCBwcm9wZXJ0eS52YWx1ZSwgJ2NvbXBvbmVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVByb3BlcnRpZXMuY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRlcGVuZGVuY2llc18xID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVByb3BlcnRpZXMuY29tcHV0ZWQudmFsdWUucHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZ2V0TWV0aG9kTmFtZShwcm9wLmtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBwcm9wLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSB2YWx1ZS5wYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbS50eXBlID09PSAnQXNzaWdubWVudFBhdHRlcm4nID8gcGFyYW0ubGVmdC5uYW1lIDogcGFyYW0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVwcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5leHBlY3RlZFByb3BlcnRpZXMuYWRkKGRlcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llc18xLnNldChrZXksIGRlcHMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0ZWRfMSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZpc2l0XzEgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRlcGVuZGVuY2llc18xLmhhcyhrZXkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbm90IGEgY29tcHV0YXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXNpdGVkXzEuaGFzKGtleSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlzaXRlZF8xLmFkZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlcHMgPSBkZXBlbmRlbmNpZXNfMS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHMuZm9yRWFjaCh2aXNpdF8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXB1dGF0aW9ucy5wdXNoKHsga2V5OiBrZXksIGRlcHM6IGRlcHMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHRlbXBsYXRlUHJvcGVydGllcy5jb21wdXRlZC52YWx1ZS5wcm9wZXJ0aWVzLmZpbmQoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIGdldE1ldGhvZE5hbWUocHJvcC5rZXkpID09PSBrZXk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRGVjbGFyYXRpb25fMShrZXksIHByb3AudmFsdWUsICdjb21wdXRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQcm9wZXJ0aWVzLmNvbXB1dGVkLnZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZpc2l0XzEoZ2V0TWV0aG9kTmFtZShwcm9wLmtleSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlUHJvcGVydGllcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9uXzEoJ2RhdGEnLCB0ZW1wbGF0ZVByb3BlcnRpZXMuZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVByb3BlcnRpZXMuZXZlbnRzICYmIGRvbSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVByb3BlcnRpZXMuZXZlbnRzLnZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9uXzEoZ2V0TWV0aG9kTmFtZShwcm9wZXJ0eS5rZXkpLCBwcm9wZXJ0eS52YWx1ZSwgJ2V2ZW50cycpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlUHJvcGVydGllcy5oZWxwZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUHJvcGVydGllcy5oZWxwZXJzLnZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9uXzEoZ2V0TWV0aG9kTmFtZShwcm9wZXJ0eS5rZXkpLCBwcm9wZXJ0eS52YWx1ZSwgJ2hlbHBlcnMnKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVByb3BlcnRpZXMubWV0aG9kcyAmJiBkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVjbGFyYXRpb25fMSgnbWV0aG9kcycsIHRlbXBsYXRlUHJvcGVydGllcy5tZXRob2RzLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlUHJvcGVydGllcy5uYW1lc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5zID0gdGVtcGxhdGVQcm9wZXJ0aWVzLm5hbWVzcGFjZS52YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzW25zXSB8fCBucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlUHJvcGVydGllcy5vbnJlbmRlcilcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQcm9wZXJ0aWVzLm9uY3JlYXRlID0gdGVtcGxhdGVQcm9wZXJ0aWVzLm9ucmVuZGVyOyAvLyByZW1vdmUgYWZ0ZXIgdjJcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVQcm9wZXJ0aWVzLm9uY3JlYXRlICYmIGRvbSkge1xuICAgICAgICAgICAgICAgICAgICBhZGREZWNsYXJhdGlvbl8xKCdvbmNyZWF0ZScsIHRlbXBsYXRlUHJvcGVydGllcy5vbmNyZWF0ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVByb3BlcnRpZXMub250ZWFyZG93bilcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQcm9wZXJ0aWVzLm9uZGVzdHJveSA9IHRlbXBsYXRlUHJvcGVydGllcy5vbnRlYXJkb3duOyAvLyByZW1vdmUgYWZ0ZXIgdjJcbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVQcm9wZXJ0aWVzLm9uZGVzdHJveSAmJiBkb20pIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVjbGFyYXRpb25fMSgnb25kZXN0cm95JywgdGVtcGxhdGVQcm9wZXJ0aWVzLm9uZGVzdHJveS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVByb3BlcnRpZXMucHJlbG9hZCkge1xuICAgICAgICAgICAgICAgICAgICBhZGREZWNsYXJhdGlvbl8xKCdwcmVsb2FkJywgdGVtcGxhdGVQcm9wZXJ0aWVzLnByZWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVQcm9wZXJ0aWVzLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMgPSB0ZW1wbGF0ZVByb3BlcnRpZXMucHJvcHMudmFsdWUuZWxlbWVudHMubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiBlbGVtZW50LnZhbHVlOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBsYXRlUHJvcGVydGllcy5zZXR1cCkge1xuICAgICAgICAgICAgICAgICAgICBhZGREZWNsYXJhdGlvbl8xKCdzZXR1cCcsIHRlbXBsYXRlUHJvcGVydGllcy5zZXR1cC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVByb3BlcnRpZXMuc3RvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkRGVjbGFyYXRpb25fMSgnc3RvcmUnLCB0ZW1wbGF0ZVByb3BlcnRpZXMuc3RvcmUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGVtcGxhdGVQcm9wZXJ0aWVzLnRhZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRhZyA9IHRlbXBsYXRlUHJvcGVydGllcy50YWcudmFsdWUudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZW1wbGF0ZVByb3BlcnRpZXMudHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQcm9wZXJ0aWVzLnRyYW5zaXRpb25zLnZhbHVlLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZERlY2xhcmF0aW9uXzEoZ2V0TWV0aG9kTmFtZShwcm9wZXJ0eS5rZXkpLCBwcm9wZXJ0eS52YWx1ZSwgJ3RyYW5zaXRpb25zJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRlbnRhdGlvbkxldmVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSW5kZW50YXRpb24oY29kZSwganMuY29udGVudC5zdGFydCwgZGVmYXVsdEV4cG9ydC5zdGFydCwgaW5kZW50YXRpb25MZXZlbCwgaW5kZW50RXhjbHVzaW9uUmFuZ2VzXzEpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVJbmRlbnRhdGlvbihjb2RlLCBkZWZhdWx0RXhwb3J0LmVuZCwganMuY29udGVudC5lbmQsIGluZGVudGF0aW9uTGV2ZWwsIGluZGVudEV4Y2x1c2lvblJhbmdlc18xKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUluZGVudGF0aW9uKGNvZGUsIGpzLmNvbnRlbnQuc3RhcnQsIGpzLmNvbnRlbnQuZW5kLCBpbmRlbnRhdGlvbkxldmVsLCBpbmRlbnRFeGNsdXNpb25SYW5nZXNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGEgPSBqcy5jb250ZW50LnN0YXJ0O1xuICAgICAgICAgICAgd2hpbGUgKC9cXHMvLnRlc3Qoc291cmNlW2FdKSlcbiAgICAgICAgICAgICAgICBhICs9IDE7XG4gICAgICAgICAgICB2YXIgYiA9IGpzLmNvbnRlbnQuZW5kO1xuICAgICAgICAgICAgd2hpbGUgKC9cXHMvLnRlc3Qoc291cmNlW2IgLSAxXSkpXG4gICAgICAgICAgICAgICAgYiAtPSAxO1xuICAgICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmphdmFzY3JpcHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoYSAhPT0gZGVmYXVsdEV4cG9ydC5zdGFydClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qYXZhc2NyaXB0ICs9IFwiW1xcdTI3MDJcIiArIGEgKyBcIi1cIiArIGRlZmF1bHRFeHBvcnQuc3RhcnQgKyBcIlxcdTI3MDJdXCI7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb25lbnREZWZpbml0aW9uLmlzRW1wdHkoKSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qYXZhc2NyaXB0ICs9IGNvbXBvbmVudERlZmluaXRpb247XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRFeHBvcnQuZW5kICE9PSBiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmphdmFzY3JpcHQgKz0gXCJbXFx1MjcwMlwiICsgZGVmYXVsdEV4cG9ydC5lbmQgKyBcIi1cIiArIGIgKyBcIlxcdTI3MDJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmphdmFzY3JpcHQgPSBhID09PSBiID8gbnVsbCA6IFwiW1xcdTI3MDJcIiArIGEgKyBcIi1cIiArIGIgKyBcIlxcdTI3MDJdXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdlbmVyYXRvci5wcm90b3R5cGUud2Fsa1RlbXBsYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ2VuZXJhdG9yID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29kZSA9IF9hLmNvZGUsIGV4cGVjdGVkUHJvcGVydGllcyA9IF9hLmV4cGVjdGVkUHJvcGVydGllcywgaGVscGVycyA9IF9hLmhlbHBlcnM7XG4gICAgICAgIHZhciBodG1sJCQxID0gdGhpcy5wYXJzZWQuaHRtbDtcbiAgICAgICAgdmFyIGNvbnRleHR1YWxpc2UgPSBmdW5jdGlvbiAobm9kZSwgY29udGV4dERlcGVuZGVuY2llcywgaW5kZXhlcywgaXNFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgICAgIF90aGlzLmFkZFNvdXJjZW1hcExvY2F0aW9ucyhub2RlKTsgLy8gVE9ETyB0aGlzIGludm9sdmVzIGFuIGFkZGl0aW9uYWwgd2FsayDigJQgY2FuIHdlIHJvbGwgaXQgaW4gc29tZXdoZXJlIGVsc2U/XG4gICAgICAgICAgICB2YXIgc2NvcGUgPSBhbm5vdGF0ZVdpdGhTY29wZXMobm9kZSk7XG4gICAgICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgd2Fsayhub2RlLCB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5hZGRTb3VyY2VtYXBMb2NhdGlvbihub2RlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5hZGRTb3VyY2VtYXBMb2NhdGlvbihub2RlLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLl9zY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBub2RlLl9zY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2Uobm9kZSwgcGFyZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBmbGF0dGVuKG5vZGUpLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NvcGUgJiYgc2NvcGUuaGFzKG5hbWUpIHx8IGhlbHBlcnMuaGFzKG5hbWUpIHx8IChuYW1lID09PSAnZXZlbnQnICYmIGlzRXZlbnRIYW5kbGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dERlcGVuZGVuY2llcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0RGVwZW5kZW5jaWVzLmdldChuYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChkZXBlbmRlbmN5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llcy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaW5kZXhlcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGxlYXZlOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLl9zY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gc2NvcGUucGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLmZvckVhY2goZnVuY3Rpb24gKGRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZFByb3BlcnRpZXMuYWRkKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNuaXBwZXQ6IFwiW1xcdTI3MDJcIiArIG5vZGUuc3RhcnQgKyBcIi1cIiArIG5vZGUuZW5kICsgXCJcXHUyNzAyXVwiLFxuICAgICAgICAgICAgICAgIGRlcGVuZGVuY2llczogQXJyYXkuZnJvbShkZXBlbmRlbmNpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY29udGV4dFN0YWNrID0gW107XG4gICAgICAgIHZhciBpbmRleFN0YWNrID0gW107XG4gICAgICAgIHZhciBkZXBlbmRlbmNpZXNTdGFjayA9IFtdO1xuICAgICAgICB2YXIgY29udGV4dERlcGVuZGVuY2llcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdmFyIGNvbnRleHREZXBlbmRlbmNpZXNTdGFjayA9IFtjb250ZXh0RGVwZW5kZW5jaWVzXTtcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHZhciBpbmRleGVzU3RhY2sgPSBbaW5kZXhlc107XG4gICAgICAgIHdhbGsoaHRtbCQkMSwge1xuICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChub2RlLCBwYXJlbnQsIGtleSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gdGhpcyBpcyBoYWNreSBhcyBoZWxsXG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ3BhcmVudCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgICAgICBub2RlLmdlbmVyYXRvciA9IGdlbmVyYXRvcjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnRWxlbWVudCcgJiYgKG5vZGUubmFtZSA9PT0gJzpDb21wb25lbnQnIHx8IG5vZGUubmFtZSA9PT0gJzpTZWxmJyB8fCBnZW5lcmF0b3IuY29tcG9uZW50cy5oYXMobm9kZS5uYW1lKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gJ0NvbXBvbmVudCc7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19wcm90b19fID0gbm9kZXMuQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5uYW1lID09PSAnOldpbmRvdycpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gJ1dpbmRvdyc7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19wcm90b19fID0gbm9kZXMuV2luZG93LnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5uYW1lID09PSAnOkhlYWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9ICdIZWFkJztcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3Byb3RvX18gPSBub2Rlcy5IZWFkLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnRWxlbWVudCcgJiYgbm9kZS5uYW1lID09PSAnc2xvdCcgJiYgIWdlbmVyYXRvci5jdXN0b21FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9ICdTbG90JztcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5fX3Byb3RvX18gPSBub2Rlcy5TbG90LnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS50eXBlIGluIG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX19wcm90b19fID0gbm9kZXNbbm9kZS50eXBlXS5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdFbGVtZW50Jykge1xuICAgICAgICAgICAgICAgICAgICBnZW5lcmF0b3Iuc3R5bGVzaGVldC5hcHBseShub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0VhY2hCbG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tZXRhZGF0YSA9IGNvbnRleHR1YWxpc2Uobm9kZS5leHByZXNzaW9uLCBjb250ZXh0RGVwZW5kZW5jaWVzLCBpbmRleGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHREZXBlbmRlbmNpZXMgPSBuZXcgTWFwKGNvbnRleHREZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0RGVwZW5kZW5jaWVzLnNldChub2RlLmNvbnRleHQsIG5vZGUubWV0YWRhdGEuZGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZGVzdHJ1Y3R1cmVkQ29udGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5kZXN0cnVjdHVyZWRDb250ZXh0cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gbm9kZS5kZXN0cnVjdHVyZWRDb250ZXh0c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmNvbnRleHQgKyBcIltcIiArIGkgKyBcIl1cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0RGVwZW5kZW5jaWVzLnNldChuYW1lLCBub2RlLm1ldGFkYXRhLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGV4dERlcGVuZGVuY2llc1N0YWNrLnB1c2goY29udGV4dERlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzID0gbmV3IFNldChpbmRleGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ZXMuYWRkKG5vZGUuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlc1N0YWNrLnB1c2goaW5kZXhlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0F3YWl0QmxvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubWV0YWRhdGEgPSBjb250ZXh0dWFsaXNlKG5vZGUuZXhwcmVzc2lvbiwgY29udGV4dERlcGVuZGVuY2llcywgaW5kZXhlcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0RGVwZW5kZW5jaWVzID0gbmV3IE1hcChjb250ZXh0RGVwZW5kZW5jaWVzKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dERlcGVuZGVuY2llcy5zZXQobm9kZS52YWx1ZSwgbm9kZS5tZXRhZGF0YS5kZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0RGVwZW5kZW5jaWVzLnNldChub2RlLmVycm9yLCBub2RlLm1ldGFkYXRhLmRlcGVuZGVuY2llcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHREZXBlbmRlbmNpZXNTdGFjay5wdXNoKGNvbnRleHREZXBlbmRlbmNpZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnSWZCbG9jaycpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tZXRhZGF0YSA9IGNvbnRleHR1YWxpc2Uobm9kZS5leHByZXNzaW9uLCBjb250ZXh0RGVwZW5kZW5jaWVzLCBpbmRleGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdNdXN0YWNoZVRhZycgfHwgbm9kZS50eXBlID09PSAnUmF3TXVzdGFjaGVUYWcnIHx8IG5vZGUudHlwZSA9PT0gJ0F0dHJpYnV0ZVNob3J0aGFuZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tZXRhZGF0YSA9IGNvbnRleHR1YWxpc2Uobm9kZS5leHByZXNzaW9uLCBjb250ZXh0RGVwZW5kZW5jaWVzLCBpbmRleGVzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnQmluZGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tZXRhZGF0YSA9IGNvbnRleHR1YWxpc2Uobm9kZS52YWx1ZSwgY29udGV4dERlcGVuZGVuY2llcywgaW5kZXhlcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0V2ZW50SGFuZGxlcicgJiYgbm9kZS5leHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZXhwcmVzc2lvbi5hcmd1bWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcubWV0YWRhdGEgPSBjb250ZXh0dWFsaXNlKGFyZywgY29udGV4dERlcGVuZGVuY2llcywgaW5kZXhlcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNraXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ1RyYW5zaXRpb24nICYmIG5vZGUuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm1ldGFkYXRhID0gY29udGV4dHVhbGlzZShub2RlLmV4cHJlc3Npb24sIGNvbnRleHREZXBlbmRlbmNpZXMsIGluZGV4ZXMsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdDb21wb25lbnQnICYmIG5vZGUubmFtZSA9PT0gJzpDb21wb25lbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubWV0YWRhdGEgPSBjb250ZXh0dWFsaXNlKG5vZGUuZXhwcmVzc2lvbiwgY29udGV4dERlcGVuZGVuY2llcywgaW5kZXhlcywgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUsIHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdFYWNoQmxvY2snKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHREZXBlbmRlbmNpZXNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dERlcGVuZGVuY2llcyA9IGNvbnRleHREZXBlbmRlbmNpZXNTdGFja1tjb250ZXh0RGVwZW5kZW5jaWVzU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleGVzID0gaW5kZXhlc1N0YWNrW2luZGV4ZXNTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnRWxlbWVudCcgJiYgbm9kZS5uYW1lID09PSAnb3B0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2Ug4oCUIHRyZWF0IHRoZXNlIHRoZSBzYW1lIHdheTpcbiAgICAgICAgICAgICAgICAgICAgLy8gICA8b3B0aW9uPnt7Zm9vfX08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgLy8gICA8b3B0aW9uIHZhbHVlPSd7e2Zvb319Jz57e2Zvb319PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZUF0dHJpYnV0ZSA9IG5vZGUuYXR0cmlidXRlcy5maW5kKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lID09PSAndmFsdWUnOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZUF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnB1c2gobmV3IG5vZGVzLkF0dHJpYnV0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdG9yOiBnZW5lcmF0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ3ZhbHVlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbm9kZS5jaGlsZHJlbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gR2VuZXJhdG9yO1xufSgpKTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDE7XG52YXIgdGVtcGxhdGVPYmplY3RfMiQxO1xudmFyIHRlbXBsYXRlT2JqZWN0XzMkMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF80JDE7XG5cbnZhciBEb21HZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERvbUdlbmVyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEb21HZW5lcmF0b3IocGFyc2VkLCBzb3VyY2UsIG5hbWUsIHN0eWxlc2hlZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGFyc2VkLCBzb3VyY2UsIG5hbWUsIHN0eWxlc2hlZXQsIG9wdGlvbnMsIHRydWUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJsb2NrcyA9IFtdO1xuICAgICAgICBfdGhpcy5yZWFkb25seSA9IG5ldyBTZXQoKTtcbiAgICAgICAgX3RoaXMuaHlkcmF0YWJsZSA9IG9wdGlvbnMuaHlkcmF0YWJsZTtcbiAgICAgICAgX3RoaXMubGVnYWN5ID0gb3B0aW9ucy5sZWdhY3k7XG4gICAgICAgIF90aGlzLm5lZWRzRW5jYXBzdWxhdGVIZWxwZXIgPSBmYWxzZTtcbiAgICAgICAgLy8gaW5pdGlhbCB2YWx1ZXMgZm9yIGUuZy4gd2luZG93LmlubmVyV2lkdGgsIGlmIHRoZXJlJ3MgYSA8OldpbmRvdz4gbWV0YSB0YWdcbiAgICAgICAgX3RoaXMubWV0YUJpbmRpbmdzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRG9tR2VuZXJhdG9yLnByb3RvdHlwZS5nZXRVbmlxdWVOYW1lTWFrZXIgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2NhbFVzZWROYW1lcyA9IG5ldyBTZXQocGFyYW1zKTtcbiAgICAgICAgZnVuY3Rpb24gYWRkKG5hbWUpIHtcbiAgICAgICAgICAgIGxvY2FsVXNlZE5hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXNlcnZlZE5hbWVzLmZvckVhY2goYWRkKTtcbiAgICAgICAgdGhpcy51c2VyVmFycy5mb3JFYWNoKGFkZCk7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gc2hhcmVkKSB7XG4gICAgICAgICAgICBsb2NhbFVzZWROYW1lcy5hZGQodGVzdCA/IG5hbWUgKyBcIiRcIiA6IG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgaWYgKHRlc3QpXG4gICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgKyBcIiRcIjtcbiAgICAgICAgICAgIHZhciBhbGlhcyA9IG5hbWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgX3RoaXMudXNlZE5hbWVzLmhhcyhhbGlhcykgfHxcbiAgICAgICAgICAgICAgICBsb2NhbFVzZWROYW1lcy5oYXMoYWxpYXMpOyBhbGlhcyA9IG5hbWUgKyBcIl9cIiArIGkrKylcbiAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICBsb2NhbFVzZWROYW1lcy5hZGQoYWxpYXMpO1xuICAgICAgICAgICAgcmV0dXJuIGFsaWFzO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIERvbUdlbmVyYXRvcjtcbn0oR2VuZXJhdG9yKSk7XG5mdW5jdGlvbiBkb20ocGFyc2VkLCBzb3VyY2UsIHN0eWxlc2hlZXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgJ2VzJztcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IERvbUdlbmVyYXRvcihwYXJzZWQsIHNvdXJjZSwgb3B0aW9ucy5uYW1lIHx8ICdTdmVsdGVDb21wb25lbnQnLCBzdHlsZXNoZWV0LCBvcHRpb25zKTtcbiAgICB2YXIgY29tcHV0YXRpb25zID0gZ2VuZXJhdG9yLmNvbXB1dGF0aW9ucywgbmFtZSA9IGdlbmVyYXRvci5uYW1lLCB0ZW1wbGF0ZVByb3BlcnRpZXMgPSBnZW5lcmF0b3IudGVtcGxhdGVQcm9wZXJ0aWVzLCBuYW1lc3BhY2UgPSBnZW5lcmF0b3IubmFtZXNwYWNlO1xuICAgIHBhcnNlZC5odG1sLmJ1aWxkKCk7XG4gICAgdmFyIGJsb2NrID0gcGFyc2VkLmh0bWwuYmxvY2s7XG4gICAgZ2VuZXJhdG9yLnN0eWxlc2hlZXQud2Fybk9uVW51c2VkU2VsZWN0b3JzKG9wdGlvbnMub253YXJuKTtcbiAgICB2YXIgYnVpbGRlciA9IG5ldyBDb2RlQnVpbGRlcigpO1xuICAgIHZhciBjb21wdXRhdGlvbkJ1aWxkZXIgPSBuZXcgQ29kZUJ1aWxkZXIoKTtcbiAgICB2YXIgY29tcHV0YXRpb25EZXBzID0gbmV3IFNldCgpO1xuICAgIGlmIChjb21wdXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbXB1dGF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IF9hLmtleSwgZGVwcyA9IF9hLmRlcHM7XG4gICAgICAgICAgICBkZXBzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGF0aW9uRGVwcy5hZGQoZGVwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRvci5yZWFkb25seS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIDw6V2luZG93PiBiaW5kaW5nc1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBoYXZlIGEgY29tcHV0ZWQgdmFsdWUgJ1wiICsga2V5ICsgXCInIHRoYXQgY2xhc2hlcyB3aXRoIGEgcmVhZC1vbmx5IHByb3BlcnR5XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuZXJhdG9yLnJlYWRvbmx5LmFkZChrZXkpO1xuICAgICAgICAgICAgdmFyIGNvbmRpdGlvbiA9IFwiXCIgKyBkZXBzLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBcImNoYW5nZWQuXCIgKyBkZXA7IH0pLmpvaW4oJyB8fCAnKTtcbiAgICAgICAgICAgIHZhciBzdGF0ZW1lbnQgPSBcImlmIChAZGlmZmVycyhzdGF0ZS5cIiArIGtleSArIFwiLCAoc3RhdGUuXCIgKyBrZXkgKyBcIiA9ICVjb21wdXRlZC1cIiArIGtleSArIFwiKFwiICsgZGVwc1xuICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gXCJzdGF0ZS5cIiArIGRlcDsgfSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKSArIFwiKSkpKSBjaGFuZ2VkLlwiICsga2V5ICsgXCIgPSB0cnVlO1wiO1xuICAgICAgICAgICAgY29tcHV0YXRpb25CdWlsZGVyLmFkZENvbmRpdGlvbmFsKGNvbmRpdGlvbiwgc3RhdGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChnZW5lcmF0b3IuamF2YXNjcmlwdCkge1xuICAgICAgICBidWlsZGVyLmFkZEJsb2NrKGdlbmVyYXRvci5qYXZhc2NyaXB0KTtcbiAgICB9XG4gICAgaWYgKGdlbmVyYXRvci5uZWVkc0VuY2Fwc3VsYXRlSGVscGVyKSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdGZ1bmN0aW9uIEBlbmNhcHN1bGF0ZVN0eWxlcyhub2RlKSB7XFxuXFx0XFx0XFx0XFx0QHNldEF0dHJpYnV0ZShub2RlLCBcXFwiXCIsIFwiXFxcIiwgXFxcIlxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdGZ1bmN0aW9uIEBlbmNhcHN1bGF0ZVN0eWxlcyhub2RlKSB7XFxuXFx0XFx0XFx0XFx0QHNldEF0dHJpYnV0ZShub2RlLCBcXFwiXCIsIFwiXFxcIiwgXFxcIlxcXCIpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0pKSwgZ2VuZXJhdG9yLnN0eWxlc2hlZXQuaWQpKTtcbiAgICB9XG4gICAgdmFyIF9hID0gZ2VuZXJhdG9yLnN0eWxlc2hlZXQucmVuZGVyKG9wdGlvbnMuZmlsZW5hbWUsICFnZW5lcmF0b3IuY3VzdG9tRWxlbWVudCksIGNzcyA9IF9hLmNzcywgY3NzTWFwID0gX2EuY3NzTWFwO1xuICAgIHZhciBzdHlsZXMgPSBnZW5lcmF0b3Iuc3R5bGVzaGVldC5oYXNTdHlsZXMgJiYgc3RyaW5naWZ5KG9wdGlvbnMuZGV2ID9cbiAgICAgICAgY3NzICsgXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1cIiArIGNzc01hcC50b1VybCgpICsgXCIgKi9cIiA6XG4gICAgICAgIGNzcywgeyBvbmx5RXNjYXBlQXRTeW1ib2w6IHRydWUgfSk7XG4gICAgaWYgKHN0eWxlcyAmJiBnZW5lcmF0b3Iub3B0aW9ucy5jc3MgIT09IGZhbHNlICYmICFnZW5lcmF0b3IuY3VzdG9tRWxlbWVudCkge1xuICAgICAgICBidWlsZGVyLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzIgfHwgKHRlbXBsYXRlT2JqZWN0XzIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRmdW5jdGlvbiBAYWRkX2NzcygpIHtcXG5cXHRcXHRcXHRcXHR2YXIgc3R5bGUgPSBAY3JlYXRlRWxlbWVudChcXFwic3R5bGVcXFwiKTtcXG5cXHRcXHRcXHRcXHRzdHlsZS5pZCA9ICdcIiwgXCItc3R5bGUnO1xcblxcdFxcdFxcdFxcdHN0eWxlLnRleHRDb250ZW50ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdEBhcHBlbmROb2RlKHN0eWxlLCBkb2N1bWVudC5oZWFkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRmdW5jdGlvbiBAYWRkX2NzcygpIHtcXG5cXHRcXHRcXHRcXHR2YXIgc3R5bGUgPSBAY3JlYXRlRWxlbWVudChcXFwic3R5bGVcXFwiKTtcXG5cXHRcXHRcXHRcXHRzdHlsZS5pZCA9ICdcIiwgXCItc3R5bGUnO1xcblxcdFxcdFxcdFxcdHN0eWxlLnRleHRDb250ZW50ID0gXCIsIFwiO1xcblxcdFxcdFxcdFxcdEBhcHBlbmROb2RlKHN0eWxlLCBkb2N1bWVudC5oZWFkKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdKSksIGdlbmVyYXRvci5zdHlsZXNoZWV0LmlkLCBzdHlsZXMpKTtcbiAgICB9XG4gICAgZ2VuZXJhdG9yLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICBidWlsZGVyLmFkZEJsb2NrKGJsb2NrLnRvU3RyaW5nKCkpO1xuICAgIH0pO1xuICAgIHZhciBzaGFyZWRQYXRoID0gb3B0aW9ucy5zaGFyZWQgPT09IHRydWVcbiAgICAgICAgPyAnc3ZlbHRlL3NoYXJlZC5qcydcbiAgICAgICAgOiBvcHRpb25zLnNoYXJlZCB8fCAnJztcbiAgICB2YXIgcHJvdG90eXBlQmFzZSA9IG5hbWUgKyBcIi5wcm90b3R5cGVcIiArXG4gICAgICAgICh0ZW1wbGF0ZVByb3BlcnRpZXMubWV0aG9kcyA/IFwiLCAlbWV0aG9kc1wiIDogJycpO1xuICAgIHZhciBwcm90byA9IHNoYXJlZFBhdGhcbiAgICAgICAgPyBcIkBwcm90b1wiXG4gICAgICAgIDogZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMyB8fCAodGVtcGxhdGVPYmplY3RfMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdHtcXG5cXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHR9XCJdLCBbXCJcXG5cXHRcXHR7XFxuXFx0XFx0XFx0XCIsXG4gICAgICAgICAgICBcIlxcblxcdFxcdH1cIl0pKSwgWydkZXN0cm95JywgJ2dldCcsICdmaXJlJywgJ29ic2VydmUnLCAnb24nLCAnc2V0JywgJ3RlYXJkb3duJywgJ19zZXQnLCAnX21vdW50JywgJ191bm1vdW50J11cbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gKyBcIjogQFwiICsgKG4gPT09ICd0ZWFyZG93bicgPyAnZGVzdHJveScgOiBuKTsgfSlcbiAgICAgICAgICAgIC5qb2luKCcsXFxuJykpO1xuICAgIHZhciBkZWJ1Z05hbWUgPSBcIjxcIiArIChnZW5lcmF0b3IuY3VzdG9tRWxlbWVudCA/IGdlbmVyYXRvci50YWcgOiBuYW1lKSArIFwiPlwiO1xuICAgIC8vIGdlbmVyYXRlIGluaXRpYWwgc3RhdGUgb2JqZWN0XG4gICAgdmFyIGV4cGVjdGVkUHJvcGVydGllcyA9IEFycmF5LmZyb20oZ2VuZXJhdG9yLmV4cGVjdGVkUHJvcGVydGllcyk7XG4gICAgdmFyIGdsb2JhbHMgPSBleHBlY3RlZFByb3BlcnRpZXMuZmlsdGVyKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBnbG9iYWxXaGl0ZWxpc3QuaGFzKHByb3ApOyB9KTtcbiAgICB2YXIgc3RvcmVQcm9wcyA9IG9wdGlvbnMuc3RvcmUgfHwgdGVtcGxhdGVQcm9wZXJ0aWVzLnN0b3JlID8gZXhwZWN0ZWRQcm9wZXJ0aWVzLmZpbHRlcihmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gcHJvcFswXSA9PT0gJyQnOyB9KSA6IFtdO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSBbXTtcbiAgICBpZiAoZ2xvYmFscy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS5wdXNoKFwieyBcIiArIGdsb2JhbHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wICsgXCIgOiBcIiArIHByb3A7IH0pLmpvaW4oJywgJykgKyBcIiB9XCIpO1xuICAgIH1cbiAgICBpZiAoc3RvcmVQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS5wdXNoKFwidGhpcy5zdG9yZS5faW5pdChbXCIgKyBzdG9yZVByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gXCJcXFwiXCIgKyBwcm9wLnNsaWNlKDEpICsgXCJcXFwiXCI7IH0pICsgXCJdKVwiKTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlUHJvcGVydGllcy5kYXRhKSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS5wdXNoKFwiJWRhdGEoKVwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2xvYmFscy5sZW5ndGggPT09IDAgJiYgc3RvcmVQcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5pdGlhbFN0YXRlLnB1c2goJ3t9Jyk7XG4gICAgfVxuICAgIGluaXRpYWxTdGF0ZS5wdXNoKFwib3B0aW9ucy5kYXRhXCIpO1xuICAgIHZhciBjb25zdHJ1Y3RvckJvZHkgPSBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF80IHx8ICh0ZW1wbGF0ZU9iamVjdF80ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0QGluaXQodGhpcywgb3B0aW9ucyk7XFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0dGhpcy5fc3RhdGUgPSBAYXNzaWduKFwiLCBcIik7XFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0dGhpcy5fZnJhZ21lbnQgPSBAY3JlYXRlX21haW5fZnJhZ21lbnQodGhpcy5fc3RhdGUsIHRoaXMpO1xcblxcblxcdFxcdFwiLCBcIlxcblxcdFwiXSwgW1wiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFx0XFx0QGluaXQodGhpcywgb3B0aW9ucyk7XFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0dGhpcy5fc3RhdGUgPSBAYXNzaWduKFwiLCBcIik7XFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsIFwiXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0dGhpcy5fZnJhZ21lbnQgPSBAY3JlYXRlX21haW5fZnJhZ21lbnQodGhpcy5fc3RhdGUsIHRoaXMpO1xcblxcblxcdFxcdFwiLFxuICAgICAgICBcIlxcblxcdFwiXSkpLCBvcHRpb25zLmRldiAmJiBcInRoaXMuX2RlYnVnTmFtZSA9ICdcIiArIGRlYnVnTmFtZSArIFwiJztcIiwgb3B0aW9ucy5kZXYgJiYgIWdlbmVyYXRvci5jdXN0b21FbGVtZW50ICYmXG4gICAgICAgIFwiaWYgKCFvcHRpb25zIHx8ICghb3B0aW9ucy50YXJnZXQgJiYgIW9wdGlvbnMucm9vdCkpIHRocm93IG5ldyBFcnJvcihcXFwiJ3RhcmdldCcgaXMgYSByZXF1aXJlZCBvcHRpb25cXFwiKTtcIiwgdGVtcGxhdGVQcm9wZXJ0aWVzLnN0b3JlICYmIFwidGhpcy5zdG9yZSA9ICVzdG9yZSgpO1wiLCBnZW5lcmF0b3IudXNlc1JlZnMgJiYgXCJ0aGlzLnJlZnMgPSB7fTtcIiwgaW5pdGlhbFN0YXRlLmpvaW4oJywgJyksIHN0b3JlUHJvcHMubGVuZ3RoID4gMCAmJiBcInRoaXMuc3RvcmUuX2FkZCh0aGlzLCBbXCIgKyBzdG9yZVByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkgeyByZXR1cm4gXCJcXFwiXCIgKyBwcm9wLnNsaWNlKDEpICsgXCJcXFwiXCI7IH0pICsgXCJdKTtcIiwgZ2VuZXJhdG9yLm1ldGFCaW5kaW5ncywgY29tcHV0YXRpb25zLmxlbmd0aCAmJiBcInRoaXMuX3JlY29tcHV0ZSh7IFwiICsgQXJyYXkuZnJvbShjb21wdXRhdGlvbkRlcHMpLm1hcChmdW5jdGlvbiAoZGVwKSB7IHJldHVybiBkZXAgKyBcIjogMVwiOyB9KS5qb2luKCcsICcpICsgXCIgfSwgdGhpcy5fc3RhdGUpO1wiLCBvcHRpb25zLmRldiAmJlxuICAgICAgICBBcnJheS5mcm9tKGdlbmVyYXRvci5leHBlY3RlZFByb3BlcnRpZXMpLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiaWYgKCEoJ1wiICsgcHJvcCArIFwiJyBpbiB0aGlzLl9zdGF0ZSkpIGNvbnNvbGUud2FybihcXFwiXCIgKyBkZWJ1Z05hbWUgKyBcIiB3YXMgY3JlYXRlZCB3aXRob3V0IGV4cGVjdGVkIGRhdGEgcHJvcGVydHkgJ1wiICsgcHJvcCArIFwiJ1xcXCIpO1wiO1xuICAgICAgICB9KSwgZ2VuZXJhdG9yLmJpbmRpbmdHcm91cHMubGVuZ3RoICYmXG4gICAgICAgIFwidGhpcy5fYmluZGluZ0dyb3VwcyA9IFtcIiArIEFycmF5KGdlbmVyYXRvci5iaW5kaW5nR3JvdXBzLmxlbmd0aCkuZmlsbCgnW10nKS5qb2luKCcsICcpICsgXCJdO1wiLCAodGVtcGxhdGVQcm9wZXJ0aWVzLm9uZGVzdHJveSB8fCBzdG9yZVByb3BzLmxlbmd0aCkgJiYgKFwidGhpcy5faGFuZGxlcnMuZGVzdHJveSA9IFtcIiArIFt0ZW1wbGF0ZVByb3BlcnRpZXMub25kZXN0cm95ICYmIFwiJW9uZGVzdHJveVwiLCBzdG9yZVByb3BzLmxlbmd0aCAmJiBcIkByZW1vdmVGcm9tU3RvcmVcIl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJywgJykgKyBcIl07XCIpLCBnZW5lcmF0b3Iuc2xvdHMuc2l6ZSAmJiBcInRoaXMuX3Nsb3R0ZWQgPSBvcHRpb25zLnNsb3RzIHx8IHt9O1wiLCBnZW5lcmF0b3IuY3VzdG9tRWxlbWVudCA/IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzUgfHwgKHRlbXBsYXRlT2JqZWN0XzUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHR0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFwiXSkpLCBjc3MgJiYgXCJ0aGlzLnNoYWRvd1Jvb3QuaW5uZXJIVE1MID0gYDxzdHlsZT5cIiArIGVzY2FwZShjc3MsIHsgb25seUVzY2FwZUF0U3ltYm9sOiB0cnVlIH0pLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgKyAob3B0aW9ucy5kZXYgPyBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPVwiICsgY3NzTWFwLnRvVXJsKCkgKyBcIiAqL1wiIDogJycpICsgXCI8L3N0eWxlPmA7XCIpIDpcbiAgICAgICAgKGdlbmVyYXRvci5zdHlsZXNoZWV0Lmhhc1N0eWxlcyAmJiBvcHRpb25zLmNzcyAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgIFwiaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcXFwiXCIgKyBnZW5lcmF0b3Iuc3R5bGVzaGVldC5pZCArIFwiLXN0eWxlXFxcIikpIEBhZGRfY3NzKCk7XCIpLCB0ZW1wbGF0ZVByb3BlcnRpZXMub25jcmVhdGUgJiYgXCJ2YXIgX29uY3JlYXRlID0gJW9uY3JlYXRlLmJpbmQodGhpcyk7XCIsICh0ZW1wbGF0ZVByb3BlcnRpZXMub25jcmVhdGUgfHwgZ2VuZXJhdG9yLmhhc0NvbXBvbmVudHMgfHwgZ2VuZXJhdG9yLmhhc0NvbXBsZXhCaW5kaW5ncyB8fCBnZW5lcmF0b3IuaGFzSW50cm9UcmFuc2l0aW9ucykgJiYgZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNiB8fCAodGVtcGxhdGVPYmplY3RfNiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdGlmICghb3B0aW9ucy5yb290KSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fb25jcmVhdGUgPSBbXCIsIFwiXTtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHR9IFwiLCBcIlxcblxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0aWYgKCFvcHRpb25zLnJvb3QpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9vbmNyZWF0ZSA9IFtcIiwgXCJdO1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdH0gXCIsXG4gICAgICAgIFwiXFxuXFx0XFx0XCJdKSksIHRlbXBsYXRlUHJvcGVydGllcy5vbmNyZWF0ZSAmJiBcIl9vbmNyZWF0ZVwiLCAoZ2VuZXJhdG9yLmhhc0NvbXBvbmVudHMgfHwgZ2VuZXJhdG9yLmhhc0NvbXBsZXhCaW5kaW5ncykgJiYgXCJ0aGlzLl9iZWZvcmVjcmVhdGUgPSBbXTtcIiwgKGdlbmVyYXRvci5oYXNDb21wb25lbnRzIHx8IGdlbmVyYXRvci5oYXNJbnRyb1RyYW5zaXRpb25zKSAmJiBcInRoaXMuX2FmdGVyY3JlYXRlID0gW107XCIsIHRlbXBsYXRlUHJvcGVydGllcy5vbmNyZWF0ZSAmJiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF83IHx8ICh0ZW1wbGF0ZU9iamVjdF83ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yb290Ll9vbmNyZWF0ZS5wdXNoKF9vbmNyZWF0ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0ZWxzZSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yb290Ll9vbmNyZWF0ZS5wdXNoKF9vbmNyZWF0ZSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFwiXSkpKSksIGdlbmVyYXRvci5zbG90cy5zaXplICYmIFwidGhpcy5zbG90cyA9IHt9O1wiLCBnZW5lcmF0b3IuY3VzdG9tRWxlbWVudCA/IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzggfHwgKHRlbXBsYXRlT2JqZWN0XzggPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHR0aGlzLl9mcmFnbWVudC5jKCk7XFxuXFx0XFx0XFx0dGhpcy5fZnJhZ21lbnQuXCIsIFwiKHRoaXMuc2hhZG93Um9vdCwgbnVsbCk7XFxuXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMudGFyZ2V0KSB0aGlzLl9tb3VudChvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IgfHwgbnVsbCk7XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHR0aGlzLl9mcmFnbWVudC5jKCk7XFxuXFx0XFx0XFx0dGhpcy5fZnJhZ21lbnQuXCIsIFwiKHRoaXMuc2hhZG93Um9vdCwgbnVsbCk7XFxuXFxuXFx0XFx0XFx0aWYgKG9wdGlvbnMudGFyZ2V0KSB0aGlzLl9tb3VudChvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IgfHwgbnVsbCk7XFxuXFx0XFx0XCJdKSksIGJsb2NrLmhhc0ludHJvTWV0aG9kID8gJ2knIDogJ20nKSA6IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzkgfHwgKHRlbXBsYXRlT2JqZWN0XzkgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRpZiAob3B0aW9ucy50YXJnZXQpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR0aGlzLl9mcmFnbWVudC5cIiwgXCIob3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yIHx8IG51bGwpO1xcblxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdGlmIChvcHRpb25zLnRhcmdldCkge1xcblxcdFxcdFxcdFxcdFwiLFxuICAgICAgICBcIlxcblxcdFxcdFxcdFxcdHRoaXMuX2ZyYWdtZW50LlwiLCBcIihvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IgfHwgbnVsbCk7XFxuXFxuXFx0XFx0XFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSkpLCBnZW5lcmF0b3IuaHlkcmF0YWJsZVxuICAgICAgICA/IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEwIHx8ICh0ZW1wbGF0ZU9iamVjdF8xMCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBub2RlcyA9IEBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b3B0aW9ucy5oeWRyYXRlID8gdGhpcy5fZnJhZ21lbnQubChub2RlcykgOiB0aGlzLl9mcmFnbWVudC5jKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9kZXMuZm9yRWFjaChAZGV0YWNoTm9kZSk7XFxuXFx0XFx0XFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbm9kZXMgPSBAY2hpbGRyZW4ob3B0aW9ucy50YXJnZXQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG9wdGlvbnMuaHlkcmF0ZSA/IHRoaXMuX2ZyYWdtZW50Lmwobm9kZXMpIDogdGhpcy5fZnJhZ21lbnQuYygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdG5vZGVzLmZvckVhY2goQGRldGFjaE5vZGUpO1xcblxcdFxcdFxcdFxcdFxcdFwiXSkpKSA6IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzExIHx8ICh0ZW1wbGF0ZU9iamVjdF8xMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2ZyYWdtZW50LmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2ZyYWdtZW50LmMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIl0pKSwgb3B0aW9ucy5kZXYgJiYgXCJpZiAob3B0aW9ucy5oeWRyYXRlKSB0aHJvdyBuZXcgRXJyb3IoXFxcIm9wdGlvbnMuaHlkcmF0ZSBvbmx5IHdvcmtzIGlmIHRoZSBjb21wb25lbnQgd2FzIGNvbXBpbGVkIHdpdGggdGhlIGBoeWRyYXRhYmxlOiB0cnVlYCBvcHRpb25cXFwiKTtcIiksIGJsb2NrLmhhc0ludHJvTWV0aG9kID8gJ2knIDogJ20nLCAoZ2VuZXJhdG9yLmhhc0NvbXBvbmVudHMgfHwgZ2VuZXJhdG9yLmhhc0NvbXBsZXhCaW5kaW5ncyB8fCB0ZW1wbGF0ZVByb3BlcnRpZXMub25jcmVhdGUgfHwgZ2VuZXJhdG9yLmhhc0ludHJvVHJhbnNpdGlvbnMpICYmIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzEyIHx8ICh0ZW1wbGF0ZU9iamVjdF8xMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0XCJdKSksIGdlbmVyYXRvci5oYXNDb21wb25lbnRzICYmIFwidGhpcy5fbG9jayA9IHRydWU7XCIsIChnZW5lcmF0b3IuaGFzQ29tcG9uZW50cyB8fCBnZW5lcmF0b3IuaGFzQ29tcGxleEJpbmRpbmdzKSAmJiBcIkBjYWxsQWxsKHRoaXMuX2JlZm9yZWNyZWF0ZSk7XCIsIChnZW5lcmF0b3IuaGFzQ29tcG9uZW50cyB8fCB0ZW1wbGF0ZVByb3BlcnRpZXMub25jcmVhdGUpICYmIFwiQGNhbGxBbGwodGhpcy5fb25jcmVhdGUpO1wiLCAoZ2VuZXJhdG9yLmhhc0NvbXBvbmVudHMgfHwgZ2VuZXJhdG9yLmhhc0ludHJvVHJhbnNpdGlvbnMpICYmIFwiQGNhbGxBbGwodGhpcy5fYWZ0ZXJjcmVhdGUpO1wiLCBnZW5lcmF0b3IuaGFzQ29tcG9uZW50cyAmJiBcInRoaXMuX2xvY2sgPSBmYWxzZTtcIikpKTtcbiAgICBpZiAoZ2VuZXJhdG9yLmN1c3RvbUVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHByb3BzID0gZ2VuZXJhdG9yLnByb3BzIHx8IEFycmF5LmZyb20oZ2VuZXJhdG9yLmV4cGVjdGVkUHJvcGVydGllcyk7XG4gICAgICAgIGJ1aWxkZXIuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTMgfHwgKHRlbXBsYXRlT2JqZWN0XzEzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0Y2xhc3MgXCIsIFwiIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xcblxcdFxcdFxcdFxcdGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xcblxcdFxcdFxcdFxcdFxcdHN1cGVyKCk7XFxuXFx0XFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBcIiwgXCI7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhhdHRyLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNldCh7IFthdHRyXTogbmV3VmFsdWUgfSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjdXN0b21FbGVtZW50cy5kZWZpbmUoXFxcIlwiLCBcIlxcXCIsIFwiLCBcIik7XFxuXFx0XFx0XFx0QGFzc2lnbihcIiwgXCIsIFwiLCBcIiwge1xcblxcdFxcdFxcdFxcdF9tb3VudCh0YXJnZXQsIGFuY2hvcikge1xcblxcdFxcdFxcdFxcdFxcdHRhcmdldC5pbnNlcnRCZWZvcmUodGhpcywgYW5jaG9yKTtcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdF91bm1vdW50KCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRjbGFzcyBcIiwgXCIgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XFxuXFx0XFx0XFx0XFx0Y29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XFxuXFx0XFx0XFx0XFx0XFx0c3VwZXIoKTtcXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFwiLCBcIjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XCIsXG4gICAgICAgICAgICBcIlxcblxcblxcdFxcdFxcdFxcdFwiLFxuICAgICAgICAgICAgXCJcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYXR0ciwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zZXQoeyBbYXR0cl06IG5ld1ZhbHVlIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Y3VzdG9tRWxlbWVudHMuZGVmaW5lKFxcXCJcIiwgXCJcXFwiLCBcIiwgXCIpO1xcblxcdFxcdFxcdEBhc3NpZ24oXCIsIFwiLCBcIiwgXCIsIHtcXG5cXHRcXHRcXHRcXHRfbW91bnQodGFyZ2V0LCBhbmNob3IpIHtcXG5cXHRcXHRcXHRcXHRcXHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHRoaXMsIGFuY2hvcik7XFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRfdW5tb3VudCgpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdFwiXSkpLCBuYW1lLCBjb25zdHJ1Y3RvckJvZHksIEpTT04uc3RyaW5naWZ5KHByb3BzKSwgcHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xNCB8fCAodGVtcGxhdGVPYmplY3RfMTQgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRnZXQgXCIsIFwiKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmdldCgnXCIsIFwiJyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHNldCBcIiwgXCIodmFsdWUpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNldCh7IFwiLCBcIjogdmFsdWUgfSk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFwiXSwgW1wiXFxuXFx0XFx0XFx0XFx0XFx0Z2V0IFwiLCBcIigpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXQoJ1wiLCBcIicpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRzZXQgXCIsIFwiKHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5zZXQoeyBcIiwgXCI6IHZhbHVlIH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcIl0pKSwgcHJvcCwgcHJvcCwgcHJvcCwgcHJvcCk7IH0pLmpvaW4oJ1xcblxcbicpLCBnZW5lcmF0b3Iuc2xvdHMuc2l6ZSAmJiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xNSB8fCAodGVtcGxhdGVPYmplY3RfMTUgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRcXHRjb25uZWN0ZWRDYWxsYmFjaygpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRPYmplY3Qua2V5cyh0aGlzLl9zbG90dGVkKS5mb3JFYWNoKGtleSA9PiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5hcHBlbmRDaGlsZCh0aGlzLl9zbG90dGVkW2tleV0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdH1cIl0sIFtcIlxcblxcdFxcdFxcdFxcdFxcdGNvbm5lY3RlZENhbGxiYWNrKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdE9iamVjdC5rZXlzKHRoaXMuX3Nsb3R0ZWQpLmZvckVhY2goa2V5ID0+IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmFwcGVuZENoaWxkKHRoaXMuX3Nsb3R0ZWRba2V5XSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0fVwiXSkpKSwgZ2VuZXJhdG9yLnRhZywgbmFtZSwgcHJvdG90eXBlQmFzZSwgcHJvdG8pKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1aWxkZXIuYWRkQmxvY2soZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMTYgfHwgKHRlbXBsYXRlT2JqZWN0XzE2ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0ZnVuY3Rpb24gXCIsIFwiKG9wdGlvbnMpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0QGFzc2lnbihcIiwgXCIsIFwiLCBcIik7XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRmdW5jdGlvbiBcIiwgXCIob3B0aW9ucykge1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRAYXNzaWduKFwiLCBcIiwgXCIsIFwiKTtcXG5cXHRcXHRcIl0pKSwgbmFtZSwgY29uc3RydWN0b3JCb2R5LCBwcm90b3R5cGVCYXNlLCBwcm90bykpO1xuICAgIH1cbiAgICBidWlsZGVyLmFkZEJsb2NrKGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE3IHx8ICh0ZW1wbGF0ZU9iamVjdF8xNyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiLCBcIlxcblxcdFwiXSwgW1wiXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0XCIsIFwiXFxuXFx0XCJdKSksIG9wdGlvbnMuZGV2ICYmIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE4IHx8ICh0ZW1wbGF0ZU9iamVjdF8xOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFwiLCBcIi5wcm90b3R5cGUuX2NoZWNrUmVhZE9ubHkgPSBmdW5jdGlvbiBfY2hlY2tSZWFkT25seShuZXdTdGF0ZSkge1xcblxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdH07XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcIiwgXCIucHJvdG90eXBlLl9jaGVja1JlYWRPbmx5ID0gZnVuY3Rpb24gX2NoZWNrUmVhZE9ubHkobmV3U3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRcIixcbiAgICAgICAgXCJcXG5cXHRcXHRcXHR9O1xcblxcdFxcdFwiXSkpLCBuYW1lLCBBcnJheS5mcm9tKGdlbmVyYXRvci5yZWFkb25seSkubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBcImlmICgnXCIgKyBwcm9wICsgXCInIGluIG5ld1N0YXRlICYmICF0aGlzLl91cGRhdGluZ1JlYWRvbmx5UHJvcGVydHkpIHRocm93IG5ldyBFcnJvcihcXFwiXCIgKyBkZWJ1Z05hbWUgKyBcIjogQ2Fubm90IHNldCByZWFkLW9ubHkgcHJvcGVydHkgJ1wiICsgcHJvcCArIFwiJ1xcXCIpO1wiO1xuICAgIH0pKSwgY29tcHV0YXRpb25zLmxlbmd0aCA/IGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzE5IHx8ICh0ZW1wbGF0ZU9iamVjdF8xOSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFwiLCBcIi5wcm90b3R5cGUuX3JlY29tcHV0ZSA9IGZ1bmN0aW9uIF9yZWNvbXB1dGUoY2hhbmdlZCwgc3RhdGUpIHtcXG5cXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcIiwgXCIucHJvdG90eXBlLl9yZWNvbXB1dGUgPSBmdW5jdGlvbiBfcmVjb21wdXRlKGNoYW5nZWQsIHN0YXRlKSB7XFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0fVxcblxcdFxcdFwiXSkpLCBuYW1lLCBjb21wdXRhdGlvbkJ1aWxkZXIpIDogKCFzaGFyZWRQYXRoICYmIG5hbWUgKyBcIi5wcm90b3R5cGUuX3JlY29tcHV0ZSA9IEBub29wO1wiKSwgdGVtcGxhdGVQcm9wZXJ0aWVzLnNldHVwICYmIFwiJXNldHVwKFwiICsgbmFtZSArIFwiKTtcIiwgdGVtcGxhdGVQcm9wZXJ0aWVzLnByZWxvYWQgJiYgbmFtZSArIFwiLnByZWxvYWQgPSAlcHJlbG9hZDtcIikpO1xuICAgIHZhciB1c2VkSGVscGVycyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcmVzdWx0ID0gYnVpbGRlclxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAucmVwbGFjZSgvKCUrfEArKShcXHcqKD86LVxcdyopPykvZywgZnVuY3Rpb24gKG1hdGNoLCBzaWdpbCwgbmFtZSkge1xuICAgICAgICBpZiAoc2lnaWwgPT09ICdAJykge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gc2hhcmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGV2ICYmIG5hbWUgKyBcIkRldlwiIGluIHNoYXJlZClcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IG5hbWUgKyBcIkRldlwiO1xuICAgICAgICAgICAgICAgIHVzZWRIZWxwZXJzLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0b3IuYWxpYXMobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ2lsID09PSAnJScpIHtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0b3IudGVtcGxhdGVWYXJzLmdldChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2lnaWwuc2xpY2UoMSkgKyBuYW1lO1xuICAgIH0pO1xuICAgIHZhciBoZWxwZXJzO1xuICAgIGlmIChzaGFyZWRQYXRoKSB7XG4gICAgICAgIGlmIChmb3JtYXQgIT09ICdlcycgJiYgZm9ybWF0ICE9PSAnY2pzJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29tcG9uZW50cyB3aXRoIHNoYXJlZCBoZWxwZXJzIG11c3QgYmUgY29tcGlsZWQgd2l0aCBgZm9ybWF0OiAnZXMnYCBvciBgZm9ybWF0OiAnY2pzJ2BcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZWQgPSBBcnJheS5mcm9tKHVzZWRIZWxwZXJzKS5zb3J0KCk7XG4gICAgICAgIGhlbHBlcnMgPSB1c2VkLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGFsaWFzID0gZ2VuZXJhdG9yLmFsaWFzKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgbmFtZTogbmFtZSwgYWxpYXM6IGFsaWFzIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGlubGluZUhlbHBlcnNfMSA9ICcnO1xuICAgICAgICB1c2VkSGVscGVycy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBzaGFyZWRba2V5XTtcbiAgICAgICAgICAgIHZhciBjb2RlID0gbmV3IE1hZ2ljU3RyaW5nJDEoc3RyKTtcbiAgICAgICAgICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VFeHByZXNzaW9uQXQoc3RyLCAwKTtcbiAgICAgICAgICAgIHZhciBzY29wZSA9IGFubm90YXRlV2l0aFNjb3BlcyhleHByZXNzaW9uKTtcbiAgICAgICAgICAgIHdhbGsoZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSwgcGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLl9zY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlID0gbm9kZS5fc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdJZGVudGlmaWVyJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZWZlcmVuY2Uobm9kZSwgcGFyZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXNjb3BlLmhhcyhub2RlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lIGluIHNoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGRlcGVuZHMgb24gYW5vdGhlciBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVwZW5kZW5jeSA9IG5vZGUubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkSGVscGVycy5hZGQoZGVwZW5kZW5jeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFsaWFzID0gZ2VuZXJhdG9yLmFsaWFzKGRlcGVuZGVuY3kpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGlhcyAhPT0gbm9kZS5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShub2RlLnN0YXJ0LCBub2RlLmVuZCwgYWxpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuX3Njb3BlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBzY29wZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAndHJhbnNpdGlvbk1hbmFnZXInKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BlY2lhbCBjYXNlXG4gICAgICAgICAgICAgICAgdmFyIGdsb2JhbCA9IFwiX3N2ZWx0ZVRyYW5zaXRpb25NYW5hZ2VyXCI7XG4gICAgICAgICAgICAgICAgaW5saW5lSGVscGVyc18xICs9IFwiXFxuXFxudmFyIFwiICsgZ2VuZXJhdG9yLmFsaWFzKCd0cmFuc2l0aW9uTWFuYWdlcicpICsgXCIgPSB3aW5kb3cuXCIgKyBnbG9iYWwgKyBcIiB8fCAod2luZG93LlwiICsgZ2xvYmFsICsgXCIgPSBcIiArIGNvZGUgKyBcIik7XFxuXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXMgPSBnZW5lcmF0b3IuYWxpYXMoZXhwcmVzc2lvbi5pZC5uYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoYWxpYXMgIT09IGV4cHJlc3Npb24uaWQubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUoZXhwcmVzc2lvbi5pZC5zdGFydCwgZXhwcmVzc2lvbi5pZC5lbmQsIGFsaWFzKTtcbiAgICAgICAgICAgICAgICBpbmxpbmVIZWxwZXJzXzEgKz0gXCJcXG5cXG5cIiArIGNvZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQgKz0gaW5saW5lSGVscGVyc18xO1xuICAgIH1cbiAgICB2YXIgZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lICYmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmZpbGVuYW1lLnJlcGxhY2UocHJvY2Vzcy5jd2QoKSwgJycpLnJlcGxhY2UoL15bXFwvXFxcXF0vLCAnJykgOiBvcHRpb25zLmZpbGVuYW1lKTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yLmdlbmVyYXRlKHJlc3VsdCwgb3B0aW9ucywge1xuICAgICAgICBiYW5uZXI6IFwiLyogXCIgKyAoZmlsZW5hbWUgPyBmaWxlbmFtZSArIFwiIFwiIDogXCJcIikgKyBcImdlbmVyYXRlZCBieSBTdmVsdGUgdlwiICsgXCIxLjQ5LjBcIiArIFwiICovXCIsXG4gICAgICAgIHNoYXJlZFBhdGg6IHNoYXJlZFBhdGgsXG4gICAgICAgIGhlbHBlcnM6IGhlbHBlcnMsXG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGZvcm1hdDogZm9ybWF0XG4gICAgfSk7XG59XG52YXIgdGVtcGxhdGVPYmplY3RfMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8yO1xudmFyIHRlbXBsYXRlT2JqZWN0XzM7XG52YXIgdGVtcGxhdGVPYmplY3RfNTtcbnZhciB0ZW1wbGF0ZU9iamVjdF83O1xudmFyIHRlbXBsYXRlT2JqZWN0XzY7XG52YXIgdGVtcGxhdGVPYmplY3RfODtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMDtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMTtcbnZhciB0ZW1wbGF0ZU9iamVjdF8xMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF85O1xudmFyIHRlbXBsYXRlT2JqZWN0XzQ7XG52YXIgdGVtcGxhdGVPYmplY3RfMTQ7XG52YXIgdGVtcGxhdGVPYmplY3RfMTU7XG52YXIgdGVtcGxhdGVPYmplY3RfMTM7XG52YXIgdGVtcGxhdGVPYmplY3RfMTY7XG52YXIgdGVtcGxhdGVPYmplY3RfMTg7XG52YXIgdGVtcGxhdGVPYmplY3RfMTk7XG52YXIgdGVtcGxhdGVPYmplY3RfMTc7XG5cbnZhciBCbG9jayQzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJsb2NrKG9wdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgQmxvY2sucHJvdG90eXBlLmFkZEJpbmRpbmcgPSBmdW5jdGlvbiAoYmluZGluZywgbmFtZSkge1xuICAgICAgICB2YXIgY29uZGl0aW9ucyA9IFtcIiEoJ1wiICsgYmluZGluZy5uYW1lICsgXCInIGluIHN0YXRlKVwiXS5jb25jYXQoXG4gICAgICAgIC8vIFRPRE8gaGFuZGxlIGNvbnRleHR1YWwgYmluZGluZ3MuLi5cbiAgICAgICAgdGhpcy5jb25kaXRpb25zLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gXCIoXCIgKyBjICsgXCIpXCI7IH0pKTtcbiAgICAgICAgdmFyIHByb3AgPSBnZXRPYmplY3QoYmluZGluZy52YWx1ZSkubmFtZTtcbiAgICAgICAgdGhpcy5nZW5lcmF0b3IuYmluZGluZ3MucHVzaChkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8xJDE0IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDE0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0aWYgKFwiLCBcIikge1xcblxcdFxcdFxcdFxcdHRtcCA9IFwiLCBcIi5kYXRhKCk7XFxuXFx0XFx0XFx0XFx0aWYgKCdcIiwgXCInIGluIHRtcCkge1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLlwiLCBcIiA9IHRtcC5cIiwgXCI7XFxuXFx0XFx0XFx0XFx0XFx0c2V0dGxlZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRpZiAoXCIsIFwiKSB7XFxuXFx0XFx0XFx0XFx0dG1wID0gXCIsIFwiLmRhdGEoKTtcXG5cXHRcXHRcXHRcXHRpZiAoJ1wiLCBcIicgaW4gdG1wKSB7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuXCIsIFwiID0gdG1wLlwiLCBcIjtcXG5cXHRcXHRcXHRcXHRcXHRzZXR0bGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcIl0pKSwgY29uZGl0aW9ucy5qb2luKCcmJicpLCBuYW1lLCBwcm9wLCBiaW5kaW5nLm5hbWUsIHByb3ApKTtcbiAgICB9O1xuICAgIEJsb2NrLnByb3RvdHlwZS5jaGlsZCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmxvY2soT2JqZWN0LmFzc2lnbih7fSwgdGhpcywgb3B0aW9ucywgeyBwYXJlbnQ6IHRoaXMgfSkpO1xuICAgIH07XG4gICAgQmxvY2sucHJvdG90eXBlLmNvbnRleHR1YWxpc2UgPSBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgY29udGV4dCwgaXNFdmVudEhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdG9yLmNvbnRleHR1YWxpc2UodGhpcy5jb250ZXh0cywgdGhpcy5pbmRleGVzLCBleHByZXNzaW9uLCBjb250ZXh0LCBpc0V2ZW50SGFuZGxlcik7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2s7XG59KCkpO1xudmFyIHRlbXBsYXRlT2JqZWN0XzEkMTQ7XG5cbmZ1bmN0aW9uIHZpc2l0QXdhaXRCbG9jayhnZW5lcmF0b3IsIGJsb2NrLCBub2RlKSB7XG4gICAgYmxvY2suY29udGV4dHVhbGlzZShub2RlLmV4cHJlc3Npb24pO1xuICAgIHZhciBfYSA9IG5vZGUubWV0YWRhdGEsIGRlcGVuZGVuY2llcyA9IF9hLmRlcGVuZGVuY2llcywgc25pcHBldCA9IF9hLnNuaXBwZXQ7XG4gICAgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSB0aGUgZ2VuZXJhdG9yJ3Mgam9iPyBJdCdzIGR1cGxpY2F0ZWQgYmV0d2VlblxuICAgIC8vIGhlcmUgYW5kIHRoZSBlcXVpdmFsZW50IERPTSBjb21waWxlciB2aXNpdG9yXG4gICAgdmFyIGNvbnRleHRzID0gbmV3IE1hcChibG9jay5jb250ZXh0cyk7XG4gICAgY29udGV4dHMuc2V0KG5vZGUudmFsdWUsICdfX3ZhbHVlJyk7XG4gICAgdmFyIGNvbnRleHREZXBlbmRlbmNpZXMgPSBuZXcgTWFwKGJsb2NrLmNvbnRleHREZXBlbmRlbmNpZXMpO1xuICAgIGNvbnRleHREZXBlbmRlbmNpZXMuc2V0KG5vZGUudmFsdWUsIGRlcGVuZGVuY2llcyk7XG4gICAgdmFyIGNoaWxkQmxvY2sgPSBibG9jay5jaGlsZCh7XG4gICAgICAgIGNvbnRleHREZXBlbmRlbmNpZXM6IGNvbnRleHREZXBlbmRlbmNpZXMsXG4gICAgICAgIGNvbnRleHRzOiBjb250ZXh0c1xuICAgIH0pO1xuICAgIGdlbmVyYXRvci5hcHBlbmQoJyR7KGZ1bmN0aW9uKF9fdmFsdWUpIHsgaWYoX19pc1Byb21pc2UoX192YWx1ZSkpIHJldHVybiBgJyk7XG4gICAgbm9kZS5wZW5kaW5nLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZpc2l0JDEoZ2VuZXJhdG9yLCBjaGlsZEJsb2NrLCBjaGlsZCk7XG4gICAgfSk7XG4gICAgZ2VuZXJhdG9yLmFwcGVuZCgnYDsgcmV0dXJuIGAnKTtcbiAgICBub2RlLnRoZW4uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmlzaXQkMShnZW5lcmF0b3IsIGNoaWxkQmxvY2ssIGNoaWxkKTtcbiAgICB9KTtcbiAgICBnZW5lcmF0b3IuYXBwZW5kKFwiYDt9KFwiICsgc25pcHBldCArIFwiKSkgfVwiKTtcbn1cblxuZnVuY3Rpb24gdmlzaXRDb21tZW50KCkge1xuICAgIC8vIGRvIG5vdGhpbmdcbn1cblxuZnVuY3Rpb24gdmlzaXRDb21wb25lbnQoZ2VuZXJhdG9yLCBibG9jaywgbm9kZSkge1xuICAgIGZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJpYnV0ZShjaHVuaykge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gJ1RleHQnKVxuICAgICAgICAgICAgcmV0dXJuIGNodW5rLmRhdGE7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSAnTXVzdGFjaGVUYWcnKSB7XG4gICAgICAgICAgICBibG9jay5jb250ZXh0dWFsaXNlKGNodW5rLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgdmFyIHNuaXBwZXQgPSBjaHVuay5tZXRhZGF0YS5zbmlwcGV0O1xuICAgICAgICAgICAgcmV0dXJuICcke19fZXNjYXBlKCAnICsgc25pcHBldCArICcpfSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBbXTtcbiAgICB2YXIgYmluZGluZ3MgPSBbXTtcbiAgICBub2RlLmF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGUudHlwZSA9PT0gJ0F0dHJpYnV0ZScpIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucHVzaChhdHRyaWJ1dGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF0dHJpYnV0ZS50eXBlID09PSAnQmluZGluZycpIHtcbiAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goYXR0cmlidXRlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBwcm9wcyA9IGF0dHJpYnV0ZXNcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPSBcInRydWVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IFwiJydcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdHRyaWJ1dGUudmFsdWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB2YXIgY2h1bmsgPSBhdHRyaWJ1dGUudmFsdWVbMF07XG4gICAgICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gJ1RleHQnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpc05hTihjaHVuay5kYXRhKSA/IHN0cmluZ2lmeShjaHVuay5kYXRhKSA6IGNodW5rLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBibG9jay5jb250ZXh0dWFsaXNlKGNodW5rLmV4cHJlc3Npb24pO1xuICAgICAgICAgICAgICAgIHZhciBzbmlwcGV0ID0gY2h1bmsubWV0YWRhdGEuc25pcHBldDtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNuaXBwZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICdgJyArIGF0dHJpYnV0ZS52YWx1ZS5tYXAoc3RyaW5naWZ5QXR0cmlidXRlKS5qb2luKCcnKSArICdgJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0cmlidXRlLm5hbWUgKyBcIjogXCIgKyB2YWx1ZTtcbiAgICB9KVxuICAgICAgICAuY29uY2F0KGJpbmRpbmdzLm1hcChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICB2YXIgbmFtZSA9IGdldE9iamVjdChiaW5kaW5nLnZhbHVlKS5uYW1lO1xuICAgICAgICB2YXIgdGFpbCA9IGJpbmRpbmcudmFsdWUudHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nXG4gICAgICAgICAgICA/IGdldFRhaWxTbmlwcGV0KGJpbmRpbmcudmFsdWUpXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICB2YXIga2V5cGF0aCA9IGJsb2NrLmNvbnRleHRzLmhhcyhuYW1lKVxuICAgICAgICAgICAgPyBcIlwiICsgbmFtZSArIHRhaWxcbiAgICAgICAgICAgIDogXCJzdGF0ZS5cIiArIG5hbWUgKyB0YWlsO1xuICAgICAgICByZXR1cm4gYmluZGluZy5uYW1lICsgXCI6IFwiICsga2V5cGF0aDtcbiAgICB9KSlcbiAgICAgICAgLmpvaW4oJywgJyk7XG4gICAgdmFyIGlzRHluYW1pY0NvbXBvbmVudCA9IG5vZGUubmFtZSA9PT0gJzpDb21wb25lbnQnO1xuICAgIGlmIChpc0R5bmFtaWNDb21wb25lbnQpXG4gICAgICAgIGJsb2NrLmNvbnRleHR1YWxpc2Uobm9kZS5leHByZXNzaW9uKTtcbiAgICB2YXIgZXhwcmVzc2lvbiA9IChub2RlLm5hbWUgPT09ICc6U2VsZicgPyBnZW5lcmF0b3IubmFtZSA6XG4gICAgICAgIGlzRHluYW1pY0NvbXBvbmVudCA/IFwiKChcIiArIG5vZGUubWV0YWRhdGEuc25pcHBldCArIFwiKSB8fCBfX21pc3NpbmdDb21wb25lbnQpXCIgOlxuICAgICAgICAgICAgXCIlY29tcG9uZW50cy1cIiArIG5vZGUubmFtZSk7XG4gICAgYmluZGluZ3MuZm9yRWFjaChmdW5jdGlvbiAoYmluZGluZykge1xuICAgICAgICBibG9jay5hZGRCaW5kaW5nKGJpbmRpbmcsIGV4cHJlc3Npb24pO1xuICAgIH0pO1xuICAgIHZhciBvcGVuID0gXCIke1wiICsgZXhwcmVzc2lvbiArIFwiLl9yZW5kZXIoX19yZXN1bHQsIHtcIiArIHByb3BzICsgXCJ9XCI7XG4gICAgdmFyIG9wdGlvbnMgPSBbXTtcbiAgICBpZiAoZ2VuZXJhdG9yLm9wdGlvbnMuc3RvcmUpIHtcbiAgICAgICAgb3B0aW9ucy5wdXNoKFwic3RvcmU6IG9wdGlvbnMuc3RvcmVcIik7XG4gICAgfVxuICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB2YXIgYXBwZW5kVGFyZ2V0XzEgPSB7XG4gICAgICAgICAgICBzbG90czogeyBcImRlZmF1bHRcIjogJycgfSxcbiAgICAgICAgICAgIHNsb3RTdGFjazogWydkZWZhdWx0J11cbiAgICAgICAgfTtcbiAgICAgICAgZ2VuZXJhdG9yLmFwcGVuZFRhcmdldHMucHVzaChhcHBlbmRUYXJnZXRfMSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZpc2l0JDEoZ2VuZXJhdG9yLCBibG9jaywgY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNsb3R0ZWQgPSBPYmplY3Qua2V5cyhhcHBlbmRUYXJnZXRfMS5zbG90cylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG5hbWUgKyBcIjogKCkgPT4gYFwiICsgYXBwZW5kVGFyZ2V0XzEuc2xvdHNbbmFtZV0gKyBcImBcIjsgfSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICBvcHRpb25zLnB1c2goXCJzbG90dGVkOiB7IFwiICsgc2xvdHRlZCArIFwiIH1cIik7XG4gICAgICAgIGdlbmVyYXRvci5hcHBlbmRUYXJnZXRzLnBvcCgpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgb3BlbiArPSBcIiwgeyBcIiArIG9wdGlvbnMuam9pbignLCAnKSArIFwiIH1cIjtcbiAgICB9XG4gICAgZ2VuZXJhdG9yLmFwcGVuZChvcGVuKTtcbiAgICBnZW5lcmF0b3IuYXBwZW5kKCcpfScpO1xufVxuXG5mdW5jdGlvbiB2aXNpdEVhY2hCbG9jayhnZW5lcmF0b3IsIGJsb2NrLCBub2RlKSB7XG4gICAgYmxvY2suY29udGV4dHVhbGlzZShub2RlLmV4cHJlc3Npb24pO1xuICAgIHZhciBfYSA9IG5vZGUubWV0YWRhdGEsIGRlcGVuZGVuY2llcyA9IF9hLmRlcGVuZGVuY2llcywgc25pcHBldCA9IF9hLnNuaXBwZXQ7XG4gICAgdmFyIG9wZW4gPSBcIiR7IFwiICsgKG5vZGVbXCJlbHNlXCJdID8gc25pcHBldCArIFwiLmxlbmd0aCA/IFwiIDogJycpICsgc25pcHBldCArIFwiLm1hcChcIiArIChub2RlLmluZGV4ID8gXCIoXCIgKyBub2RlLmNvbnRleHQgKyBcIiwgXCIgKyBub2RlLmluZGV4ICsgXCIpXCIgOiBub2RlLmNvbnRleHQpICsgXCIgPT4gYFwiO1xuICAgIGdlbmVyYXRvci5hcHBlbmQob3Blbik7XG4gICAgLy8gVE9ETyBzaG91bGQgdGhpcyBiZSB0aGUgZ2VuZXJhdG9yJ3Mgam9iPyBJdCdzIGR1cGxpY2F0ZWQgYmV0d2VlblxuICAgIC8vIGhlcmUgYW5kIHRoZSBlcXVpdmFsZW50IERPTSBjb21waWxlciB2aXNpdG9yXG4gICAgdmFyIGNvbnRleHRzID0gbmV3IE1hcChibG9jay5jb250ZXh0cyk7XG4gICAgY29udGV4dHMuc2V0KG5vZGUuY29udGV4dCwgbm9kZS5jb250ZXh0KTtcbiAgICB2YXIgaW5kZXhlcyA9IG5ldyBNYXAoYmxvY2suaW5kZXhlcyk7XG4gICAgaWYgKG5vZGUuaW5kZXgpXG4gICAgICAgIGluZGV4ZXMuc2V0KG5vZGUuaW5kZXgsIG5vZGUuY29udGV4dCk7XG4gICAgdmFyIGNvbnRleHREZXBlbmRlbmNpZXMgPSBuZXcgTWFwKGJsb2NrLmNvbnRleHREZXBlbmRlbmNpZXMpO1xuICAgIGNvbnRleHREZXBlbmRlbmNpZXMuc2V0KG5vZGUuY29udGV4dCwgZGVwZW5kZW5jaWVzKTtcbiAgICBpZiAobm9kZS5kZXN0cnVjdHVyZWRDb250ZXh0cykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuZGVzdHJ1Y3R1cmVkQ29udGV4dHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnRleHRzLnNldChub2RlLmRlc3RydWN0dXJlZENvbnRleHRzW2ldLCBub2RlLmNvbnRleHQgKyBcIltcIiArIGkgKyBcIl1cIik7XG4gICAgICAgICAgICBjb250ZXh0RGVwZW5kZW5jaWVzLnNldChub2RlLmRlc3RydWN0dXJlZENvbnRleHRzW2ldLCBkZXBlbmRlbmNpZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBjaGlsZEJsb2NrID0gYmxvY2suY2hpbGQoe1xuICAgICAgICBjb250ZXh0czogY29udGV4dHMsXG4gICAgICAgIGluZGV4ZXM6IGluZGV4ZXMsXG4gICAgICAgIGNvbnRleHREZXBlbmRlbmNpZXM6IGNvbnRleHREZXBlbmRlbmNpZXNcbiAgICB9KTtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZpc2l0JDEoZ2VuZXJhdG9yLCBjaGlsZEJsb2NrLCBjaGlsZCk7XG4gICAgfSk7XG4gICAgdmFyIGNsb3NlID0gXCJgKS5qb2luKFxcXCJcXFwiKVwiO1xuICAgIGdlbmVyYXRvci5hcHBlbmQoY2xvc2UpO1xuICAgIGlmIChub2RlW1wiZWxzZVwiXSkge1xuICAgICAgICBnZW5lcmF0b3IuYXBwZW5kKFwiIDogYFwiKTtcbiAgICAgICAgbm9kZVtcImVsc2VcIl0uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZpc2l0JDEoZ2VuZXJhdG9yLCBibG9jaywgY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2VuZXJhdG9yLmFwcGVuZChcImBcIik7XG4gICAgfVxuICAgIGdlbmVyYXRvci5hcHBlbmQoJ30nKTtcbn1cblxuZnVuY3Rpb24gdmlzaXRTbG90KGdlbmVyYXRvciwgYmxvY2ssIG5vZGUpIHtcbiAgICB2YXIgbmFtZSA9IG5vZGUuYXR0cmlidXRlcy5maW5kKGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHsgcmV0dXJuIGF0dHJpYnV0ZS5uYW1lOyB9KTtcbiAgICB2YXIgc2xvdE5hbWUgPSBuYW1lICYmIG5hbWUudmFsdWVbMF0uZGF0YSB8fCAnZGVmYXVsdCc7XG4gICAgZ2VuZXJhdG9yLmFwcGVuZChcIiR7b3B0aW9ucyAmJiBvcHRpb25zLnNsb3R0ZWQgJiYgb3B0aW9ucy5zbG90dGVkLlwiICsgc2xvdE5hbWUgKyBcIiA/IG9wdGlvbnMuc2xvdHRlZC5cIiArIHNsb3ROYW1lICsgXCIoKSA6IGBcIik7XG4gICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2aXNpdCQxKGdlbmVyYXRvciwgYmxvY2ssIGNoaWxkKTtcbiAgICB9KTtcbiAgICBnZW5lcmF0b3IuYXBwZW5kKFwiYH1cIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUF0dHJpYnV0ZVZhbHVlJDEoYmxvY2ssIGNodW5rcykge1xuICAgIHJldHVybiBjaHVua3NcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09ICdUZXh0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGVzY2FwZShjaHVuay5kYXRhKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYmxvY2suY29udGV4dHVhbGlzZShjaHVuay5leHByZXNzaW9uKTtcbiAgICAgICAgdmFyIHNuaXBwZXQgPSBjaHVuay5tZXRhZGF0YS5zbmlwcGV0O1xuICAgICAgICByZXR1cm4gJyR7JyArIHNuaXBwZXQgKyAnfSc7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuXG5mdW5jdGlvbiB2aXNpdEVsZW1lbnQoZ2VuZXJhdG9yLCBibG9jaywgbm9kZSkge1xuICAgIGlmIChub2RlLm5hbWUgPT09ICdzbG90Jykge1xuICAgICAgICB2aXNpdFNsb3QoZ2VuZXJhdG9yLCBibG9jaywgbm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG9wZW5pbmdUYWcgPSBcIjxcIiArIG5vZGUubmFtZTtcbiAgICB2YXIgdGV4dGFyZWFDb250ZW50czsgLy8gYXdrd2FyZCBzcGVjaWFsIGNhc2VcbiAgICB2YXIgc2xvdCA9IG5vZGUuZ2V0U3RhdGljQXR0cmlidXRlVmFsdWUoJ3Nsb3QnKTtcbiAgICBpZiAoc2xvdCAmJiBub2RlLmhhc0FuY2VzdG9yKCdDb21wb25lbnQnKSkge1xuICAgICAgICB2YXIgc2xvdF8xID0gbm9kZS5hdHRyaWJ1dGVzLmZpbmQoZnVuY3Rpb24gKGF0dHJpYnV0ZSkgeyByZXR1cm4gYXR0cmlidXRlLm5hbWUgPT09ICdzbG90JzsgfSk7XG4gICAgICAgIHZhciBzbG90TmFtZSA9IHNsb3RfMS52YWx1ZVswXS5kYXRhO1xuICAgICAgICB2YXIgYXBwZW5kVGFyZ2V0ID0gZ2VuZXJhdG9yLmFwcGVuZFRhcmdldHNbZ2VuZXJhdG9yLmFwcGVuZFRhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICAgIGFwcGVuZFRhcmdldC5zbG90U3RhY2sucHVzaChzbG90TmFtZSk7XG4gICAgICAgIGFwcGVuZFRhcmdldC5zbG90c1tzbG90TmFtZV0gPSAnJztcbiAgICB9XG4gICAgbm9kZS5hdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAoYXR0cmlidXRlLnR5cGUgIT09ICdBdHRyaWJ1dGUnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYXR0cmlidXRlLm5hbWUgPT09ICd2YWx1ZScgJiYgbm9kZS5uYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgICAgICAgICB0ZXh0YXJlYUNvbnRlbnRzID0gc3RyaW5naWZ5QXR0cmlidXRlVmFsdWUkMShibG9jaywgYXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdHIgPSBcIiBcIiArIGF0dHJpYnV0ZS5uYW1lO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZS52YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHN0ciArPSBcIj1cXFwiXCIgKyBzdHJpbmdpZnlBdHRyaWJ1dGVWYWx1ZSQxKGJsb2NrLCBhdHRyaWJ1dGUudmFsdWUpICsgXCJcXFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcGVuaW5nVGFnICs9IHN0cjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChub2RlLl9uZWVkc0Nzc0F0dHJpYnV0ZSkge1xuICAgICAgICBvcGVuaW5nVGFnICs9IFwiIFwiICsgZ2VuZXJhdG9yLnN0eWxlc2hlZXQuaWQ7XG4gICAgICAgIGlmIChub2RlLl9jc3NSZWZBdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIG9wZW5pbmdUYWcgKz0gXCIgc3ZlbHRlLXJlZi1cIiArIG5vZGUuX2Nzc1JlZkF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuaW5nVGFnICs9ICc+JztcbiAgICBnZW5lcmF0b3IuYXBwZW5kKG9wZW5pbmdUYWcpO1xuICAgIGlmIChub2RlLm5hbWUgPT09ICd0ZXh0YXJlYScgJiYgdGV4dGFyZWFDb250ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdlbmVyYXRvci5hcHBlbmQodGV4dGFyZWFDb250ZW50cyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICB2aXNpdCQxKGdlbmVyYXRvciwgYmxvY2ssIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaXNWb2lkRWxlbWVudE5hbWUobm9kZS5uYW1lKSkge1xuICAgICAgICBnZW5lcmF0b3IuYXBwZW5kKFwiPC9cIiArIG5vZGUubmFtZSArIFwiPlwiKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZpc2l0RG9jdW1lbnQoZ2VuZXJhdG9yLCBibG9jaywgbm9kZSkge1xuICAgIGdlbmVyYXRvci5hcHBlbmQoJyR7KF9fcmVzdWx0LmhlYWQgKz0gYCcpO1xuICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmlzaXQkMShnZW5lcmF0b3IsIGJsb2NrLCBjaGlsZCk7XG4gICAgfSk7XG4gICAgZ2VuZXJhdG9yLmFwcGVuZCgnYCwgXCJcIil9Jyk7XG59XG5cbmZ1bmN0aW9uIHZpc2l0SWZCbG9jayhnZW5lcmF0b3IsIGJsb2NrLCBub2RlKSB7XG4gICAgYmxvY2suY29udGV4dHVhbGlzZShub2RlLmV4cHJlc3Npb24pO1xuICAgIHZhciBzbmlwcGV0ID0gbm9kZS5tZXRhZGF0YS5zbmlwcGV0O1xuICAgIGdlbmVyYXRvci5hcHBlbmQoJyR7ICcgKyBzbmlwcGV0ICsgJyA/IGAnKTtcbiAgICB2YXIgY2hpbGRCbG9jayA9IGJsb2NrLmNoaWxkKHtcbiAgICAgICAgY29uZGl0aW9uczogYmxvY2suY29uZGl0aW9ucy5jb25jYXQoc25pcHBldClcbiAgICB9KTtcbiAgICBub2RlLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZpc2l0JDEoZ2VuZXJhdG9yLCBjaGlsZEJsb2NrLCBjaGlsZCk7XG4gICAgfSk7XG4gICAgZ2VuZXJhdG9yLmFwcGVuZCgnYCA6IGAnKTtcbiAgICBpZiAobm9kZVtcImVsc2VcIl0pIHtcbiAgICAgICAgbm9kZVtcImVsc2VcIl0uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHZpc2l0JDEoZ2VuZXJhdG9yLCBjaGlsZEJsb2NrLCBjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZW5lcmF0b3IuYXBwZW5kKCdgIH0nKTtcbn1cblxuZnVuY3Rpb24gdmlzaXRNdXN0YWNoZVRhZyhnZW5lcmF0b3IsIGJsb2NrLCBub2RlKSB7XG4gICAgYmxvY2suY29udGV4dHVhbGlzZShub2RlLmV4cHJlc3Npb24pO1xuICAgIHZhciBzbmlwcGV0ID0gbm9kZS5tZXRhZGF0YS5zbmlwcGV0O1xuICAgIGdlbmVyYXRvci5hcHBlbmQoJyR7X19lc2NhcGUoJyArIHNuaXBwZXQgKyAnKX0nKTtcbn1cblxuZnVuY3Rpb24gdmlzaXRSYXdNdXN0YWNoZVRhZyhnZW5lcmF0b3IsIGJsb2NrLCBub2RlKSB7XG4gICAgYmxvY2suY29udGV4dHVhbGlzZShub2RlLmV4cHJlc3Npb24pO1xuICAgIHZhciBzbmlwcGV0ID0gbm9kZS5tZXRhZGF0YS5zbmlwcGV0O1xuICAgIGdlbmVyYXRvci5hcHBlbmQoJyR7JyArIHNuaXBwZXQgKyAnfScpO1xufVxuXG5mdW5jdGlvbiB2aXNpdFRleHQoZ2VuZXJhdG9yLCBibG9jaywgbm9kZSkge1xuICAgIGdlbmVyYXRvci5hcHBlbmQoZXNjYXBlKG5vZGUuZGF0YSkucmVwbGFjZSgvKFxcJHt8YHxcXFxcKS9nLCAnXFxcXCQxJykpO1xufVxuXG5mdW5jdGlvbiB2aXNpdFdpbmRvdygpIHtcbiAgICAvLyBub29wXG59XG5cbnZhciB2aXNpdG9ycyA9IHtcbiAgICBBd2FpdEJsb2NrOiB2aXNpdEF3YWl0QmxvY2ssXG4gICAgQ29tbWVudDogdmlzaXRDb21tZW50LFxuICAgIENvbXBvbmVudDogdmlzaXRDb21wb25lbnQsXG4gICAgRWFjaEJsb2NrOiB2aXNpdEVhY2hCbG9jayxcbiAgICBFbGVtZW50OiB2aXNpdEVsZW1lbnQsXG4gICAgSGVhZDogdmlzaXREb2N1bWVudCxcbiAgICBJZkJsb2NrOiB2aXNpdElmQmxvY2ssXG4gICAgTXVzdGFjaGVUYWc6IHZpc2l0TXVzdGFjaGVUYWcsXG4gICAgUmF3TXVzdGFjaGVUYWc6IHZpc2l0UmF3TXVzdGFjaGVUYWcsXG4gICAgU2xvdDogdmlzaXRTbG90LFxuICAgIFRleHQ6IHZpc2l0VGV4dCxcbiAgICBXaW5kb3c6IHZpc2l0V2luZG93XG59O1xuXG5mdW5jdGlvbiB2aXNpdCQxKGdlbmVyYXRvciwgYmxvY2ssIG5vZGUpIHtcbiAgICB2YXIgdmlzaXRvciA9IHZpc2l0b3JzW25vZGUudHlwZV07XG4gICAgdmlzaXRvcihnZW5lcmF0b3IsIGJsb2NrLCBub2RlKTtcbn1cblxudmFyIFNzckdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3NyR2VuZXJhdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNzckdlbmVyYXRvcihwYXJzZWQsIHNvdXJjZSwgbmFtZSwgc3R5bGVzaGVldCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJzZWQsIHNvdXJjZSwgbmFtZSwgc3R5bGVzaGVldCwgb3B0aW9ucywgZmFsc2UpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJpbmRpbmdzID0gW107XG4gICAgICAgIF90aGlzLnJlbmRlckNvZGUgPSAnJztcbiAgICAgICAgX3RoaXMuYXBwZW5kVGFyZ2V0cyA9IFtdO1xuICAgICAgICBfdGhpcy5zdHlsZXNoZWV0Lndhcm5PblVudXNlZFNlbGVjdG9ycyhvcHRpb25zLm9ud2Fybik7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3NyR2VuZXJhdG9yLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAodGhpcy5hcHBlbmRUYXJnZXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGFwcGVuZFRhcmdldCA9IHRoaXMuYXBwZW5kVGFyZ2V0c1t0aGlzLmFwcGVuZFRhcmdldHMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB2YXIgc2xvdE5hbWUgPSBhcHBlbmRUYXJnZXQuc2xvdFN0YWNrW2FwcGVuZFRhcmdldC5zbG90U3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBhcHBlbmRUYXJnZXQuc2xvdHNbc2xvdE5hbWVdICs9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNvZGUgKz0gY29kZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNzckdlbmVyYXRvcjtcbn0oR2VuZXJhdG9yKSk7XG5mdW5jdGlvbiBzc3IocGFyc2VkLCBzb3VyY2UsIHN0eWxlc2hlZXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgZm9ybWF0ID0gb3B0aW9ucy5mb3JtYXQgfHwgJ2Nqcyc7XG4gICAgdmFyIGdlbmVyYXRvciA9IG5ldyBTc3JHZW5lcmF0b3IocGFyc2VkLCBzb3VyY2UsIG9wdGlvbnMubmFtZSB8fCAnU3ZlbHRlQ29tcG9uZW50Jywgc3R5bGVzaGVldCwgb3B0aW9ucyk7XG4gICAgdmFyIGNvbXB1dGF0aW9ucyA9IGdlbmVyYXRvci5jb21wdXRhdGlvbnMsIG5hbWUgPSBnZW5lcmF0b3IubmFtZSwgdGVtcGxhdGVQcm9wZXJ0aWVzID0gZ2VuZXJhdG9yLnRlbXBsYXRlUHJvcGVydGllcztcbiAgICAvLyBjcmVhdGUgbWFpbiByZW5kZXIoKSBmdW5jdGlvblxuICAgIHZhciBtYWluQmxvY2sgPSBuZXcgQmxvY2skMyh7XG4gICAgICAgIGdlbmVyYXRvcjogZ2VuZXJhdG9yLFxuICAgICAgICBjb250ZXh0czogbmV3IE1hcCgpLFxuICAgICAgICBpbmRleGVzOiBuZXcgTWFwKCksXG4gICAgICAgIGNvbmRpdGlvbnM6IFtdXG4gICAgfSk7XG4gICAgdHJpbShwYXJzZWQuaHRtbC5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2aXNpdCQxKGdlbmVyYXRvciwgbWFpbkJsb2NrLCBub2RlKTtcbiAgICB9KTtcbiAgICB2YXIgX2EgPSBnZW5lcmF0b3IuY3VzdG9tRWxlbWVudCA/XG4gICAgICAgIHsgY3NzOiBudWxsLCBjc3NNYXA6IG51bGwgfSA6XG4gICAgICAgIGdlbmVyYXRvci5zdHlsZXNoZWV0LnJlbmRlcihvcHRpb25zLmZpbGVuYW1lLCB0cnVlKSwgY3NzID0gX2EuY3NzLCBjc3NNYXAgPSBfYS5jc3NNYXA7XG4gICAgLy8gZ2VuZXJhdGUgaW5pdGlhbCBzdGF0ZSBvYmplY3RcbiAgICB2YXIgZXhwZWN0ZWRQcm9wZXJ0aWVzID0gQXJyYXkuZnJvbShnZW5lcmF0b3IuZXhwZWN0ZWRQcm9wZXJ0aWVzKTtcbiAgICB2YXIgZ2xvYmFscyA9IGV4cGVjdGVkUHJvcGVydGllcy5maWx0ZXIoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIGdsb2JhbFdoaXRlbGlzdC5oYXMocHJvcCk7IH0pO1xuICAgIHZhciBzdG9yZVByb3BzID0gb3B0aW9ucy5zdG9yZSB8fCB0ZW1wbGF0ZVByb3BlcnRpZXMuc3RvcmUgPyBleHBlY3RlZFByb3BlcnRpZXMuZmlsdGVyKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBwcm9wWzBdID09PSAnJCc7IH0pIDogW107XG4gICAgdmFyIGluaXRpYWxTdGF0ZSA9IFtdO1xuICAgIGlmIChnbG9iYWxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaW5pdGlhbFN0YXRlLnB1c2goXCJ7IFwiICsgZ2xvYmFscy5tYXAoZnVuY3Rpb24gKHByb3ApIHsgcmV0dXJuIHByb3AgKyBcIiA6IFwiICsgcHJvcDsgfSkuam9pbignLCAnKSArIFwiIH1cIik7XG4gICAgfVxuICAgIGlmIChzdG9yZVByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGluaXRpYWxpemUgPSBcIl9pbml0KFtcIiArIHN0b3JlUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7IHJldHVybiBcIlxcXCJcIiArIHByb3Auc2xpY2UoMSkgKyBcIlxcXCJcIjsgfSkgKyBcIl0pXCI7XG4gICAgICAgIGlmIChvcHRpb25zLnN0b3JlIHx8IHRlbXBsYXRlUHJvcGVydGllcy5zdG9yZSkge1xuICAgICAgICAgICAgaW5pdGlhbFN0YXRlLnB1c2goXCJvcHRpb25zLnN0b3JlLlwiICsgaW5pdGlhbGl6ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlUHJvcGVydGllcy5kYXRhKSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZS5wdXNoKFwiJWRhdGEoKVwiKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ2xvYmFscy5sZW5ndGggPT09IDAgJiYgc3RvcmVQcm9wcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5pdGlhbFN0YXRlLnB1c2goJ3t9Jyk7XG4gICAgfVxuICAgIGluaXRpYWxTdGF0ZS5wdXNoKCdzdGF0ZScpO1xuICAgIC8vIFRPRE8gY29uY2F0ZW5hdGUgQ1NTIG1hcHNcbiAgICB2YXIgcmVzdWx0ID0gZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfMSQxMyB8fCAodGVtcGxhdGVPYmplY3RfMSQxMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdHZhciBcIiwgXCIgPSB7fTtcXG5cXG5cXHRcXHRcIiwgXCI7XFxuXFxuXFx0XFx0XCIsIFwiLmRhdGEgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZXR1cm4gXCIsIFwiO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0XCIsIFwiLnJlbmRlciA9IGZ1bmN0aW9uKHN0YXRlLCBvcHRpb25zID0ge30pIHtcXG5cXHRcXHRcXHR2YXIgY29tcG9uZW50cyA9IG5ldyBTZXQoKTtcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBhZGRDb21wb25lbnQoY29tcG9uZW50KSB7XFxuXFx0XFx0XFx0XFx0Y29tcG9uZW50cy5hZGQoY29tcG9uZW50KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IHsgaGVhZDogJycsIGFkZENvbXBvbmVudCB9O1xcblxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdHZhciBodG1sID0gXCIsIFwiLl9yZW5kZXIocmVzdWx0LCBzdGF0ZSwgb3B0aW9ucyk7XFxuXFxuXFx0XFx0XFx0dmFyIGNzc0NvZGUgPSBBcnJheS5mcm9tKGNvbXBvbmVudHMpLm1hcChjID0+IGMuY3NzICYmIGMuY3NzLmNvZGUpLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXFxcbicpO1xcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0aHRtbCxcXG5cXHRcXHRcXHRcXHRoZWFkOiByZXN1bHQuaGVhZCxcXG5cXHRcXHRcXHRcXHRjc3M6IHsgY29kZTogY3NzQ29kZSwgbWFwOiBudWxsIH0sXFxuXFx0XFx0XFx0XFx0dG9TdHJpbmcoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5odG1sO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRcIiwgXCIuX3JlbmRlciA9IGZ1bmN0aW9uKF9fcmVzdWx0LCBzdGF0ZSwgb3B0aW9ucykge1xcblxcdFxcdFxcdF9fcmVzdWx0LmFkZENvbXBvbmVudChcIiwgXCIpO1xcblxcblxcdFxcdFxcdHN0YXRlID0gT2JqZWN0LmFzc2lnbihcIiwgXCIpO1xcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdHJldHVybiBgXCIsIFwiYDtcXG5cXHRcXHR9O1xcblxcblxcdFxcdFwiLCBcIi5jc3MgPSB7XFxuXFx0XFx0XFx0Y29kZTogXCIsIFwiLFxcblxcdFxcdFxcdG1hcDogXCIsIFwiXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR2YXIgd2FybmVkID0gZmFsc2U7XFxuXFx0XFx0XCIsIFwiLnJlbmRlckNzcyA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdGlmICghd2FybmVkKSB7XFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvcignQ29tcG9uZW50LnJlbmRlckNzcyguLi4pIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiBcXHUyMDE0IHVzZSBDb21wb25lbnQucmVuZGVyKC4uLikuY3NzIGluc3RlYWQnKTtcXG5cXHRcXHRcXHRcXHR3YXJuZWQgPSB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgY29tcG9uZW50cyA9IFtdO1xcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0Y3NzOiBjb21wb25lbnRzLm1hcCh4ID0+IHguY3NzKS5qb2luKCdcXFxcbicpLFxcblxcdFxcdFxcdFxcdG1hcDogbnVsbCxcXG5cXHRcXHRcXHRcXHRjb21wb25lbnRzXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiLCBcIlxcblxcdFwiXSwgW1wiXFxuXFx0XFx0XCIsIFwiXFxuXFxuXFx0XFx0dmFyIFwiLCBcIiA9IHt9O1xcblxcblxcdFxcdFwiLCBcIjtcXG5cXG5cXHRcXHRcIiwgXCIuZGF0YSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiBcIiwgXCI7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRcIiwgXCIucmVuZGVyID0gZnVuY3Rpb24oc3RhdGUsIG9wdGlvbnMgPSB7fSkge1xcblxcdFxcdFxcdHZhciBjb21wb25lbnRzID0gbmV3IFNldCgpO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGFkZENvbXBvbmVudChjb21wb25lbnQpIHtcXG5cXHRcXHRcXHRcXHRjb21wb25lbnRzLmFkZChjb21wb25lbnQpO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0geyBoZWFkOiAnJywgYWRkQ29tcG9uZW50IH07XFxuXFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0dmFyIGh0bWwgPSBcIiwgXCIuX3JlbmRlcihyZXN1bHQsIHN0YXRlLCBvcHRpb25zKTtcXG5cXG5cXHRcXHRcXHR2YXIgY3NzQ29kZSA9IEFycmF5LmZyb20oY29tcG9uZW50cykubWFwKGMgPT4gYy5jc3MgJiYgYy5jc3MuY29kZSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcXFxcXFxcbicpO1xcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0aHRtbCxcXG5cXHRcXHRcXHRcXHRoZWFkOiByZXN1bHQuaGVhZCxcXG5cXHRcXHRcXHRcXHRjc3M6IHsgY29kZTogY3NzQ29kZSwgbWFwOiBudWxsIH0sXFxuXFx0XFx0XFx0XFx0dG9TdHJpbmcoKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5odG1sO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRcIiwgXCIuX3JlbmRlciA9IGZ1bmN0aW9uKF9fcmVzdWx0LCBzdGF0ZSwgb3B0aW9ucykge1xcblxcdFxcdFxcdF9fcmVzdWx0LmFkZENvbXBvbmVudChcIiwgXCIpO1xcblxcblxcdFxcdFxcdHN0YXRlID0gT2JqZWN0LmFzc2lnbihcIiwgXCIpO1xcblxcblxcdFxcdFxcdFwiLFxuICAgICAgICBcIlxcblxcblxcdFxcdFxcdFwiLFxuICAgICAgICBcIlxcblxcblxcdFxcdFxcdHJldHVybiBcXFxcYFwiLCBcIlxcXFxgO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0XCIsIFwiLmNzcyA9IHtcXG5cXHRcXHRcXHRjb2RlOiBcIiwgXCIsXFxuXFx0XFx0XFx0bWFwOiBcIiwgXCJcXG5cXHRcXHR9O1xcblxcblxcdFxcdHZhciB3YXJuZWQgPSBmYWxzZTtcXG5cXHRcXHRcIiwgXCIucmVuZGVyQ3NzID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0aWYgKCF3YXJuZWQpIHtcXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCdDb21wb25lbnQucmVuZGVyQ3NzKC4uLikgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyIFxcdTIwMTQgdXNlIENvbXBvbmVudC5yZW5kZXIoLi4uKS5jc3MgaW5zdGVhZCcpO1xcblxcdFxcdFxcdFxcdHdhcm5lZCA9IHRydWU7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBjb21wb25lbnRzID0gW107XFxuXFxuXFx0XFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHRjc3M6IGNvbXBvbmVudHMubWFwKHggPT4geC5jc3MpLmpvaW4oJ1xcXFxcXFxcbicpLFxcblxcdFxcdFxcdFxcdG1hcDogbnVsbCxcXG5cXHRcXHRcXHRcXHRjb21wb25lbnRzXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdFwiLCBcIlxcblxcblxcdFxcdFwiXG4gICAgICAgIC8vIFRPRE8gdGhpcyBpcyBhIGJpdCBoYWNreVxuICAgICAgICAsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFxuXFx0XFx0XCIsXG4gICAgICAgIFwiXFxuXFx0XCJdKSksIGdlbmVyYXRvci5qYXZhc2NyaXB0LCBuYW1lLCBvcHRpb25zLmZpbGVuYW1lICYmIG5hbWUgKyBcIi5maWxlbmFtZSA9IFwiICsgc3RyaW5naWZ5KG9wdGlvbnMuZmlsZW5hbWUpLCBuYW1lLCB0ZW1wbGF0ZVByb3BlcnRpZXMuZGF0YSA/IFwiJWRhdGEoKVwiIDogXCJ7fVwiLCBuYW1lLCB0ZW1wbGF0ZVByb3BlcnRpZXMuc3RvcmUgJiYgXCJvcHRpb25zLnN0b3JlID0gJXN0b3JlKCk7XCIsIG5hbWUsIG5hbWUsIG5hbWUsIGluaXRpYWxTdGF0ZS5qb2luKCcsICcpLCBjb21wdXRhdGlvbnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIga2V5ID0gX2Eua2V5LCBkZXBzID0gX2EuZGVwcztcbiAgICAgICAgcmV0dXJuIFwic3RhdGUuXCIgKyBrZXkgKyBcIiA9ICVjb21wdXRlZC1cIiArIGtleSArIFwiKFwiICsgZGVwcy5tYXAoZnVuY3Rpb24gKGRlcCkgeyByZXR1cm4gXCJzdGF0ZS5cIiArIGRlcDsgfSkuam9pbignLCAnKSArIFwiKTtcIjtcbiAgICB9KSwgZ2VuZXJhdG9yLmJpbmRpbmdzLmxlbmd0aCAmJiBkZWluZGVudCh0ZW1wbGF0ZU9iamVjdF8yJDEyIHx8ICh0ZW1wbGF0ZU9iamVjdF8yJDEyID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0dmFyIHNldHRsZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHR2YXIgdG1wO1xcblxcblxcdFxcdFxcdFxcdHdoaWxlICghc2V0dGxlZCkge1xcblxcdFxcdFxcdFxcdFxcdHNldHRsZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFwiLCBcIlxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdHZhciBzZXR0bGVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dmFyIHRtcDtcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAoIXNldHRsZWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRzZXR0bGVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcIiwgXCJcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XCJdKSksIGdlbmVyYXRvci5iaW5kaW5ncy5qb2luKCdcXG5cXG4nKSksIGdlbmVyYXRvci5yZW5kZXJDb2RlLCBuYW1lLCBjc3MgPyBzdHJpbmdpZnkoY3NzKSA6IFwiJydcIiwgY3NzTWFwID8gc3RyaW5naWZ5KGNzc01hcC50b1N0cmluZygpKSA6ICdudWxsJywgbmFtZSwgZ2VuZXJhdG9yLnN0eWxlc2hlZXQuaGFzU3R5bGVzICYmIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzMkMTIgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMTIgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG5cXHRcXHRcXHRcXHRjb21wb25lbnRzLnB1c2goe1xcblxcdFxcdFxcdFxcdFxcdGZpbGVuYW1lOiBcIiwgXCIuZmlsZW5hbWUsXFxuXFx0XFx0XFx0XFx0XFx0Y3NzOiBcIiwgXCIuY3NzICYmIFwiLCBcIi5jc3MuY29kZSxcXG5cXHRcXHRcXHRcXHRcXHRtYXA6IFwiLCBcIi5jc3MgJiYgXCIsIFwiLmNzcy5tYXBcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGNvbXBvbmVudHMucHVzaCh7XFxuXFx0XFx0XFx0XFx0XFx0ZmlsZW5hbWU6IFwiLCBcIi5maWxlbmFtZSxcXG5cXHRcXHRcXHRcXHRcXHRjc3M6IFwiLCBcIi5jc3MgJiYgXCIsIFwiLmNzcy5jb2RlLFxcblxcdFxcdFxcdFxcdFxcdG1hcDogXCIsIFwiLmNzcyAmJiBcIiwgXCIuY3NzLm1hcFxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFwiXSkpLCBuYW1lLCBuYW1lLCBuYW1lLCBuYW1lLCBuYW1lKSwgdGVtcGxhdGVQcm9wZXJ0aWVzLmNvbXBvbmVudHMgJiYgZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNCQxMiB8fCAodGVtcGxhdGVPYmplY3RfNCQxMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdHZhciBzZWVuID0ge307XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gYWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xcblxcdFxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBjb21wb25lbnQucmVuZGVyQ3NzKCk7XFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0LmNvbXBvbmVudHMuZm9yRWFjaCh4ID0+IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoc2Vlblt4LmZpbGVuYW1lXSkgcmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdFxcdHNlZW5beC5maWxlbmFtZV0gPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbXBvbmVudHMucHVzaCh4KTtcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XCIsIFwiXFxuXFx0XFx0XFx0XCJdLCBbXCJcXG5cXHRcXHRcXHRcXHR2YXIgc2VlbiA9IHt9O1xcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIGFkZENvbXBvbmVudChjb21wb25lbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gY29tcG9uZW50LnJlbmRlckNzcygpO1xcblxcdFxcdFxcdFxcdFxcdHJlc3VsdC5jb21wb25lbnRzLmZvckVhY2goeCA9PiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKHNlZW5beC5maWxlbmFtZV0pIHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzZWVuW3guZmlsZW5hbWVdID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb21wb25lbnRzLnB1c2goeCk7XFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFwiLFxuICAgICAgICBcIlxcblxcdFxcdFxcdFwiXSkpLCB0ZW1wbGF0ZVByb3BlcnRpZXMuY29tcG9uZW50cy52YWx1ZS5wcm9wZXJ0aWVzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gXCJhZGRDb21wb25lbnQoJWNvbXBvbmVudHMtXCIgKyBnZXRNZXRob2ROYW1lKHByb3Aua2V5KSArIFwiKTtcIjtcbiAgICB9KSksIHRlbXBsYXRlUHJvcGVydGllcy5wcmVsb2FkICYmIG5hbWUgKyBcIi5wcmVsb2FkID0gJXByZWxvYWQ7XCIsIFxuICAgIC8vIFRPRE8gdGhpcyBpcyBhIGJpdCBoYWNreVxuICAgIC9fX2VzY2FwZS8udGVzdChnZW5lcmF0b3IucmVuZGVyQ29kZSkgJiYgZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNSQxMCB8fCAodGVtcGxhdGVPYmplY3RfNSQxMCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdHZhciBlc2NhcGVkID0ge1xcblxcdFxcdFxcdFxcdFxcdCdcXFwiJzogJyZxdW90OycsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIidcXFwiOiAnJiMjMzk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnJic6ICcmYW1wOycsXFxuXFx0XFx0XFx0XFx0XFx0JzwnOiAnJmx0OycsXFxuXFx0XFx0XFx0XFx0XFx0Jz4nOiAnJmd0OydcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIF9fZXNjYXBlKGh0bWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gU3RyaW5nKGh0bWwpLnJlcGxhY2UoL1tcXFwiJyY8Pl0vZywgbWF0Y2ggPT4gZXNjYXBlZFttYXRjaF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdHZhciBlc2NhcGVkID0ge1xcblxcdFxcdFxcdFxcdFxcdCdcXFwiJzogJyZxdW90OycsXFxuXFx0XFx0XFx0XFx0XFx0XFxcIidcXFwiOiAnJiMjMzk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnJic6ICcmYW1wOycsXFxuXFx0XFx0XFx0XFx0XFx0JzwnOiAnJmx0OycsXFxuXFx0XFx0XFx0XFx0XFx0Jz4nOiAnJmd0OydcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIF9fZXNjYXBlKGh0bWwpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gU3RyaW5nKGh0bWwpLnJlcGxhY2UoL1tcXFwiJyY8Pl0vZywgbWF0Y2ggPT4gZXNjYXBlZFttYXRjaF0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0pKSksIC9fX2lzUHJvbWlzZS8udGVzdChnZW5lcmF0b3IucmVuZGVyQ29kZSkgJiYgZGVpbmRlbnQodGVtcGxhdGVPYmplY3RfNiQxMCB8fCAodGVtcGxhdGVPYmplY3RfNiQxMCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIF9faXNQcm9taXNlKHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIF9faXNQcm9taXNlKHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcIl0pKSksIC9fX21pc3NpbmdDb21wb25lbnQvLnRlc3QoZ2VuZXJhdG9yLnJlbmRlckNvZGUpICYmIGRlaW5kZW50KHRlbXBsYXRlT2JqZWN0XzckOCB8fCAodGVtcGxhdGVPYmplY3RfNyQ4ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuXFx0XFx0XFx0XFx0dmFyIF9fbWlzc2luZ0NvbXBvbmVudCA9IHtcXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXI6ICgpID0+ICcnXFxuXFx0XFx0XFx0XFx0fTtcXG5cXHRcXHRcXHRcIl0sIFtcIlxcblxcdFxcdFxcdFxcdHZhciBfX21pc3NpbmdDb21wb25lbnQgPSB7XFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyOiAoKSA9PiAnJ1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XCJdKSkpKS5yZXBsYWNlKC8oQCt8Iyt8JSspKFxcdyooPzotXFx3Kik/KS9nLCBmdW5jdGlvbiAobWF0Y2gsIHNpZ2lsLCBuYW1lKSB7XG4gICAgICAgIGlmIChzaWdpbCA9PT0gJ0AnKVxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRvci5hbGlhcyhuYW1lKTtcbiAgICAgICAgaWYgKHNpZ2lsID09PSAnJScpXG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdG9yLnRlbXBsYXRlVmFycy5nZXQobmFtZSk7XG4gICAgICAgIHJldHVybiBzaWdpbC5zbGljZSgxKSArIG5hbWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvci5nZW5lcmF0ZShyZXN1bHQsIG9wdGlvbnMsIHsgbmFtZTogbmFtZSwgZm9ybWF0OiBmb3JtYXQgfSk7XG59XG5mdW5jdGlvbiB0cmltKG5vZGVzKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBub2Rlcy5sZW5ndGg7IHN0YXJ0ICs9IDEpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tzdGFydF07XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdUZXh0JylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlLmRhdGEgPSBub2RlLmRhdGEucmVwbGFjZSgvXlxccysvLCAnJyk7XG4gICAgICAgIGlmIChub2RlLmRhdGEpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGVuZCA9IG5vZGVzLmxlbmd0aDtcbiAgICBmb3IgKDsgZW5kID4gc3RhcnQ7IGVuZCAtPSAxKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbZW5kIC0gMV07XG4gICAgICAgIGlmIChub2RlLnR5cGUgIT09ICdUZXh0JylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBub2RlLmRhdGEgPSBub2RlLmRhdGEucmVwbGFjZSgvXFxzKyQvLCAnJyk7XG4gICAgICAgIGlmIChub2RlLmRhdGEpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxudmFyIHRlbXBsYXRlT2JqZWN0XzIkMTI7XG52YXIgdGVtcGxhdGVPYmplY3RfMyQxMjtcbnZhciB0ZW1wbGF0ZU9iamVjdF80JDEyO1xudmFyIHRlbXBsYXRlT2JqZWN0XzUkMTA7XG52YXIgdGVtcGxhdGVPYmplY3RfNiQxMDtcbnZhciB0ZW1wbGF0ZU9iamVjdF83JDg7XG52YXIgdGVtcGxhdGVPYmplY3RfMSQxMztcblxuZnVuY3Rpb24gYXNzaWduJDEodGFyZ2V0KSB7XG5cdHZhciBrLFxuXHRcdHNvdXJjZSxcblx0XHRpID0gMSxcblx0XHRsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXHRmb3IgKDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0c291cmNlID0gYXJndW1lbnRzW2ldO1xuXHRcdGZvciAoayBpbiBzb3VyY2UpIHRhcmdldFtrXSA9IHNvdXJjZVtrXTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cbnZhciBVTktOT1dOID0ge307XG5mdW5jdGlvbiBnYXRoZXJQb3NzaWJsZVZhbHVlcyhub2RlLCBzZXQpIHtcbiAgICBpZiAobm9kZS50eXBlID09PSAnTGl0ZXJhbCcpIHtcbiAgICAgICAgc2V0LmFkZChub2RlLnZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS50eXBlID09PSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJykge1xuICAgICAgICBnYXRoZXJQb3NzaWJsZVZhbHVlcyhub2RlLmNvbnNlcXVlbnQsIHNldCk7XG4gICAgICAgIGdhdGhlclBvc3NpYmxlVmFsdWVzKG5vZGUuYWx0ZXJuYXRlLCBzZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0LmFkZChVTktOT1dOKTtcbiAgICB9XG59XG5cbnZhciBTZWxlY3RvciQyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlbGVjdG9yKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5ibG9ja3MgPSBncm91cFNlbGVjdG9ycyhub2RlKTtcbiAgICAgICAgLy8gdGFrZSB0cmFpbGluZyA6Z2xvYmFsKC4uLikgc2VsZWN0b3JzIG91dCBvZiBjb25zaWRlcmF0aW9uXG4gICAgICAgIHZhciBpID0gdGhpcy5ibG9ja3MubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaSA+IDApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ibG9ja3NbaSAtIDFdLmdsb2JhbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGkgLT0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsQmxvY2tzID0gdGhpcy5ibG9ja3Muc2xpY2UoMCwgaSk7XG4gICAgICAgIHRoaXMudXNlZCA9IHRoaXMuYmxvY2tzWzBdLmdsb2JhbDtcbiAgICB9XG4gICAgU2VsZWN0b3IucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKG5vZGUsIHN0YWNrKSB7XG4gICAgICAgIHZhciB0b0VuY2Fwc3VsYXRlID0gW107XG4gICAgICAgIGFwcGx5U2VsZWN0b3IodGhpcy5sb2NhbEJsb2Nrcy5zbGljZSgpLCBub2RlLCBzdGFjay5zbGljZSgpLCB0b0VuY2Fwc3VsYXRlKTtcbiAgICAgICAgaWYgKHRvRW5jYXBzdWxhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdG9FbmNhcHN1bGF0ZS5maWx0ZXIoZnVuY3Rpb24gKF8sIGkpIHsgcmV0dXJuIGkgPT09IDAgfHwgaSA9PT0gdG9FbmNhcHN1bGF0ZS5sZW5ndGggLSAxOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gX2Eubm9kZSwgYmxvY2sgPSBfYS5ibG9jaztcbiAgICAgICAgICAgICAgICBub2RlLl9uZWVkc0Nzc0F0dHJpYnV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYmxvY2suc2hvdWxkRW5jYXBzdWxhdGUgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnVzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTZWxlY3Rvci5wcm90b3R5cGUubWluaWZ5ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdmFyIGMgPSBudWxsO1xuICAgICAgICB0aGlzLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaywgaSkge1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrLnN0YXJ0IC0gYyA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUoYywgYmxvY2suc3RhcnQsIGJsb2NrLmNvbWJpbmF0b3IubmFtZSB8fCAnICcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMgPSBibG9jay5lbmQ7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0b3IucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjb2RlLCBhdHRyKSB7XG4gICAgICAgIGZ1bmN0aW9uIGVuY2Fwc3VsYXRlQmxvY2soYmxvY2spIHtcbiAgICAgICAgICAgIHZhciBpID0gYmxvY2suc2VsZWN0b3JzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBibG9jay5zZWxlY3RvcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdQc2V1ZG9FbGVtZW50U2VsZWN0b3InIHx8IHNlbGVjdG9yLnR5cGUgPT09ICdQc2V1ZG9DbGFzc1NlbGVjdG9yJylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdUeXBlU2VsZWN0b3InICYmIHNlbGVjdG9yLm5hbWUgPT09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShzZWxlY3Rvci5zdGFydCwgc2VsZWN0b3IuZW5kLCBhdHRyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUuYXBwZW5kTGVmdChzZWxlY3Rvci5lbmQsIGF0dHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgPSBibG9jay5zZWxlY3RvcnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBzZWxlY3RvciA9IGJsb2NrLnNlbGVjdG9yc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gJ1JlZlNlbGVjdG9yJykge1xuICAgICAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShzZWxlY3Rvci5zdGFydCwgc2VsZWN0b3IuZW5kLCBcIltzdmVsdGUtcmVmLVwiICsgc2VsZWN0b3IubmFtZSArIFwiXVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50T25seTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlTmFtZTogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmxvY2tzLmZvckVhY2goZnVuY3Rpb24gKGJsb2NrLCBpKSB7XG4gICAgICAgICAgICBpZiAoYmxvY2suZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yID0gYmxvY2suc2VsZWN0b3JzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdCA9IHNlbGVjdG9yLmNoaWxkcmVuWzBdO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gc2VsZWN0b3IuY2hpbGRyZW5bc2VsZWN0b3IuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoc2VsZWN0b3Iuc3RhcnQsIGZpcnN0LnN0YXJ0KS5yZW1vdmUobGFzdC5lbmQsIHNlbGVjdG9yLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2suc2hvdWxkRW5jYXBzdWxhdGUpXG4gICAgICAgICAgICAgICAgZW5jYXBzdWxhdGVCbG9jayhibG9jayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VsZWN0b3IucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICB0aGlzLmJsb2Nrcy5mb3JFYWNoKGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgdmFyIGkgPSBibG9jay5zZWxlY3RvcnMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGktLSA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBibG9jay5zZWxlY3RvcnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdQc2V1ZG9DbGFzc1NlbGVjdG9yJyAmJiBzZWxlY3Rvci5uYW1lID09PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0b3IuZXJyb3IoXCI6Z2xvYmFsKC4uLikgbXVzdCBiZSB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIGNvbXBvdW5kIHNlbGVjdG9yXCIsIHNlbGVjdG9yLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5ibG9ja3MubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgc3RhcnQgPCBlbmQ7IHN0YXJ0ICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ibG9ja3Nbc3RhcnRdLmdsb2JhbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgZW5kID4gc3RhcnQ7IGVuZCAtPSAxKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuYmxvY2tzW2VuZCAtIDFdLmdsb2JhbClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tzW2ldLmdsb2JhbCkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRvci5lcnJvcihcIjpnbG9iYWwoLi4uKSBjYW4gYmUgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiBhIHNlbGVjdG9yIHNlcXVlbmNlLCBidXQgbm90IGluIHRoZSBtaWRkbGVcIiwgdGhpcy5ibG9ja3NbaV0uc2VsZWN0b3JzWzBdLnN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFNlbGVjdG9yO1xufSgpKTtcbmZ1bmN0aW9uIGFwcGx5U2VsZWN0b3IoYmxvY2tzLCBub2RlLCBzdGFjaywgdG9FbmNhcHN1bGF0ZSkge1xuICAgIHZhciBibG9jayA9IGJsb2Nrcy5wb3AoKTtcbiAgICBpZiAoIWJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBibG9ja3MuZXZlcnkoZnVuY3Rpb24gKGJsb2NrKSB7IHJldHVybiBibG9jay5nbG9iYWw7IH0pO1xuICAgIH1cbiAgICB2YXIgaSA9IGJsb2NrLnNlbGVjdG9ycy5sZW5ndGg7XG4gICAgdmFyIGogPSBzdGFjay5sZW5ndGg7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IGJsb2NrLnNlbGVjdG9yc1tpXTtcbiAgICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdQc2V1ZG9DbGFzc1NlbGVjdG9yJyAmJiBzZWxlY3Rvci5uYW1lID09PSAnZ2xvYmFsJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdQc2V1ZG9DbGFzc1NlbGVjdG9yJyB8fCBzZWxlY3Rvci50eXBlID09PSAnUHNldWRvRWxlbWVudFNlbGVjdG9yJykge1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZWN0b3IudHlwZSA9PT0gJ0NsYXNzU2VsZWN0b3InKSB7XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZU1hdGNoZXMobm9kZSwgJ2NsYXNzJywgc2VsZWN0b3IubmFtZSwgJ349JywgZmFsc2UpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdJZFNlbGVjdG9yJykge1xuICAgICAgICAgICAgaWYgKCFhdHRyaWJ1dGVNYXRjaGVzKG5vZGUsICdpZCcsIHNlbGVjdG9yLm5hbWUsICc9JywgZmFsc2UpKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdBdHRyaWJ1dGVTZWxlY3RvcicpIHtcbiAgICAgICAgICAgIGlmICghYXR0cmlidXRlTWF0Y2hlcyhub2RlLCBzZWxlY3Rvci5uYW1lLm5hbWUsIHNlbGVjdG9yLnZhbHVlICYmIHVucXVvdGUoc2VsZWN0b3IudmFsdWUpLCBzZWxlY3Rvci5tYXRjaGVyLCBzZWxlY3Rvci5mbGFncykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VsZWN0b3IudHlwZSA9PT0gJ1R5cGVTZWxlY3RvcicpIHtcbiAgICAgICAgICAgIGlmIChub2RlLm5hbWUgIT09IHNlbGVjdG9yLm5hbWUgJiYgc2VsZWN0b3IubmFtZSAhPT0gJyonKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNlbGVjdG9yLnR5cGUgPT09ICdSZWZTZWxlY3RvcicpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmF0dHJpYnV0ZXMuc29tZShmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gYXR0ci50eXBlID09PSAnUmVmJyAmJiBhdHRyLm5hbWUgPT09IHNlbGVjdG9yLm5hbWU7IH0pKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5fY3NzUmVmQXR0cmlidXRlID0gc2VsZWN0b3IubmFtZTtcbiAgICAgICAgICAgICAgICB0b0VuY2Fwc3VsYXRlLnB1c2goeyBub2RlOiBub2RlLCBibG9jazogYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRydWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGJhaWwuIFRPRE8gZmlndXJlIG91dCB3aGF0IHRoZXNlIGNvdWxkIGJlXG4gICAgICAgICAgICB0b0VuY2Fwc3VsYXRlLnB1c2goeyBub2RlOiBub2RlLCBibG9jazogYmxvY2sgfSk7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSgpO1xuICAgICAgICBpZiAodHlwZW9mIHN0YXRlXzEgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVfMS52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGJsb2NrLmNvbWJpbmF0b3IpIHtcbiAgICAgICAgaWYgKGJsb2NrLmNvbWJpbmF0b3IudHlwZSA9PT0gJ1doaXRlU3BhY2UnKSB7XG4gICAgICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFwcGx5U2VsZWN0b3IoYmxvY2tzLnNsaWNlKCksIHN0YWNrLnBvcCgpLCBzdGFjaywgdG9FbmNhcHN1bGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9FbmNhcHN1bGF0ZS5wdXNoKHsgbm9kZTogbm9kZSwgYmxvY2s6IGJsb2NrIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2suY29tYmluYXRvci5uYW1lID09PSAnPicpIHtcbiAgICAgICAgICAgIGlmIChhcHBseVNlbGVjdG9yKGJsb2Nrcywgc3RhY2sucG9wKCksIHN0YWNrLCB0b0VuY2Fwc3VsYXRlKSkge1xuICAgICAgICAgICAgICAgIHRvRW5jYXBzdWxhdGUucHVzaCh7IG5vZGU6IG5vZGUsIGJsb2NrOiBibG9jayB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG90aGVyIGNvbWJpbmF0b3JzXG4gICAgICAgIHRvRW5jYXBzdWxhdGUucHVzaCh7IG5vZGU6IG5vZGUsIGJsb2NrOiBibG9jayB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvRW5jYXBzdWxhdGUucHVzaCh7IG5vZGU6IG5vZGUsIGJsb2NrOiBibG9jayB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBvcGVyYXRvcnMgPSB7XG4gICAgJz0nOiBmdW5jdGlvbiAodmFsdWUsIGZsYWdzKSB7IHJldHVybiBuZXcgUmVnRXhwKFwiXlwiICsgdmFsdWUgKyBcIiRcIiwgZmxhZ3MpOyB9LFxuICAgICd+PSc6IGZ1bmN0aW9uICh2YWx1ZSwgZmxhZ3MpIHsgcmV0dXJuIG5ldyBSZWdFeHAoXCJcXFxcYlwiICsgdmFsdWUgKyBcIlxcXFxiXCIsIGZsYWdzKTsgfSxcbiAgICAnfD0nOiBmdW5jdGlvbiAodmFsdWUsIGZsYWdzKSB7IHJldHVybiBuZXcgUmVnRXhwKFwiXlwiICsgdmFsdWUgKyBcIigtLispPyRcIiwgZmxhZ3MpOyB9LFxuICAgICdePSc6IGZ1bmN0aW9uICh2YWx1ZSwgZmxhZ3MpIHsgcmV0dXJuIG5ldyBSZWdFeHAoXCJeXCIgKyB2YWx1ZSwgZmxhZ3MpOyB9LFxuICAgICckPSc6IGZ1bmN0aW9uICh2YWx1ZSwgZmxhZ3MpIHsgcmV0dXJuIG5ldyBSZWdFeHAodmFsdWUgKyBcIiRcIiwgZmxhZ3MpOyB9LFxuICAgICcqPSc6IGZ1bmN0aW9uICh2YWx1ZSwgZmxhZ3MpIHsgcmV0dXJuIG5ldyBSZWdFeHAodmFsdWUsIGZsYWdzKTsgfVxufTtcbmZ1bmN0aW9uIGF0dHJpYnV0ZU1hdGNoZXMobm9kZSwgbmFtZSwgZXhwZWN0ZWRWYWx1ZSwgb3BlcmF0b3IsIGNhc2VJbnNlbnNpdGl2ZSkge1xuICAgIHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzLmZpbmQoZnVuY3Rpb24gKGF0dHIpIHsgcmV0dXJuIGF0dHIubmFtZSA9PT0gbmFtZTsgfSk7XG4gICAgaWYgKCFhdHRyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGF0dHIudmFsdWUgPT09IHRydWUpXG4gICAgICAgIHJldHVybiBvcGVyYXRvciA9PT0gbnVsbDtcbiAgICBpZiAoYXR0ci52YWx1ZS5sZW5ndGggPiAxKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWV4cGVjdGVkVmFsdWUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIHZhciBwYXR0ZXJuID0gb3BlcmF0b3JzW29wZXJhdG9yXShleHBlY3RlZFZhbHVlLCBjYXNlSW5zZW5zaXRpdmUgPyAnaScgOiAnJyk7XG4gICAgdmFyIHZhbHVlID0gYXR0ci52YWx1ZVswXTtcbiAgICBpZiAoIXZhbHVlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZhbHVlLnR5cGUgPT09ICdUZXh0JylcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh2YWx1ZS5kYXRhKTtcbiAgICB2YXIgcG9zc2libGVWYWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgZ2F0aGVyUG9zc2libGVWYWx1ZXModmFsdWUuZXhwcmVzc2lvbiwgcG9zc2libGVWYWx1ZXMpO1xuICAgIGlmIChwb3NzaWJsZVZhbHVlcy5oYXMoVU5LTk9XTikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBBcnJheS5mcm9tKHBvc3NpYmxlVmFsdWVzKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHggPSBfYVtfaV07XG4gICAgICAgIGlmIChwYXR0ZXJuLnRlc3QoeCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdW5xdW90ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAnSWRlbnRpZmllcicpXG4gICAgICAgIHJldHVybiB2YWx1ZS5uYW1lO1xuICAgIHZhciBzdHIgPSB2YWx1ZS52YWx1ZTtcbiAgICBpZiAoc3RyWzBdID09PSBzdHJbc3RyLmxlbmd0aCAtIDFdICYmIHN0clswXSA9PT0gXCInXCIgfHwgc3RyWzBdID09PSAnXCInKSB7XG4gICAgICAgIHJldHVybiBzdHIuc2xpY2UoMSwgc3RyLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxudmFyIEJsb2NrJDQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmxvY2soY29tYmluYXRvcikge1xuICAgICAgICB0aGlzLmNvbWJpbmF0b3IgPSBjb21iaW5hdG9yO1xuICAgICAgICB0aGlzLmdsb2JhbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdG9ycyA9IFtdO1xuICAgICAgICB0aGlzLnN0YXJ0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbmQgPSBudWxsO1xuICAgICAgICB0aGlzLnNob3VsZEVuY2Fwc3VsYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIEJsb2NrLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHNlbGVjdG9yLnN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5nbG9iYWwgPSBzZWxlY3Rvci50eXBlID09PSAnUHNldWRvQ2xhc3NTZWxlY3RvcicgJiYgc2VsZWN0b3IubmFtZSA9PT0gJ2dsb2JhbCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RvcnMucHVzaChzZWxlY3Rvcik7XG4gICAgICAgIHRoaXMuZW5kID0gc2VsZWN0b3IuZW5kO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrO1xufSgpKTtcbmZ1bmN0aW9uIGdyb3VwU2VsZWN0b3JzKHNlbGVjdG9yKSB7XG4gICAgdmFyIGJsb2NrID0gbmV3IEJsb2NrJDQobnVsbCk7XG4gICAgdmFyIGJsb2NrcyA9IFtibG9ja107XG4gICAgc2VsZWN0b3IuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT09ICdXaGl0ZVNwYWNlJyB8fCBjaGlsZC50eXBlID09PSAnQ29tYmluYXRvcicpIHtcbiAgICAgICAgICAgIGJsb2NrID0gbmV3IEJsb2NrJDQoY2hpbGQpO1xuICAgICAgICAgICAgYmxvY2tzLnB1c2goYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmxvY2suYWRkKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBibG9ja3M7XG59XG5cbnZhciBSdWxlJDIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUnVsZShub2RlLCBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzID0gbm9kZS5zZWxlY3Rvci5jaGlsZHJlbi5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5ldyBTZWxlY3RvciQyKG5vZGUpOyB9KTtcbiAgICAgICAgdGhpcy5kZWNsYXJhdGlvbnMgPSBub2RlLmJsb2NrLmNoaWxkcmVuLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbmV3IERlY2xhcmF0aW9uJDIobm9kZSk7IH0pO1xuICAgIH1cbiAgICBSdWxlLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChub2RlLCBzdGFjaykge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3RvcikgeyByZXR1cm4gc2VsZWN0b3IuYXBwbHkobm9kZSwgc3RhY2spOyB9KTsgLy8gVE9ETyBtb3ZlIHRoZSBsb2dpYyBpbiBoZXJlP1xuICAgIH07XG4gICAgUnVsZS5wcm90b3R5cGUuaXNVc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQubm9kZS50eXBlID09PSAnQXRydWxlJyAmJiB0aGlzLnBhcmVudC5ub2RlLm5hbWUgPT09ICdrZXlmcmFtZXMnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9ycy5zb21lKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLnVzZWQ7IH0pO1xuICAgIH07XG4gICAgUnVsZS5wcm90b3R5cGUubWluaWZ5ID0gZnVuY3Rpb24gKGNvZGUsIGNhc2NhZGUpIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLm5vZGUuc3RhcnQ7XG4gICAgICAgIHZhciBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdG9yLCBpKSB7XG4gICAgICAgICAgICBpZiAoY2FzY2FkZSB8fCBzZWxlY3Rvci51c2VkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IHN0YXJ0ZWQgPyAnLCcgOiAnJztcbiAgICAgICAgICAgICAgICBpZiAoKHNlbGVjdG9yLm5vZGUuc3RhcnQgLSBjKSA+IHNlcGFyYXRvci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUoYywgc2VsZWN0b3Iubm9kZS5zdGFydCwgc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjYXNjYWRlKVxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rvci5taW5pZnkoY29kZSk7XG4gICAgICAgICAgICAgICAgYyA9IHNlbGVjdG9yLm5vZGUuZW5kO1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29kZS5yZW1vdmUoYywgdGhpcy5ub2RlLmJsb2NrLnN0YXJ0KTtcbiAgICAgICAgYyA9IHRoaXMubm9kZS5ibG9jay5zdGFydCArIDE7XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmF0aW9uLCBpKSB7XG4gICAgICAgICAgICB2YXIgc2VwYXJhdG9yID0gaSA+IDAgPyAnOycgOiAnJztcbiAgICAgICAgICAgIGlmICgoZGVjbGFyYXRpb24ubm9kZS5zdGFydCAtIGMpID4gc2VwYXJhdG9yLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGMsIGRlY2xhcmF0aW9uLm5vZGUuc3RhcnQsIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNsYXJhdGlvbi5taW5pZnkoY29kZSk7XG4gICAgICAgICAgICBjID0gZGVjbGFyYXRpb24ubm9kZS5lbmQ7XG4gICAgICAgIH0pO1xuICAgICAgICBjb2RlLnJlbW92ZShjLCB0aGlzLm5vZGUuYmxvY2suZW5kIC0gMSk7XG4gICAgfTtcbiAgICBSdWxlLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY29kZSwgaWQsIGtleWZyYW1lcywgY2FzY2FkZSkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQubm9kZS50eXBlID09PSAnQXRydWxlJyAmJiB0aGlzLnBhcmVudC5ub2RlLm5hbWUgPT09ICdrZXlmcmFtZXMnKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHZhciBhdHRyID0gXCJbXCIgKyBpZCArIFwiXVwiO1xuICAgICAgICBpZiAoY2FzY2FkZSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGRpc2FibGUgY2FzY2FkaW5nICh3aXRob3V0IDpnbG9iYWwoLi4uKSkgaW4gdjJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBzZWxlY3Rvci5ub2RlLCBzdGFydCA9IF9hLnN0YXJ0LCBlbmQgPSBfYS5lbmQsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgdmFyIGNzcyA9IGNvZGUub3JpZ2luYWw7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9yU3RyaW5nID0gY3NzLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdFRva2VuID0gY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFRva2VuLnR5cGUgPT09ICdUeXBlU2VsZWN0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnNlcnQgPSBmaXJzdFRva2VuLmVuZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWQgPSBmaXJzdFRva2VuLm5hbWUgPT09ICcqJyA/ICcnIDogY3NzLnNsaWNlKHN0YXJ0LCBpbnNlcnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFpbCA9IGNzcy5zbGljZShpbnNlcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gXCJcIiArIGhlYWQgKyBhdHRyICsgdGFpbCArIFwiLFwiICsgYXR0ciArIFwiIFwiICsgc2VsZWN0b3JTdHJpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZCA9IFwiXCIgKyBhdHRyICsgc2VsZWN0b3JTdHJpbmcgKyBcIixcIiArIGF0dHIgKyBcIiBcIiArIHNlbGVjdG9yU3RyaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShzdGFydCwgZW5kLCB0cmFuc2Zvcm1lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JzLmZvckVhY2goZnVuY3Rpb24gKHNlbGVjdG9yKSB7IHJldHVybiBzZWxlY3Rvci50cmFuc2Zvcm0oY29kZSwgYXR0cik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVjbGFyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKGRlY2xhcmF0aW9uKSB7IHJldHVybiBkZWNsYXJhdGlvbi50cmFuc2Zvcm0oY29kZSwga2V5ZnJhbWVzKTsgfSk7XG4gICAgfTtcbiAgICBSdWxlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHNlbGVjdG9yLnZhbGlkYXRlKHZhbGlkYXRvcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUnVsZS5wcm90b3R5cGUud2Fybk9uVW51c2VkU2VsZWN0b3IgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnNlbGVjdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rvci51c2VkKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIoc2VsZWN0b3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSdWxlO1xufSgpKTtcbnZhciBEZWNsYXJhdGlvbiQyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlY2xhcmF0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgRGVjbGFyYXRpb24ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjb2RlLCBrZXlmcmFtZXMpIHtcbiAgICAgICAgdmFyIHByb3BlcnR5ID0gdGhpcy5ub2RlLnByb3BlcnR5ICYmIHRoaXMubm9kZS5wcm9wZXJ0eS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAocHJvcGVydHkgPT09ICdhbmltYXRpb24nIHx8IHByb3BlcnR5ID09PSAnYW5pbWF0aW9uLW5hbWUnKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUudmFsdWUuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sudHlwZSA9PT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYmxvY2submFtZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleWZyYW1lcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGUub3ZlcndyaXRlKGJsb2NrLnN0YXJ0LCBibG9jay5lbmQsIGtleWZyYW1lcy5nZXQobmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlY2xhcmF0aW9uLnByb3RvdHlwZS5taW5pZnkgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5wcm9wZXJ0eSlcbiAgICAgICAgICAgIHJldHVybjsgLy8gQGFwcGx5LCBhbmQgcG9zc2libHkgb3RoZXIgd2VpcmQgY2FzZXM/XG4gICAgICAgIHZhciBjID0gdGhpcy5ub2RlLnN0YXJ0ICsgdGhpcy5ub2RlLnByb3BlcnR5Lmxlbmd0aDtcbiAgICAgICAgdmFyIGZpcnN0ID0gdGhpcy5ub2RlLnZhbHVlLmNoaWxkcmVuID9cbiAgICAgICAgICAgIHRoaXMubm9kZS52YWx1ZS5jaGlsZHJlblswXSA6XG4gICAgICAgICAgICB0aGlzLm5vZGUudmFsdWU7XG4gICAgICAgIHZhciBzdGFydCA9IGZpcnN0LnN0YXJ0O1xuICAgICAgICB3aGlsZSAoL1xccy8udGVzdChjb2RlLm9yaWdpbmFsW3N0YXJ0XSkpXG4gICAgICAgICAgICBzdGFydCArPSAxO1xuICAgICAgICBpZiAoc3RhcnQgLSBjID4gMSkge1xuICAgICAgICAgICAgY29kZS5vdmVyd3JpdGUoYywgc3RhcnQsICc6Jyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBEZWNsYXJhdGlvbjtcbn0oKSk7XG52YXIgQXRydWxlJDIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXRydWxlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIH1cbiAgICBBdHJ1bGUucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKG5vZGUsIHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubmFtZSA9PT0gJ21lZGlhJykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmFwcGx5KG5vZGUsIHN0YWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubm9kZS5uYW1lID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgICAgICAgICAgICAgcnVsZS5zZWxlY3RvcnMuZm9yRWFjaChmdW5jdGlvbiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3IudXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQXRydWxlLnByb3RvdHlwZS5pc1VzZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBUT0RPXG4gICAgfTtcbiAgICBBdHJ1bGUucHJvdG90eXBlLm1pbmlmeSA9IGZ1bmN0aW9uIChjb2RlLCBjYXNjYWRlKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubmFtZSA9PT0gJ21lZGlhJykge1xuICAgICAgICAgICAgdmFyIGV4cHJlc3Npb25DaGFyID0gY29kZS5vcmlnaW5hbFt0aGlzLm5vZGUuZXhwcmVzc2lvbi5zdGFydF07XG4gICAgICAgICAgICB2YXIgY18xID0gdGhpcy5ub2RlLnN0YXJ0ICsgKGV4cHJlc3Npb25DaGFyID09PSAnKCcgPyA2IDogNyk7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlLmV4cHJlc3Npb24uc3RhcnQgPiBjXzEpXG4gICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoY18xLCB0aGlzLm5vZGUuZXhwcmVzc2lvbi5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLm5vZGUuZXhwcmVzc2lvbi5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWluaWZ5IHF1ZXJpZXNcbiAgICAgICAgICAgICAgICBjXzEgPSBxdWVyeS5lbmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKGNfMSwgdGhpcy5ub2RlLmJsb2NrLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm5vZGUubmFtZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgICAgIHZhciBjID0gdGhpcy5ub2RlLnN0YXJ0ICsgMTA7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlLmV4cHJlc3Npb24uc3RhcnQgLSBjID4gMSlcbiAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShjLCB0aGlzLm5vZGUuZXhwcmVzc2lvbi5zdGFydCwgJyAnKTtcbiAgICAgICAgICAgIGMgPSB0aGlzLm5vZGUuZXhwcmVzc2lvbi5lbmQ7XG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlLmJsb2NrLnN0YXJ0IC0gYyA+IDApXG4gICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoYywgdGhpcy5ub2RlLmJsb2NrLnN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIG90aGVyIGF0cnVsZXNcbiAgICAgICAgaWYgKHRoaXMubm9kZS5ibG9jaykge1xuICAgICAgICAgICAgdmFyIGNfMiA9IHRoaXMubm9kZS5ibG9jay5zdGFydCArIDE7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhc2NhZGUgfHwgY2hpbGQuaXNVc2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoY18yLCBjaGlsZC5ub2RlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQubWluaWZ5KGNvZGUsIGNhc2NhZGUpO1xuICAgICAgICAgICAgICAgICAgICBjXzIgPSBjaGlsZC5ub2RlLmVuZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvZGUucmVtb3ZlKGNfMiwgdGhpcy5ub2RlLmJsb2NrLmVuZCAtIDEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdHJ1bGUucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIChjb2RlLCBpZCwga2V5ZnJhbWVzLCBjYXNjYWRlKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUubmFtZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZS5leHByZXNzaW9uLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBfYS50eXBlLCBuYW1lID0gX2EubmFtZSwgc3RhcnQgPSBfYS5zdGFydCwgZW5kID0gX2EuZW5kO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnSWRlbnRpZmllcicpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLWdsb2JhbC0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZS5yZW1vdmUoc3RhcnQsIHN0YXJ0ICsgOCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlLm92ZXJ3cml0ZShzdGFydCwgZW5kLCBrZXlmcmFtZXMuZ2V0KG5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnRyYW5zZm9ybShjb2RlLCBpZCwga2V5ZnJhbWVzLCBjYXNjYWRlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBdHJ1bGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC52YWxpZGF0ZSh2YWxpZGF0b3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF0cnVsZS5wcm90b3R5cGUud2Fybk9uVW51c2VkU2VsZWN0b3IgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICBpZiAodGhpcy5ub2RlLm5hbWUgIT09ICdtZWRpYScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLndhcm5PblVudXNlZFNlbGVjdG9yKGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBBdHJ1bGU7XG59KCkpO1xudmFyIFN0eWxlc2hlZXQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3R5bGVzaGVldChzb3VyY2UsIHBhcnNlZCwgZmlsZW5hbWUsIGNhc2NhZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICB0aGlzLmNhc2NhZGUgPSBjYXNjYWRlO1xuICAgICAgICB0aGlzLmZpbGVuYW1lID0gZmlsZW5hbWU7XG4gICAgICAgIHRoaXMuaWQgPSBcInN2ZWx0ZS1cIiArIHBhcnNlZC5oYXNoO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgICAgIHRoaXMua2V5ZnJhbWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBpZiAocGFyc2VkLmNzcyAmJiBwYXJzZWQuY3NzLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5oYXNTdHlsZXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIHN0YWNrXzEgPSBbXTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50QXRydWxlXzEgPSBudWxsO1xuICAgICAgICAgICAgd2Fsayh0aGlzLnBhcnNlZC5jc3MsIHtcbiAgICAgICAgICAgICAgICBlbnRlcjogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0F0cnVsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsYXN0ID0gc3RhY2tfMVtzdGFja18xLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0cnVsZSA9IG5ldyBBdHJ1bGUkMihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrXzEucHVzaChhdHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbiBhd2t3YXJkIHNwZWNpYWwgY2FzZSDigJQgQGFwcGx5IChhbmRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBvc3NpYmx5IG90aGVyIGZ1dHVyZSBjb25zdHJ1Y3RzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3QgJiYgIShsYXN0IGluc3RhbmNlb2YgQXRydWxlJDIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXRydWxlXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXRydWxlXzEuY2hpbGRyZW4ucHVzaChhdHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hpbGRyZW4ucHVzaChhdHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmV4cHJlc3Npb24uY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhwcmVzc2lvbi50eXBlID09PSAnSWRlbnRpZmllcicgJiYgIWV4cHJlc3Npb24ubmFtZS5zdGFydHNXaXRoKCctZ2xvYmFsLScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5rZXlmcmFtZXMuc2V0KGV4cHJlc3Npb24ubmFtZSwgX3RoaXMuaWQgKyBcIi1cIiArIGV4cHJlc3Npb24ubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHJ1bGVfMSA9IGF0cnVsZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09PSAnUnVsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydWxlID0gbmV3IFJ1bGUkMihub2RlLCBjdXJyZW50QXRydWxlXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tfMS5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRBdHJ1bGVfMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHJ1bGVfMS5jaGlsZHJlbi5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2hpbGRyZW4ucHVzaChydWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGVhdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdSdWxlJyB8fCBub2RlLnR5cGUgPT09ICdBdHJ1bGUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tfMS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ0F0cnVsZScpXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50QXRydWxlXzEgPSBzdGFja18xW3N0YWNrXzEubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhc1N0eWxlcyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N0eWxlcylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlO1xuICAgICAgICB3aGlsZSAocGFyZW50ID0gcGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlID09PSAnRWxlbWVudCcpXG4gICAgICAgICAgICAgICAgc3RhY2sudW5zaGlmdChwYXJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhc2NhZGUpIHtcbiAgICAgICAgICAgIGlmIChzdGFjay5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgbm9kZS5fbmVlZHNDc3NBdHRyaWJ1dGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNoaWxkLmFwcGx5KG5vZGUsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R5bGVzaGVldC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNzc091dHB1dEZpbGVuYW1lLCBzaG91bGRUcmFuc2Zvcm1TZWxlY3RvcnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc1N0eWxlcykge1xuICAgICAgICAgICAgcmV0dXJuIHsgY3NzOiBudWxsLCBjc3NNYXA6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29kZSA9IG5ldyBNYWdpY1N0cmluZyQxKHRoaXMuc291cmNlKTtcbiAgICAgICAgd2Fsayh0aGlzLnBhcnNlZC5jc3MsIHtcbiAgICAgICAgICAgIGVudGVyOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGNvZGUuYWRkU291cmNlbWFwTG9jYXRpb24obm9kZS5zdGFydCk7XG4gICAgICAgICAgICAgICAgY29kZS5hZGRTb3VyY2VtYXBMb2NhdGlvbihub2RlLmVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2hvdWxkVHJhbnNmb3JtU2VsZWN0b3JzKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQudHJhbnNmb3JtKGNvZGUsIF90aGlzLmlkLCBfdGhpcy5rZXlmcmFtZXMsIF90aGlzLmNhc2NhZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSAwO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY2FzY2FkZSB8fCBjaGlsZC5pc1VzZWQoKSkge1xuICAgICAgICAgICAgICAgIGNvZGUucmVtb3ZlKGMsIGNoaWxkLm5vZGUuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNoaWxkLm1pbmlmeShjb2RlLCBfdGhpcy5jYXNjYWRlKTtcbiAgICAgICAgICAgICAgICBjID0gY2hpbGQubm9kZS5lbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb2RlLnJlbW92ZShjLCB0aGlzLnNvdXJjZS5sZW5ndGgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3NzOiBjb2RlLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBjc3NNYXA6IGNvZGUuZ2VuZXJhdGVNYXAoe1xuICAgICAgICAgICAgICAgIGluY2x1ZGVDb250ZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5maWxlbmFtZSxcbiAgICAgICAgICAgICAgICBmaWxlOiBjc3NPdXRwdXRGaWxlbmFtZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC52YWxpZGF0ZSh2YWxpZGF0b3IpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLndhcm5PblVudXNlZFNlbGVjdG9ycyA9IGZ1bmN0aW9uIChvbndhcm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY2FzY2FkZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGxvY2F0b3I7XG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gc2VsZWN0b3Iubm9kZS5zdGFydDtcbiAgICAgICAgICAgIGlmICghbG9jYXRvcilcbiAgICAgICAgICAgICAgICBsb2NhdG9yID0gZ2V0TG9jYXRvcihfdGhpcy5zb3VyY2UpO1xuICAgICAgICAgICAgdmFyIF9hID0gbG9jYXRvcihwb3MpLCBsaW5lID0gX2EubGluZSwgY29sdW1uID0gX2EuY29sdW1uO1xuICAgICAgICAgICAgdmFyIGZyYW1lID0gZ2V0Q29kZUZyYW1lKF90aGlzLnNvdXJjZSwgbGluZSwgY29sdW1uKTtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gXCJVbnVzZWQgQ1NTIHNlbGVjdG9yXCI7XG4gICAgICAgICAgICBvbndhcm4oe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgZnJhbWU6IGZyYW1lLFxuICAgICAgICAgICAgICAgIGxvYzogeyBsaW5lOiBsaW5lICsgMSwgY29sdW1uOiBjb2x1bW4gfSxcbiAgICAgICAgICAgICAgICBwb3M6IHBvcyxcbiAgICAgICAgICAgICAgICBmaWxlbmFtZTogX3RoaXMuZmlsZW5hbWUsXG4gICAgICAgICAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1lc3NhZ2UgKyBcIiAoXCIgKyAobGluZSArIDEpICsgXCI6XCIgKyBjb2x1bW4gKyBcIilcXG5cIiArIGZyYW1lOyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQud2Fybk9uVW51c2VkU2VsZWN0b3IoaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlc2hlZXQ7XG59KCkpO1xuXG52YXIgdmVyc2lvbiA9ICcxLjQ5LjAnO1xuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIG5vcm1hbGl6ZWRPcHRpb25zID0gYXNzaWduJDEoeyBnZW5lcmF0ZTogJ2RvbScgfSwgb3B0aW9ucyk7XG4gICAgdmFyIG9ud2FybiA9IG5vcm1hbGl6ZWRPcHRpb25zLm9ud2Fybiwgb25lcnJvciA9IG5vcm1hbGl6ZWRPcHRpb25zLm9uZXJyb3I7XG4gICAgbm9ybWFsaXplZE9wdGlvbnMub253YXJuID0gb253YXJuXG4gICAgICAgID8gZnVuY3Rpb24gKHdhcm5pbmcpIHsgcmV0dXJuIG9ud2Fybih3YXJuaW5nLCBkZWZhdWx0T253YXJuKTsgfVxuICAgICAgICA6IGRlZmF1bHRPbndhcm47XG4gICAgbm9ybWFsaXplZE9wdGlvbnMub25lcnJvciA9IG9uZXJyb3JcbiAgICAgICAgPyBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIG9uZXJyb3IoZXJyb3IsIGRlZmF1bHRPbmVycm9yKTsgfVxuICAgICAgICA6IGRlZmF1bHRPbmVycm9yO1xuICAgIHJldHVybiBub3JtYWxpemVkT3B0aW9ucztcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbndhcm4od2FybmluZykge1xuICAgIGlmICh3YXJuaW5nLmxvYykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCIoXCIgKyB3YXJuaW5nLmxvYy5saW5lICsgXCI6XCIgKyB3YXJuaW5nLmxvYy5jb2x1bW4gKyBcIikgXFx1MjAxMyBcIiArIHdhcm5pbmcubWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcubWVzc2FnZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZmF1bHRPbmVycm9yKGVycm9yKSB7XG4gICAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZVZhbHVlKHZhbHVlKSB7XG4gICAgcmV0dXJuIC9eWydcIl0vLnRlc3QodmFsdWUpID9cbiAgICAgICAgdmFsdWUuc2xpY2UoMSwgLTEpIDpcbiAgICAgICAgdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZUF0dHJpYnV0ZXMoc3RyKSB7XG4gICAgdmFyIGF0dHJzID0ge307XG4gICAgc3RyLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgdmFyIF9hID0gYXR0ci5zcGxpdCgnPScpLCBuYW1lID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgIGF0dHJzW25hbWVdID0gdmFsdWUgPyBwYXJzZUF0dHJpYnV0ZVZhbHVlKHZhbHVlKSA6IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGF0dHJzO1xufVxuZnVuY3Rpb24gcmVwbGFjZVRhZ0NvbnRlbnRzKHNvdXJjZSwgdHlwZSwgcHJlcHJvY2Vzc29yLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXhwLCBtYXRjaCwgYXR0cmlidXRlcywgY29udGVudCwgcHJvY2Vzc2VkO1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBleHAgPSBuZXcgUmVnRXhwKFwiPFwiICsgdHlwZSArIFwiKFtcXFxcU1xcXFxzXSo/KT4oW1xcXFxTXFxcXHNdKj8pPFxcXFwvXCIgKyB0eXBlICsgXCI+XCIsICdpZycpO1xuICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGV4cC5leGVjKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzID0gcGFyc2VBdHRyaWJ1dGVzKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBwcmVwcm9jZXNzb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogb3B0aW9ucy5maWxlbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2VkICYmIHByb2Nlc3NlZC5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgKHNvdXJjZS5zbGljZSgwLCBtYXRjaC5pbmRleCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCI8XCIgKyB0eXBlICsgXCI+XCIgKyBwcm9jZXNzZWQuY29kZSArIFwiPC9cIiArIHR5cGUgKyBcIj5cIikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2Uuc2xpY2UobWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGgpKV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHNvdXJjZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gcHJlcHJvY2Vzcyhzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXJrdXAsIHN0eWxlLCBzY3JpcHQsIHByb2Nlc3NlZDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgbWFya3VwID0gb3B0aW9ucy5tYXJrdXAsIHN0eWxlID0gb3B0aW9ucy5zdHlsZSwgc2NyaXB0ID0gb3B0aW9ucy5zY3JpcHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghISFtYXJrdXApIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBtYXJrdXAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlbmFtZTogb3B0aW9ucy5maWxlbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2VkID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBwcm9jZXNzZWQuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhIXN0eWxlKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVwbGFjZVRhZ0NvbnRlbnRzKHNvdXJjZSwgJ3N0eWxlJywgc3R5bGUsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEhIXNjcmlwdCkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcGxhY2VUYWdDb250ZW50cyhzb3VyY2UsICdzY3JpcHQnLCBzY3JpcHQsIG9wdGlvbnMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA2O1xuICAgICAgICAgICAgICAgIGNhc2UgNjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmV0dXJuIHNlcGFyYXRlZCBvdXRwdXQsIGluIGZ1dHVyZSB2ZXJzaW9uIHdoZXJlIHN2ZWx0ZS5jb21waWxlIHN1cHBvcnRzIGl0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3R5bGU6IHsgY29kZTogc3R5bGVDb2RlLCBtYXA6IHN0eWxlTWFwIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzY3JpcHQgeyBjb2RlOiBzY3JpcHRDb2RlLCBtYXA6IHNjcmlwdE1hcCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFya3VwIHsgY29kZTogbWFya3VwQ29kZSwgbWFwOiBtYXJrdXBNYXAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY29tcGlsZShzb3VyY2UsIF9vcHRpb25zKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVPcHRpb25zKF9vcHRpb25zKTtcbiAgICB2YXIgcGFyc2VkO1xuICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZCA9IHBhcnNlKHNvdXJjZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgb3B0aW9ucy5vbmVycm9yKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0eWxlc2hlZXQgPSBuZXcgU3R5bGVzaGVldChzb3VyY2UsIHBhcnNlZCwgb3B0aW9ucy5maWxlbmFtZSwgb3B0aW9ucy5jYXNjYWRlICE9PSBmYWxzZSk7XG4gICAgdmFsaWRhdGUocGFyc2VkLCBzb3VyY2UsIHN0eWxlc2hlZXQsIG9wdGlvbnMpO1xuICAgIHZhciBjb21waWxlciA9IG9wdGlvbnMuZ2VuZXJhdGUgPT09ICdzc3InID8gc3NyIDogZG9tO1xuICAgIHJldHVybiBjb21waWxlcihwYXJzZWQsIHNvdXJjZSwgc3R5bGVzaGVldCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZShzb3VyY2UsIF9vcHRpb25zKSB7XG4gICAgaWYgKF9vcHRpb25zID09PSB2b2lkIDApIHsgX29wdGlvbnMgPSB7fTsgfVxuICAgIF9vcHRpb25zLmZvcm1hdCA9ICdldmFsJztcbiAgICB2YXIgY29tcGlsZWQgPSBjb21waWxlKHNvdXJjZSwgX29wdGlvbnMpO1xuICAgIGlmICghY29tcGlsZWQgfHwgIWNvbXBpbGVkLmNvZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gKDAsIGV2YWwpKGNvbXBpbGVkLmNvZGUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChfb3B0aW9ucy5vbmVycm9yKSB7XG4gICAgICAgICAgICBfb3B0aW9ucy5vbmVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydHMucHJlcHJvY2VzcyA9IHByZXByb2Nlc3M7XG5leHBvcnRzLmNvbXBpbGUgPSBjb21waWxlO1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG5leHBvcnRzLlZFUlNJT04gPSB2ZXJzaW9uO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3ZlbHRlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc3ZlbHRlL2NvbXBpbGVyL3N2ZWx0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTA5XG4vLyBtb2R1bGUgY2h1bmtzID0gNyIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NhcHBlci9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDcgOCIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NhcHBlci9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDUgNyA4IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NhcHBlci9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDUgNyA4IiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuLi9zYXBwZXIvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDMxXG4vLyBtb2R1bGUgY2h1bmtzID0gNSA3IDgiLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vc2FwcGVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM0XG4vLyBtb2R1bGUgY2h1bmtzID0gNSA3IDgiLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4uL3NhcHBlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMzVcbi8vIG1vZHVsZSBjaHVua3MgPSA1IDcgOCJdLCJzb3VyY2VSb290IjoiIn0=