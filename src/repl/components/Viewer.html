<iframe ref:child srcdoc='{{srcdoc}}'></iframe>

<style>
	iframe {
		width: 100%;
		height: 100%;
		border: none;
	}
</style>

<script>
	const eval2 = eval;

	const srcdoc = `
		<!doctype html>
		<html>
			<head>
				<link href="https://fonts.googleapis.com/css?family=Rajdhani:300,500,700|Roboto:300,300i,500|Roboto+Mono:300" rel="stylesheet">
				<link rel='stylesheet' href='/repl-viewer.css'>
			</head>
			<body></body>
		</html>
	`;

	export default {
		data: () => ({
			srcdoc
		}),

		onrender () {
			let component;

			this.refs.child.addEventListener( 'load', () => {
				const iframe = this.refs.child;
				const body = iframe.contentDocument.body;

				this.observe( 'compiled', compiled => {
					if ( !compiled ) return;

					const code = compiled.code.replace( 'export default ', '' ) + '\n\nreturn SvelteComponent;';
					const SvelteComponent = eval2( `(function () { ${code} }());` );

					if ( component ) component.teardown();

					component = window.component = new SvelteComponent({
						target: body,
						data: this.get( 'data' )
					});
				});

				this.observe( 'data', data => {
					if ( component ) component.set( data );
				});

				// mousemove/mouseup events need to bubble. TODO is this the best way? maybe
				// we just cover the iframe with a transparent <div> while dragging dividers?
				function propagate ( event ) {
					const { top, left } = iframe.getBoundingClientRect();

					const clone = new MouseEvent( event.type, {
						clientX: event.clientX + left,
						clientY: event.clientY + top
					});

					iframe.dispatchEvent( clone );
				}

				iframe.contentWindow.addEventListener( 'mousemove', propagate, false );
				iframe.contentWindow.addEventListener( 'mouseup', propagate, false );
			});
		}
	};
</script>
